language: rs
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx = 0;\n    for row\
    \ in lst {\n        let mut col = Vec::new();\n        let mut col_idx = 0;\n\
    \        for row in row {\n            if col_idx <= x {\n                col.push((row,\
    \ col_idx));\n            }\n            col_idx += 1;\n        }\n        if\
    \ col_idx > x {\n            row.push(col.iter().cloned().collect());\n      \
    \  }\n        if row_idx != row.len() {\n            row.push((row_idx, 0));\n\
    \        }\n        row_idx += 1;\n    }\n    row.sort_by_key(|v| v.1);\n    row.sort_by_key(|v|\
    \ v.1, |v| v.1.1);\n    row.sort_by_key(|v| v.1.1);\n    row.iter().map(|r| r.0).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `isize` cannot be built from an iterator\
    \ over elements of type `(isize, isize)`\n    --> /tmp/tmpwmtx2_0l.rs:29:42\n\
    \     |\n29   |             row.push(col.iter().cloned().collect());\n     | \
    \                                         ^^^^^^^ value of type `isize` cannot\
    \ be built from `std::iter::Iterator<Item=(isize, isize)>`\n     |\n     = help:\
    \ the trait `FromIterator<(isize, isize)>` is not implemented for `isize`\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmtx2_0l.rs:32:22\n\
    \   |\n32 |             row.push((row_idx, 0));\n   |                      ^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `(usize, {integer})`\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n   --> /tmp/tmpwmtx2_0l.rs:37:9\n\
    \    |\n37  |     row.sort_by_key(|v| v.1, |v| v.1.1);\n    |         ^^^^^^^^^^^\
    \ -------  --------- supplied 2 arguments\n    |         |\n    |         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpwmtx2_0l.rs:38:29\n\
    \   |\n38 |     row.sort_by_key(|v| v.1.1);\n   |                            \
    \ ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `isize`\n    --> /tmp/tmpwmtx2_0l.rs:39:29\n\
    \     |\n39   |     row.iter().map(|r| r.0).collect()\n     |                \
    \             ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from\
    \ `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait `FromIterator<isize>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ out = Vec::with_capacity(lst.len());\n\n    for row in lst {\n        let mut\
    \ row_out = Vec::with_capacity(row.len());\n\n        // append the tuple to the\
    \ output vector\n        for (i, elem) in row.iter().enumerate() {\n         \
    \   if elem == x {\n                row_out.push((i, x));\n                break;\n\
    \            }\n        }\n\n        // sort the tuples by columns in descending\
    \ order\n        let mut sorted_row_out = row_out.iter().sorted().reverse();\n\
    \n        // sort the tuples by rows in ascending order\n        let mut sorted_out\
    \ = sorted_row_out.iter().sorted();\n\n        // append the tuple to the output\
    \ vector\n        for (i, _) in sorted_out {\n            out.push((i, sorted_row_out.last().unwrap()));\n\
    \        }\n    }\n\n    out\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp9ffbxp_e.rs:24:21\n\
    \   |\n24 |             if elem == x {\n   |                     ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `sorted`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp9ffbxp_e.rs:31:49\n\
    \   |\n31 |         let mut sorted_row_out = row_out.iter().sorted().reverse();\n\
    \   |                                                 ^^^^^^ method not found\
    \ in `std::slice::Iter<'_, (usize, isize)>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for i in lst {\n        if i.len() == x {\n          \
    \  result.push((i.len(), i));\n        }\n    }\n    result.sort_by_key(|i| i.1).reverse();\n\
    \    result.sort_by_key(|i| i.0, |&i1, &i2| i2.1.cmp(&i1.1).reverse());\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv_d9nw13.rs:19:23\n   |\n\
    19 |         if i.len() == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if i.len() == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `reverse` found for unit type `()` in the current scope\n  --> /tmp/tmpv_d9nw13.rs:23:33\n\
    \   |\n23 |     result.sort_by_key(|i| i.1).reverse();\n   |                 \
    \                ^^^^^^^ method not found in `()`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpv_d9nw13.rs:24:12\n\
    \    |\n24  |     result.sort_by_key(|i| i.0, |&i1, &i2| i2.1.cmp(&i1.1).reverse());\n\
    \    |            ^^^^^^^^^^^ -------  ------------------------------------ supplied\
    \ 2 arguments\n    |            |\n    |            expected 1 argument\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv_d9nw13.rs:25:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n25 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, Vec<isize>)>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = Vec::new();\n    let mut row_lst = lst.to_vec();\n    for i in row_lst.into_iter().rev()\
    \ {\n        let mut row_result = Vec::new();\n        for j in i.iter().rev()\
    \ {\n            if j == x {\n                row_result.push((j, i));\n     \
    \       }\n        }\n        result.push(row_result);\n    }\n    sort_by_row_and_col(vec![vec![]],\
    \ vec![vec![]], result)\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_by_row_and_col` in this scope\n\
    \  --> /tmp/tmpg2oa65ql.rs:28:5\n   |\n28 |     sort_by_row_and_col(vec![vec![]],\
    \ vec![vec![]], result)\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpg2oa65ql.rs:22:18\n\
    \   |\n22 |             if j == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = Vec::new();\n    let mut cur = x;\n    let mut first = lst[0].len() as\
    \ isize;\n    let mut second = lst[0].len() - cur.trunc() as isize;\n    for i\
    \ in lst {\n        let mut cur_row = i;\n        let mut cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \        let mut cur_col_last = cur_row[1..].iter().cloned().collect();\n    \
    \    let mut cur_row = i;\n        let mut cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \        let mut cur_col_last = cur_row[1..].iter().cloned().collect();\n    \
    \    while cur_row != i {\n            cur_col_first.sort_by_key(|&x| x.cmp(&cur_row[first]));\n\
    \            cur_col_last.sort_by_key(|&x| x.cmp(&cur_row[first]));\n        \
    \    cur_col_first.zip(cur_col_last).for_each(|&(_, &b)| {\n                ret.push((b,\
    \ cur_row.len() - b.cmp(&cur_row[first]).unwrap() as isize));\n            });\n\
    \            cur_col_last = cur_col_first;\n            cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \            cur_row = i;\n            cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \            cur_col_last = cur_row[1..].iter().cloned().collect();\n        }\n\
    \    }\n    let mut first = lst[0].len() as isize;\n    let mut second = lst[0].len()\
    \ - cur.trunc() as isize;\n    while cur_row != i {\n        cur_col_first.sort_by_key(|&x|\
    \ x.cmp(&cur_row[first]));\n        cur_col_last.sort_by_key(|&x| x.cmp(&cur_row[first]));\n\
    \        cur_col_first.zip(cur_col_last).for_each(|&(_, &b)| {\n            ret.push((b,\
    \ cur_row.len() - b.cmp(&cur_row[first]).unwrap() as isize));\n        });\n \
    \       cur_col_last = cur_col_first;\n        cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \        cur_row = i;\n        cur_col_first = cur_row[first..].iter().cloned().collect();\n\
    \        cur_col_last = cur_row[1..].iter().cloned().collect();\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `cur_row` in this scope\n  --> /tmp/tmpz901ouim.rs:43:11\n\
    \   |\n43 |     while cur_row != i {\n   |           ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpz901ouim.rs:43:22\n\
    \   |\n43 |     while cur_row != i {\n   |                      ^ help: a local\
    \ variable with a similar name exists: `x`\n\nerror[E0425]: cannot find value\
    \ `cur_col_first` in this scope\n  --> /tmp/tmpz901ouim.rs:44:9\n   |\n44 |  \
    \       cur_col_first.sort_by_key(|&x| x.cmp(&cur_row[first]));\n   |        \
    \ ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `cur_row`\
    \ in this scope\n  --> /tmp/tmpz901ouim.rs:44:47\n   |\n44 |         cur_col_first.sort_by_key(|&x|\
    \ x.cmp(&cur_row[first]));\n   |                                             \
    \  ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `cur_col_last`\
    \ in this scope\n  --> /tmp/tmpz901ouim.rs:45:9\n   |\n45 |         cur_col_last.sort_by_key(|&x|\
    \ x.cmp(&cur_row[first]));\n   |         ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `cur_row` in this scope\n  --> /tmp/tmpz901ouim.rs:45:46\n\
    \   |\n45 |         cur_col_last.sort_by_key(|&x| x.cmp(&cur_row[first]));\n \
    \  |                                              ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `cur_col_first` in this scope\n  --> /tmp/tmpz901ouim.rs:46:9\n\
    \   |\n46 |         cur_col_first.zip(cur_col_last).for_each(|&(_, &b)| {\n  \
    \ |         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `cur_col_last` in this scope\n  --> /tmp/tmpz901ouim.rs:46:27\n   |\n\
    46 |         cur_col_first.zip(cur_col_last).for_each(|&(_, &b)| {\n   |     \
    \                      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `cur_row` in this scope\n  --> /tmp/tmpz901ouim.rs:47:26\n   |\n\
    47 |             ret.push((b, cur_row.len() - b.cmp(&cur_row[first]).unwrap()\
    \ as isize));\n   |                          ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `cur_row` in this scop"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Sort\
    \ coordinates initially by rows in ascending order.\n    lst.sort_by(|a, b| a.len()\
    \ as isize);\n    lst.sort_by(|a, b| b.len() as isize);\n\n    // Sort coordinates\
    \ of row by columns in descending order.\n    let mut res = vec![];\n    for i\
    \ in 0..lst.len() {\n        for j in lst[i].len() - 1 {\n            if j <=\
    \ x {\n                break;\n            }\n            res.push((i, j));\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwqv4_r2z.rs:18:24\n   |\n\
    18 |     lst.sort_by(|a, b| a.len() as isize);\n   |                        ^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwqv4_r2z.rs:19:24\n   |\n19 |     lst.sort_by(|a, b| b.len()\
    \ as isize);\n   |                        ^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0277]: `usize` is not an iterator\n  --> /tmp/tmpwqv4_r2z.rs:24:18\n\
    \   |\n24 |         for j in lst[i].len() - 1 {\n   |                  ^^^^^^^^^^^^^^^^\
    \ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwqv4_r2z.rs:31:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n31 |     res\n   |     ^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, _)>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ min_idx = -1;\n    let mut max_idx = lst.len();\n    while let Some((r, c))\
    \ = get_row_from_idx(max_idx, &lst, &x) {\n        if r < min_idx {\n        \
    \    min_idx = r;\n        }\n        if c < min_idx {\n            min_idx =\
    \ c;\n        }\n        if r > max_idx {\n            max_idx = r;\n        }\n\
    \        if c > max_idx {\n            max_idx = c;\n        }\n        result.push((r,\
    \ c));\n    }\n    let mut reversed_result = vec![];\n    for i in 0..=max_idx\
    \ {\n        reversed_result.push((min_idx - i, min_idx - i));\n    }\n    reversed_result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_row_from_idx` in this scope\n \
    \ --> /tmp/tmp1pxheb5b.rs:23:30\n   |\n23 |     while let Some((r, c)) = get_row_from_idx(max_idx,\
    \ &lst, &x) {\n   |                              ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp1pxheb5b.rs:21:23\n   |\n21 |     let mut min_idx = -1;\n   | \
    \                      ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1pxheb5b.rs:42:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n42 |     reversed_result\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted = vec![];\n    sorted.push(Vec::new());\n    let mut col = 0;\n    for\
    \ row in lst {\n        sorted.push(row.iter().cloned().cloned().zip(x).collect());\n\
    \        col = x.iter().cloned().collect::<Vec<isize>>().len();\n    }\n    sorted.sort_by_key(|x|\
    \ x.0);\n    sorted.sort_by_key(|x| x.1.reverse());\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n    --> /tmp/tmp8mc1fl8v.rs:21:41\n     |\n21   | \
    \        sorted.push(row.iter().cloned().cloned().zip(x).collect());\n     | \
    \                                        ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&&_`\n                found reference\
    \ `&isize`\n     = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `zip` exists for struct `Cloned<Cloned<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp8mc1fl8v.rs:21:50\n\
    \   |\n21 |           sorted.push(row.iter().cloned().cloned().zip(x).collect());\n\
    \   |                                                    ^^^ method cannot be\
    \ called on `Cloned<Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Cloned<std::slice::Iter<'_, isize>> as Iterator>::Item = &_`\n   \
    \        which is required by `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \           `Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n        \
    \   which is required by `&mut Cloned<Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp8mc1fl8v.rs:22:17\n   |\n22 |         col = x.iter().cloned().collect::<Vec<isize>>().len();\n\
    \   |                 ^^^^ method not found in `isize`\n\nerror[E0609]: no field\
    \ `0` on type `&Vec<_>`\n  --> /tmp/tmp8mc1fl8v.rs:24:30\n   |\n24 |     sorted.sort_by_key(|x|\
    \ x.0);\n   |                              ^ unknown field\n\nerror[E0609]: no\
    \ field `1` on type `&Vec<_>`\n  --> /tmp/tmp8mc1fl8v.rs:25:30\n   |\n25 |   \
    \  sorted.sort_by_key(|x| x.1.reverse());\n   |                              ^\
    \ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mc1fl8v.rs:26:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter().fold(Vec::new(),\
    \ |mut res, l| {\n        let mut found = false;\n        for mut y in l {\n \
    \           if x == y {\n                found = true;\n                break;\n\
    \            }\n        }\n        if found {\n            res.push((l[0], y));\n\
    \        }\n        res.reverse();\n        res\n    })\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpibvyt2c9.rs:26:29\n\
    \   |\n26 |             res.push((l[0], y));\n   |                           \
    \  ^ help: a local variable with a similar name exists: `l`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpibvyt2c9.rs:20:21\n   |\n20 |             if x == y {\n\
    \   |                     ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             if x == *y {\n   |        \
    \             +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut coords = vec![];\n\n    for row in 0..rows\
    \ {\n        let row_coords = vec![];\n        for col in 0..cols {\n        \
    \    if row == col {\n                row_coords.push((row, col));\n         \
    \   } else {\n                for r in 0..rows {\n                    for c in\
    \ 0..cols {\n                        if r == c && row < col {\n              \
    \              row_coords.push((r, c));\n                        }\n         \
    \           }\n                }\n            }\n        }\n        coords.push(row_coords);\n\
    \    }\n\n    coords.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\n  \
    \  coords.iter().enumerate().filter(|(i, j)| {\n        (i, j) == (coords.iter().next().unwrap().unwrap(),\
    \ coords.iter().next().unwrap().unwrap())\n    }).map(|(i, j)| {\n        if i\
    \ < *coords[0].len() {\n            let (row, col) = coords.iter().next().unwrap().unwrap();\n\
    \            (row, (col, j))\n        } else {\n            (i, j)\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, (usize, usize)>` is not an iterator\n\
    \    --> /tmp/tmp7z90i4re.rs:42:40\n     |\n42   |     coords.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \     |                                    --- ^^^^^^^^^ `&std::slice::Iter<'_,\
    \ (usize, usize)>` is not an iterator\n     |                                \
    \    |\n     |                                    required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Iterator` is not implemented for\
    \ `&std::slice::Iter<'_, (usize, usize)>`\n     = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_, (usize,\
    \ usize)>`\nnote: required by a bound in `std::iter::Iterator::cmp`\nhelp: consider\
    \ dereferencing here\n     |\n42   |     coords.sort_by(|a, b| a.iter().cmp(*&b.iter()).reverse());\n\
    \     |                                        +\nhelp: consider removing the\
    \ leading `&`-reference\n     |\n42   -     coords.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    42   +     coords.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n     | \n\
    help: consider changing this borrow's mutability\n     |\n42   |     coords.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n     |                         \
    \               ~~~~\n\nerror[E0599]: no method named `unwrap` found for reference\
    \ `&Vec<(usize, usize)>` in the current scope\n  --> /tmp/tmp7z90i4re.rs:45:50\n\
    \   |\n45 |         (i, j) == (coords.iter().next().unwrap().unwrap(), coords.iter().next().unwrap().unwrap())\n\
    \   |                                                  ^^^^^^ help: there is an\
    \ associated function with a similar name: `swap`\n\nerror[E0599]: no method named\
    \ `unwrap` found for reference `&Vec<(usize, usize)>` in the current scope\n \
    \ --> /tmp/tmp7z90i4re.rs:45:90\n   |\n45 |         (i, j) == (coords.iter().next().unwrap().unwrap(),\
    \ coords.iter().next().unwrap().unwrap())\n   |                              \
    \                                                            ^^^^^^ help: there\
    \ is an associated function with a similar name: `swap`\n\nerror[E061"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter().filter(|row|\
    \ row.len() == x).map(|row| (row.iter().enumerate().rev().map(|(i, _)| i).collect(),\
    \ row)).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4ncjrir.rs:17:42\n   |\n\
    17 |     lst.iter().filter(|row| row.len() == x).map(|row| (row.iter().enumerate().rev().map(|(i,\
    \ _)| i).collect(), row)).collect()\n   |                                    \
    \      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |     lst.iter().filter(|row|\
    \ row.len() == x.try_into().unwrap()).map(|row| (row.iter().enumerate().rev().map(|(i,\
    \ _)| i).collect(), row)).collect()\n   |                                    \
    \       ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<(isize, isize)>`\
    \ cannot be built from an iterator over elements of type `(_, &Vec<isize>)`\n\
    \    --> /tmp/tmpo4ncjrir.rs:17:118\n     |\n17   |     lst.iter().filter(|row|\
    \ row.len() == x).map(|row| (row.iter().enumerate().rev().map(|(i, _)| i).collect(),\
    \ row)).collect()\n     |                                                    \
    \                                                                  ^^^^^^^ value\
    \ of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(_,\
    \ &Vec<isize>)>`\n     |\n     = help: the trait `FromIterator<(_, &Vec<isize>)>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows_coords = vec![];\n    let mut cols = lst[0].len();\n\
    \n    if lst.is_empty() {\n        return vec![];\n    }\n\n    let rows = lst.len();\n\
    \    if rows > 1 {\n        cols = lst[0].last().unwrap();\n    }\n    let (rows,\
    \ cols) = lst.into_iter().map(|row| row.len()).unzip();\n\n    for _ in 0..rows\
    \ {\n        cols = lst[0].last().unwrap();\n        let mut row = vec![];\n \
    \       let mut row_coord = vec![];\n        for row in lst {\n            row_coord.push(row_coord.last().unwrap()\
    \ + cols);\n            row.push(row[0].unwrap());\n        }\n        row_coord.sort();\n\
    \        row_coord.sort_by(|a, b| b - a);\n        row_coord.iter().for_each(|&a|\
    \ {\n            row.push(a);\n        });\n        rows_coords.push((row_coord.last().unwrap(),\
    \ row.last().unwrap()));\n    }\n    rows_coords.iter().for_each(|&(_, a)| {\n\
    \        if a > x {\n            coords.push((a, 0));\n            coords.push((a,0));\n\
    \        }\n        if a < x {\n            coords.push((a,0));\n        }\n \
    \   });\n    coords.sort_by(|a, b| b.0 - a.0);\n    coords.reverse();\n    coords\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvim_j2rg.rs:27:16\n   |\n\
    19 |     let mut cols = lst[0].len();\n   |                    ------------ expected\
    \ due to this value\n...\n27 |         cols = lst[0].last().unwrap();\n   |  \
    \              ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\nerror[E0271]:\
    \ type mismatch resolving `<[closure@/tmp/tmpvim_j2rg.rs:29:44: 29:59] as FnOnce<(Vec<isize>,)>>::Output\
    \ == (_, _)`\n    --> /tmp/tmpvim_j2rg.rs:29:61\n     |\n29   |     let (rows,\
    \ cols) = lst.into_iter().map(|row| row.len()).unzip();\n     |              \
    \                                               ^^^^^ expected tuple, found `usize`\n\
    \     |\n     = note: expected tuple `(_, _)`\n                 found type `usize`\n\
    \     = note: required because of the requirements on the impl of `Iterator` for\
    \ `Map<std::vec::IntoIter<Vec<isize>>, [closure@/tmp/tmpvim_j2rg.rs:29:44: 29:59]>`\n\
    note: required by a bound in `unzip`\n\nerror[E0277]: the trait bound `{integer}:\
    \ Extend<_>` is not satisfied\n    --> /tmp/tmpvim_j2rg.rs:29:61\n     |\n29 \
    \  |     let (rows, cols) = lst.into_iter().map(|row| row.len()).unzip();\n  \
    \   |                                                             ^^^^^ the trait\
    \ `Extend<_>` is not implemented for `{integer}`\n     |\n     = help: the following\
    \ other types implement trait `Extend<A>`:\n               <() as Extend<()>>\n\
    \               <(ExtendA, ExtendB) as Extend<(A, B)>>\n               <BTreeMap<K,\
    \ V> as Extend<(&'a K, &'a V)>>\n               <BTreeMap<K, V> as Extend<(K,\
    \ V)>>\n               <BTreeSet<T> as Extend<&'a T>>\n               <BTreeSet<T>\
    \ as Extend<T>>\n               <BinaryHeap<T> as Extend<&'a T>>\n           \
    \    <BinaryHeap<T> as Extend<T>>\n             and 25 others\nnote: required\
    \ by a bound in `unzip`\n\nerror[E0277]: the trait bound `&isize: Default` is\
    \ not satisfied\n    --> /tmp/tmpvim_j2rg.rs:29:61\n     |\n29   |     let (rows,\
    \ cols) = lst.into_iter().map(|row| row.len()).unzip();\n     |              \
    \                                               ^^^^^ the trait `Default` is not\
    \ implemente"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        vec![]\n    } else if x == 0 {\n        vec![(0, 0)]\n    }\
    \ else {\n        let mut i = 0;\n        let mut j = 0;\n        let mut result\
    \ = vec![];\n        while j < lst.len() {\n            if lst[j].len() <= x {\n\
    \                i += 1;\n                result.push((i, j));\n            }\
    \ else {\n                let k = lst[j].len() - 1;\n                while k <\
    \ x {\n                    k -= 1;\n                    j += 1;\n            \
    \    }\n                i += 1;\n                result.push((i, j));\n      \
    \      }\n        }\n        result.sort_by(|a, b| {\n            a.1.cmp(&b.1)\n\
    \        });\n        result.sort_by(|a, b| {\n            b.1.cmp(&a.1)\n   \
    \     });\n        result\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkgajtr4c.rs:26:32\n   |\n\
    26 |             if lst[j].len() <= x {\n   |                                ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n26 |           \
    \  if lst[j].len() <= x.try_into().unwrap() {\n   |                          \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkgajtr4c.rs:31:27\n\
    \   |\n31 |                 while k < x {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |                 while\
    \ k < x.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkgajtr4c.rs:45:9\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n45 |         result\n   |         ^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<({integer}, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    for row in lst {\n        let mut col:\
    \ Vec<(isize, isize)> = vec![];\n        for col in row {\n            if col\
    \ == x {\n                col.push((row.clone(), col.clone()));\n            }\n\
    \        }\n        row.push(col.clone());\n    }\n    row.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    row.sort_by(|a, b| b.0.cmp(&a.0));\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpomirywzt.rs:22:21\n   |\n22 |                 col.push((row.clone(),\
    \ col.clone()));\n   |                     ^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpomirywzt.rs:25:18\n   |\n25 |  \
    \       row.push(col.clone());\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<(isize, isize)>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = 0;\n    let mut columns = 0;\n    for row_lst\
    \ in lst.iter().flat_map(|row_vec| row_vec.iter()) {\n        row_lst.remove(x);\n\
    \        let row = get_row_from_vec(row_lst, &mut rows, &mut columns);\n     \
    \   result.push(row);\n    }\n    result.sort_by_key(|row| row[0]);\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_row_from_vec` in this scope\n \
    \ --> /tmp/tmp0q0qte28.rs:22:19\n   |\n22 |         let row = get_row_from_vec(row_lst,\
    \ &mut rows, &mut columns);\n   |                   ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `remove` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp0q0qte28.rs:21:17\n   |\n21 | \
    \        row_lst.remove(x);\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 || x.is_nan() {\n        return vec![];\n    }\n    let mut v = Vec::new();\n\
    \    let mut cnt = 0;\n    let mut row = 0;\n    let mut col_num = 0;\n    while\
    \ cnt < lst.len() {\n        let c = lst[cnt].iter().find(|&x| x != x).expect(\"\
    cannot find x\");\n        if *c >= x {\n            v.push((row, col_num));\n\
    \            col_num +=1;\n        } else {\n            cnt += 1;\n         \
    \   row += 1;\n            col_num = 0;\n        }\n    }\n    v.sort_by_key(|&(x,\
    \ y)| x.0);\n    v.sort_by_key(|&(x, y)| -y.0);\n    v\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_nan` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpyq9ka115.rs:17:28\n   |\n17 |     if lst.len() == 0 ||\
    \ x.is_nan() {\n   |                            ^^^^^^ method not found in `isize`\n\
    \nerror[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpyq9ka115.rs:35:31\n   |\n35 |     v.sort_by_key(|&(x, y)| x.0);\n\
    \   |                               ^\n\nerror[E0610]: `{integer}` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpyq9ka115.rs:36:32\n  \
    \ |\n36 |     v.sort_by_key(|&(x, y)| -y.0);\n   |                           \
    \     ^\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // The\
    \ idea of solving this problem is to first sort the elements in the 2D matrix\
    \ in ascending order.\n    // Then, sort each row of the 2D matrix in descending\
    \ order.\n    // Then, use binary search to find the index of the element in the\
    \ sorted row.\n    // Then, for each coordinate in this row, we have the index\
    \ of the coordinate in the sorted matrix.\n    // For example, if x = 4, the sorted\
    \ matrix looks like this:\n    // a b\n    // c d\n    // c d\n    // e f\n  \
    \  // e f\n    // e f\n    //   c\n    // In this case, we can use binary search\
    \ to find the index of the coordinate (4, c) in the sorted matrix,\n    // which\
    \ is the index of (a, b) in sorted matrix. Then, we just need the coordinate of\
    \ this element\n    // in sorted matrix.\n    let mut indexes = Vec::new();\n\
    \    for row in lst {\n        let mut idx = binary_search(row, x, |x| x.0);\n\
    \        indexes.push((idx, row.len()));\n    }\n\n    indexes.sort_by(|a, b|\
    \ a.0 > b.0);\n\n    indexes.into_iter().map(|(idx, row)| idx .. (row - idx)).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_search` in this scope\n  -->\
    \ /tmp/tmpakx1ilnp.rs:34:23\n   |\n34 |         let mut idx = binary_search(row,\
    \ x, |x| x.0);\n   |                       ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpakx1ilnp.rs:38:28\n   |\n38 |\
    \     indexes.sort_by(|a, b| a.0 > b.0);\n   |                            ^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0277]: a value of\
    \ type `Vec<(isize, isize)>` cannot be built from an iterator over elements of\
    \ type `std::ops::Range<_>`\n    --> /tmp/tmpakx1ilnp.rs:40:62\n     |\n40   |\
    \     indexes.into_iter().map(|(idx, row)| idx .. (row - idx)).collect()\n   \
    \  |                                                              ^^^^^^^ value\
    \ of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=std::ops::Range<_>>`\n\
    \     |\n     = help: the trait `FromIterator<std::ops::Range<_>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut cols = 1;\n    let mut rows = 0;\n    let mut index =\
    \ 0;\n    let mut coords = vec![];\n\n    while cols != x {\n        rows += 1;\n\
    \        cols = 1;\n        coords.clear();\n        for r in lst[rows].iter()\
    \ {\n            cols += 1;\n            coords.push((r, cols));\n        }\n\n\
    \        if rows > 0 {\n            coords.sort();\n            coords.reverse();\n\
    \            row = 0;\n            for (index, (_, cols)) in coords.iter().enumerate()\
    \ {\n                coords.insert(index, (0, row));\n                coords.insert(index,\
    \ (cols, row));\n                coords.insert(index + 1, (1, row));\n       \
    \         coords.insert(index + 1, (2, row));\n                row += 1;\n   \
    \         }\n        }\n    }\n\n    coords\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo22caejb.rs:37:39\n   |\n\
    37 |                 coords.insert(index, (0, row));\n   |                   \
    \                    ^\n   |                                       |\n   |   \
    \                                    expected `&isize`, found integer\n   |  \
    \                                     help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpo22caejb.rs:39:43\n   |\n39 |  \
    \               coords.insert(index + 1, (1, row));\n   |                    \
    \                       ^\n   |                                           |\n\
    \   |                                           expected `&isize`, found integer\n\
    \   |                                           help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo22caejb.rs:40:43\n  \
    \ |\n40 |                 coords.insert(index + 1, (2, row));\n   |          \
    \                                 ^\n   |                                    \
    \       |\n   |                                           expected `&isize`, found\
    \ integer\n   |                                           help: consider borrowing\
    \ here: `&2`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo22caejb.rs:46:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n46 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ _)>`\n              found struct `Vec<(&isize, _)>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut result = vec![];\n \
    \       for elem in row.iter().cloned() {\n            if elem == x {\n      \
    \          result.push((elem.0, elem.1));\n            }\n        }\n        result.sort_by(|a,\
    \ b| b.1);\n        result.sort_by(|a, b| -a.1);\n        result.sort();\n   \
    \     for coord in result {\n            result.push((coord, coord.0));\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp279ekx6h.rs:22:35\n   |\n22 |                 result.push((elem.0,\
    \ elem.1));\n   |                                   ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp279ekx6h.rs:22:43\n\
    \   |\n22 |                 result.push((elem.0, elem.1));\n   |             \
    \                              ^\n\nerror[E0609]: no field `1` on type `&_`\n\
    \  --> /tmp/tmp279ekx6h.rs:25:33\n   |\n25 |         result.sort_by(|a, b| b.1);\n\
    \   |                                 ^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0609, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut row: Vec<(isize, isize)> = vec![];\n\
    \n    let mut rows = vec![];\n    let mut cols = vec![];\n\n    for (y, row) in\
    \ lst.into_iter().enumerate() {\n        row.sort_by_key(|v| v.0);\n        row.sort_by_key(|v|\
    \ v.1);\n\n        rows.push(row.iter().cloned());\n\n        for v in row {\n\
    \            if v.0 == x {\n                cols.push(vec![(v.0, y)]);\n     \
    \       }\n        }\n    }\n\n    let mut row_idx = 0;\n    let mut col_idx =\
    \ 0;\n    let mut min_row = vec![];\n    let mut max_row = vec![];\n    let mut\
    \ min_col = vec![];\n    let mut max_col = vec![];\n\n    for (y, row) in rows.into_iter().enumerate()\
    \ {\n        if row_idx == 0 {\n            row_idx = y;\n            min_row\
    \ = vec![];\n            max_row = vec![];\n        }\n\n        let row_max =\
    \ max_row.clone();\n        let row_min = min_row.clone();\n\n        let col_max\
    \ = max_col.clone();\n        let col_min = min_col.clone();\n\n        for v\
    \ in row {\n            let col_x = v.0;\n            let row_x = v.1;\n\n   \
    \         if row_x < row_x {\n                min_row.push((row_x, col_x));\n\
    \                max_row.push((row_x, col_x));\n            } else {\n       \
    \         max_row.push((row_x, col_x));\n                min_row.push((row_x,\
    \ col_x));\n            }\n\n            if col_idx < col_x {\n              \
    \  if col_x < col_x {\n                    min_col.push((col_x, col_x));\n   \
    \                 max_col.push((col_x, col_x));\n                } else {\n  \
    \                  max_col.push((col_x, col_x));\n                    min_col.push((col_x,\
    \ col_x));\n                }\n            }\n\n            col_idx++;\n     \
    \   }\n\n        row_idx++;\n    }\n\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut min_row = vec![];\n    let mut max_row = vec![];\n    let\
    \ mut min_col = vec![];\n    let mut max_col = vec![];\n\n    for row in lst.into_iter()\
    \ {\n        if row_idx == 0 {\n            row_idx = row.len();\n           \
    \ min_row = vec![];\n            max_row = vec![];\n        }\n\n        let row_max\
    \ = max_row.clone();\n        let row_min = min_row.clone();\n\n        let col_max\
    \ = max_col.clone();\n        let col_min = min_col.clone();\n\n        for v\
    \ in row {\n            let col_x = v.0;\n            let row_x = v.\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp2oscao5.rs:120:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n94  |     for row in lst.into_iter() {\n    |     \
    \                           - unclosed delimiter\n...\n107 |         for v in\
    \ row {\n    |                      - this delimiter might not be properly closed...\n\
    ...\n110 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n120 | }\n    |   ^\n\nerror: Rust has no postfix increment operator\n  -->\
    \ /tmp/tmpp2oscao5.rs:81:20\n   |\n81 |             col_idx++;\n   |         \
    \           ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n81 |             { let tmp = col_idx; col_idx += 1; tmp };\n   |      \
    \       +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n81 -             col_idx++;\n\
    81 +             col_idx += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpp2oscao5.rs:84:16\n   |\n84 |         row_idx++;\n \
    \  |                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n84 |         { let tmp = row_idx; row_idx += 1; tmp };\n   |         +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n84 -         row_idx++;\n84 +         row_idx\
    \ += 1;\n   | \n\nerror: unexpected token: `}`\n   --> /tmp/tmpp2oscao5.rs:110:1\n\
    \    |\n110 | }\n    | ^\n\nerror: expected `;`, found `}`\n   --> /tmp/tmpp2oscao5.rs:109:27\n\
    \    |\n109 |             let row_x = v.\n    |                           ^ help:\
    \ add `;` here\n110 | }\n    | - unexpected token\n\nerror[E0609]: no field `0`\
    \ on type `&isize`\n  --> /tmp/tmpp2oscao5.rs:27:31\n   |\n27 |         row.sort_by_key(|v|\
    \ v.0);\n   |                               ^\n\nerror[E0609]: no field `1` on\
    \ type `&isize`\n  --> /tmp/tmpp2oscao5.rs:28:31\n   |\n28 |         row.sort_by_key(|v|\
    \ v.1);\n   |                               ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpp2oscao5.rs:33:18\n  \
    \ |\n33 |             if v.0 == x {\n   |"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    for row in lst {\n        let mut row_coords = vec![];\n\
    \        let mut row_x_coord = vec![];\n        let mut row_y_coord = vec![];\n\
    \        for row in row {\n            row_x_coord.push(row + x);\n          \
    \  row_y_coord.push(row - x);\n        }\n        row_coords.sort_by(|a, b| a.cmp(b));\n\
    \        row_coords.sort_by(|a, b| b.cmp(a));\n        for (i, coord) in row_coords.iter().enumerate()\
    \ {\n            row_coords.push((i, coord));\n        }\n        let mut row_x_coord\
    \ = row_x_coord.sort_by(|a, b| b.cmp(a));\n        for (i, coord) in row_x_coord.iter().enumerate()\
    \ {\n            row_x_coord.push((i, coord));\n        }\n        for (i, coord)\
    \ in row_y_coord.iter().enumerate() {\n            row_y_coord.push((i, coord));\n\
    \        }\n        coords.push(row_coords);\n    }\n    coords.sort_by(|a, b|\
    \ a.len().cmp(b.len()));\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpmo8xqh41.rs:26:29\n\
    \   |\n26 |         row_coords.sort_by(|a, b| a.cmp(b));\n   |               \
    \              ^ consider giving this closure parameter the explicit type `&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0599]: no method named `iter` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmpmo8xqh41.rs:32:39\n   |\n32 |         for\
    \ (i, coord) in row_x_coord.iter().enumerate() {\n   |                       \
    \                ^^^^ method not found in `()`\n\nerror[E0599]: no method named\
    \ `push` found for unit type `()` in the current scope\n  --> /tmp/tmpmo8xqh41.rs:33:25\n\
    \   |\n33 |             row_x_coord.push((i, coord));\n   |                  \
    \       ^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmo8xqh41.rs:36:30\n   |\n36 |             row_y_coord.push((i, coord));\n\
    \   |                              ^^^^^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(usize, &isize)`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // TODO:\
    \ Implement me\n    panic!();\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''explicit panic'', /tmp/tmpg_bv4jxk.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_rows: Vec<Vec<(isize, isize)>> = Vec::new();\n    let mut sorted_row_idx:\
    \ Vec<usize> = Vec::new();\n    sorted_rows.reserve(lst.len());\n    for row in\
    \ lst {\n        let mut sorted_cols: Vec<(isize, isize)> = Vec::new();\n    \
    \    sorted_cols.reserve(row.len());\n        let mut col = 0;\n        for &x\
    \ in row {\n            if x == x {\n                sorted_cols.push((x, col));\n\
    \            } else {\n                col += 1;\n            }\n        }\n \
    \       sorted_rows.push_back(sorted_cols);\n        sorted_row_idx.push(0);\n\
    \    }\n    sorted_rows.push(sorted_row_idx);\n    sorted_rows.sort_by(|a, b|\
    \ {\n        a.len() - b.len()\n    });\n    sorted_rows\n        .iter()\n  \
    \      .filter(|row| row.len() == x)\n        .enumerate()\n        .map(|(i,\
    \ row)| {\n            (row.clone(), (i as isize, sorted_rows[i].len() - 1))\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpygris9s7.rs:24:13\n   |\n\
    24 |         for &x in row {\n   |             ^^    --- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `x`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<Vec<(isize,\
    \ isize)>>` in the current scope\n  --> /tmp/tmpygris9s7.rs:31:21\n   |\n31 |\
    \         sorted_rows.push_back(sorted_cols);\n   |                     ^^^^^^^^^\
    \ method not found in `Vec<Vec<(isize, isize)>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpygris9s7.rs:34:22\n   |\n34 |     sorted_rows.push(sorted_row_idx);\n\
    \   |                      ^^^^^^^^^^^^^^ expected tuple, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpygris9s7.rs:36:9\n\
    \   |\n36 |         a.len() - b.len()\n   |         ^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpygris9s7.rs:40:36\n   |\n40 |         .filter(|row| row.len() ==\
    \ x)\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n40 |         .filter(|row| row.len() == x.try_into().unwrap())\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `(Vec<(isize, isize)>, (isize, usize))`\n    --> /tmp/tmpygris9s7.rs:45:10\n\
    \     |\n45   |         .collect()\n     |          ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=(Vec<(isize, isize)>,\
    \ (isize, usize))>`\n     |\n     = help: the trait `FromIterator<(Vec<(isize,\
    \ isize)>, (isize, usize))>` is not implemented for `Vec<(isize, isize)>`\n  \
    \   = help: the trait `FromItera"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Check\
    \ that the matrix is square\n    assert_eq!(lst.len(), lst.len());\n\n    // Sort\
    \ the rows by columns in descending order\n    lst.sort_by_key(|row| {\n     \
    \   row.iter().rev()\n    });\n\n    // Sort the row by columns in ascending order\n\
    \    lst.sort_by_key(|row| row.iter());\n\n    // Get the index\n    let idx =\
    \ lst.iter().position(|row| row.iter().contains(&x));\n\n    // Return the coordinates\n\
    \    lst.iter().take(idx + 1).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Rev<std::slice::Iter<'_, isize>>: Ord` is\
    \ not satisfied\n   --> /tmp/tmp8soz7uj2.rs:21:21\n    |\n21  |       lst.sort_by_key(|row|\
    \ {\n    |  _________-----------_^\n    | |         |\n    | |         required\
    \ by a bound introduced by this call\n22  | |         row.iter().rev()\n23  |\
    \ |     });\n    | |_____^ the trait `Ord` is not implemented for `Rev<std::slice::Iter<'_,\
    \ isize>>`\n    |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\
    \nerror[E0277]: the trait bound `std::slice::Iter<'_, isize>: Ord` is not satisfied\n\
    \   --> /tmp/tmp8soz7uj2.rs:26:21\n    |\n26  |     lst.sort_by_key(|row| row.iter());\n\
    \    |         ----------- ^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `std::slice::Iter<'_, isize>`\n    |         |\n    |         required by\
    \ a bound introduced by this call\n    |\nnote: required by a bound in `slice::<impl\
    \ [T]>::sort_by_key`\n\nerror[E0599]: no method named `contains` found for struct\
    \ `std::slice::Iter` in the current scope\n  --> /tmp/tmp8soz7uj2.rs:29:52\n \
    \  |\n29 |     let idx = lst.iter().position(|row| row.iter().contains(&x));\n\
    \   |                                                    ^^^^^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror[E0369]: cannot add `{integer}` to\
    \ `Option<usize>`\n  --> /tmp/tmp8soz7uj2.rs:32:25\n   |\n32 |     lst.iter().take(idx\
    \ + 1).collect::<Vec<_>>()\n   |                     --- ^ - {integer}\n   | \
    \                    |\n   |                     Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8soz7uj2.rs:32:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n32 |     lst.iter().take(idx + 1).collect::<Vec<_>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `&Vec<isize>`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<&Vec<isize>>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = 0;\n    for r in lst {\n        rows +=\
    \ r.len();\n    }\n    let mut cols = x;\n    let mut rows = rows + x - 1;\n \
    \   for r in lst {\n        if cols == r.len() {\n            break;\n       \
    \ }\n        let mut cols = cols - r.len();\n        for (idx, &c) in r.iter().enumerate()\
    \ {\n            if c == x {\n                result.push((rows, idx));\n    \
    \        }\n        }\n    }\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzl43u52.rs:23:27\n   |\n\
    23 |     let mut rows = rows + x - 1;\n   |                           ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  -->\
    \ /tmp/tmpnzl43u52.rs:23:25\n   |\n23 |     let mut rows = rows + x - 1;\n   |\
    \                         ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzl43u52.rs:25:20\n   |\n25 |         if cols == r.len()\
    \ {\n   |                    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         if cols == r.len().try_into().unwrap() {\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnzl43u52.rs:28:31\n   |\n28 |         let mut cols = cols - r.len();\n\
    \   |                               ^^^^^^^ expected `isize`, found `usize`\n\n\
    error[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpnzl43u52.rs:28:29\n\
    \   |\n28 |         let mut cols = cols - r.len();\n   |                     \
    \        ^ no implementation for `isize - usize`\n   |\n   = help: the trait `Sub<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Sort\
    \ lst\n    lst.sort_by(|x, y| x.len().cmp(y.len()));\n    // Find x among lst\n\
    \    find_index(lst, x).unwrap()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_index` in this scope\n  --> /tmp/tmpt9nc5m28.rs:20:5\n\
    \   |\n20 |     find_index(lst, x).unwrap()\n   |     ^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt9nc5m28.rs:18:36\n\
    \   |\n18 |     lst.sort_by(|x, y| x.len().cmp(y.len()));\n   |              \
    \                      ^^^^^^^\n   |                                    |\n  \
    \ |                                    expected `&usize`, found `usize`\n   |\
    \                                    help: consider borrowing here: `&y.len()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut row_coords = vec![];\n    for row in lst {\n \
    \       for (i, elt) in row.iter().enumerate() {\n            if elt == x {\n\
    \                coords.push((i, row.len()));\n                row_coords.push((i,\
    \ row.len()));\n            }\n        }\n    }\n    row_coords.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.iter().map(|coord|\
    \ coord.1).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmphtdq6mpq.rs:21:20\n\
    \   |\n21 |             if elt == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ isize)>` cannot be built from an iterator over elements of type `usize`\n  \
    \  --> /tmp/tmphtdq6mpq.rs:29:40\n     |\n29   |     coords.iter().map(|coord|\
    \ coord.1).collect()\n     |                                        ^^^^^^^ value\
    \ of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    loop {\n        let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut x = x;\n        while let Some(row) = (lst.iter().rev().skip(x).next(),\
    \ *row) {\n            let mut cols = row.iter().cloned().collect::<Vec<_>>();\n\
    \            cols = cols.sort_by(|a, b| b - a);\n            cols = cols.reverse();\n\
    \            let mut y = x;\n            let mut z = cols.iter().map(|c| c + y).collect::<Vec<_>>();\n\
    \            if z == 0 {\n                result.push((z, z));\n             \
    \   break;\n            }\n            let mut i = 0;\n            loop {\n  \
    \              if z[i] == z[i + 1] {\n                    break;\n           \
    \     }\n                i += 1;\n            }\n            z = z - i;\n    \
    \    }\n        if lst.len() == 0 {\n            break;\n        }\n        let\
    \ mut lst = lst.iter().cloned().collect::<Vec<_>>();\n        let mut x = x;\n\
    \        while let Some(row) = (lst.iter().rev().skip(x).next(), *row) {\n   \
    \         let mut cols = row.iter().cloned().collect::<Vec<_>>();\n          \
    \  cols = cols.sort_by(|a, b| b - a);\n            cols = cols.reverse();\n  \
    \          let mut y = x;\n            let mut z = cols.iter().map(|c| c + y).collect::<Vec<_>>();\n\
    \            if z == 0 {\n                result.push((z, z));\n             \
    \   break;\n            }\n            let mut i = 0;\n            loop {\n  \
    \              if z[i] == z[i + 1] {\n                    break;\n           \
    \     }\n                i += 1;\n            }\n            z = z - i;\n    \
    \    }\n        if lst.len() == 0 {\n            break;\n        }\n        x\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `row` in this scope\n  --> /tmp/tmpccy766eb.rs:21:66\n\
    \   |\n21 |         while let Some(row) = (lst.iter().rev().skip(x).next(), *row)\
    \ {\n   |                                                                  ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `row` in this scope\n\
    \  --> /tmp/tmpccy766eb.rs:45:66\n   |\n45 |         while let Some(row) = (lst.iter().rev().skip(x).next(),\
    \ *row) {\n   |                                                              \
    \    ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpccy766eb.rs:21:54\n\
    \   |\n21 |         while let Some(row) = (lst.iter().rev().skip(x).next(), *row)\
    \ {\n   |                                                      ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         while let Some(row) =\
    \ (lst.iter().rev().skip(x.try_into().unwrap()).next(), *row) {\n   |        \
    \                                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpccy766eb.rs:45:54\n   |\n45 |         while\
    \ let Some(row) = (lst.iter().rev().skip(x).next(), *row) {\n   |            \
    \                                          ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n45 |         while let Some(row) = (lst.iter().rev().skip(x.try_into().unwrap()).next(),\
    \ *row) {\n   |                                                       ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst.first().len();\n\
    \    let mut cur_row_mut_ref = lst.as_mut_slice();\n    cur_row_mut_ref.sort_by_key(|x|\
    \ *x).reverse();\n    while cur_row_mut_ref.len() > 0 {\n        let row = cur_row_mut_ref.as_slice();\n\
    \        let mut cur_col_mut_ref = row.as_mut_slice();\n        cur_col_mut_ref.sort_by_key(|x|\
    \ *x).reverse();\n        cur_row_mut_ref = row;\n        cur_col_mut_ref.sort_by_key(|x|\
    \ *x).reverse();\n        result.push((cur_col_mut_ref.iter().skip(x).collect::<Vec<_>>(),\
    \ cur_row_mut_ref.iter().take(x).collect::<Vec<_>>()));\n        cols = cur_col_mut_ref.len();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpw4hqospb.rs:19:32\n   |\n19 |     let mut cols = lst.first().len();\n\
    \   |                                ^^^ method not found in `Option<&Vec<isize>>`\n\
    \nerror[E0599]: no method named `reverse` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpw4hqospb.rs:21:41\n   |\n21 |     cur_row_mut_ref.sort_by_key(|x|\
    \ *x).reverse();\n   |                                         ^^^^^^^ method\
    \ not found in `()`\n\nerror[E0599]: no method named `as_slice` found for mutable\
    \ reference `&mut [Vec<isize>]` in the current scope\n  --> /tmp/tmpw4hqospb.rs:23:35\n\
    \   |\n23 |         let row = cur_row_mut_ref.as_slice();\n   |              \
    \                     ^^^^^^^^ method not found in `&mut [Vec<isize>]`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use core::slice::SlicePattern;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw4hqospb.rs:28:102\n   |\n28 |         result.push((cur_col_mut_ref.iter().skip(x).collect::<Vec<_>>(),\
    \ cur_row_mut_ref.iter().take(x).collect::<Vec<_>>()));\n   |                \
    \                                                                            \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n28 |      \
    \   result.push((cur_col_mut_ref.iter().skip(x).collect::<Vec<_>>(), cur_row_mut_ref.iter().take(x.try_into().unwrap()).collect::<Vec<_>>()));\n\
    \   |                                                                        \
    \                               ++++++++++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for (y, row) in lst.iter().enumerate() {\n        for\
    \ (x, elem) in row.iter().enumerate() {\n            if elem == x {\n        \
    \        result.push((x, y));\n            }\n        }\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.1);\n    result.sort_by_key(|&(x, y)| y.1);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpafhz1duk.rs:20:24\n   |\n\
    20 |             if elem == x {\n   |                        ^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n  --> /tmp/tmpafhz1duk.rs:20:21\n\
    \   |\n20 |             if elem == x {\n   |                     ^^ no implementation\
    \ for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0610]: `usize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpafhz1duk.rs:25:36\n  \
    \ |\n25 |     result.sort_by_key(|&(x, y)| x.1);\n   |                       \
    \             ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpafhz1duk.rs:26:36\n   |\n26 |     result.sort_by_key(|&(x,\
    \ y)| y.1);\n   |                                    ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpafhz1duk.rs:27:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n27 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.sort_by(|a,\
    \ b| a.iter().rev().zip(b.iter().rev()).collect::<Vec<(isize, isize)>>())\n  \
    \      .into_iter()\n        .filter_map(|(_, ys)| ys.iter().enumerate().filter_map(|(_,\
    \ y)| y.iter().filter(|x| *x == x).collect::<Vec<isize>>()))\n        .enumerate()\n\
    \        .filter_map(|(i, ys)| ys.iter().enumerate().filter_map(|(_, y)| y.iter().filter_map(|x|\
    \ *x == x).collect::<Vec<isize>>()))\n        .filter_map(|(i, ys)| ys.iter().enumerate().filter_map(|(_,\
    \ ys)| ys.iter().filter_map(|(_, y)| y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n\
    \        .filter_map(|(i, ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_,\
    \ y)| y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_, y)|\
    \ y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_, y)|\
    \ y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_, y)|\
    \ y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_, y)|\
    \ y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter().enumerate().filter_map(|(_, ys)| ys.iter().filter_map(|(_, y)|\
    \ y.iter().filter_map(|x| *x == x).collect::<Vec<isize>>())))\n        .filter_map(|(i,\
    \ ys)| ys.iter\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp02mopksn.rs:29:20\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n29 |         .filter_map(|(i,\
    \ ys)| ys.iter\n   |                    ^ unclosed delimiter\n30 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot\
    \ be built from an iterator over elements of type `(&isize, &isize)`\n    -->\
    \ /tmp/tmp02mopksn.rs:17:59\n     |\n17   |     lst.sort_by(|a, b| a.iter().rev().zip(b.iter().rev()).collect::<Vec<(isize,\
    \ isize)>>())\n     |                                                        \
    \   ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp02mopksn.rs:17:24\n   |\n17 |     lst.sort_by(|a,\
    \ b| a.iter().rev().zip(b.iter().rev()).collect::<Vec<(isize, isize)>>())\n  \
    \ |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found struct `Vec`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n            found struct `Vec<(isize, isize)>`\n\n\
    error[E0599]: `()` is not an iterator\n  --> /tmp/tmp02mopksn.rs:18:10\n   |\n\
    18 |         .into_iter()\n   |          ^^^^^^^^^ `()` is not an iterator\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `(): IntoIterator`\n           `&():\
    \ Iterator`\n           which is required by `&(): IntoIterator`\n           `&mut\
    \ (): Iterator`\n           which is required by `&mut (): IntoIterator`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more infor"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ rows_vec: Vec<Vec<isize>> = vec![];\n    let mut cols = lst[0].len();\n    let\
    \ mut i = 0;\n    // find row with index i\n    let mut row: Vec<isize> = vec![];\n\
    \    for _row in lst {\n        if _row[0] == i {\n            row = vec![i];\n\
    \        }\n    }\n    if row.is_empty() {\n        return result;\n    }\n  \
    \  let mut cols_vec: Vec<isize> = vec![];\n    // find columns with index i\n\
    \    for _col in row.iter().rev() {\n        for _col in lst.iter().rev() {\n\
    \            if _col == _col {\n                cols_vec.push(_col);\n       \
    \     }\n        }\n    }\n    let mut i = 0;\n    for _col in cols_vec.iter().rev()\
    \ {\n        let mut j = 0;\n        for row in rows_vec.iter_mut().rev() {\n\
    \            if _col == row[0] {\n                row[1] = j;\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    for row in rows_vec.iter_mut().rev()\
    \ {\n        for col in cols_vec.iter_mut().rev() {\n            if col == row[0]\
    \ {\n                let _row = row[0];\n                let _col = col;\n   \
    \             result.push((_row, _col));\n            }\n        }\n    }\n  \
    \  result.sort_by_key(|x| -x[0]);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp363jgil8.rs:39:31\n   |\n\
    39 |                 cols_vec.push(_col);\n   |                              \
    \ ^^^^ expected `isize`, found `&Vec<isize>`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&Vec<isize>`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmp363jgil8.rs:47:21\n   |\n47 |         \
    \    if _col == row[0] {\n   |                     ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&mut isize` with `isize`\n\
    \  --> /tmp/tmp363jgil8.rs:56:20\n   |\n56 |             if col == row[0] {\n\
    \   |                    ^^ no implementation for `&mut isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&mut isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp363jgil8.rs:59:36\n\
    \   |\n59 |                 result.push((_row, _col));\n   |                 \
    \                   ^^^^ expected `isize`, found `&mut isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n59 |                 result.push((_row, *_col));\n\
    \   |                                    +\n\nerror[E0608]: cannot index into\
    \ a value of type `&(isize, isize)`\n  --> /tmp/tmp363jgil8.rs:63:29\n   |\n63\
    \ |     result.sort_by_key(|x| -x[0]);\n   |                             ^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n    let\
    \ mut current_row = vec![];\n    for row in lst {\n        let mut found_x_in_row\
    \ = false;\n        let mut found_x = false;\n        let mut current_column =\
    \ 0;\n        for col in row {\n            if col == x {\n                found_x_in_row\
    \ = true;\n                found_x = true;\n            }\n            found_x\
    \ = found_x || col > x;\n            current_column = current_column + 1 unless\
    \ found_x_in_row;\n            current_row.push((current_column, col))\n     \
    \   }\n        if found_x_in_row {\n            result.push(current_row);\n  \
    \          current_row = vec![];\n        }\n    }\n    result.sort_by(|a, b|\
    \ a.iter().cmp(b.iter()));\n    result.sort_by_key(|a| a.iter().cmp(&-a.iter()));\n\
    \    result.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `unless`\n\
    \  --> /tmp/tmp48tvsaj0.rs:32:49\n   |\n32 |             current_column = current_column\
    \ + 1 unless found_x_in_row;\n   |                                           \
    \      ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `std::slice::Iter<'_, _>`\n  --> /tmp/tmp48tvsaj0.rs:41:42\n\
    \   |\n41 |     result.sort_by_key(|a| a.iter().cmp(&-a.iter()));\n   |      \
    \                                    ^^^^^^^^^ cannot apply unary operator `-`\n\
    \nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from an\
    \ iterator over elements of type `Vec<_>`\n    --> /tmp/tmp48tvsaj0.rs:42:28\n\
    \     |\n42   |     result.iter().cloned().collect()\n     |                 \
    \           ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Vec<_>>`\n\
    \     |\n     = help: the trait `FromIterator<Vec<_>>` is not implemented for\
    \ `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sorted_rows: Vec<(isize, isize)>\
    \ = lst.into_iter().fold(vec![], |mut sorted_rows, vec| {\n        sorted_rows.sort_by(|a,\
    \ b| a.0.cmp(&b.0).reverse());\n        sorted_rows.sort_by(|a, b| b.0.cmp(&a.0).reverse());\n\
    \        sorted_rows\n    });\n    sorted_rows.dedup();\n    sorted_rows.sort_by_key(|x|\
    \ x.0.clone());\n    let mut cols: Vec<isize> = vec![];\n    let mut rows: Vec<isize>\
    \ = vec![];\n    for y in sorted_rows.rev() {\n        cols.clear();\n       \
    \ for (x0, x1) in y.1 {\n            if x0.cmp(&x) == 0 {\n                cols.push(x0);\n\
    \            }\n            cols.push(x1);\n        }\n        if cols.len() >\
    \ 0 {\n            rows.push((y.0, cols));\n        }\n        cols.clear();\n\
    \    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<(isize, isize)>` is not an iterator\n   --> /tmp/tmpp8h7y3ti.rs:29:26\n\
    \    |\n29  |       for y in sorted_rows.rev() {\n    |                      \
    \      ^^^ `Vec<(isize, isize)>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<(isize, isize)>: Iterator`\n\
    \            which is required by `&mut Vec<(isize, isize)>: Iterator`\n     \
    \       `[(isize, isize)]: Iterator`\n            which is required by `&mut [(isize,\
    \ isize)]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8h7y3ti.rs:42:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n42 |     rows\n   |     ^^^^\
    \ expected tuple, found `isize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<isize>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = Vec::with_capacity(lst.len());\n    coords.reserve(lst.len());\n  \
    \  for row in lst {\n        coords.extend_from_slice(&row.iter().enumerate().map(|(i,\
    \ _)| i as isize));\n    }\n    let mut sorted = coords.iter().cloned().sorted();\n\
    \    sorted.reverse();\n    let mut result_coords = vec![];\n    for coord in\
    \ sorted.skip(x).take(coords.len() - x) {\n        result_coords.extend_from_slice(&coord.iter().map(|(_,\
    \ y)| (y, coord)));\n    }\n    result_coords\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpge6tm_.rs:20:34\n   |\n\
    20 |         coords.extend_from_slice(&row.iter().enumerate().map(|(i, _)| i as\
    \ isize));\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected slice, found struct `Map`\n   |\n   = note: expected reference `&[_]`\n\
    \              found reference `&Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpgpge6tm_.rs:20:62:\
    \ 20:81]>`\n\nerror[E0599]: no method named `sorted` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpgpge6tm_.rs:22:45\n   |\n22 |     let mut\
    \ sorted = coords.iter().cloned().sorted();\n   |                            \
    \                 ^^^^^^ method not found in `Cloned<std::slice::Iter<'_, _>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgpge6tm_.rs:25:53\n   |\n25 |\
    \     for coord in sorted.skip(x).take(coords.len() - x) {\n   |             \
    \                                        ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpgpge6tm_.rs:25:51\n\
    \   |\n25 |     for coord in sorted.skip(x).take(coords.len() - x) {\n   |   \
    \                                                ^ no implementation for `usize\
    \ - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ans = Vec::new();\n    for row in lst {\n        let mut an = vec![];\n    \
    \    for column in row {\n            if column == x {\n                ans.push((column,\
    \ 0));\n                break;\n            }\n            ans.push((column));\n\
    \        }\n        ans.sort_by_key(|x| x.0);\n        ans.sort_by_key(|x| -x.0);\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpje5zb0fs.rs:25:22\n\
    \   |\n25 |             ans.push((column));\n   |                      ^     \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n25 -             ans.push((column));\n25 +             ans.push(column);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpje5zb0fs.rs:25:22\n  \
    \ |\n25 |             ans.push((column));\n   |                      ^^^^^^^^\
    \ expected tuple, found `isize`\n   |\n   = note: expected tuple `(isize, {integer})`\n\
    \               found type `isize`\n\nerror: aborting due to previous error; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        vec![]\n    }\n    let mut min_row = lst.len();\n    let mut max_row\
    \ = min_row;\n    let mut min_col = vec![0];\n    let mut max_col = min_col;\n\
    \    let mut min_y = vec![0];\n    let mut max_y = min_y;\n\n    for row in lst\
    \ {\n        match row.len() {\n            0 => continue,\n            _ => {\n\
    \                min_row = std::cmp::min(min_row, row.len());\n              \
    \  max_row = std::cmp::max(max_row, row.len());\n            }\n        }\n\n\
    \        for (i, v) in row.iter().enumerate() {\n            min_col[i] = std::cmp::min(min_col[i],\
    \ v);\n            max_col[i] = std::cmp::max(max_col[i], v);\n        }\n\n \
    \       for y in row.iter() {\n            min_y[i] = std::cmp::min(min_y[i],\
    \ y);\n            max_y[i] = std::cmp::max(max_y[i], y);\n        }\n    }\n\n\
    \    vec![(min_row, min_col), (max_row, min_col), (min_row, max_col), (max_row,\
    \ max_col), (min_row, min_y), (max_row, min_y), (min_row, max_y), (max_row, max_y)]\n\
    \        .iter()\n        .enumerate()\n        .sort();\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp_0qy7ipx.rs:42:19\n\
    \   |\n42 |             min_y[i] = std::cmp::min(min_y[i], y);\n   |         \
    \          ^ help: a local variable with a similar name exists: `x`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmp_0qy7ipx.rs:42:44\n   |\n\
    42 |             min_y[i] = std::cmp::min(min_y[i], y);\n   |                \
    \                            ^ help: a local variable with a similar name exists:\
    \ `x`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp_0qy7ipx.rs:43:19\n\
    \   |\n43 |             max_y[i] = std::cmp::max(max_y[i], y);\n   |         \
    \          ^ help: a local variable with a similar name exists: `x`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmp_0qy7ipx.rs:43:44\n   |\n\
    43 |             max_y[i] = std::cmp::max(max_y[i], y);\n   |                \
    \                            ^ help: a local variable with a similar name exists:\
    \ `x`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0qy7ipx.rs:18:9\n   |\n\
    17 | /     if lst.is_empty() {\n18 | |         vec![]\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n19 | |     }\n   | |_____- expected this to be `()`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<_>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n19 |     };\n   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0qy7ipx.rs:37:52\n\
    \   |\n37 |             min_col[i] = std::cmp::min(min_col[i], v);\n   |     \
    \                                               ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n37 |             min_col[i]\
    \ = std::cmp::min(min_col[i], *v);\n   |                                     \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_0qy7ipx.rs:38:52\n\
    \   |\n38 |             max_col[i] = std::cmp::max(max_col[i], v);\n   |     \
    \                                               ^ expected integer, found `&isize`\n\
    \   |\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = vec![];\n    for mut row1 in lst {\n        if row1.len() == x {\n  \
    \          rows.push((row1.iter().nth(0).unwrap(), row1.iter().nth(1).unwrap()));\n\
    \        }\n    }\n    let mut cols: Vec<_> = vec![];\n    rows.sort_by(|a, b|\
    \ b[1].cmp(&a[1]).unwrap());\n    for (row1, row2) in rows {\n        cols.push(\n\
    \            row1.iter().map(|x| x).collect::<Vec<_>>().sort_by(|a, b| b.cmp(&a).unwrap()),\n\
    \        );\n    }\n    return cols\n        .iter()\n        .map(|x| x.zip(x).collect())\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| a.0.cmp(&b.0).unwrap())\n\
    \        .collect();\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_dpztvg.rs:19:26\n   |\n\
    19 |         if row1.len() == x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if row1.len() == x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `&(&isize, &isize)`\n  --> /tmp/tmph_dpztvg.rs:24:25\n\
    \   |\n24 |     rows.sort_by(|a, b| b[1].cmp(&a[1]).unwrap());\n   |         \
    \                ^^^^\n\nerror[E0608]: cannot index into a value of type `&(&isize,\
    \ &isize)`\n  --> /tmp/tmph_dpztvg.rs:24:35\n   |\n24 |     rows.sort_by(|a, b|\
    \ b[1].cmp(&a[1]).unwrap());\n   |                                   ^^^^\n\n\
    error[E0599]: no method named `iter` found for reference `&isize` in the current\
    \ scope\n  --> /tmp/tmph_dpztvg.rs:27:18\n   |\n27 |             row1.iter().map(|x|\
    \ x).collect::<Vec<_>>().sort_by(|a, b| b.cmp(&a).unwrap()),\n   |           \
    \       ^^^^ method not found in `&isize`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    if lst.is_empty() {\n        return result;\n    }\n \
    \   let mut rows_vec = vec![];\n    let mut rows_idx = Vec::new();\n    rows_vec.push(vec![]);\n\
    \    rows_idx.push(0);\n    rows\n        .into_iter()\n        .enumerate()\n\
    \        .filter(|&(_, &v)| v != x)\n        .sort_by(|&(_, &v)| v)\n        .for_each(|(&i,\
    \ _)| {\n            rows_vec.push(rows_idx[i as usize]);\n            rows_idx.push(i);\n\
    \        });\n    rows_vec\n        .iter()\n        .enumerate()\n        .filter_map(|(&r,\
    \ &c)| {\n            match (rows_idx[r as usize], rows_idx[c as usize]) {\n \
    \               (Some(r1), Some(c1)) => (r1, c1),\n                (Some(r2),\
    \ Some(c2)) => (r2, c2),\n                (None, None) => None,\n            }\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `rows` in this scope\n  --> /tmp/tmppl35cbdg.rs:25:5\n\
    \   |\n25 |     rows\n   |     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppl35cbdg.rs:31:27\n   |\n31 |             rows_vec.push(rows_idx[i\
    \ as usize]);\n   |                           ^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<_>`\n          \
    \      found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppl35cbdg.rs:37:23\n\
    \   |\n37 |         .filter_map(|(&r, &c)| {\n   |                       ^^  \
    \  - expected due to this\n   |                       |\n   |                \
    \       expected `usize`, found reference\n   |                       help: you\
    \ can probably remove the explicit borrow: `r`\n   |\n   = note:   expected type\
    \ `usize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppl35cbdg.rs:39:18\n   |\n38 |             match (rows_idx[r as\
    \ usize], rows_idx[c as usize]) {\n   |                   --------------------------------------------\
    \ this expression has type `({integer}, {integer})`\n39 |                 (Some(r1),\
    \ Some(c1)) => (r1, c1),\n   |                  ^^^^^^^^ expected integer, found\
    \ enum `Option`\n   |\n   = note: expected type `{integer}`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppl35cbdg.rs:39:28\n\
    \   |\n38 |             match (rows_idx[r as usize], rows_idx[c as usize]) {\n\
    \   |                   -------------------------------------------- this expression\
    \ has type `({integer}, {integer})`\n39 |                 (Some(r1), Some(c1))\
    \ => (r1, c1),\n   |                            ^^^^^^^^ expected integer, found\
    \ enum `Option`\n   |\n   = note: expected type `{integer}`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppl35cbdg.rs:40:18\n\
    \   |\n38 |             match (rows_idx[r as usize], rows_idx[c as usize]) {\n\
    \   |                   -------------------------------------------- this expression\
    \ has type `({integer}, {integer})`\n39 |                 "
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = vec![];\n    for vec in lst {\n        for (i, elt) in vec.iter().enumerate()\
    \ {\n            if elt == x {\n                row.push((i, vec));\n        \
    \        break;\n            }\n        }\n    }\n    if row.is_empty() {\n  \
    \      row\n    } else {\n        let mut cols = row.iter().map(|&(ref i, _)|\
    \ i).collect::<Vec<_>>();\n        cols.sort_by(|&(a, _), &(b)| *a < *b);\n  \
    \      cols.sort_by_key(|&(_, &b)| b);\n        cols.into_iter().map(|&(_, v)|\
    \ v).collect()\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmp97wk7p8z.rs:30:33\n\
    \   |\n30 |         cols.sort_by(|&(a, _), &(b)| *a < *b);\n   |             \
    \                    ^ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n30 -         cols.sort_by(|&(a, _), &(b)|\
    \ *a < *b);\n30 +         cols.sort_by(|&(a, _), &b| *a < *b);\n   | \n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmp97wk7p8z.rs:20:20\n   |\n\
    20 |             if elt == x {\n   |                    ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97wk7p8z.rs:27:9\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n27 |         row\n   |  \
    \       ^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<(usize, Vec<isize>)>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp97wk7p8z.rs:30:24\n   |\n30 |\
    \         cols.sort_by(|&(a, _), &(b)| *a < *b);\n   |                       \
    \ ^^^^^-\n   |                        |    |\n   |                        |  \
    \  expected due to this\n   |                        expected `usize`, found tuple\n\
    \   |\n   = note: expected type `usize`\n             found tuple `(_, _)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp97wk7p8z.rs:30:38\n   |\n30 |  \
    \       cols.sort_by(|&(a, _), &(b)| *a < *b);\n   |                         \
    \             ^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97wk7p8z.rs:31:28\n   |\n31 |         cols.sort_by_key(|&(_,\
    \ &b)| b);\n   |                  "
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = Vec::new();\n    let mut rows = Vec::new();\n    let mut cols = Vec::new();\n\
    \    let mut row_cnt = 0;\n    let mut row_cnt_idx = 0;\n    for r in lst {\n\
    \        cols.clear();\n        let mut col_count = 0;\n        for row in r {\n\
    \            if row == x {\n                row_cnt += 1;\n                cols.push(col_count);\n\
    \                col_count += 1;\n                rows.push(row_cnt);\n      \
    \      }\n            col_count += 1;\n        }\n        if !cols.is_empty()\
    \ {\n            row_cnt_idx += 1;\n            ret.push((row_cnt_idx, cols.clone()));\n\
    \        }\n    }\n    sort_rows(rows, row_cnt_idx, ret)\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmpgnuryad2.rs:39:5\n\
    \   |\n39 |     sort_rows(rows, row_cnt_idx, ret)\n   |     ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // sort\
    \ by rows in ascending order\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n\
    \    for (i, row) in lst.iter().enumerate() {\n        rows = rows.append(row.iter().enumerate().cloned().collect());\n\
    \    }\n    rows = rows.sort_by(|a, b| a.1.cmp(b.1).reverse());\n    // sort by\
    \ columns in descending order\n    rows = rows.reverse().iter().map(|a| {\n  \
    \      (a.0, a.1.iter().enumerate().cloned().collect())\n    }).collect();\n \
    \   // find row's indices\n    let mut index = 0;\n    for (i, row) in rows.iter().enumerate()\
    \ {\n        if index == x {\n            return row;\n        }\n        index\
    \ = row.len() - 1;\n    }\n    unreachable!()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Enumerate<std::slice::Iter<'_,\
    \ isize>> as Iterator>::Item == &_`\n    --> /tmp/tmp738m9uzy.rs:20:51\n     |\n\
    20   |         rows = rows.append(row.iter().enumerate().cloned().collect());\n\
    \     |                                                   ^^^^^^ expected reference,\
    \ found tuple\n     |\n     = note: expected reference `&_`\n                \
    \    found tuple `(usize, &isize)`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp738m9uzy.rs:20:60\n\
    \   |\n20 |            rows = rows.append(row.iter().enumerate().cloned().collect());\n\
    \   |                                                               ^^^^^^^ method\
    \ cannot be called on `Cloned<Enumerate<std::slice::Iter<'_, isize>>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Enumerate<std::slice::Iter<'_, isize>> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n           `Cloned<Enumerate<std::slice::Iter<'_, isize>>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Enumerate<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp738m9uzy.rs:20:16\n\
    \   |\n18 |     let mut rows: Vec<(isize, isize)> = Vec::new();\n   |        \
    \           ------------------- expected due to this type\n19 |     for (i, row)\
    \ in lst.iter().enumerate() {\n20 |         rows = rows.append(row.iter().enumerate().cloned().collect());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\nnote: method `append` modifies its receiver\
    \ in-place\n  --> /tmp/tmp738m9uzy.rs:20:21\n   |\n20 |         rows = rows.append(row.iter().enumerate().cloned().collect());\n\
    \   |                ---- ^^^^^^ this call modifies `rows` in-place\n   |   "
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rows = lst.len();\n    if rows\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut cols = lst[0].len();\n\
    \    if cols == 0 {\n        return vec![];\n    }\n\n    let mut coordinates\
    \ = Vec::new();\n\n    // find sorted coordinates\n    for j in 0..cols {\n  \
    \      for i in 0..rows {\n            let a = lst[i][j];\n            if a <\
    \ x {\n                break;\n            }\n\n            if a > x {\n     \
    \           coordinates.push((i, j));\n                rows = rows - 1;\n    \
    \            cols = cols - 1;\n            }\n        }\n    }\n\n    coordinates\n\
    \        .iter()\n        .cloned()\n        .sort_by(|a, b| a.0.cmp(b.0));\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpn1g10ffb.rs:52:10\n   |\n52 |         .sort_by(|a,\
    \ b| a.0.cmp(b.0));\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ (usize, usize)>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn1g10ffb.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        vec![]\n    } else {\n        match lst.len() {\n            2 =>\
    \ {\n                if x == 0 || x == lst.first_unwrap().len() {\n          \
    \          vec![(lst.first_unwrap()[0], lst.first_unwrap().len())]\n         \
    \       } else {\n                    let mut l = vec![];\n                  \
    \  for i in lst.iter().skip(1).rev() {\n                        if i == 0 || i\
    \ == lst.len() - 1 {\n                            let mut m = vec![];\n      \
    \                      for j in i.iter().skip(1).rev() {\n                   \
    \             if j == 0 || j == i.len() - 1 {\n                              \
    \      m.push((j, i[j]));\n                                }\n               \
    \             }\n                            l.push((lst.len() - 1, m));\n   \
    \                     }\n                    }\n                    l\n      \
    \          }\n            },\n            3 => {\n                if x == 0 ||\
    \ x == lst.len() {\n                    vec![(lst.first_unwrap()[0], lst.len())]\n\
    \                } else {\n                    let mut l = vec![];\n         \
    \           for i in lst.iter().skip(1).rev() {\n                        if i\
    \ == 0 || i == lst.len() - 1 {\n                            let mut m = vec![];\n\
    \                            for j in i.iter().skip(1).rev() {\n             \
    \                   if j == 0 || j == i.len() - 1 {\n                        \
    \            m.push((j, i[j]));\n                                }\n         \
    \                   }\n                            l.push((lst.len() - 1, m));\n\
    \                        }\n                    }\n                    l\n   \
    \             }\n            },\n            _ => {\n                let mut l\
    \ = vec![];\n                for i in lst.iter().skip(1).rev() {\n           \
    \         if i == 0 || i == lst.len() - 1 {\n                        let mut m\
    \ = vec![];\n                        for j in i.iter().skip(1).rev() {\n     \
    \                       if j == 0 || j == i.len() - 1 {\n                    \
    \            m.push((j, i[j]));\n                            }\n             \
    \           }\n                        l.push((lst.len() - 1, m));\n         \
    \           }\n                }\n                l\n            }\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `first_unwrap` found for struct `Vec<Vec<isize>>`\
    \ in the current scope\n  --> /tmp/tmpsvs17awy.rs:22:39\n   |\n22 |          \
    \       if x == 0 || x == lst.first_unwrap().len() {\n   |                   \
    \                    ^^^^^^^^^^^^ method not found in `Vec<Vec<isize>>`\n\nerror[E0599]:\
    \ no method named `first_unwrap` found for struct `Vec<Vec<isize>>` in the current\
    \ scope\n  --> /tmp/tmpsvs17awy.rs:23:31\n   |\n23 |                     vec![(lst.first_unwrap()[0],\
    \ lst.first_unwrap().len())]\n   |                               ^^^^^^^^^^^^\
    \ method not found in `Vec<Vec<isize>>`\n\nerror[E0599]: no method named `first_unwrap`\
    \ found for struct `Vec<Vec<isize>>` in the current scope\n  --> /tmp/tmpsvs17awy.rs:23:54\n\
    \   |\n23 |                     vec![(lst.first_unwrap()[0], lst.first_unwrap().len())]\n\
    \   |                                                      ^^^^^^^^^^^^ method\
    \ not found in `Vec<Vec<isize>>`\n\nerror[E0277]: can't compare `&Vec<isize>`\
    \ with `{integer}`\n  --> /tmp/tmpsvs17awy.rs:27:30\n   |\n27 |              \
    \           if i == 0 || i == lst.len() - 1 {\n   |                          \
    \    ^^ no implementation for `&Vec<isize> == {integer}`\n   |\n   = help: the\
    \ trait `PartialEq<{integer}>` is not implemented for `&Vec<isize>`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0277]: can't compare `&Vec<isize>` with `usize`\n\
    \  --> /tmp/tmpsvs17awy.rs:27:40\n   |\n27 |                         if i == 0\
    \ || i == lst.len() - 1 {\n   |                                        ^^ no implementation\
    \ for `&Vec<isize> == usize`\n   |\n   = help: the trait `PartialEq<usize>` is\
    \ not implemented for `&Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as Part"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        if row.len() == x {\n      \
    \      result.push((row.len() - 1, row.len() - 1));\n        }\n    }\n    result.sort_by_key(|&(k,\
    \ &v)| k.cmp(v));\n    result.sort_by_key(|&(_, v)| -v.cmp(&x));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzr18z_y0.rs:19:25\n   |\n\
    19 |         if row.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if row.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzr18z_y0.rs:23:30\n   |\n23 |     result.sort_by_key(|&(k,\
    \ &v)| k.cmp(v));\n   |                              ^^- expected due to this\n\
    \   |                              |\n   |                              expected\
    \ `usize`, found reference\n   |                              help: you can probably\
    \ remove the explicit borrow: `v`\n   |\n   = note:   expected type `usize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzr18z_y0.rs:24:41\n\
    \   |\n24 |     result.sort_by_key(|&(_, v)| -v.cmp(&x));\n   |              \
    \                           ^^ expected `usize`, found `isize`\n   |\n   = note:\
    \ expected reference `&usize`\n              found reference `&isize`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `std::cmp::Ordering`\n  --> /tmp/tmpzr18z_y0.rs:24:34\n\
    \   |\n24 |     result.sort_by_key(|&(_, v)| -v.cmp(&x));\n   |              \
    \                    ^^^^^^^^^^ cannot apply unary operator `-`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzr18z_y0.rs:25:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coordinates: Vec<(isize, isize)> = vec![];\n    let mut row_coords: Vec<(isize,\
    \ isize)> = vec![];\n    let mut col_coords: Vec<(isize, isize)> = vec![];\n\n\
    \    for i in lst {\n        if i == vec![] {\n            coordinates.push((i,\
    \ 0));\n        } else {\n            if let Some(j) = get_row(i, x) {\n     \
    \           coordinates.push((i, j));\n            }\n        }\n    }\n\n   \
    \ for i in coordinates {\n        let mut min = (i.0 + i.1, i.0);\n        let\
    \ mut max = (i.0 + i.1, i.1);\n        for j in lst {\n            if j == vec![]\
    \ {\n                row_coords.push((i.0 + i.1, j.0));\n                col_coords.push((i.0\
    \ + i.1, j.1));\n                continue;\n            }\n            if let\
    \ Some(k) = get_row(j, x) {\n                if min > k {\n                  \
    \  min = k;\n                }\n                if max < k {\n               \
    \     max = k;\n                }\n            }\n        }\n\n        if max\
    \ < min.0 {\n            row_coords.push((i.0 + i.1, min.0));\n            col_coords.push((i.0\
    \ + i.1, min.1));\n        } else {\n            row_coords.push((i.0 + i.1, max.0));\n\
    \            col_coords.push((i.0 + i.1, max.1));\n        }\n    }\n\n    row_coords.sort_by(|a,\
    \ b| a.0).reverse();\n    col_coords.sort_by(|a, b| b.0).reverse();\n    coordinates.iter().map(|&coord|\
    \ {\n        (coord.0 + coord.1, (coord.1 - coord.0, coord.1))\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4s9_8mn8.rs:23:31\n   |\n\
    23 |             coordinates.push((i, 0));\n   |                             \
    \  ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4s9_8mn8.rs:25:38\n   |\n25 |             if let Some(j) = get_row(i,\
    \ x) {\n   |                                      ^ expected struct `Vec`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4s9_8mn8.rs:25:20\n\
    \   |\n25 |             if let Some(j) = get_row(i, x) {\n   |               \
    \     ^^^^^^^   ------------- this expression has type `Vec<(isize, isize)>`\n\
    \   |                    |\n   |                    expected struct `Vec`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \            found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4s9_8mn8.rs:26:35\n\
    \   |\n26 |                 coordinates.push((i, j));\n   |                  \
    \                 ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<isize>`\n\nerror[E0609]: no field\
    \ `0` on type `Vec<isize>`\n  --> /tmp/tmp4s9_8mn8.rs:36:47\n   |\n36 |      \
    \           row_coords.push((i.0 + i.1, j.0));\n   |                         \
    \                      ^ unknown field\n\nerror[E0609]: no field `1` on type `Vec<isize>`\n\
    \  --> /tmp/tmp4s9_8mn8.rs:37:47\n   |\n37 |                 col_coords.push((i.0\
    \ + i.1, j.1));\n   |                                               ^ unknown\
    \ field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4s9_8mn8.rs:40:38\n \
    \  |\n40 |             if let Some(k) = get_row(j, x) {\n   |                \
    \                      ^ expected struct `Vec`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<Vec<isize>>`\n              found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4s9_8mn8.rs:40:20\n   |\n40 |\
    \             if let Some(k) = get_row(j, x) {\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rs = vec![];\n    let mut cs = vec![];\n    loop {\n        match rs.pop() {\n\
    \            Some(r) => {\n                match cs.pop() {\n                \
    \    Some(c) if r == c => {\n                        break;\n                \
    \    }\n                    Some(c) => {\n                        rs.push((r,\
    \ c));\n                    }\n                    None => {\n               \
    \         cs.push(c);\n                    }\n                }\n            }\n\
    \            None => break,\n        }\n    }\n    rs.sort_by_key(|r| r);\n  \
    \  rs.sort_by_key(|r| -r.1);\n    let mut rs = rs.into_iter().collect::<Vec<_>>();\n\
    \    rs.sort_by_key(|r| -r);\n    rs.sort_by_key(|r| -r);\n    rs.iter().enumerate().filter_map(|(i,\
    \ r)| {\n        if *r == x {\n            let mut cs = cs.into_iter().collect::<Vec<_>>();\n\
    \            cs.sort_by_key(|c| -c.1);\n            rs.push(i as isize);\n   \
    \         rs.extend(cs.into_iter().collect::<Vec<_>>());\n            return Some((i,\
    \ *r));\n        }\n        None\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpjjxsldwc.rs:30:33\n\
    \   |\n30 |                         cs.push(c);\n   |                        \
    \         ^ help: a local variable with a similar name exists: `cs`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjjxsldwc.rs:27:33\n   |\n27 |              \
    \           rs.push((r, c));\n   |                                 ^^^^^^ cyclic\
    \ type of infinite size\n\nerror[E0609]: no field `1` on type `&_`\n  --> /tmp/tmpjjxsldwc.rs:38:27\n\
    \   |\n38 |     rs.sort_by_key(|r| -r.1);\n   |                           ^\n\n\
    error[E0609]: no field `1` on type `&_`\n  --> /tmp/tmpjjxsldwc.rs:45:35\n   |\n\
    45 |             cs.sort_by_key(|c| -c.1);\n   |                             \
    \      ^\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![(0, 0)].iter().cloned().collect();\n    if lst.len() == 0 || lst.len()\
    \ != lst[0].len() {\n        return vec![];\n    }\n    let mut row = 0;\n   \
    \ let mut col = 0;\n    while row < lst.len() {\n        if row == x {\n     \
    \       return coords.iter().cloned().collect();\n        }\n        if lst[row].len()\
    \ <= col {\n            break;\n        }\n        let i = lst[row].len() - 1;\n\
    \        let v = lst[row][i];\n        coords.insert(coords[coords.len() - 1],\
    \ v);\n        row++;\n        col--;\n    }\n    coords.iter().cloned().sort_by(|a,\
    \ b| b.1.cmp_lower(a.1));\n    coords.iter().cloned().reverse().sort_by(|a, b|\
    \ b.1.cmp_lower(a.1));\n    return coords.iter().cloned().collect();\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfuif48jg.rs:33:12\n\
    \   |\n33 |         row++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n33 |         { let tmp = row; row += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n33 -         row++;\n\
    33 +         row += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfuif48jg.rs:24:19\n\
    \   |\n24 |         if row == x {\n   |                   ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |         if row == x.try_into().unwrap()\
    \ {\n   |                    ++++++++++++++++++++\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret: Vec<(isize, isize)> = Vec::new();\n    for mut r in lst.iter() {\n    \
    \    if r.len() > x {\n            ret = r.iter().take(x).collect();\n       \
    \     break;\n        }\n    }\n    ret.sort();\n    ret.sort_by_key(|(x, y)|\
    \ {\n        y.cmp(x)\n    });\n    ret\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbsju4qs.rs:19:22\n   |\n\
    19 |         if r.len() > x {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |         if r.len() > x.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkbsju4qs.rs:20:33\n   |\n20 |             ret = r.iter().take(x).collect();\n\
    \   |                                 ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n20 |             ret = r.iter().take(x.try_into().unwrap()).collect();\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0277]: a\
    \ value of type `Vec<(isize, isize)>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmpkbsju4qs.rs:20:36\n     |\n20   |        \
    \     ret = r.iter().take(x).collect();\n     |                              \
    \      ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut col = 0;\n    for row in 0..(lst.len()) {\n        let\
    \ mut col_max = row.iter().cloned().max().unwrap() + 1;\n        let mut col_min\
    \ = 0;\n        for row in 0..row.len() {\n            if col_max == row.len()\
    \ {\n                if lst[row[row]] < x {\n                    col_max = 1;\n\
    \                } else {\n                    col_max = row.len() + 1;\n    \
    \            }\n            }\n            if col_min == 0 {\n               \
    \ if lst[row[row]] >= x {\n                    col_min = 1;\n                }\
    \ else {\n                    col_min = row.len() + 1;\n                }\n  \
    \          }\n            if col_min < col_max {\n                return vec![(row,\
    \ col)]\n            }\n            col += 1;\n        }\n        col -= 1;\n\
    \    }\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpvz_dq8wv.rs:20:31\n   |\n20 |         let mut col_max =\
    \ row.iter().cloned().max().unwrap() + 1;\n   |                              \
    \ ^^^^ method not found in `usize`\n\nerror[E0599]: no method named `len` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpvz_dq8wv.rs:22:27\n   |\n\
    22 |         for row in 0..row.len() {\n   |                           ^^^ method\
    \ not found in `usize`\n\nerror[E0689]: can't call method `len` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmpvz_dq8wv.rs:23:31\n   |\n22 |         for row\
    \ in 0..row.len() {\n   |             --- you must specify a type for this binding,\
    \ like `i32`\n23 |             if col_max == row.len() {\n   |               \
    \                ^^^\n\nerror[E0608]: cannot index into a value of type `{integer}`\n\
    \  --> /tmp/tmpvz_dq8wv.rs:24:24\n   |\n24 |                 if lst[row[row]]\
    \ < x {\n   |                        ^^^^^^^^\n\nerror[E0689]: can't call method\
    \ `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpvz_dq8wv.rs:27:35\n\
    \   |\n22 |         for row in 0..row.len() {\n   |             --- you must specify\
    \ a type for this binding, like `i32`\n...\n27 |                     col_max =\
    \ row.len() + 1;\n   |                                   ^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `{integer}`\n  --> /tmp/tmpvz_dq8wv.rs:31:24\n\
    \   |\n31 |                 if lst[row[row]] >= x {\n   |                    \
    \    ^^^^^^^^\n\nerror[E0689]: can't call method `len` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmpvz_dq8wv.rs:34:35\n   |\n22 |         for row in\
    \ 0..row.len() {\n   |             --- you must specify a type for this binding,\
    \ like `i32`\n...\n34 |                     col_min = row.len() + 1;\n   |   \
    \                                ^^^\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst_rows: Vec<Vec<(isize, isize)>> = vec![];\n    for row in lst {\n       \
    \ let mut lst_columns: Vec<isize> = vec![];\n        for col in row {\n      \
    \      let y = col - x;\n            if y < 0 {\n                y = 0;\n    \
    \        }\n            lst_columns.push(y);\n        }\n        lst_rows.push(lst_columns);\n\
    \    }\n    lst_rows.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n    lst_rows.iter().map(|lst|\
    \ lst.sort_by(|a, b| b.iter().cmp(b.iter()).reverse()));\n    lst_rows.iter().map(|lst|\
    \ lst.iter().cloned().collect::<Vec<_>>()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmu2u0uf.rs:27:23\n   |\n\
    27 |         lst_rows.push(lst_columns);\n   |                       ^^^^^^^^^^^\
    \ expected tuple, found `isize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `iter` found for reference `&(isize, isize)` in the current scope\n  -->\
    \ /tmp/tmphmu2u0uf.rs:30:52\n   |\n30 |     lst_rows.iter().map(|lst| lst.sort_by(|a,\
    \ b| b.iter().cmp(b.iter()).reverse()));\n   |                               \
    \                     ^^^^ method not found in `&(isize, isize)`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&(isize, isize)` in the current\
    \ scope\n  --> /tmp/tmphmu2u0uf.rs:30:65\n   |\n30 |     lst_rows.iter().map(|lst|\
    \ lst.sort_by(|a, b| b.iter().cmp(b.iter()).reverse()));\n   |               \
    \                                                  ^^^^ method not found in `&(isize,\
    \ isize)`\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built\
    \ from an iterator over elements of type `Vec<(isize, isize)>`\n    --> /tmp/tmphmu2u0uf.rs:31:72\n\
    \     |\n31   |     lst_rows.iter().map(|lst| lst.iter().cloned().collect::<Vec<_>>()).collect()\n\
    \     |                                                                      \
    \  ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Vec<(isize,\
    \ isize)>>`\n     |\n     = help: the trait `FromIterator<Vec<(isize, isize)>>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ col = vec![];\n    let mut row = vec![];\n    let mut row_len = lst.len() as\
    \ isize;\n    let mut col_len = lst.first().len() as isize;\n\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst.first().len() {\n            if i == x {\n      \
    \          result.push((i, j));\n            }\n            row.append((i, j));\n\
    \            if j == col_len - 1 {\n                col.push((i, j));\n      \
    \      }\n        }\n        if row != row.last() {\n            result.push((i,\
    \ row));\n        }\n        col.pop();\n    }\n    if row != row.last() {\n \
    \       result.push((i, row));\n    }\n    if col != col.last() {\n        result.push((i,\
    \ col));\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpz8wwacz7.rs:42:22\n\
    \   |\n42 |         result.push((i, row));\n   |                      ^ help:\
    \ a local variable with a similar name exists: `x`\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpz8wwacz7.rs:45:22\n   |\n45 |       \
    \  result.push((i, col));\n   |                      ^ help: a local variable\
    \ with a similar name exists: `x`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpz8wwacz7.rs:24:35\n  \
    \ |\n24 |     let mut col_len = lst.first().len() as isize;\n   |            \
    \                       ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpz8wwacz7.rs:27:33\n\
    \   |\n27 |         for j in 0..lst.first().len() {\n   |                    \
    \             ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz8wwacz7.rs:28:21\n   |\n28 |             if i == x {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n28 |             if i == x.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz8wwacz7.rs:31:24\n\
    \   |\n31 |             row.append((i, j));\n   |                        ^^^^^^\
    \ expected `&mut Vec<_>`, found tuple\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                          found tuple `(usize, {integer})`\n\n\
    error[E0277]: can't compare `Vec<_>` with `Option<&_>`\n  --> /tmp/tmpz8wwacz7.rs:36:16\n\
    \   |\n36 |         if row != row.last() {\n   |                ^^ no implementation\
    \ for `Vec<_> == Option<&_>`\n   |\n   = help: the trait `PartialEq<Option<&_>>`\
    \ is not implemented for `Vec<_>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as Partial"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = Vec::new();\n    let mut row = 0;\n    let mut col = 0;\n    while\
    \ row != lst.len() {\n        let mut row = row + 1;\n        let mut col = x;\n\
    \        while col != lst[row].len() {\n            result.push((row, col));\n\
    \            col = col + 1;\n        }\n        row = row + 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| -y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd631khj7.rs:23:22\n   |\n\
    23 |         while col != lst[row].len() {\n   |                      ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n23 |         while\
    \ col != lst[row].len().try_into().unwrap() {\n   |                          \
    \          ++++++++++++++++++++\n\nerror[E0610]: `usize` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpd631khj7.rs:29:36\n   |\n29 | \
    \    result.sort_by_key(|&(x, y)| x.0);\n   |                                \
    \    ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpd631khj7.rs:30:37\n   |\n30 |     result.sort_by_key(|&(x,\
    \ y)| -y.0);\n   |                                     ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd631khj7.rs:31:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n31 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, _)>`\n              found struct\
    \ `Vec<(usize, _)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Sort\
    \ the rows initially by rows in ascending order\n    lst.sort_by_key(|row| row.iter().cloned().collect::<Vec<_>>()).reverse();\n\
    \n    // Sort the columns initially by columns in descending order\n    lst.sort_by_key(|row|\
    \ row.to_vec().reverse());\n\n    // Return coordinates (row, column) for given\
    \ index\n    lst.iter().enumerate().map(|(i, row)| {\n        (i, row.iter().enumerate().map(|(j,\
    \ col)| {\n            (j, col)\n        }).collect::<Vec<_>>())\n    }).find(|row|\
    \ row.0 == x).map(|row| row.1).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpmbdebndd.rs:18:68\n   |\n18 |     lst.sort_by_key(|row|\
    \ row.iter().cloned().collect::<Vec<_>>()).reverse();\n   |                  \
    \                                                  ^^^^^^^ method not found in\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmbdebndd.rs:28:28\n  \
    \ |\n28 |     }).find(|row| row.0 == x).map(|row| row.1).collect()\n   |     \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n28 |     }).find(|row| row.0 == x.try_into().unwrap()).map(|row| row.1).collect()\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0599]: `Option<Vec<(usize,\
    \ &isize)>>` is not an iterator\n   --> /tmp/tmpmbdebndd.rs:28:48\n    |\n28 \
    \ |       }).find(|row| row.0 == x).map(|row| row.1).collect()\n    |        \
    \                                          ^^^^^^^ `Option<Vec<(usize, &isize)>>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<Vec<(usize, &isize)>>: Iterator`\n            which is required\
    \ by `&mut Option<Vec<(usize, &isize)>>: Iterator`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted = vec![];\n    let mut last_row = vec![];\n\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        last_row.clear();\n        let mut j = 0;\n        let mut row_sort_j\
    \ = -1;\n        let mut row_sort_k = -1;\n\n        for (j, col) in row.iter().enumerate()\
    \ {\n            if j == x {\n                row_sort_j = (i, col);\n       \
    \     }\n            if j == last_row.len() - 1 {\n                row_sort_k\
    \ = (i, col);\n            }\n\n            last_row.push(col);\n\n          \
    \  if j == row_sort_j {\n                sorted.push((i, col));\n            }\n\
    \        }\n    }\n\n    sorted.sort_by(|a, b| a[0] > b[0] ? -1 : 1);\n\n    sorted\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `1`\n  --> /tmp/tmpy04l9mgp.rs:42:46\n   |\n\
    42 |     sorted.sort_by(|a, b| a[0] > b[0] ? -1 : 1);\n   |                  \
    \                          - ^ expected type\n   |                           \
    \                 |\n   |                                            tried to\
    \ parse a type due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy04l9mgp.rs:27:21\n\
    \   |\n27 |             if j == x {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |             if j == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy04l9mgp.rs:28:30\n   |\n23 |         let mut row_sort_j\
    \ = -1;\n   |                              -- expected due to this value\n...\n\
    28 |                 row_sort_j = (i, col);\n   |                            \
    \  ^^^^^^^^ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, &isize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy04l9mgp.rs:31:30\n   |\n24 |         let mut row_sort_k = -1;\n\
    \   |                              -- expected due to this value\n...\n31 |  \
    \               row_sort_k = (i, col);\n   |                              ^^^^^^^^\
    \ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, &isize)`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpy04l9mgp.rs:23:30\n   |\n23 |         let\
    \ mut row_sort_j = -1;\n   |                              ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n\n    let mut lst_copy = lst.clone();\n    lst_copy.sort();\n\
    \    let mut row_copy = lst_copy[0].clone();\n    let mut row_sort_desc = row_copy.clone();\n\
    \    row_sort_desc.sort();\n    let mut last_row: Vec<(isize, isize)> = vec![];\n\
    \    for elem in row_copy {\n        if elem == x {\n            result.push((last_row.len(),\
    \ last_row.len()));\n            last_row.push((elem.len(), elem));\n        }\
    \ else {\n            last_row.push((elem.len(), elem));\n        }\n    }\n \
    \   result.sort_by_key(|a, b| b.1.cmp(b.0).reverse());\n    let mut row_sort_asc\
    \ = result.clone();\n    row_sort_asc.sort_by_key(|a, b| b.0.cmp(b.1).reverse());\n\
    \n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpvg55encn.rs:28:33\n   |\n28 |             last_row.push((elem.len(),\
    \ elem));\n   |                                 ^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpvg55encn.rs:30:33\n   |\n30 |             last_row.push((elem.len(),\
    \ elem));\n   |                                 ^^^ method not found in `isize`\n\
    \nerror[E0593]: closure is expected to take 1 argument, but it takes 2 arguments\n\
    \  --> /tmp/tmpvg55encn.rs:33:12\n   |\n33 |     result.sort_by_key(|a, b| b.1.cmp(b.0).reverse());\n\
    \   |            ^^^^^^^^^^^ ------ takes 2 arguments\n   |            |\n   |\
    \            expected closure that takes 1 argument\n\nerror[E0593]: closure is\
    \ expected to take 1 argument, but it takes 2 arguments\n  --> /tmp/tmpvg55encn.rs:35:18\n\
    \   |\n35 |     row_sort_asc.sort_by_key(|a, b| b.0.cmp(b.1).reverse());\n   |\
    \                  ^^^^^^^^^^^ ------ takes 2 arguments\n   |                \
    \  |\n   |                  expected closure that takes 1 argument\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvg55encn.rs:37:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0593, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row: Vec<(isize, isize)> = vec![];\n    lst\n\
    \        .iter()\n        .map(|y| {\n            row.clear();\n            row.extend(y.iter().cloned());\n\
    \            result.push((\n                row.iter()\n                    .map(|x|\
    \ x.1).collect::<Vec<_>>(),\n                row.iter()\n                    .map(|x|\
    \ x.1).reverse().collect::<Vec<_>>(),\n            ));\n        })\n        .filter(|y|\
    \ {\n            match y {\n                None => false,\n                Some((None,\
    \ None)) => false,\n                Some((x, y)) => x <= x,\n                Some((x,\
    \ _)) => false,\n                Some((_, y)) => false,\n            }\n     \
    \   })\n        .sort_by(|x, y| y.1).reverse();\n    result.sort_by(|x, y| y.2);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Vec<(isize, isize)>: Extend<isize>` is not\
    \ satisfied\n  --> /tmp/tmp9luu9_xc.rs:23:17\n   |\n23 |             row.extend(y.iter().cloned());\n\
    \   |                 ^^^^^^ the trait `Extend<isize>` is not implemented for\
    \ `Vec<(isize, isize)>`\n   |\n   = help: the following other types implement\
    \ trait `Extend<A>`:\n             <Vec<T, A> as Extend<&'a T>>\n            \
    \ <Vec<T, A> as Extend<T>>\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `Map` in the current scope\n  --> /tmp/tmp9luu9_xc.rs:28:35\n   |\n28\
    \ |                     .map(|x| x.1).reverse().collect::<Vec<_>>(),\n   |   \
    \                                ^^^^^^^ method not found in `Map<std::slice::Iter<'_,\
    \ (isize, isize)>, [closure@/tmp/tmp9luu9_xc.rs:28:26: 28:33]>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9luu9_xc.rs:33:17\n   |\n32 |             match\
    \ y {\n   |                   - this expression has type `&()`\n33 |         \
    \        None => false,\n   |                 ^^^^ expected `()`, found enum `Option`\n\
    \   |\n   = note: expected unit type `()`\n                   found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9luu9_xc.rs:34:17\n   |\n32 |\
    \             match y {\n   |                   - this expression has type `&()`\n\
    33 |                 None => false,\n34 |                 Some((None, None)) =>\
    \ false,\n   |                 ^^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n\
    \   |\n   = note: expected unit type `()`\n                   found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9luu9_xc.rs:35:17\n   |\n32 |\
    \             match y {\n   |                   - this expression has type `&()`\n\
    ...\n35 |                 Some((x, y)) => x <= x,\n   |                 ^^^^^^^^^^^^\
    \ expected `()`, found enum `Option`\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9luu9_xc.rs:36:17\n   |\n32 |             match y {\n   |     \
    \              - this expression has type `&()`\n...\n36 |                 Some((x,\
    \ _)) => false,\n   |"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut vec: Vec<(isize, isize)> =\
    \ vec![];\n        for y in lst {\n            for x in y {\n                if\
    \ x == x {\n                    vec.push((x, y))\n                } else {\n \
    \                   continue;\n                }\n            }\n        }\n \
    \       vec.sort_by_key(|&(_, y)| y.cmp(&x));\n        vec.sort_by_key(|&(_, y)|\
    \ y.cmp(&x.reverse()));\n        vec\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr_o27hgn.rs:24:34\n   |\n\
    24 |                     vec.push((x, y))\n   |                              \
    \    ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0599]: no method named `reverse`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpr_o27hgn.rs:31:44\n\
    \   |\n31 |         vec.sort_by_key(|&(_, y)| y.cmp(&x.reverse()));\n   |    \
    \                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    sortRows(lst,\
    \ |v| v.iter().rev().take(x));\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sortRows` in this scope\n  --> /tmp/tmpo_dch87v.rs:17:5\n\
    \   |\n17 |     sortRows(lst, |v| v.iter().rev().take(x));\n   |     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_dch87v.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    debug_assert!(lst.len()\
    \ > 0);\n    debug_assert!(lst.len() <= 4);\n    let mut result = vec![];\n  \
    \  for y in lst.iter().rev() {\n        for (x, y) in y.iter().enumerate() {\n\
    \            if x == x {\n                result.push((x, y - 1));\n         \
    \   }\n        }\n    }\n    result.sort();\n    result.sort();\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpafauengt.rs:29:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, _)>`\n\
    \              found struct `Vec<(usize, _)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut ret: Vec<(isize, isize)>\
    \ = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut ind = 0;\n    let mut cols = -cols;\n\n    for row in &lst {\n  \
    \      for row in row {\n            if ind >= x {\n                break;\n \
    \           }\n\n            let ind2 = ind - row;\n            let (row, cols)\
    \ = rows.next_back().unwrap();\n            ret.append((ind2, col));\n       \
    \     ind += 1;\n        }\n    }\n\n    ret.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    ret.sort_by(|a, b| b.2.cmp(&a.2));\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `col` in this scope\n  --> /tmp/tmp92mxmi1a.rs:35:31\n\
    \   |\n35 |             ret.append((ind2, col));\n   |                       \
    \        ^^^ help: a local variable with a similar name exists: `cols`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp92mxmi1a.rs:25:20\n\
    \   |\n25 |     let mut cols = -cols;\n   |                    ^^^^^ cannot apply\
    \ unary operator `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0599]:\
    \ no method named `next_back` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmp92mxmi1a.rs:34:36\n   |\n34 |             let (row, cols) = rows.next_back().unwrap();\n\
    \   |                                    ^^^^^^^^^ method not found in `usize`\n\
    \nerror[E0609]: no field `2` on type `&(isize, isize)`\n  --> /tmp/tmp92mxmi1a.rs:41:26\n\
    \   |\n41 |     ret.sort_by(|a, b| b.2.cmp(&a.2));\n   |                     \
    \     ^\n\nerror[E0609]: no field `2` on type `&(isize, isize)`\n  --> /tmp/tmp92mxmi1a.rs:41:35\n\
    \   |\n41 |     ret.sort_by(|a, b| b.2.cmp(&a.2));\n   |                     \
    \              ^\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599, E0600, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut rows = vec![];\n    let mut cols\
    \ = vec![];\n    let mut r = x;\n    while let Some(ref cell) = lst.first() {\n\
    \        if r < cell.len() {\n            rows.push((r + 1, cell.len() - 1));\n\
    \            cols.push(r);\n        }\n        r += cell.len();\n    }\n    if\
    \ cols.len() == rows.len() {\n        return vec![];\n    }\n    cols.sort();\n\
    \    rows.sort();\n    let mut i = 0;\n    let mut j = cols.len() - 1;\n    while\
    \ i != cols.len() && j != rows.len() {\n        if cols[i].0 > rows[j].0 {\n \
    \           rows[j], rows[i] = rows[i], rows[j];\n        }\n        if i == cols.len()\
    \ - 1 && j == rows.len() - 1 {\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    rows\n        .into_iter()\n        .map(|x| vec![(x[0]\
    \ + 1, x[1] - 1), (x[0] + 1, x[1] + 1), (x[0], x[1] - 1), (x[0], x[1] + 1)])\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmp7ghf7c8s.rs:39:20\n   |\n39 |             rows[j], rows[i] = rows[i],\
    \ rows[j];\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ghf7c8s.rs:24:16\n\
    \   |\n24 |         if r < cell.len() {\n   |                ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |         if r < cell.len().try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7ghf7c8s.rs:28:14\n   |\n28 |         r += cell.len();\n\
    \   |              ^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add-assign `usize` to `isize`\n  --> /tmp/tmp7ghf7c8s.rs:28:11\n   |\n\
    28 |         r += cell.len();\n   |           ^^ no implementation for `isize\
    \ += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp7ghf7c8s.rs:38:20\n   |\n38 |         if cols[i].0\
    \ > rows[j].0 {\n   |                    ^\n\nerror[E0608]: cannot index into\
    \ a value of type `(isize, usize)`\n  --> /tmp/tmp7ghf7c8s.rs:49:24\n   |\n49\
    \ |         .map(|x| vec![(x[0] + 1, x[1] - 1), (x[0] + 1, x[1] + 1), (x[0], x[1]\
    \ - 1), (x[0], x[1] + 1)])\n   |                        ^^^^ help: to access tuple\
    \ elements, use: `x.0`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ usize)`\n  --> /tmp/tmp7ghf7c8s.rs:49:34\n   |\n49 |         .map(|x| vec![(x[0]\
    \ + 1, x[1] - 1), (x[0] + 1, x[1] + 1), (x[0], x["
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = Vec::new();\n\
    \n    for (i, row) in lst.iter().enumerate() {\n        if i == x {\n        \
    \    return coords;\n        }\n\n        cols = row.len();\n\n        for row\
    \ in row.iter().rev() {\n            if row == x {\n                coords.push((i,\
    \ cols - 1));\n                return coords;\n            }\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8cw8y9b.rs:22:17\n   |\n\
    22 |         if i == x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         if i == x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw8cw8y9b.rs:30:30\n   |\n30 |                 coords.push((i, cols -\
    \ 1));\n   |                              ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |                 coords.push((i.try_into().unwrap(),\
    \ cols - 1));\n   |                               ++++++++++++++++++++\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpw8cw8y9b.rs:29:20\n   |\n\
    29 |             if row == x {\n   |                    ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw8cw8y9b.rs:30:33\n\
    \   |\n30 |                 coords.push((i, cols - 1));\n   |                \
    \                 ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n30 |                 coords.push((i, (cols - 1).try_into().unwrap()));\n\
    \   |                                 +        +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw8cw8y9b.rs:21:5\n   |\n16 |   fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                               ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n21 | /     for (i, row) in lst.iter().enumerate()\
    \ {\n22 | |         if i == x {\n23 | |        "
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if !lst.is_empty()\
    \ {\n        let mut res = vec![];\n        for r in lst {\n            let mut\
    \ col_counts = vec![];\n            for c in r {\n                if c == x {\n\
    \                    res.push((r.iter().cloned().collect(), col_counts.iter().cloned().collect()));\n\
    \                }\n                col_counts.push(1);\n            }\n     \
    \       if col_counts.len() > 1 {\n                col_counts.sort();\n      \
    \          col_counts.reverse();\n                col_counts.sort();\n       \
    \     }\n        }\n        res.sort_by(|a, b| b[0].cmp(&a[0]));\n        res.sort_by(|a,\
    \ b| b[1].cmp(&b[0]));\n        return res;\n    } else {\n        vec![]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&(_, _)`\n  --> /tmp/tmp832hjzkd.rs:33:28\n\
    \   |\n33 |         res.sort_by(|a, b| b[0].cmp(&a[0]));\n   |               \
    \             ^^^^\n\nerror[E0608]: cannot index into a value of type `&(_, _)`\n\
    \  --> /tmp/tmp832hjzkd.rs:33:38\n   |\n33 |         res.sort_by(|a, b| b[0].cmp(&a[0]));\n\
    \   |                                      ^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `&(_, _)`\n  --> /tmp/tmp832hjzkd.rs:34:28\n   |\n34 |\
    \         res.sort_by(|a, b| b[1].cmp(&b[0]));\n   |                         \
    \   ^^^^\n\nerror[E0608]: cannot index into a value of type `&(_, _)`\n  --> /tmp/tmp832hjzkd.rs:34:38\n\
    \   |\n34 |         res.sort_by(|a, b| b[1].cmp(&b[0]));\n   |               \
    \                       ^^^^\n\nerror[E0277]: a value of type `isize` cannot be\
    \ built from an iterator over elements of type `isize`\n    --> /tmp/tmp832hjzkd.rs:23:49\n\
    \     |\n23   |                     res.push((r.iter().cloned().collect(), col_counts.iter().cloned().collect()));\n\
    \     |                                                 ^^^^^^^ value of type\
    \ `isize` cannot be built from `std::iter::Iterator<Item=isize>`\n     |\n   \
    \  = help: the trait `FromIterator<isize>` is not implemented for `isize`\nnote:\
    \ required by a bound in `collect`\n\nerror[E0277]: a value of type `isize` cannot\
    \ be built from an iterator over elements of type `{integer}`\n    --> /tmp/tmp832hjzkd.rs:23:87\n\
    \     |\n23   |                     res.push((r.iter().cloned().collect(), col_counts.iter().cloned().collect()));\n\
    \     |                                                                      \
    \                 ^^^^^^^ value of type `isize` cannot be built from `std::iter::Iterator<Item={integer}>`\n\
    \     |\n     = help: the trait `FromIterator<{integer}>` is not implemented for\
    \ `isize`\nnote: required by a bound in `collect`\n\nerror: aborting due to 6\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ tuples: Vec<(isize, isize)> = Vec::new();\n    let mut sorted_rows: Vec<isize>\
    \ = Vec::new();\n    let mut sorted_columns: Vec<isize> = Vec::new();\n    for\
    \ row in lst {\n        let mut row = row.clone();\n        let mut sorted_row\
    \ = row.clone();\n        sorted_row.sort_by_key(|&x| x).unwrap();\n        for\
    \ col in sorted_row.iter().rev() {\n            let mut col = col.clone();\n \
    \           col.sort_by_key(|&x| -x)\n                .expect(\"Cannot sort row\
    \ or column\");\n            if *col >= x {\n                let tuple = (*row,\
    \ *col);\n                tuples.push(tuple);\n            }\n        }\n    \
    \    sorted_rows.sort_by_key(|&x| x).unwrap();\n        sorted_columns.sort_by_key(|&x|\
    \ -x)\n            .expect(\"Cannot sort row or column\");\n    }\n    tuples.sort_by(|&a,\
    \ &b| a.0 > b.0);\n    let mut tuples = tuples.clone();\n    for i in 0..tuples.len()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        let mut tuple\
    \ = tuples.clone();\n        let mut last_tuple = tuples.clone();\n        last_tuple.pop();\n\
    \        for j in 0..last_tuple.len() {\n            let mut tuple = last_tuple.clone();\n\
    \            tuple.pop();\n            if tuple == tuple {\n                continue;\n\
    \            }\n            if let Some(row) = i {\n                let mut row\
    \ = sorted_rows.clone();\n                row.sort_by_key(|&x| x).unwrap();\n\
    \                let mut sorted_column = row.clone();\n                sorted_column.sort_by_key(|&x|\
    \ -x)\n                    .expect(\"Cannot sort row or column\");\n         \
    \       if *row == *j {\n                    if let Some(column) = sorted_columns.iter().find(|&x|\
    \ x == *column) {\n                        let tuple = (*row, *column);\n    \
    \                    tuples.push(tuple);\n                    }\n            \
    \    }\n            }\n        }\n    }\n    tuples\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `column`\n  --> /tmp/tmp0tugxzpx.rs:59:81\n\
    \   |\n59 |                     if let Some(column) = sorted_columns.iter().find(|&x|\
    \ x == *column) {\n   |                                                      \
    \                           ^^^^^^ not a value\n\nerror[E0599]: no method named\
    \ `unwrap` found for unit type `()` in the current scope\n  --> /tmp/tmp0tugxzpx.rs:23:40\n\
    \   |\n23 |         sorted_row.sort_by_key(|&x| x).unwrap();\n   |           \
    \                             ^^^^^^ method not found in `()`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp0tugxzpx.rs:26:17\n   |\n26 |             col.sort_by_key(|&x|\
    \ -x)\n   |                 ^^^^^^^^^^^ method not found in `isize`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp0tugxzpx.rs:28:16\n   |\n\
    28 |             if *col >= x {\n   |                ^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmp0tugxzpx.rs:29:36\n   |\n29 |\
    \                 let tuple = (*row, *col);\n   |                            \
    \        ^^^^\n\nerror[E0599]: no method named `unwrap` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmp0tugxzpx.rs:33:41\n   |\n33 |         sorted_rows.sort_by_key(|&x|\
    \ x).unwrap();\n   |                                         ^^^^^^ method not\
    \ found in `()`\n\nerror[E0599]: no method named `expect` found for unit type\
    \ `()` in the current scope\n  --> /tmp/tmp0tugxzpx.rs:35:14\n   |\n35 |     \
    \        .expect(\"Cannot sort row or column\");\n   |              ^^^^^^ method\
    \ not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tugxzpx.rs:37:29\n\
    \   |\n37 |     tuples.sort_by(|&a, &b| a.0 > b.0);\n   |                    \
    \         ^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0tugxzpx.rs:52:20\n   |\n52 |             if\
    \ let Some(row) = i {\n   |                    ^^^^^^^^^   - this expression has\
    \ type `usize`\n   |                    |\n   |                    expected `usize`,\
    \ found enum `Optio"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.into_iter().cloned().collect::<Vec<Vec<isize>>>();\n    if lst.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut x = lst.iter().position(|row|\
    \ row.contains(&x)).unwrap();\n        let mut y = x;\n        let mut counter\
    \ = 1;\n        while counter < lst.len() {\n            if lst[x].len() > y {\n\
    \                lst.swap(x, y);\n                x -= 1;\n                y -=\
    \ 1;\n                counter += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        lst[x..y].into_iter().cloned().collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<Vec<isize>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp9la391s6.rs:17:35\n     |\n17   |\
    \     let mut lst = lst.into_iter().cloned().collect::<Vec<Vec<isize>>>();\n \
    \    |                                   ^^^^^^ expected reference, found struct\
    \ `Vec`\n     |\n     = note: expected reference `&_`\n                   found\
    \ struct `Vec<isize>`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<Vec<isize>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp9la391s6.rs:17:44\n \
    \  |\n17 |       let mut lst = lst.into_iter().cloned().collect::<Vec<Vec<isize>>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<Vec<isize>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<Vec<isize>>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<Vec<isize>>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<Vec<isize>>>: Iterator`\n \
    \          which is required by `&mut Cloned<std::vec::IntoIter<Vec<isize>>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    debug_assert!(lst.len()\
    \ > 0);\n\n    // To speed things up, we only need to scan upto x once.\n    //\
    \ We can do the same thing in reverse as well.\n    let mut res = vec![];\n  \
    \  let mut curr_row = vec![];\n    let mut curr_col = vec![];\n    for row in\
    \ lst {\n        let mut curr_row_tmp = vec![];\n        let mut curr_col_tmp\
    \ = vec![];\n        let mut curr_row_last = -1;\n        let mut curr_col_last\
    \ = -1;\n        for mut col in row.iter().rev() {\n            if curr_col +\
    \ 1 == x {\n                curr_row_tmp.push(curr_row);\n                curr_col_tmp\
    \ = curr_col;\n                curr_col += 1;\n            } else {\n        \
    \        if col + 1 == x {\n                    curr_row_tmp.push(curr_row);\n\
    \                    curr_col_tmp = curr_col;\n                } else {\n    \
    \                if curr_row_last == -1 || col + 1 > x {\n                   \
    \     curr_row_last = row;\n                        curr_col_tmp = col;\n    \
    \                }\n                }\n            }\n        }\n        res.push(curr_row_tmp);\n\
    \        curr_col = curr_col_tmp;\n        curr_row = curr_row_last;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Vec<_>`\n  --> /tmp/tmpqocq62hy.rs:30:25\n\
    \   |\n30 |             if curr_col + 1 == x {\n   |                -------- ^\
    \ - {integer}\n   |                |\n   |                Vec<_>\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpqocq62hy.rs:33:17\n\
    \   |\n33 |                 curr_col += 1;\n   |                 --------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `Vec<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqocq62hy.rs:40:41\n   |\n27 |\
    \         let mut curr_row_last = -1;\n   |                                 --\
    \ expected due to this value\n...\n40 |                         curr_row_last\
    \ = row;\n   |                                         ^^^ expected integer, found\
    \ struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found\
    \ struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqocq62hy.rs:41:40\n\
    \   |\n26 |         let mut curr_col_tmp = vec![];\n   |                     \
    \           ------ expected due to this value\n...\n41 |                     \
    \    curr_col_tmp = col;\n   |                                        ^^^ expected\
    \ struct `Vec`, found `&isize`\n   |\n   = note: expected struct `Vec<_>`\n  \
    \         found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqocq62hy.rs:48:20\n\
    \   |\n22 |     let mut curr_row = vec![];\n   |                        ------\
    \ expected due to this value\n...\n48 |         curr_row = curr_row_last;\n  \
    \ |                    ^^^^^^^^^^^^^ expected struct `Vec`, found integer\n  \
    \ |\n   = note: expected struct `Vec<_>`\n                found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqocq62hy.rs:50:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n50 |     res\n   |     ^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              fo"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ v = Vec::new();\n    let mut rows = lst.len();\n    let mut columns = lst.first().len();\n\
    \n    let mut i = 0;\n    while i <= rows {\n        let mut j = 0;\n        while\
    \ j <= columns {\n            if i + j < rows && lst.as_slice()[i + j].iter().all(|x|\
    \ x == x) {\n                let y = lst.iter().skip(i + j).skip(1).take(columns).nth(0).unwrap();\n\
    \                v.push((i, j));\n                i += 1;\n                break;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    v.sort_by_key(|&(x,\
    \ y)| x.0);\n    v.sort_by_key(|&(x, y)| y.0);\n    v.sort_by_key(|&(x, y)| x.0);\n\
    \    v.sort_by_key(|&(x, y)| y.0);\n    v.iter().map(|&(x, y)| {\n        (x.0,\
    \ y.0)\n    }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpwxirc5m4.rs:19:35\n   |\n19 |     let mut columns = lst.first().len();\n\
    \   |                                   ^^^ method not found in `Option<&Vec<isize>>`\n\
    \nerror[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpwxirc5m4.rs:35:31\n   |\n35 |     v.sort_by_key(|&(x, y)| x.0);\n\
    \   |                               ^\n\nerror[E0610]: `usize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpwxirc5m4.rs:36:31\n  \
    \ |\n36 |     v.sort_by_key(|&(x, y)| y.0);\n   |                            \
    \   ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpwxirc5m4.rs:37:31\n   |\n37 |     v.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                               ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpwxirc5m4.rs:38:31\n\
    \   |\n38 |     v.sort_by_key(|&(x, y)| y.0);\n   |                          \
    \     ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpwxirc5m4.rs:40:12\n   |\n40 |         (x.0, y.0)\n   |\
    \            ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpwxirc5m4.rs:40:17\n   |\n40 |         (x.0, y.0)\n\
    \   |                 ^\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010912
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.to_vec();\n    let mut vec = Vec::new();\n    while lst.len() > 0\
    \ {\n        let mut i = 0;\n        let mut j = 0;\n        let mut k = lst[0];\n\
    \        while i < lst.len() {\n            if k == x {\n                let mut\
    \ tmp_vec = Vec::new();\n                tmp_vec.push((i, k));\n             \
    \   vec.push(tmp_vec);\n                break;\n            }\n            if\
    \ lst[i][0] == k {\n                i += 1;\n                k = lst[i];\n   \
    \             let mut tmp_vec = Vec::new();\n                tmp_vec.push((i,\
    \ k));\n                vec.push(tmp_vec);\n            } else {\n           \
    \     i += 1;\n                j += 1;\n                k = lst[i];\n        \
    \    }\n        }\n        if i == lst.len() {\n            let mut tmp_vec =\
    \ Vec::new();\n            tmp_vec.push((j, k));\n            vec.push(tmp_vec);\n\
    \        }\n    }\n    vec.sort_by_key(|&(i, k)| i);\n    vec.sort_by_key(|&(i,\
    \ k)| k, Desc);\n    vec\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `Desc` in this scope\n  --> /tmp/tmp59qh2ir8.rs:49:34\n\
    \   |\n49 |     vec.sort_by_key(|&(i, k)| k, Desc);\n   |                    \
    \              ^^^^ not found in this scope\n\nerror[E0277]: can't compare `Vec<isize>`\
    \ with `isize`\n  --> /tmp/tmp59qh2ir8.rs:24:18\n   |\n24 |             if k ==\
    \ x {\n   |                  ^^ no implementation for `Vec<isize> == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp59qh2ir8.rs:30:29\n   |\n30 |             if lst[i][0] == k {\n   |\
    \                             ^ expected `isize`, found struct `Vec`\n   |\n \
    \  = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp59qh2ir8.rs:48:23\n   |\n48 |     vec.sort_by_key(|&(i,\
    \ k)| i);\n   |                       ^^^^^-\n   |                       |   \
    \ |\n   |                       |    expected due to this\n   |              \
    \         expected struct `Vec`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<(usize, Vec<isize>)>`\n               found tuple `(_, _)`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmp59qh2ir8.rs:49:9\n\
    \    |\n49  |     vec.sort_by_key(|&(i, k)| k, Desc);\n    |         ^^^^^^^^^^^\
    \ -----------  ---- supplied 2 arguments\n    |         |\n    |         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp59qh2ir8.rs:50:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter().enumerate().filter\
    \ (|(i, _)| {\n        if i == 0 {\n            // We are in row 0 and columns\
    \ are sorted\n            return true;\n        }\n        \n        // We are\
    \ in some row that is not sorted\n        let current_row: Vec<isize> = lst.first();\n\
    \        \n        // Check if we have reached our target column\n        if i\
    \ == lst.len() - 1 && current_row.last() == x {\n            return true;\n  \
    \      }\n        \n        // Otherwise we need to check other rows\n       \
    \ for r in 0..lst.len() {\n            if r == i {\n                continue;\n\
    \            }\n            \n            if current_row[r] < x {\n          \
    \      return false;\n            }\n        }\n        \n        // We are in\
    \ target row and column is sorted\n        return true;\n    }).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `{integer}`\n  --> /tmp/tmp0fm49rz5.rs:18:14\n\
    \   |\n18 |         if i == 0 {\n   |              ^^ no implementation for `&usize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fm49rz5.rs:24:39\n\
    \   |\n24 |         let current_row: Vec<isize> = lst.first();\n   |         \
    \                 ----------   ^^^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |                          |\n   |                          expected due to\
    \ this\n   |\n   = note: expected struct `Vec<isize>`\n                found enum\
    \ `Option<&Vec<isize>>`\n\nerror[E0277]: can't compare `&usize` with `usize`\n\
    \  --> /tmp/tmp0fm49rz5.rs:27:14\n   |\n27 |         if i == lst.len() - 1 &&\
    \ current_row.last() == x {\n   |              ^^ no implementation for `&usize\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fm49rz5.rs:27:56\n\
    \   |\n27 |         if i == lst.len() - 1 && current_row.last() == x {\n   | \
    \                                                       ^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n           \
    \   found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fm49rz5.rs:33:21\n\
    \   |\n33 |             if r == i {\n   |                     ^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \           if r == *i {\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0fm49r"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.sort_by(|a,\
    \ b| a.iter().zip(b.iter()).collect::<Vec<_>>().cmp(&a).reverse());\n    lst.iter().enumerate().filter_map(|(i,\
    \ row)| {\n        if row.len() == 0 || row[0] == x {\n            vec![]\n  \
    \      } else {\n            let mut r = vec![];\n            row.iter().enumerate().filter_map(|(i,\
    \ c)| {\n                if i == 0 {\n                    r.push((i, c));\n  \
    \              } else {\n                    let r = r.last().unwrap();\n    \
    \                r.1 = r.1 + 1;\n                    r.push((r.0, c));\n     \
    \           }\n            });\n            r.to_owned()\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvsvsedl2.rs:17:71\n   |\n\
    17 |     lst.sort_by(|a, b| a.iter().zip(b.iter()).collect::<Vec<_>>().cmp(&a).reverse());\n\
    \   |                                                                       ^^\
    \ expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected reference\
    \ `&Vec<(&isize, &isize)>`\n              found reference `&&Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvsvsedl2.rs:20:13\n   |\n20 |             vec![]\n\
    \   |             ^^^^^^ expected enum `Option`, found struct `Vec`\n   |\n  \
    \ = note: expected enum `Option<_>`\n            found struct `Vec<_>`\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvsvsedl2.rs:24:27\n\
    \   |\n24 |                   if i == 0 {\n   |  ___________________________^\n\
    25 | |                     r.push((i, c));\n26 | |                 } else {\n\
    \   | |_________________^ expected enum `Option`, found `()`\n   |\n   = note:\
    \   expected enum `Option<_>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvsvsedl2.rs:28:27\n   |\n28 |              \
    \       r.1 = r.1 + 1;\n   |                     ---   ^^^^^^^\n   |         \
    \            |     |\n   |                     |     expected `&isize`, found\
    \ `isize`\n   |                     |     help: consider borrowing here: `&(r.1\
    \ + 1)`\n   |                     expected due to the type of this binding\n\n\
    error[E0599]: no method named `push` found for reference `&(usize, &isize)` in\
    \ the current scope\n  --> /tmp/tmpvsvsedl2.rs:29:23\n   |\n29 |             \
    \        r.push((r.0, c));\n   |                       ^^^^ method not found in\
    \ `&(usize, &isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvsvsedl2.rs:26:24\n\
    \   |\n26 |                   } else {\n   |  ________________________^\n27 |\
    \ |                     let r = r.last().unwrap();\n28 | |                   \
    \  r.1 = r.1 + 1;\n29 | |                     r.push((r.0, c));\n30 | |      \
    \           }\n   | |_________________^ exp"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    if lst.len() == 1 {\n        return\
    \ vec![(0, 0)];\n    }\n\n    // Sort the row by rows in ascending order\n   \
    \ lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut rows: Vec<(isize, isize)>\
    \ = vec![];\n    for row in lst.iter() {\n        if row.len() == 0 {\n      \
    \      break;\n        }\n\n        // Sort the column by columns in descending\
    \ order\n        row.sort_by(|a, b| b.cmp(a));\n        let mut row_coord = vec![];\n\
    \        let mut row_row_coord = vec![];\n        for (i, coord) in row.iter().enumerate()\
    \ {\n            if coord < x {\n                row_coord.push((i, coord));\n\
    \            } else {\n                row_row_coord.push((i, coord));\n     \
    \       }\n        }\n        if row_row_coord.is_empty() {\n            rows\
    \ = rows.clone();\n            rows = rows.push((row_coord.len(), row_coord.clone()));\n\
    \        } else {\n            row_row_coord.sort();\n            row_row_coord.sort();\n\
    \            row_row_coord.push(row_coord.len());\n            row_row_coord.push(row_coord.clone());\n\
    \            rows = rows.push((row_row_coord.len(), row_row_coord.clone()));\n\
    \        }\n    }\n    return rows;\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4ap_f84.rs:37:24\n   |\n\
    37 |             if coord < x {\n   |                        ^\n   |         \
    \               |\n   |                        expected `&isize`, found `isize`\n\
    \   |                        help: consider borrowing here: `&x`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy4ap_f84.rs:45:31\n   |\n45 |             rows\
    \ = rows.push((row_coord.len(), row_coord.clone()));\n   |                   \
    \            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n45 |             rows = rows.push((row_coord.len().try_into().unwrap(),\
    \ row_coord.clone()));\n   |                                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy4ap_f84.rs:45:48\n   |\n45 |\
    \             rows = rows.push((row_coord.len(), row_coord.clone()));\n   |  \
    \                                              ^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<(usize, &isize)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4ap_f84.rs:45:20\n\
    \   |\n26 |     let mut rows: Vec<(isize, isize)> = vec![];\n   |            \
    \       ------------------- expected due to this type\n...\n45 |             rows\
    \ = rows.push((row_coord.len(), row_coord.clone()));\n   |                   \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found\
    \ unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpy4ap_f84.rs:45:25\n\
    \   |\n45 |             rows = rows.push((row_coord.len(), row_coord.clone()));\n\
    \   |                    ---- ^^^^ this call modifies `rows` in-place\n   |  \
    \                  |\n   |                    you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4ap_f84.rs:49:32\n\
    \   |\n49 |   "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = get_row(l, x, 0, 0);\n    row.sort();\n    row.sort_by_key();\n    row\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmpm27jka8e.rs:17:27\n\
    \   |\n17 |     let mut row = get_row(l, x, 0, 0);\n   |                     \
    \      ^ help: a local variable with a similar name exists: `x`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 4 arguments were supplied\n  --> /tmp/tmpm27jka8e.rs:17:19\n\
    \   |\n17 |     let mut row = get_row(l, x, 0, 0);\n   |                   ^^^^^^^\
    \ -  -  -  - supplied 4 arguments\n   |                   |\n   |            \
    \       expected 2 arguments\n   |\nnote: function defined here\n  --> /tmp/tmpm27jka8e.rs:16:4\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    ^^^^^^^ --------------------  --------\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpm27jka8e.rs:19:9\n\
    \    |\n19  |     row.sort_by_key();\n    |         ^^^^^^^^^^^- supplied 0 arguments\n\
    \    |         |\n    |         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut rows = vec![];\n    let mut cols\
    \ = vec![];\n    for row in lst {\n        let mut current_cols = vec![];\n  \
    \      for v in row {\n            if v == x {\n                current_cols.push((*row,\
    \ v));\n            }\n        }\n        cols.push(current_cols);\n        rows.push(current_cols.iter().cloned().collect::<Vec<_>>());\n\
    \    }\n    rows.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n    cols.sort_by(|a,\
    \ b| b.iter().cmp(a.iter()).reverse());\n    rows\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpn_hf9rt1.rs:26:17\n   |\n26 |              \
    \   current_cols.push((*row, v));\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `[isize]`\n   = note: only the last element of a tuple\
    \ may have a dynamically sized type\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n  --> /tmp/tmpn_hf9rt1.rs:23:32\n\
    \   |\n23 |         let mut current_cols = vec![];\n   |                     \
    \           ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `[isize]`\n   = note: only the last\
    \ element of a tuple may have a dynamically sized type\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `[isize]` cannot\
    \ be known at compilation time\n  --> /tmp/tmpn_hf9rt1.rs:29:9\n   |\n29 |   \
    \      cols.push(current_cols);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[isize]`\n   = note: only the last element of a tuple may have\
    \ a dynamically sized type\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpn_hf9rt1.rs:21:20\n   |\n\
    21 |     let mut cols = vec![];\n   |                    ^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: only the last element of a tuple may have a dynamically\
    \ sized type\n   = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size\
    \ for values of type `[isize]` cannot be known at compilation time\n  --> /tmp/tmpn_hf9rt1.rs:30:32\n\
    \   |\n30 |         rows.push(current_cols.iter().cloned().collect::<Vec<_>>());\n\
    \   |                                ^^^^ d"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ row = 0usize;\n    for y in lst {\n        if row == x {\n            result.push((row,\
    \ y));\n        }\n        row += 1;\n    }\n    result.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    result.sort_by(|a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfja55hm5.rs:23:19\n   |\n\
    23 |         if row == x {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         if row == x.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfja55hm5.rs:30:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n30 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, Vec<isize>)>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    debug_assert_eq!(lst.len(), lst.iter().map(|v|\
    \ v.len()).sum());\n\n    let mut rows = lst.iter().map(|v| v.iter().cloned()).collect::<Vec<_>>();\n\
    \    let mut cols = lst.iter().map(|v| v.len()).collect::<Vec<_>>();\n    for\
    \ i in 0..rows.len() {\n        let mut row_i = rows[i].iter().cloned();\n   \
    \     row_i\n            .sort_by(|&x, &y| x.partial_cmp(&y).unwrap())\n     \
    \       .map(|&x| x.partial_cmp(&x).unwrap())\n            .collect::<Vec<_>>()\n\
    \            .sort_by(|&x, y| y.partial_cmp(&x).unwrap()).collect::<Vec<_>>();\n\
    \        rows[i].clear();\n        cols[i]\n            .iter()\n            .filter(|&x|\
    \ *x != row_i.next().unwrap())\n            .sort_by(|&x, y| y.partial_cmp(&x).unwrap())\n\
    \            .collect::<Vec<_>>()\n            .sort_by(|&x, y| y.partial_cmp(&y).unwrap()).collect::<Vec<_>>();\n\
    \        cols[i].clear();\n    }\n\n    if cols[0].is_empty() {\n        return\
    \ vec![];\n    }\n    let mut ret = vec![];\n\n    for i in 0..cols[0].len() {\n\
    \        let mut i = i;\n        let mut j = i;\n        let mut row = rows[i].clone();\n\
    \        let mut col = cols[i].clone();\n        while !col[j].is_empty() {\n\
    \            debug_assert_eq!(row.len(), col.len());\n            let mut row_i\
    \ = row;\n            let mut col_j = col;\n            row_i.sort_by(|&x, &y|\
    \ y.partial_cmp(&x).unwrap()).collect::<Vec<_>>();\n            col_j.sort_by(|&x,\
    \ &y| y.partial_cmp(&y).unwrap()).collect::<Vec<_>>();\n            for r in row_i.iter()\
    \ {\n                for c in col_j.iter() {\n                    if *r == *c\
    \ {\n                        ret = ret.push((i, j));\n                       \
    \ break;\n                    }\n                }\n            }\n          \
    \  if i == j {\n                break;\n            }\n            i += 1;\n \
    \           j += 1;\n        }\n    }\n\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpidb01v1y.rs:26:33\n   |\n26 |         let mut row_i = rows[i].iter().cloned();\n\
    \   |                                 ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `clear` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpidb01v1y.rs:32:17\n   |\n32 |         rows[i].clear();\n\
    \   |                 ^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `iter` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpidb01v1y.rs:34:14\n   |\n34 |             .iter()\n   |       \
    \       ^^^^ method not found in `usize`\n\nerror[E0599]: no method named `clear`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpidb01v1y.rs:39:17\n\
    \   |\n39 |         cols[i].clear();\n   |                 ^^^^^ method not found\
    \ in `usize`\n\nerror[E0599]: no method named `is_empty` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpidb01v1y.rs:42:16\n   |\n42 |     if cols[0].is_empty()\
    \ {\n   |                ^^^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmpidb01v1y.rs:47:25\n\
    \   |\n47 |     for i in 0..cols[0].len() {\n   |                         ^^^\
    \ method not found in `usize`\n\nerror[E0608]: cannot index into a value of type\
    \ `usize`\n  --> /tmp/tmpidb01v1y.rs:52:16\n   |\n52 |         while !col[j].is_empty()\
    \ {\n   |                ^^^^^^\n\nerror[E0599]: no method named `len` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmpidb01v1y.rs:53:45\n   |\n53\
    \ |             debug_assert_eq!(row.len(), col.len());\n   |                \
    \                             ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Cloned` in the current scope\n \
    \ --> /tmp/tmpidb01v1y.rs:56:19\n   |\n56 |             row_i.sort_by(|&x, &y|\
    \ y.partial_cmp(&x).unwrap()).collect::<Vec<_>>();\n   |                   ^^^^^^^\
    \ method not found in `Cloned<std::slice::Iter"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ v = Vec::new();\n\n    let mut row = lst.iter().enumerate();\n\n    if row.is_empty()\
    \ {\n        v.push((0, 0));\n    } else {\n        let mut last_row = 0;\n  \
    \      let mut last_col = 0;\n        for (i, row) in row.iter().enumerate() {\n\
    \            if i != 0 {\n                last_row = i - 1;\n                last_col\
    \ = row.iter().enumerate().next().unwrap().1;\n            }\n            if i\
    \ == row.len() - 1 {\n                v.push((last_row, last_col));\n        \
    \    }\n        }\n    }\n\n    v.sort_by_key(|&(ref row, _)| row);\n    v.sort_by_key(|&(ref\
    \ row, _)| {\n        let (mut a, mut b) = (0.0, 0.0);\n        for (index, value)\
    \ in row.iter().enumerate() {\n            a += 1;\n            b.push(value);\n\
    \        }\n        b.cmp(&a)\n    });\n\n    v\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'exact_size_is_empty'\n \
    \ --> /tmp/tmpbghnr7jv.rs:21:12\n   |\n21 |     if row.is_empty() {\n   |    \
    \        ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0599]: no method named `iter` found for struct\
    \ `Enumerate` in the current scope\n  --> /tmp/tmpbghnr7jv.rs:26:29\n   |\n26\
    \ |         for (i, row) in row.iter().enumerate() {\n   |                   \
    \          ^^^^ private field, not a method\n\nerror[E0599]: no method named `iter`\
    \ found for reference `&{integer}` in the current scope\n  --> /tmp/tmpbghnr7jv.rs:40:35\n\
    \   |\n40 |         for (index, value) in row.iter().enumerate() {\n   |     \
    \                              ^^^^ method not found in `&{integer}`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmpbghnr7jv.rs:41:15\n\
    \   |\n41 |             a += 1;\n   |               ^^ no implementation for `{float}\
    \ += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0599]: no method named `push` found for type `{float}` in\
    \ the current scope\n  --> /tmp/tmpbghnr7jv.rs:42:15\n   |\n42 |             b.push(value);\n\
    \   |               ^^^^ method not found in `{float}`\n\nerror[E0689]: can't\
    \ call method `cmp` on ambiguous numeric type `{float}`\n  --> /tmp/tmpbghnr7jv.rs:44:11\n\
    \   |\n39 |         let (mut a, mut b) = (0.0, 0.0);\n   |                   \
    \  ----- you must specify a type for this binding, like `f32`\n...\n44 |     \
    \    b.cmp(&a)\n   |           ^^^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599, E0658, E0689.\nFor more\
    \ information "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_rows: Vec<Vec<isize>> = vec![];\n\n    for row_vec in lst {\n       \
    \ let mut row = vec![];\n\n        for row_val in row_vec {\n            row.push((row_val,\
    \ row_vec.get(i).unwrap()));\n        }\n\n        sorted_rows.push_back(row);\n\
    \    }\n\n    let mut row_sort_order = vec![];\n\n    for row in sorted_rows {\n\
    \        row_sort_order.sort_by(|a, b| {\n            a.1\n                .partial_cmp(&b.1)\n\
    \                .unwrap_or(-1)\n                .cmp(&b.1)\n                .unwrap_or(-1)\n\
    \        });\n\n        row_sort_order.sort_by(|a, b| {\n            b.1\n   \
    \             .partial_cmp(&a.1)\n                .unwrap_or(-1)\n           \
    \     .cmp(&a.1)\n                .unwrap_or(-1)\n        });\n\n        if row_sort_order\n\
    \            .iter()\n            .fold(false, |mut flag, row_val| {\n       \
    \         if flag {\n                    return row_val == x;\n              \
    \  }\n\n                flag\n            })\n        {\n            return row;\n\
    \        }\n    }\n\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpctxce8pi.rs:23:44\n\
    \   |\n23 |             row.push((row_val, row_vec.get(i).unwrap()));\n   |  \
    \                                          ^ help: a local variable with a similar\
    \ name exists: `x`\n\nerror[E0599]: no method named `push_back` found for struct\
    \ `Vec<Vec<isize>>` in the current scope\n  --> /tmp/tmpctxce8pi.rs:26:21\n  \
    \ |\n26 |         sorted_rows.push_back(row);\n   |                     ^^^^^^^^^\
    \ method not found in `Vec<Vec<isize>>`\n\nerror[E0609]: no field `1` on type\
    \ `&_`\n  --> /tmp/tmpctxce8pi.rs:33:15\n   |\n33 |             a.1\n   |    \
    \           ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctxce8pi.rs:58:20\n\
    \   |\n58 |             return row;\n   |                    ^^^ expected tuple,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0599, E0609.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = vec![];\n\n    let mut i = 0;\n    let mut j = 0;\n    while i < lst.len()\
    \ {\n        let n = 0;\n        while j < lst[i].len() && n < x {\n         \
    \   i += 1;\n            n += 1;\n            i += 1;\n            n += 1;\n \
    \           i += 1;\n            n += 1;\n            i += 1;\n            n +=\
    \ 1;\n        }\n        i += 1;\n        rows.push(i);\n    }\n    \n    rows.sort_by_key(|x|\
    \ x.0);\n    rows.iter().map(|x| {\n        let mut y = vec![];\n        \n  \
    \      let mut i = 0;\n        while i < x.1 {\n            y += vec![i as isize];\n\
    \            i += 1;\n        }\n        \n        y\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&usize`\n  --> /tmp/tmp9su9swai.rs:37:28\n\
    \   |\n37 |     rows.sort_by_key(|x| x.0);\n   |                            ^\n\
    \nerror[E0609]: no field `1` on type `&usize`\n  --> /tmp/tmp9su9swai.rs:42:21\n\
    \   |\n42 |         while i < x.1 {\n   |                     ^\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmp9su9swai.rs:43:13\n\
    \   |\n43 |             y += vec![i as isize];\n   |             -^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `Vec<_>`\n    --> /tmp/tmp9su9swai.rs:48:8\n     |\n48   |\
    \     }).collect()\n     |        ^^^^^^^ value of type `Vec<(isize, isize)>`\
    \ cannot be built from `std::iter::Iterator<Item=Vec<_>>`\n     |\n     = help:\
    \ the trait `FromIterator<Vec<_>>` is not implemented for `Vec<(isize, isize)>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0368, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for col in lst {\n        if col.len() == 0 {\n      \
    \      continue;\n        }\n        let mut row = (0, 0);\n        for _i in\
    \ col {\n            row.0 += 1;\n            if row.0 >= x {\n              \
    \  break;\n            }\n            if row.1 > col.rev().iter().position(|x|\
    \ x == _i).unwrap_or(col.len() + 1) {\n                break;\n            }\n\
    \        }\n        result.push((row.0, _i + 1));\n    }\n    result.sort_by(|x,\
    \ y| x.1.cmp(&y.1));\n    result.sort_by(|x, y| -x.1.cmp(&y.1));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `_i` in this scope\n  --> /tmp/tmpk27m9q3i.rs:32:29\n\
    \   |\n32 |         result.push((row.0, _i + 1));\n   |                      \
    \       ^^ not found in this scope\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpk27m9q3i.rs:28:28\n    |\n28  |               if row.1 > col.rev().iter().position(|x|\
    \ x == _i).unwrap_or(col.len() + 1) {\n    |                              ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror[E0609]: no\
    \ field `1` on type `&_`\n  --> /tmp/tmpk27m9q3i.rs:34:29\n   |\n34 |     result.sort_by(|x,\
    \ y| x.1.cmp(&y.1));\n   |                             ^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(b).unwrap());\n\n  \
    \  let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(a).unwrap());\n\
    \n    lst.iter().enumerate().filter(|(i, _)| i < x).map(|(i, elem)| {\n      \
    \  let mut res = vec![];\n        for (j, elem) in lst.iter().enumerate() {\n\
    \            if j == i {\n                res.push((i, elem));\n            }\n\
    \        }\n        res\n    })\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpwys_ywor.rs:18:40\n   |\n18 |     lst.sort_by(|a,\
    \ b| a.iter().cmp(b).unwrap());\n   |                                        ^^^^^^\
    \ method not found in `std::cmp::Ordering`\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpwys_ywor.rs:21:40\n\
    \   |\n21 |     lst.sort_by(|a, b| b.iter().cmp(a).unwrap());\n   |          \
    \                              ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwys_ywor.rs:23:48\n   |\n23 |\
    \     lst.iter().enumerate().filter(|(i, _)| i < x).map(|(i, elem)| {\n   |  \
    \                                              ^ expected `&usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwys_ywor.rs:23:5\n   |\n16 | \
    \  fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   | \
    \                                                ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n23 | /     lst.iter().enumerate().filter(|(i,\
    \ _)| i < x).map(|(i, elem)| {\n24 | |         let mut res = vec![];\n25 | | \
    \        for (j, elem) in lst.iter().enumerate() {\n26 | |             if j ==\
    \ i {\n...  |\n30 | |         res\n31 | |     })\n   | |______^ expected struct\
    \ `Vec`, found struct `Map`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Map<Filter<Enumerate<std::slice::Iter<'_, Vec<isize>>>,\
    \ [closure@/tmp/tmpwys_ywor.rs:23:35: 23:49]>, [closure@/tmp/tmpwys_ywor.rs:23:55:\
    \ 31:6]>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ counter = 0;\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_counter\
    \ = 0;\n    for i in 0..lst.len() {\n        if i == x {\n            row.push((row_counter,\
    \ counter));\n        }\n        for i in 0..(lst[i].len() - 1) {\n          \
    \  if lst[i][counter] > lst[i][counter + 1] {\n                counter = i;\n\
    \            }\n        }\n        row_counter = counter;\n        counter = 0;\n\
    \    }\n    row.push((row_counter, counter));\n    row.sort_by_key(|&(a, b)| a.1.cmp(&b.1));\n\
    \    row.reverse();\n    vec![row.into_iter().map(|&v| v.1).collect::<Vec<_>>()]\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa9wan71h.rs:21:17\n   |\n\
    21 |         if i == x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if i == x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpa9wan71h.rs:25:16\n   |\n25 |         \
    \    if lst[i][counter] > lst[i][counter + 1] {\n   |                ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa9wan71h.rs:25:34\n\
    \   |\n25 |             if lst[i][counter] > lst[i][counter + 1] {\n   |     \
    \                             ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9wan71h.rs:26:27\n\
    \   |\n17 |     let mut counter = 0;\n   |                       - expected due\
    \ to this value\n...\n26 |                 counter = i;\n   |                \
    \           ^ expected `isize`, found `usize`\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpa9wan71h.rs:33:33\n  \
    \ |\n33 |     row.sort_by_key(|&(a, b)| a.1.cmp(&b.1));\n   |                \
    \                 ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpa9wan71h.rs:33:42\n   |\n33 |     row.sort_by_key(|&(a,\
    \ b)| a.1.cmp(&b.1));\n   |                                          ^\n\nerror[E0308]:\
    \ mismatched types\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    for (y, vec) in lst.iter().enumerate()\
    \ {\n        match vec.len() {\n            1 => rows.push((x, y)),\n        \
    \    2 => rows.push((y, x)),\n            _ => {\n                let mut row\
    \ = vec![];\n                for &i in vec {\n                    if i > x {\n\
    \                        row.push(i);\n                    }\n               \
    \ }\n                rows.push((x, y));\n                rows.push((y, x));\n\
    \                rows.push((x, y));\n                rows.push((y, x));\n    \
    \        }\n        }\n    }\n    rows\n        .iter()\n        .map(|(x, y)|\
    \ {\n            (x, y)\n        })\n        .sort_by(|(a, b)| {\n           \
    \ b.1.cmp(&a.1)\n        })\n        .map(|(x, y)| {\n            (x, y)\n   \
    \     })\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:20:32\n   |\n\
    20 |             1 => rows.push((x, y)),\n   |                               \
    \ ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n20 |        \
    \     1 => rows.push((x, y.try_into().unwrap())),\n   |                      \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:21:29\n\
    \   |\n21 |             2 => rows.push((y, x)),\n   |                        \
    \     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     \
    \        2 => rows.push((y.try_into().unwrap(), x)),\n   |                   \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:29:31\n\
    \   |\n29 |                 rows.push((x, y));\n   |                         \
    \      ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n29 |     \
    \            rows.push((x, y.try_into().unwrap()));\n   |                    \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:30:28\n\
    \   |\n30 |                 rows.push((y, x));\n   |                         \
    \   ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n30 |        \
    \         rows.push((y.try_into().unwrap(), x));\n   |                       \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:31:31\n\
    \   |\n31 |                 rows.push((x, y));\n   |                         \
    \      ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n31 |     \
    \            rows.push((x, y.try_into().unwrap()));\n   |                    \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zgvqsln.rs:32:28\n\
    \   |\n32 |"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.sort_by(|a,\
    \ b| b.iter().rev().zip(a).collect::<Vec<_>>());\n    let mut rev_row = vec![];\n\
    \    for i in lst.iter().rev() {\n        i.sort_by(|a, b| a.iter().rev().zip(b).collect::<Vec<_>>());\n\
    \        rev_row.extend(&i);\n    }\n    rev_row.sort_by(|a, b| b.iter().rev().collect::<Vec<_>>());\n\
    \    rev_row.iter().skip(x).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb38mcaq7.rs:17:24\n   |\n\
    17 |     lst.sort_by(|a, b| b.iter().rev().zip(a).collect::<Vec<_>>());\n   |\
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `std::cmp::Ordering`, found struct `Vec`\n   |\n   = note: expected enum `std::cmp::Ordering`\n\
    \            found struct `Vec<(&isize, &isize)>`\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&isize` in the current scope\n  --> /tmp/tmpb38mcaq7.rs:20:28\n\
    \   |\n20 |         i.sort_by(|a, b| a.iter().rev().zip(b).collect::<Vec<_>>());\n\
    \   |                            ^^^^ method not found in `&isize`\n\nerror[E0277]:\
    \ `&&Vec<isize>` is not an iterator\n   --> /tmp/tmpb38mcaq7.rs:21:24\n    |\n\
    21  |         rev_row.extend(&i);\n    |                 ------ ^^\n    |    \
    \             |      |\n    |                 |      `&&Vec<isize>` is not an\
    \ iterator\n    |                 |      help: consider dereferencing here: `&*i`\n\
    \    |                 required by a bound introduced by this call\n    |\n  \
    \  = help: the trait `Iterator` is not implemented for `&&Vec<isize>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&&Vec<isize>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_rows = vec![];\n    let mut sorted_columns = vec![];\n    for r in lst\
    \ {\n        if r.len() > 0 {\n            sorted_rows.push(r[0]);\n         \
    \   sorted_columns.push(r[r.len() - 1]);\n        }\n    }\n    sort_row_by_columns(&mut\
    \ sorted_columns, &mut sorted_rows);\n    let mut result = vec![];\n    for i\
    \ in 0..sorted_rows.len() {\n        let row_i = i as usize;\n        let column_i\
    \ = sorted_columns[row_i];\n        if column_i <= x {\n            result.push((row_i,\
    \ column_i));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_row_by_columns` in this scope\n\
    \  --> /tmp/tmpheq57vvy.rs:25:5\n   |\n25 |     sort_row_by_columns(&mut sorted_columns,\
    \ &mut sorted_rows);\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpheq57vvy.rs:34:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n34 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, _)>`\n\
    \              found struct `Vec<(usize, _)>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst_len = lst.len();\n    let mut col_len = 0;\n\n    for v in lst {\n     \
    \   if v.len() > col_len {\n            col_len = v.len();\n        }\n    }\n\
    \    let mut i = 1;\n\n    while i < lst_len {\n        let mut j = i;\n\n   \
    \     while j < lst_len && lst[j].len() < col_len {\n            j += 1;\n   \
    \     }\n\n        if j == lst_len {\n            break;\n        }\n\n      \
    \  let mut col = 0;\n\n        while col < col_len && lst[j][col] < x {\n    \
    \        col += 1;\n        }\n\n        if col == col_len {\n            break;\n\
    \        }\n\n        i += 1;\n    }\n\n    if i == lst_len {\n        return\
    \ vec![];\n    }\n\n    let mut res = vec![];\n\n    for j in 0 .. i {\n     \
    \   let mut cols = vec![];\n\n        let mut row = lst[j].clone();\n\n      \
    \  let mut idx = 0;\n\n        while idx < col_len && row[cols[idx]] >= x {\n\
    \            cols.push(idx);\n            idx += 1;\n        }\n\n        res.push((j,\
    \ cols));\n    }\n\n    sort_row_by_columns(&res);\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_row_by_columns` in this scope\n\
    \  --> /tmp/tmphn8sdo_z.rs:72:5\n   |\n72 |     sort_row_by_columns(&res);\n \
    \  |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphn8sdo_z.rs:74:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n74 |     res\n   |     ^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, Vec<usize>)>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ l = lst.len();\n    let mut y = 0;\n    let mut r = -1;\n\n    let mut c = vec![];\n\
    \    loop {\n        while r < 0 {\n            l -= 1;\n            match lst[l].len()\
    \ {\n                0 => {\n                    return c;\n                }\n\
    \                _ => {\n                    r = -1;\n                }\n    \
    \        }\n        }\n        let mut v = vec![];\n        for n in lst[l].iter()\
    \ {\n            if n == x {\n                v.push((n, y));\n              \
    \  y += 1;\n            } else {\n                v.push((n, y));\n          \
    \  }\n        }\n        c = c.into_iter().chain(v.into_iter()).collect();\n \
    \       l += 1;\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmphus4h9z6.rs:36:18\n\
    \   |\n36 |             if n == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0271]: type mismatch resolving\
    \ `<std::vec::IntoIter<(&isize, {integer})> as IntoIterator>::Item == (isize,\
    \ isize)`\n   --> /tmp/tmphus4h9z6.rs:43:27\n    |\n43  |         c = c.into_iter().chain(v.into_iter()).collect();\n\
    \    |                           ^^^^^ expected `isize`, found `&isize`\n    |\n\
    \    = note: expected tuple `(isize, isize)`\n               found tuple `(&isize,\
    \ {integer})`\nnote: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<(&isize, {integer})>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmphus4h9z6.rs:43:48\n   |\n43 |            c = c.into_iter().chain(v.into_iter()).collect();\n\
    \   |                                                   ^^^^^^^ method cannot\
    \ be called on `std::iter::Chain<std::vec::IntoIter<(isize, isize)>, std::vec::IntoIter<(&isize,\
    \ {integer})>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<std::vec::IntoIter<(&isize, {integer})>\
    \ as Iterator>::Item = (isize, isize)`\n           which is required by `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<(&isize, {integer})>>: Iterator`\n           `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<(&isize, {integer})>>: Iterator`\n           which\
    \ is required by `&mut std::iter::Chain<std::vec::IntoIter<(isize, isize)>, std::vec::IntoIter<(&isize,\
    \ {integer})>>: Iterator`\n\nerror: aborting due to 3 previous error"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.sort_by(|a,\
    \ b| {\n        a.iter().zip(b.iter()).map(|(x, y)| (y, x))\n    });\n    let\
    \ mut res = vec![];\n    res[0] = (0, 0);\n    for i in lst {\n        for j in\
    \ i.iter().rev() {\n            if j == x {\n                res.push((i.iter().cloned().skip(1).next().unwrap()\
    \ + 1, j));\n            }\n        }\n    }\n    res.sort_by(|a, b| b.0.cmp_from(b.1));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95qn4wls.rs:18:9\n   |\n\
    18 |         a.iter().zip(b.iter()).map(|(x, y)| (y, x))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found struct `Map`\n   |\n   = note: expected\
    \ enum `std::cmp::Ordering`\n            found struct `Map<Zip<std::slice::Iter<'_,\
    \ isize>, std::slice::Iter<'_, isize>>, [closure@/tmp/tmp95qn4wls.rs:18:36: 18:51]>`\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp95qn4wls.rs:24:18\n\
    \   |\n24 |             if j == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp95qn4wls.rs:25:74\n   |\n25 |                 res.push((i.iter().cloned().skip(1).next().unwrap()\
    \ + 1, j));\n   |                                                            \
    \              ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |                 res.push((i.iter().cloned().skip(1).next().unwrap()\
    \ + 1, *j));\n   |                                                           \
    \               +\n\nerror[E0599]: no method named `cmp_from` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp95qn4wls.rs:29:28\n   |\n29 |     res.sort_by(|a,\
    \ b| b.0.cmp_from(b.1));\n   |                            ^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ y = vec![];\n    for (i, vec) in lst.into_iter().enumerate() {\n        let\
    \ mut x_idx = 0;\n        while x_idx < vec.len() {\n            if vec[x_idx]\
    \ == x {\n                y.push((i, x_idx));\n            }\n            x_idx\
    \ += 1;\n        }\n    }\n    y.sort();\n    y.reverse();\n    y\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpobrra9wc.rs:29:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     y\n   |     ^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.into_iter();\n    lst.sort_by(|a, b| a.len().cmp(b.len()).reverse());\n\
    \    let mut rows = Vec::with_capacity(x.max() + 1);\n    for (idx, row) in lst.iter().enumerate()\
    \ {\n        row.sort_by(|a, b| a.cmp(b));\n        rows.push(idx as isize);\n\
    \    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp34ygjoun.rs:18:9\n   |\n18 |     lst.sort_by(|a,\
    \ b| a.len().cmp(b.len()).reverse());\n   |         ^^^^^^^ method not found in\
    \ `std::vec::IntoIter<Vec<isize>>`\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmp34ygjoun.rs:19:41\n    |\n19 \
    \ |     let mut rows = Vec::with_capacity(x.max() + 1);\n    |               \
    \                          ^^^- supplied 0 arguments\n    |                  \
    \                       |\n    |                                         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp34ygjoun.rs:19:39\n   |\n19 |     let mut rows = Vec::with_capacity(x.max()\
    \ + 1);\n   |                                       ^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |     let mut rows = Vec::with_capacity((x.max()\
    \ + 1).try_into().unwrap());\n   |                                       +   \
    \        +++++++++++++++++++++\n\nerror[E0599]: no method named `iter` found for\
    \ struct `std::vec::IntoIter` in the current scope\n  --> /tmp/tmp34ygjoun.rs:20:27\n\
    \   |\n20 |     for (idx, row) in lst.iter().enumerate() {\n   |             \
    \              ^^^^ method not found in `std::vec::IntoIter<Vec<isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp34ygjoun.rs:24:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n24 |     rows\n   |     ^^^^ expected tuple, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n          \
    \    found struct `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter().enumerate().filter(|(i,\
    \ c)| c.iter().any(|&i| i == x)).collect().sort_by(|a, b| a.1.cmp(b.1)).map(|a|\
    \ {\n        let mut b = (a.1, a.0.iter().map(|&i| (i, 0)).collect());\n     \
    \   b.sort_by_key(|&(_, y)| y.cmp(&0));\n        b\n    }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpck027p9l.rs:17:71\n\
    \   |\n17 |     lst.iter().enumerate().filter(|(i, c)| c.iter().any(|&i| i ==\
    \ x)).collect().sort_by(|a, b| a.1.cmp(b.1)).map(|a| {\n   |                 \
    \                                                      ^^^^^^^ cannot infer type\
    \ for type parameter `B` declared on the associated function `collect`\n   |\n\
    \   = note: type must be known at this point\nhelp: consider specifying the type\
    \ argument in the method call\n   |\n17 |     lst.iter().enumerate().filter(|(i,\
    \ c)| c.iter().any(|&i| i == x)).collect::<B>().sort_by(|a, b| a.1.cmp(b.1)).map(|a|\
    \ {\n   |                                                                    \
    \          +++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rets = Vec::new();\n    let mut l = lst.len();\n    let mut m = lst.len();\n\
    \n    if l < x {\n        return rets;\n    }\n\n    if m == 0 {\n        return\
    \ rets;\n    }\n\n    let mut i = l;\n    let mut j = m;\n\n    // Find largest\
    \ and smallest element by row\n    let mut max_i = i;\n    let mut min_i = i;\n\
    \n    while j > 0 {\n        if lst[j - 1].len() > max_i {\n            max_i\
    \ = lst[j - 1].len();\n        }\n        j -= 1;\n    }\n\n    while i > 0) {\n\
    \        if lst[i - 1].len() > min_i {\n            min_i = lst[i - 1].len();\n\
    \        }\n        i -= 1;\n    }\n\n    let mut max_j = j;\n    let mut min_j\
    \ = j;\n\n    while i < l {\n        if lst[i].len() > max_j {\n            max_j\
    \ = lst[i].len();\n        }\n        i += 1;\n    }\n\n    while j < m {\n  \
    \      if lst[j].len() > min_j {\n            min_j = lst[j].len();\n        }\n\
    \        j += 1;\n    }\n\n    if max_j > max_i {\n        max_i = max_j;\n  \
    \  }\n\n    if min_j < min_i {\n        min_i = min_j;\n    }\n\n    // sort rows\
    \ by increasing length, in descending order\n    if max_i < min_i {\n        let\
    \ mut i = max_i;\n        let mut j = min_i;\n\n        while i > 0) {\n     \
    \       rets.push(vec![i..j]);\n            i -= 1;\n            j += 1;\n   \
    \     }\n    }\n\n    // sort columns by descending order\n    for i in (0..(min_i\
    \ - max_i)).rev() {\n        j = (max_i + 1) - i;\n\n        let mut j2 = min_i;\n\
    \        while j2 < j {\n            rets.push(vec![j2..j + 1]);\n           \
    \ j2 += 1;\n        }\n    }\n\n    // sort coords by (row, columns)\n    for\
    \ i in (0..(max_i - min_i + 1)).iter().rev() {\n        let mut j = min_i;\n \
    \       let mut j2 = max_i;\n\n        while j < j2 {\n            rets.push(vec![(i\
    \ - j + min_i), (j - j2 + max_i)]);\n            j += 1;\n            j2 -= 1;\n\
    \        }\n    }\n\n    rets\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpdl_gyz3t.rs:85:5\n\
    \   |\n80 |         while i > 0) {\n   |                      - this opening brace...\n\
    ...\n84 |         }\n   |         - ...matches this closing brace\n85 |     }\n\
    \   |     ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter:\
    \ `)`\n  --> /tmp/tmpdl_gyz3t.rs:16:67\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \                                ^ unclosed delimiter\n...\n43 |     while i >\
    \ 0) {\n   |                ^ mismatched closing delimiter\n\nerror: mismatched\
    \ closing delimiter: `)`\n  --> /tmp/tmpdl_gyz3t.rs:76:22\n   |\n76 |     if max_i\
    \ < min_i {\n   |                      ^ unclosed delimiter\n...\n80 |       \
    \  while i > 0) {\n   |                    ^ mismatched closing delimiter\n\n\
    error: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ x = Vec::new();\n    let mut lst = lst.clone();\n\n    for row in &lst {\n \
    \       x.clear();\n        for (i, e) in row.iter().enumerate() {\n         \
    \   if i == x {\n                x.push(i);\n            }\n        }\n      \
    \  x.sort();\n        let mut v = Vec::new();\n        for (i, e) in row.iter().enumerate()\
    \ {\n            v.push((x.remove(&i).unwrap(), e));\n        }\n        v.sort();\n\
    \        v.push(row.len());\n        x.iter().zip(v).for_each(|(x, y)| x.push(y));\n\
    \    }\n\n    x\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmum3p0h.rs:23:21\n   |\n\
    23 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `usize`\n            found struct\
    \ `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmum3p0h.rs:30:30\n\
    \   |\n30 |             v.push((x.remove(&i).unwrap(), e));\n   |            \
    \                  ^^ expected `usize`, found `&usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n30 -             v.push((x.remove(&i).unwrap(), e));\n30 +\
    \             v.push((x.remove(i).unwrap(), e));\n   | \n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpjmum3p0h.rs:30:34\n\
    \   |\n30 |             v.push((x.remove(&i).unwrap(), e));\n   |            \
    \                      ^^^^^^ method not found in `usize`\n\nerror[E0599]: no\
    \ method named `push` found for reference `&usize` in the current scope\n  -->\
    \ /tmp/tmpjmum3p0h.rs:34:45\n   |\n34 |         x.iter().zip(v).for_each(|(x,\
    \ y)| x.push(y));\n   |                                             ^^^^ method\
    \ not found in `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjmum3p0h.rs:37:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n37 |     x\n   |     ^ expected\
    \ tuple, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.sort_by_key(|a|\
    \ a.iter().rev());\n    lst.iter()\n        .zip(lst.iter().skip(1))\n       \
    \ .filter(|a| a.1 == x)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Rev<std::slice::Iter<'_, isize>>: Ord` is\
    \ not satisfied\n   --> /tmp/tmp602u_s1d.rs:17:21\n    |\n17  |     lst.sort_by_key(|a|\
    \ a.iter().rev());\n    |         ----------- ^^^^^^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `Rev<std::slice::Iter<'_, isize>>`\n    |         |\n\
    \    |         required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0277]: can't compare\
    \ `&Vec<isize>` with `isize`\n  --> /tmp/tmp602u_s1d.rs:20:25\n   |\n20 |    \
    \     .filter(|a| a.1 == x)\n   |                         ^^ no implementation\
    \ for `&Vec<isize> == isize`\n   |\n   = help: the trait `PartialEq<isize>` is\
    \ not implemented for `&Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: a value of\
    \ type `Vec<(isize, isize)>` cannot be built from an iterator over elements of\
    \ type `(&Vec<isize>, &Vec<isize>)`\n    --> /tmp/tmp602u_s1d.rs:21:10\n     |\n\
    21   |         .collect()\n     |          ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=(&Vec<isize>, &Vec<isize>)>`\n\
    \     |\n     = help: the trait `FromIterator<(&Vec<isize>, &Vec<isize>)>` is\
    \ not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut res = vec![];\n    loop {\n        if row == lst.len()\
    \ {\n            break;\n        }\n        if lst[row as usize].len() == 0 {\n\
    \            row += 1;\n            continue;\n        }\n        let mut col\
    \ = x;\n        while col > 0 && !(col % lst[row as usize].len()) {\n        \
    \    col -= 1;\n        }\n        res.push((row, col));\n        row += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3fkv2ng.rs:28:34\n   |\n\
    28 |         while col > 0 && !(col % lst[row as usize].len()) {\n   |       \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpd3fkv2ng.rs:28:32\n\
    \   |\n28 |         while col > 0 && !(col % lst[row as usize].len()) {\n   |\
    \                                ^ no implementation for `isize % usize`\n   |\n\
    \   = help: the trait `Rem<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd3fkv2ng.rs:28:26\n   |\n28 |         while col > 0 &&\
    \ !(col % lst[row as usize].len()) {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3fkv2ng.rs:34:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n34 |     res\n   |     ^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ _)>`\n              found struct `Vec<(usize, _)>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    if lst.len() > 0 {\n        sort_rows(&lst);\n        sort_rows(&lst[..]);\n\
    \        for r in lst {\n            let mut col_max = std::cmp::max(r[0].len(),\
    \ 1);\n            for c in r[0].iter().rev() {\n                if c > col_max\
    \ {\n                    col_max = c;\n                }\n            }\n    \
    \        res.push((0, c));\n            for i in r {\n                res.push((i\
    \ + 1, c - (i + 1)));\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmp9e32yrrc.rs:19:9\n\
    \   |\n19 |         sort_rows(&lst);\n   |         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `sort_rows` in this scope\n  -->\
    \ /tmp/tmp9e32yrrc.rs:20:9\n   |\n20 |         sort_rows(&lst[..]);\n   |    \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `c`\
    \ in this scope\n  --> /tmp/tmp9e32yrrc.rs:28:26\n   |\n28 |             res.push((0,\
    \ c));\n   |                          ^ help: a local variable with a similar\
    \ name exists: `r`\n\nerror[E0425]: cannot find value `c` in this scope\n  -->\
    \ /tmp/tmp9e32yrrc.rs:30:34\n   |\n30 |                 res.push((i + 1, c - (i\
    \ + 1)));\n   |                                  ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror[E0599]: no method named `len` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp9e32yrrc.rs:22:50\n   |\n22\
    \ |             let mut col_max = std::cmp::max(r[0].len(), 1);\n   |        \
    \                                          ^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp9e32yrrc.rs:23:27\n   |\n23 |             for c in r[0].iter().rev()\
    \ {\n   |                           ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    for i in lst.iter() {\n        for j in i.iter().rev() {\n\
    \            if j == x {\n                res.push((i, j));\n            }\n \
    \       }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2t5qnclh.rs:20:18\n\
    \   |\n20 |             if j == x {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2t5qnclh.rs:25:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n25 |     res\n   |     ^^^ expected `isize`, found `&Vec<isize>`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(&Vec<isize>, &isize)>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res: Vec<(isize, isize)> = vec![];\n\n    for i in lst {\n        for j in i\
    \ {\n            if j == x {\n                res.push((i, j));\n            }\n\
    \        }\n    }\n\n    res.sort_by(|a, b| a.1.cmp(b.1));\n\n    for k in res.iter().rev()\
    \ {\n        let mut res2 = vec![];\n        for i in k {\n            for j in\
    \ i {\n                res2.push((i, j));\n            }\n        }\n        res.swap(k,\
    \ res2);\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxvshrke.rs:22:27\n   |\n\
    22 |                 res.push((i, j));\n   |                           ^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxvshrke.rs:27:32\n\
    \   |\n27 |     res.sort_by(|a, b| a.1.cmp(b.1));\n   |                      \
    \          ^^^\n   |                                |\n   |                  \
    \              expected `&isize`, found `isize`\n   |                        \
    \        help: consider borrowing here: `&b.1`\n\nerror[E0277]: `&(isize, isize)`\
    \ is not an iterator\n  --> /tmp/tmpwxvshrke.rs:31:18\n   |\n31 |         for\
    \ i in k {\n   |                  ^ `&(isize, isize)` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&(isize, isize)`\n  \
    \ = note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&(isize, isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwxvshrke.rs:36:18\n\
    \   |\n36 |         res.swap(k, res2);\n   |                  ^ expected `usize`,\
    \ found `&(isize, isize)`\n   |\n   = note:   expected type `usize`\n        \
    \   found reference `&(isize, isize)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwxvshrke.rs:36:21\n   |\n36 |         res.swap(k, res2);\n   |     \
    \                ^^^^ expected `usize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `Vec<(_, _)>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    lst.sort_by_key(|x| {\n        x.iter().cloned().enumerate().filter(|(i,\
    \ _)| i == x).map(|(i, y)| y).max().unwrap()\n    });\n\n    let mut res = vec![];\n\
    \    for (i, y) in lst.iter().cloned().enumerate().filter(|(i, _)| i == x).map(|(i,\
    \ y)| y).min().unwrap() {\n        let mut tuple = (i, x);\n        let mut next_tuple\
    \ = (i, y);\n        if next_tuple.b > x {\n            let tmp = tuple;\n   \
    \         tuple = next_tuple;\n            next_tuple = tmp;\n        }\n    \
    \    res.push(tuple);\n    }\n\n    res\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `usize` with `Vec<isize>`\n  --> /tmp/tmp8squmkf9.rs:19:57\n\
    \   |\n19 |         x.iter().cloned().enumerate().filter(|(i, _)| i == x).map(|(i,\
    \ y)| y).max().unwrap()\n   |                                                \
    \         ^^ no implementation for `usize == Vec<isize>`\n   |\n   = help: the\
    \ trait `PartialEq<Vec<isize>>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<&Vec<isize>>`\
    \ for `&usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8squmkf9.rs:23:72\n\
    \   |\n23 |     for (i, y) in lst.iter().cloned().enumerate().filter(|(i, _)|\
    \ i == x).map(|(i, y)| y).min().unwrap() {\n   |                             \
    \                                           ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: can't compare `&usize` with `isize`\n  --> /tmp/tmp8squmkf9.rs:23:69\n\
    \   |\n23 |     for (i, y) in lst.iter().cloned().enumerate().filter(|(i, _)|\
    \ i == x).map(|(i, y)| y).min().unwrap() {\n   |                             \
    \                                        ^^ no implementation for `&usize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&usize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8squmkf9.rs:23:9\n\
    \   |\n23 |     for (i, y) in lst.iter().cloned().enumerate().filter(|(i, _)|\
    \ i == x).map(|(i, y)| y).min().unwrap() {\n   |         ^^^^^^    --------------------------------------------------------------------------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found tuple\n   |\n   = note: expected type "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ out = Vec::new();\n    let mut rows = lst.len();\n    let mut columns = lst.len(0);\n\
    \    let mut row = 0;\n    let mut col = 0;\n    while col < columns {\n     \
    \   while row < rows {\n            out.push((row, col));\n            row +=\
    \ 1;\n        }\n        row -= 1;\n        columns += 1;\n        col = x - 1;\n\
    \        while col >= 0 && row >= 0 {\n            let (row1, col1) = out.last_mut().unwrap();\n\
    \            if col1 < x {\n                col1 += 1;\n            } else {\n\
    \                out.push(std::vec::Vec::new());\n                col -= 1;\n\
    \            }\n            row -= 1;\n        }\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp9v3igkd4.rs:19:27\n     |\n19   |     let mut columns = lst.len(0);\n\
    \     |                           ^^^ - supplied 1 argument\n     |          \
    \                 |\n     |                           expected 0 arguments\n \
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9v3igkd4.rs:29:15\n   |\n21 |     let mut col = 0;\n   |      \
    \             - expected due to this value\n...\n29 |         col = x - 1;\n \
    \  |               ^^^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9v3igkd4.rs:32:23\n   |\n32 |             if col1 < x {\n\
    \   |                       ^ expected `&mut usize`, found `isize`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut usize`\n  -->\
    \ /tmp/tmp9v3igkd4.rs:33:17\n   |\n33 |                 col1 += 1;\n   |     \
    \            ----^^^^^\n   |                 |\n   |                 cannot use\
    \ `+=` on type `&mut usize`\n   |\nhelp: `+=` can be used on `usize`, you can\
    \ dereference `col1`\n   |\n33 |                 *col1 += 1;\n   |           \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v3igkd4.rs:35:26\n\
    \   |\n35 |                 out.push(std::vec::Vec::new());\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected tuple `(usize, usize)`\n             found struct `Vec<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9v3igkd4.rs:41:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n41 |     out\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0isize;\n    let mut column = 0isize;\n    for d in lst {\n        row\
    \ = row.min(row.max(d));\n        column = column.min(column.max(d));\n    }\n\
    \    let mut coordinates = vec![];\n    while row <= lst.len() - 1 {\n       \
    \ let row_coord = vec![(row, column)];\n        while column >= lst.len() - 1\
    \ {\n            let column_coord = vec![(row, column)];\n            if column_coord\
    \ in row_coord {\n                let row_coord = row_coord.clone();\n       \
    \         let column_coord = column_coord.clone();\n                row_coord.swap(column_coord);\n\
    \                coordinates.push((row_coord, column_coord));\n              \
    \  break;\n            }\n            column -= 1;\n        }\n        row +=\
    \ 1;\n        column = 0isize;\n    }\n    coordinates.sort();\n    coordinates\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp87a_inuh.rs:28:29\n\
    \   |\n28 |             if column_coord in row_coord {\n   |             --  \
    \            ^^ expected `{`\n   |             |\n   |             this `if` expression\
    \ has a condition, but no block\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp87a_inuh.rs:20:31\n\
    \   |\n20 |         row = row.min(row.max(d));\n   |                         \
    \      ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type\
    \ `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp87a_inuh.rs:21:40\n   |\n21 |         column = column.min(column.max(d));\n\
    \   |                                        ^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp87a_inuh.rs:24:18\n   |\n24 |\
    \     while row <= lst.len() - 1 {\n   |                  ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |     while row <= (lst.len()\
    \ - 1).try_into().unwrap() {\n   |                  +             +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp87a_inuh.rs:26:25\n   |\n26 |\
    \         while column >= lst.len() - 1 {\n   |                         ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n26 |         while\
    \ column >= (lst.len() - 1).try_into().unwrap() {\n   |                      \
    \   +             +++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut min_row = std::cmp::min(rows,\
    \ cols);\n    let mut max_row = rows - 1;\n    let mut min_col = std::cmp::min(rows,\
    \ cols);\n    let mut max_col = cols - 1;\n\n    while min_row >= 0 && max_row\
    \ >= 0 && min_col >= 0 && max_col >= 0 {\n        if rows[min_row].len() >= cols[min_col].len()\
    \ {\n            if cols[min_col].len() < x {\n                min_col -= 1;\n\
    \            } else {\n                let col = min_col;\n                while\
    \ col < cols && cols[col].len() < x {\n                    col += 1;\n       \
    \         }\n                if cols[col].len() == x {\n                    let\
    \ (row_i, col_i) = find_index(rows, cols, min_row, col, x);\n                \
    \    if row_i == min_row && col_i == min_col {\n                        min_row\
    \ = -1;\n                        max_row = rows - 1;\n                       \
    \ min_col = -1;\n                        max_col = cols - 1;\n               \
    \     }\n                    if col_i > min_col {\n                        min_col\
    \ = col_i - 1;\n                    }\n                    if row_i > min_row\
    \ {\n                        min_row = row_i - 1;\n                    }\n   \
    \             }\n                if cols[min_col].len() > x {\n              \
    \      min_col -= 1;\n                }\n            }\n        } else {\n   \
    \         if rows[min_row].len() > cols[min_col].len() {\n                max_col\
    \ -= 1;\n            } else {\n                let row = min_row;\n          \
    \      while row < rows && rows[row].len() < cols[min_col].len() {\n         \
    \           row += 1;\n                }\n                if rows[row].len() ==\
    \ cols[min_col].len() {\n                    let (col_i, row_i) = find_index(rows,\
    \ cols, row, min_col, max_col);\n                    if row_i == row && col_i\
    \ == min_col {\n                        min_row = -1;\n                      \
    \  max_row = rows - 1;\n                        min_col = -1;\n              \
    \          max_col = cols - 1;\n                    }\n                    if\
    \ row_i > row {\n                        min_row = row_i - 1;\n              \
    \      }\n                    if col_i > min_col {\n                        min_col\
    \ = col_i - 1;\n                    }\n                }\n                if rows[min_row].len()\
    \ > cols[min_col].len() {\n                    max_col -= 1;\n               \
    \ }\n            }\n        }\n    }\n    Vec::new()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_index` in this scope\n  --> /tmp/tmpn4vhvjc1.rs:34:42\n\
    \   |\n34 |                     let (row_i, col_i) = find_index(rows, cols, min_row,\
    \ col, x);\n   |                                          ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `find_index` in this scope\n\
    \  --> /tmp/tmpn4vhvjc1.rs:61:42\n   |\n61 |                     let (col_i, row_i)\
    \ = find_index(rows, cols, row, min_col, max_col);\n   |                     \
    \                     ^^^^^^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:25:12\n   |\n\
    25 |         if rows[min_row].len() >= cols[min_col].len() {\n   |           \
    \ ^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `usize`\n \
    \ --> /tmp/tmpn4vhvjc1.rs:25:35\n   |\n25 |         if rows[min_row].len() >=\
    \ cols[min_col].len() {\n   |                                   ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:26:16\n\
    \   |\n26 |             if cols[min_col].len() < x {\n   |                ^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:30:37\n\
    \   |\n30 |                 while col < cols && cols[col].len() < x {\n   |  \
    \                                   ^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:33:20\n   |\n33 |       \
    \          if cols[col].len() == x {\n   |                    ^^^^^^^^^\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:36:35\n\
    \   |\n36 |                         min_row = -1;\n   |                      \
    \             ^^\n   |                                   |\n   |             \
    \                      cannot apply unary operator `-`\n   |                 \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `usize`\n  --> /tmp/tmpn4vhvjc1.rs:38:35\n   |\n\
    38 "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.iter().cloned().collect::<Vec<_>>();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \n    let mut row = vec![(0, 0)];\n    let mut x = x;\n    let mut row = row;\n\
    \    let mut x = x;\n    let mut i = 1;\n    let mut j = lst.len() - 1;\n    while\
    \ i <= j {\n        if lst[i][0] != x {\n            i += 1;\n            continue;\n\
    \        }\n        if lst[i][1] == x {\n            return vec![\n          \
    \      (i - 1, j - 1),\n                (i + 1, j - 1),\n                (i +\
    \ 1, j),\n                (i - 1, j),\n            ];\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n    -->\
    \ /tmp/tmp8mydcuuf.rs:18:37\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \     |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n18   |     lst.sort_by(|a, b| a.iter().cmp(*&b.iter()).reverse());\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-reference\n     |\n18   -     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    18   +     lst.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n     | \nhelp:\
    \ consider changing this borrow's mutability\n     |\n18   |     lst.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n     |                         \
    \            ~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mydcuuf.rs:33:18\n\
    \   |\n33 |                 (i - 1, j - 1),\n   |                  ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |                 ((i\
    \ - 1).try_into().unwrap(), j - 1),\n   |                  +     +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8mydcuuf.rs:33:25\n   |\n33 |\
    \                 (i - 1, j - 1),\n   |                         ^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n33 |                 (i\
    \ - 1, (j - 1).try_into().unwrap()),\n   |                         +     +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8mydcuuf.rs:34:18\n   |\n34 |\
    \                 (i + "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    sort_rows_cols_first(lst);\n    lst.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    lst.sort_by(|a, b| b.iter().cmp(&a.iter()));\n    lst\n        .iter()\n\
    \        .map(|row| {\n            let mut row = row.clone();\n            sort_cols_first(row);\n\
    \            (\n                row.iter().cloned().collect::<Vec<_>>().to_vec(),\n\
    \                row.len() as isize,\n            )\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows_cols_first` in this scope\n\
    \  --> /tmp/tmpfb0wlb90.rs:18:5\n   |\n18 |     sort_rows_cols_first(lst);\n \
    \  |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_cols_first` in this scope\n  --> /tmp/tmpfb0wlb90.rs:25:13\n\
    \   |\n25 |             sort_cols_first(row);\n   |             ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: `&std::slice::Iter<'_, isize>` is not\
    \ an iterator\n    --> /tmp/tmpfb0wlb90.rs:20:37\n     |\n20   |     lst.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()));\n     |                                 --- ^^^^^^^^^\
    \ `&std::slice::Iter<'_, isize>` is not an iterator\n     |                  \
    \               |\n     |                                 required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, isize>`\nnote: required\
    \ by a bound in `std::iter::Iterator::cmp`\nhelp: consider dereferencing here\n\
    \     |\n20   |     lst.sort_by(|a, b| b.iter().cmp(*&a.iter()));\n     |    \
    \                                 +\nhelp: consider removing the leading `&`-reference\n\
    \     |\n20   -     lst.sort_by(|a, b| b.iter().cmp(&a.iter()));\n20   +     lst.sort_by(|a,\
    \ b| b.iter().cmp(a.iter()));\n     | \nhelp: consider changing this borrow's\
    \ mutability\n     |\n20   |     lst.sort_by(|a, b| b.iter().cmp(&mut a.iter()));\n\
    \     |                                     ~~~~\n\nerror[E0277]: a value of type\
    \ `Vec<(isize, isize)>` cannot be built from an iterator over elements of type\
    \ `(Vec<isize>, isize)`\n    --> /tmp/tmpfb0wlb90.rs:31:10\n     |\n31   |   \
    \      .collect()\n     |          ^^^^^^^ value of type `Vec<(isize, isize)>`\
    \ cannot be built from `std::iter::Iterator<Item=(Vec<isize>, isize)>`\n     |\n\
    \     = help: the trait `FromIterator<(Vec<isize>, isize)>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote:"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if !lst.is_empty()\
    \ {\n        let mut max_row = 0;\n        let mut min_row = 0;\n        for v\
    \ in lst {\n            if max_row < v.len() {\n                max_row = v.len();\n\
    \            }\n            if min_row > v.len() {\n                min_row =\
    \ v.len();\n            }\n        }\n        let mut min_col = max_row - 1;\n\
    \        let mut max_col = 0;\n        for v in lst {\n            if max_col\
    \ < v.len() {\n                max_col = v.len();\n            }\n           \
    \ if min_col > v.len() {\n                min_col = v.len();\n            }\n\
    \        }\n        let mut result: Vec<(isize, isize)> = Vec::new();\n      \
    \  for v in lst {\n            for r in 0..v.len() {\n                if r > max_row\
    \ - 1 {\n                    continue;\n                }\n                if\
    \ r < min_row {\n                    continue;\n                }\n          \
    \      let mut curr_r = r;\n                let mut curr_col = 0;\n          \
    \      for c in 0..v.len() {\n                    if c > max_col {\n         \
    \               continue;\n                    }\n                    if c < min_col\
    \ {\n                        continue;\n                    }\n              \
    \      if c == 0 {\n                        curr_col = 0;\n                  \
    \  } else if c == 1 {\n                        curr_col = 1;\n               \
    \     } else if c == 2 {\n                        curr_col = 2;\n            \
    \        } else if c == 3 {\n                        curr_col = 3;\n         \
    \           } else if c == 4 {\n                        curr_col = 4;\n      \
    \              } else if c == 5 {\n                        curr_col = 5;\n   \
    \                 } else if c == 6 {\n                        curr_col = 6;\n\
    \                    }\n                    let mut curr_row = v.len();\n    \
    \                if curr_row < 3 {\n                        continue;\n      \
    \              }\n                    if curr_row > 3 {\n                    \
    \    curr_row = 3;\n                    }\n                    let x = ((curr_r\
    \ - 1) * x.len() + curr_col) as isize;\n                    result.push((x, (curr_r\
    \ - 1) * x.len() + curr_col));\n                }\n            }\n        }\n\
    \        result.sort_by(|a, b| b.0.cmp_to(b.1));\n        result\n    } else {\n\
    \        vec![]\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpzbwagyxn.rs:78:47\n   |\n78 |                     let x\
    \ = ((curr_r - 1) * x.len() + curr_col) as isize;\n   |                      \
    \                         ^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpzbwagyxn.rs:79:54\n\
    \   |\n79 |                     result.push((x, (curr_r - 1) * x.len() + curr_col));\n\
    \   |                                                      ^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbwagyxn.rs:79:37\n\
    \   |\n79 |                     result.push((x, (curr_r - 1) * x.len() + curr_col));\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n79 |                   \
    \  result.push((x, ((curr_r - 1) * x.len() + curr_col).try_into().unwrap()));\n\
    \   |                                     +                                 +++++++++++++++++++++\n\
    \nerror[E0599]: no method named `cmp_to` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpzbwagyxn.rs:83:35\n   |\n83 |         result.sort_by(|a,\
    \ b| b.0.cmp_to(b.1));\n   |                                   ^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .map(|row| get_row_(row, x))\n        .collect::<Vec<(isize, isize)>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_row_` in this scope\n  --> /tmp/tmpo5mu4pjh.rs:18:20\n\
    \   |\n18 |         .map(|row| get_row_(row, x))\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ vec = vec![];\n    for y in lst {\n        let mut vec1 = vec![];\n        for\
    \ y in y {\n            if y == x {\n                vec1.push((0, 0));\n    \
    \        } else {\n                vec1.push((y, y - 1));\n            }\n   \
    \     }\n        vec.push((vec1.len(), vec1));\n    }\n    vec.sort_by(|a, b|\
    \ a.1.len().cmp(&b.1.len()));\n    vec.sort_by(|a, b| b.1.iter().zip(b.1.iter().rev()).cloned().rev().map(|&b|\
    \ b.1).cmp(&a.1));\n    vec\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Zip<std::slice::Iter<'_, (isize,\
    \ isize)>, Rev<std::slice::Iter<'_, (isize, isize)>>> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpjuzvunen.rs:30:57\n     |\n30   |     vec.sort_by(|a, b| b.1.iter().zip(b.1.iter().rev()).cloned().rev().map(|&b|\
    \ b.1).cmp(&a.1));\n     |                                                   \
    \      ^^^^^^ expected reference, found tuple\n     |\n     = note: expected reference\
    \ `&_`\n                    found tuple `(&(isize, isize), &(isize, isize))`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `rev` exists\
    \ for struct `Cloned<Zip<std::slice::Iter<'_, (isize, isize)>, Rev<std::slice::Iter<'_,\
    \ (isize, isize)>>>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpjuzvunen.rs:30:66\n\
    \   |\n30 |        vec.sort_by(|a, b| b.1.iter().zip(b.1.iter().rev()).cloned().rev().map(|&b|\
    \ b.1).cmp(&a.1));\n   |                                                     \
    \                ^^^ method cannot be called on `Cloned<Zip<std::slice::Iter<'_,\
    \ (isize, isize)>, Rev<std::slice::Iter<'_, (isize, isize)>>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Zip<std::slice::Iter<'_, (isize, isize)>, Rev<std::slice::Iter<'_,\
    \ (isize, isize)>>> as Iterator>::Item = &_`\n           which is required by\
    \ `Cloned<Zip<std::slice::Iter<'_, (isize, isize)>, Rev<std::slice::Iter<'_, (isize,\
    \ isize)>>>>: Iterator`\n           `Cloned<Zip<std::slice::Iter<'_, (isize, isize)>,\
    \ Rev<std::slice::Iter<'_, (isize, isize)>>>>: Iterator`\n           which is\
    \ required by `&mut Cloned<Zip<std::slice::Iter<'_, (isize, isize)>, Rev<std::slice::Iter<'_,\
    \ (isize, isize)>>>>: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjuzvunen.rs:31:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n31 |     vec\n   |     ^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rev = lst.iter().rev();\n    let mut rows = Vec::new();\n    for row in rev.by_ref()\
    \ {\n        let mut cols: Vec<_> = row.iter().map(|v| v - x).collect();\n   \
    \     cols.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        let mut rows =\
    \ Vec::new();\n        for col in cols.iter() {\n            rows.push((col[0],\
    \ col + 1));\n        }\n        if !rows.is_empty() {\n            return rows;\n\
    \        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpgzxj7pdc.rs:24:24\n\
    \   |\n24 |             rows.push((col[0], col + 1));\n   |                  \
    \      ^^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = vec![];\n    for r in lst {\n        if r.len() == x {\n            ret.push((r,\
    \ 0));\n        }\n    }\n    ret.sort_by_key(|r| r[1]).reverse();\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b929t9m.rs:19:23\n   |\n\
    19 |         if r.len() == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |         if r.len() == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `&(Vec<isize>, {integer})`\n  --> /tmp/tmp8b929t9m.rs:23:25\n\
    \   |\n23 |     ret.sort_by_key(|r| r[1]).reverse();\n   |                   \
    \      ^^^^\n\nerror[E0599]: no method named `reverse` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmp8b929t9m.rs:23:31\n   |\n23 |     ret.sort_by_key(|r|\
    \ r[1]).reverse();\n   |                               ^^^^^^^ method not found\
    \ in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8b929t9m.rs:24:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n24 |     ret\n   |     ^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(Vec<isize>, {integer})>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Solution\
    \ #1\n    let mut result = vec![];\n    let mut row_idx = 1;\n\n    // First,\
    \ sort coordinates by rows\n    for row in lst {\n        if row_idx > row.len()\
    \ {\n            continue;\n        }\n        if row[0] == x {\n            result.push(vec![(row_idx,\
    \ row_idx - 1), (row_idx, 0)]);\n        }\n        row_idx += 1;\n    }\n\n \
    \   // Then sort coordinates by columns\n    let mut col_idx = 1;\n    for row\
    \ in lst {\n        if col_idx > row.len() {\n            continue;\n        }\n\
    \        for coord in row {\n            if col_idx < (row.len() - 1) && (coord\
    \ >= (row_idx - col_idx + 1)) && (coord <= (row_idx - col_idx)) {\n          \
    \      result.push(vec![(row_idx - col_idx + 1, col_idx), (row_idx - col_idx,\
    \ col_idx)]);\n            }\n            col_idx += 1;\n        }\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvcbsne8w.rs:39:55\n   |\n\
    39 |             if col_idx < (row.len() - 1) && (coord >= (row_idx - col_idx\
    \ + 1)) && (coord <= (row_idx - col_idx)) {\n   |                            \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n39 |             if col_idx < (row.len() - 1) && (coord\
    \ >= ((row_idx - col_idx + 1)).try_into().unwrap()) && (coord <= (row_idx - col_idx))\
    \ {\n   |                                                       +            \
    \           +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcbsne8w.rs:39:93\n\
    \   |\n39 |             if col_idx < (row.len() - 1) && (coord >= (row_idx - col_idx\
    \ + 1)) && (coord <= (row_idx - col_idx)) {\n   |                            \
    \                                                                 ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n39 |           \
    \  if col_idx < (row.len() - 1) && (coord >= (row_idx - col_idx + 1)) && (coord\
    \ <= ((row_idx - col_idx)).try_into().unwrap()) {\n   |                      \
    \                                                                       +    \
    \               +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvcbsne8w.rs:46:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n46 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ans = vec![];\n\n    lst.sort_by(|a, b| a.iter().zip(b.iter()).collect::<Vec<_>>()).reverse();\n\
    \n    for i in 0..lst.len() {\n        if i < (lst.len() - 1) && i >= x {\n  \
    \          ans.push(vec![(i, x - i)].iter().cloned().collect::<Vec<_>>());\n \
    \       }\n    }\n\n    ans.iter().cloned().collect::<Vec<_>>().sort_by(|a, b|\
    \ b.iter().zip(a.iter()).collect::<Vec<_>>()).reverse()\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoawd7djz.rs:19:24\n   |\n\
    19 |     lst.sort_by(|a, b| a.iter().zip(b.iter()).collect::<Vec<_>>()).reverse();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found struct `Vec`\n   |\n   = note: expected enum\
    \ `std::cmp::Ordering`\n            found struct `Vec<(&isize, &isize)>`\n\nerror[E0599]:\
    \ no method named `reverse` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpoawd7djz.rs:19:68\n   |\n19 |     lst.sort_by(|a, b| a.iter().zip(b.iter()).collect::<Vec<_>>()).reverse();\n\
    \   |                                                                    ^^^^^^^\
    \ method not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoawd7djz.rs:22:40\n\
    \   |\n22 |         if i < (lst.len() - 1) && i >= x {\n   |                 \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n22 |         if i < (lst.len() - 1) && i >= x.try_into().unwrap() {\n \
    \  |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoawd7djz.rs:23:35\n   |\n23 |             ans.push(vec![(i,\
    \ x - i)].iter().cloned().collect::<Vec<_>>());\n   |                        \
    \           ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract\
    \ `usize` from `isize`\n  --> /tmp/tmpoawd7djz.rs:23:33\n   |\n23 |          \
    \   ans.push(vec![(i, x - i)].iter().cloned().collect::<Vec<_>>());\n   |    \
    \                             ^ no implementation for `isize - usize`\n   |\n\
    \   = help: the trait `Sub<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coordinates = Vec::new();\n    let mut rows = Vec::new();\n    for row in lst\
    \ {\n        rows.push(row.len());\n    }\n    if rows.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut row_order = Vec::with_capacity(rows[0].clone());\n\
    \    for (i, _) in row_order.iter().enumerate() {\n        *row_order.get(i) =\
    \ i;\n    }\n    let mut cols = Vec::with_capacity(rows[0].clone());\n    for\
    \ (i, _) in cols.iter().enumerate() {\n        *cols.get(i) = i;\n    }\n    for\
    \ (i, row) in row_order.iter().enumerate() {\n        for (j, col) in cols.iter().enumerate()\
    \ {\n            let x_coord = row + (j - cols.len()) / 2;\n            if x_coord\
    \ < x {\n                coordinates.push((i, j));\n            }\n        }\n\
    \    }\n    coordinates.sort_by(|(_, a), (_, b)| a.cmp(b));\n    coordinates.sort_by(|(_,\
    \ a), (_, b)| b.cmp(a));\n    coordinates\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&_>` cannot be dereferenced\n  --> /tmp/tmp0jgjdsv4.rs:27:9\n\
    \   |\n27 |         *row_order.get(i) = i;\n   |         ^^^^^^^^^^^^^^^^^\n\n\
    error[E0614]: type `Option<&_>` cannot be dereferenced\n  --> /tmp/tmp0jgjdsv4.rs:31:9\n\
    \   |\n31 |         *cols.get(i) = i;\n   |         ^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0jgjdsv4.rs:36:26\n   |\n36 |             if\
    \ x_coord < x {\n   |                          ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n36 |             if x_coord < x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0jgjdsv4.rs:43:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n43 |     coordinates\n   |     ^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n          \
    \    found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        vec![]\n    } else {\n        // sort coordinates by rows, in ascending\
    \ order\n        let mut sorted: Vec<(isize, isize)> = vec![];\n        for (i,\
    \ row) in lst.iter().enumerate() {\n            let mut j = i; // j is index in\
    \ row, from 0 to n\n            for _ in 0...row.len() {\n                // sort\
    \ coordinates by columns in descending order\n                if row[j] > x {\n\
    \                    break;\n                }\n                j += 1;\n    \
    \        }\n            sorted.push((i, j));\n        }\n        sorted.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n        sorted\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpra6c2yan.rs:24:23\n   |\n\
    24 |             for _ in 0...row.len() {\n   |                       ^^^\n  \
    \ |\nhelp: use `..` for an exclusive range\n   |\n24 |             for _ in 0..row.len()\
    \ {\n   |                       ~~\nhelp: or `..=` for an inclusive range\n  \
    \ |\n24 |             for _ in 0..=row.len() {\n   |                       ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpra6c2yan.rs:31:26\n   |\n31 |\
    \             sorted.push((i, j));\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |             sorted.push((i.try_into().unwrap(),\
    \ j));\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpra6c2yan.rs:31:29\n   |\n31 |             sorted.push((i,\
    \ j));\n   |                             ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |             sorted.push((i, j.try_into().unwrap()));\n\
    \   |                              ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    if lst.len() == 1 {\n        return\
    \ vec![(x, 0)];\n    }\n\n    let mut row1 = vec![];\n    let mut row2 = vec![];\n\
    \    let mut row_len = lst.len();\n    let mut col_len = row_len;\n    let mut\
    \ col_num = 0;\n\n    for row in lst {\n        if row.len() == 1 {\n        \
    \    row1.push((row[0], 0));\n            row2.push((row[0], 0));\n        } else\
    \ {\n            let mut col = vec![];\n\n            for i in 0..col_num {\n\
    \                if row[i] >= x {\n                    col.push((row[i], i));\n\
    \                    break;\n                }\n            }\n\n            if\
    \ col.len() == col_num {\n                col_num = col_num + 1;\n           \
    \ }\n\n            row1.push(vec![(row[0], col[0])]);\n            row2.push(vec![(row[0],\
    \ col[col_num])]);\n        }\n    }\n\n    let mut row1_sorted = vec![];\n  \
    \  let mut row2_sorted = vec![];\n\n    for i in 0..row_len - 1 {\n        row1_sorted.push((row1[i][0],\
    \ row1[i][1]));\n        row2_sorted.push((row2[i][0], row2[i][1]));\n    }\n\n\
    \    row1_sorted.sort_by(|a, b| b.1.cmp(&a.1).reverse());\n    row2_sorted.sort_by(|a,\
    \ b| b.1.cmp(&a.1).reverse());\n\n    return vec![\n        (row1_sorted[row_len\
    \ - 1], row2_sorted[row_len - 1]),\n        (row1_sorted[0], row2_sorted[0]),\n\
    \    ];\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphcz3exrt.rs:49:23\n   |\n\
    49 |             row1.push(vec![(row[0], col[0])]);\n   |                    \
    \   ^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note:\
    \ expected tuple `(isize, {integer})`\n             found struct `Vec<(isize,\
    \ (isize, usize))>`\n   = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphcz3exrt.rs:50:23\n   |\n50 |             row2.push(vec![(row[0],\
    \ col[col_num])]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize, {integer})`\n\
    \             found struct `Vec<(isize, (isize, usize))>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0608]: cannot index into a value of type `(isize, {integer})`\n\
    \  --> /tmp/tmphcz3exrt.rs:58:27\n   |\n58 |         row1_sorted.push((row1[i][0],\
    \ row1[i][1]));\n   |                           ^^^^^^^^^^ help: to access tuple\
    \ elements, use: `row1[i].0`\n\nerror[E0608]: cannot index into a value of type\
    \ `(isize, {integer})`\n  --> /tmp/tmphcz3exrt.rs:58:39\n   |\n58 |         row1_sorted.push((row1[i][0],\
    \ row1[i][1]));\n   |                                       ^^^^^^^^^^ help: to\
    \ access tuple elements, use: `row1[i].1`\n\nerror[E0608]: cannot index into a\
    \ value of type `(isize, {integer})`\n  --> /tmp/tmphcz3exrt.rs:59:27\n   |\n\
    59 |         row2_sorted.push((row2[i][0], row2[i][1]));\n   |               \
    \            ^^^^^^^^^^ help: to access tuple elements, use: `row2[i].0`\n\nerror[E0608]:\
    \ cannot index into a value of type `(isize, {integer})`\n  --> /tmp/tmphcz3exrt.rs:59:39\n\
    \   |\n59 |         row2_sorted.push((row2[i][0], row2[i][1]));\n   |        \
    \                               ^^^^^^^^^^ help: to access tuple elements, use:\
    \ `row2[i].1`\n\nerror[E0609]: no field `1` on type `&_`\n  --> /tmp/tmphcz3exrt.rs:62:34\n\
    \   |\n62 |     row1_sorted.sort_by(|a, b| b.1.cmp(&a.1).rever"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .map(|v| v.iter().map(|x| (*x, x)))\n        .filter_map(|(_, y)| y.iter().take(x).cloned())\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|x, y| y.iter().count().cmp(x.iter().count()))\n\
    \        .map(|y| {\n            let mut x = y.iter().take(x).cloned();\n    \
    \        x.sort_by(|x, y| y.iter().count().cmp(x.iter().count()));\n         \
    \   x\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdf7lfb2b.rs:19:22\n   |\n\
    18 |         .map(|v| v.iter().map(|x| (*x, x)))\n   |                       \
    \        ----------- the expected closure\n19 |         .filter_map(|(_, y)| y.iter().take(x).cloned())\n\
    \   |                      ^^^^^-\n   |                      |    |\n   |    \
    \                  |    expected due to this\n   |                      expected\
    \ struct `Map`, found tuple\n   |\n   = note: expected struct `Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpdf7lfb2b.rs:18:31: 18:42]>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpdf7lfb2b.rs:22:10\n\
    \   |\n22 |         .map(|y| {\n   |          ^^^ `()` is not an iterator\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rows = vec![];\n    let mut\
    \ cols = vec![];\n\n    rows.reserve(lst.len());\n    cols.reserve(lst.len());\n\
    \n    for row in lst {\n        cols.clear();\n        for col in row.iter() {\n\
    \            cols.push((*col).clone());\n        }\n\n        rows.push((*row).clone());\n\
    \    }\n\n    rows.sort_by(|a, b| a.1.cmp(&b.1));\n    cols.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \n    let mut result = vec![];\n    let mut current_row = 0;\n    let mut current_col\
    \ = 0;\n\n    for row in rows.iter() {\n        for col in cols.iter() {\n   \
    \         if current_row == row.0.to_usize() && current_col == col.0.to_usize()\
    \ {\n                result.push((current_row, current_col));\n              \
    \  current_col = 0;\n            } else {\n                current_col += 1;\n\
    \            }\n        }\n\n        current_row += 1;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone` found for slice `[isize]` in the\
    \ current scope\n  --> /tmp/tmpf32oiqeu.rs:33:26\n   |\n33 |         rows.push((*row).clone());\n\
    \   |                          ^^^^^ method not found in `[isize]`\n\nerror[E0609]:\
    \ no field `1` on type `&_`\n  --> /tmp/tmpf32oiqeu.rs:36:27\n   |\n36 |     rows.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n   |                           ^\n\nerror[E0609]: no field\
    \ `1` on type `&isize`\n  --> /tmp/tmpf32oiqeu.rs:37:27\n   |\n37 |     cols.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                           ^\n\nerror[E0609]: no field\
    \ `1` on type `&isize`\n  --> /tmp/tmpf32oiqeu.rs:37:36\n   |\n37 |     cols.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                                    ^\n\nerror[E0609]:\
    \ no field `0` on type `&isize`\n  --> /tmp/tmpf32oiqeu.rs:45:70\n   |\n45 | \
    \            if current_row == row.0.to_usize() && current_col == col.0.to_usize()\
    \ {\n   |                                                                    \
    \  ^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = Vec::new();\n    if lst.len() == 0 {\n        return res;\n    }\n   \
    \ for i in 0..lst.len() {\n        if i == x {\n            for j in lst[i].iter().rev()\
    \ {\n                res.push((i, j));\n            }\n        }\n    }\n    if\
    \ let Some(mut lst) = lst.iter().cloned() {\n        lst.rev();\n        for (i,\
    \ row) in lst.iter().enumerate() {\n            for j in row[0..row.len() - 1].iter().rev()\
    \ {\n                res.push((i, j));\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvcpv2n6.rs:22:17\n   |\n\
    22 |         if i == x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         if i == x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqvcpv2n6.rs:24:27\n   |\n24 |                 res.push((i, j));\n  \
    \ |                           ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |                 res.push((i.try_into().unwrap(), j));\n   |\
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqvcpv2n6.rs:24:30\n   |\n24 |                 res.push((i,\
    \ j));\n   |                              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |                 res.push((i,\
    \ *j));\n   |                              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqvcpv2n6.rs:28:12\n   |\n28 |     if let Some(mut lst) = lst.iter().cloned()\
    \ {\n   |            ^^^^^^^^^^^^^   ------------------- this expression has type\
    \ `Cloned<std::slice::Iter<'_, Vec<isize>>>`\n   |            |\n   |        \
    \    expected struct `Cloned`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Cloned<std::slice::Iter<'_, Vec<isize>>>`\n                found enum\
    \ `Option<_>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = Vec::new();\n    for row in lst {\n        for cell in row {\n    \
    \        if cell == x {\n                coords.push((row, cell));\n         \
    \   }\n        }\n    }\n    coords.sort_by(|a, b| a.0.cmp(b.0));\n    let mut\
    \ sorted_row = Vec::new();\n    let mut sorted_col = Vec::new();\n    for coord\
    \ in coords {\n        sorted_row.push(coord.0.clone());\n        sorted_col.push(coord.1.clone());\n\
    \    }\n    sorted_row.sort_by(|a, b| b.cmp(a));\n    sorted_col.sort_by(|a, b|\
    \ b.cmp(a));\n    sorted_row.iter().zip(sorted_col).map(|(x, y)| (x.0, x.1, y)).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8vj4g9fe.rs:25:35\n   |\n\
    25 |     coords.sort_by(|a, b| a.0.cmp(b.0));\n   |                          \
    \         ^^^\n   |                                   |\n   |                \
    \                   expected `&Vec<isize>`, found struct `Vec`\n   |         \
    \                          help: consider borrowing here: `&b.0`\n   |\n   = note:\
    \ expected reference `&Vec<isize>`\n                 found struct `Vec<isize>`\n\
    \nerror[E0609]: no field `0` on type `&Vec<isize>`\n  --> /tmp/tmp8vj4g9fe.rs:34:55\n\
    \   |\n34 |     sorted_row.iter().zip(sorted_col).map(|(x, y)| (x.0, x.1, y)).collect()\n\
    \   |                                                       ^ unknown field\n\n\
    error[E0609]: no field `1` on type `&Vec<isize>`\n  --> /tmp/tmp8vj4g9fe.rs:34:60\n\
    \   |\n34 |     sorted_row.iter().zip(sorted_col).map(|(x, y)| (x.0, x.1, y)).collect()\n\
    \   |                                                            ^ unknown field\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.to_vec();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().map(|&x|\
    \ (x, 0)).collect::<Vec<_>>());\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().map(|&x|\
    \ (x, 1)).collect::<Vec<_>>());\n    let mut res: Vec<(isize, isize)> = vec![];\n\
    \    lst.iter().for_each(|row| {\n        let mut row: Vec<isize> = vec![];\n\
    \        let mut col: isize = 0;\n        row.push(0);\n        row.push(0);\n\
    \        row.push(1);\n        row.push(0);\n        row.push(0);\n        row.push(0);\n\
    \        row.push(1);\n        row.push(1);\n        row.push(0);\n        row.push(0);\n\
    \        row.push(1);\n        row.push(1);\n        let mut col_iter: Vec<_>\
    \ = row.iter().cloned().collect();\n        col_iter.sort_by(|a, b| b.cmp(&a).reverse());\n\
    \        col_iter.iter().for_each(|&i| {\n            if i <= x {\n          \
    \      col.push(i);\n            }\n        });\n        res.push(col.clone());\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n    -->\
    \ /tmp/tmplvevq6db.rs:18:37\n     |\n18   |     lst.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().map(|&x|\
    \ (x, 0)).collect::<Vec<_>>());\n     |                                 --- ^^^^^^^^^\
    \ `&std::slice::Iter<'_, isize>` is not an iterator\n     |                  \
    \               |\n     |                                 required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n     = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, isize>`\nnote: required\
    \ by a bound in `std::iter::Iterator::cmp`\nhelp: consider dereferencing here\n\
    \     |\n18   |     lst.sort_by(|a, b| b.iter().cmp(*&a.iter()).rev().map(|&x|\
    \ (x, 0)).collect::<Vec<_>>());\n     |                                     +\n\
    help: consider removing the leading `&`-reference\n     |\n18   -     lst.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).rev().map(|&x| (x, 0)).collect::<Vec<_>>());\n18\
    \   +     lst.sort_by(|a, b| b.iter().cmp(a.iter()).rev().map(|&x| (x, 0)).collect::<Vec<_>>());\n\
    \     | \nhelp: consider changing this borrow's mutability\n     |\n18   |   \
    \  lst.sort_by(|a, b| b.iter().cmp(&mut a.iter()).rev().map(|&x| (x, 0)).collect::<Vec<_>>());\n\
    \     |                                     ~~~~\n\nerror[E0599]: `std::cmp::Ordering`\
    \ is not an iterator\n   --> /tmp/tmplvevq6db.rs:18:48\n    |\n18  |       lst.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).rev().map(|&x| (x, 0)).collect::<Vec<_>>());\n  \
    \  |                                                  ^^^ `std::cmp::Ordering`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `std::cmp::Ordering: Iterator`\n            which is required by\
    \ `&mut std::cmp::Ordering: Iterator`\n\nerror[E0277]: `&std::slice::Iter<'_,\
    \ isize>` is not an iterator\n    --> /tmp/tmplvevq6db.rs:19:37\n     |\n19  \
    \ |     lst.sort_by(|a, b| b.iter().cmp(&a.iter()).rev().map(|&x| (x, 1)).collect::<Vec<_>>());\n\
    \     |               "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    // TODO: add test cases when sorting by\
    \ rows or columns.\n    let mut result = vec![];\n    for row in lst {\n     \
    \   let mut current = vec![];\n        for v in row {\n            if v == x {\n\
    \                current.push((row, v));\n            }\n        }\n        result.push(current);\n\
    \    }\n    result.sort_by_key(|&(_, v)| v);\n    result.sort_by_key(|&(_, v)|\
    \ -v, |&(_, v)| v);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpekzxajc0.rs:31:26\n   |\n\
    31 |     result.sort_by_key(|&(_, v)| v);\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<(Vec<isize>, isize)>`\n               found\
    \ tuple `(_, _)`\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmpekzxajc0.rs:32:12\n    |\n32  |     result.sort_by_key(|&(_,\
    \ v)| -v, |&(_, v)| v);\n    |            ^^^^^^^^^^^ ------------  -----------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpekzxajc0.rs:33:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n33 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    debug_assert!(lst.len()\
    \ > 0);\n    debug_assert!(lst.len() == lst[0].len());\n    let mut lst = lst.clone();\n\
    \    lst.sort_by(|a, b| a.iter().cmp(&b.iter()));\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut v = vec![];\n    for i in lst {\n        let mut res = vec![];\n\
    \        for j in i.iter().cloned().rev() {\n            if j == x {\n       \
    \         res.push((i, j));\n            }\n        }\n        v.append(&res);\n\
    \    }\n    v.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    v\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n    -->\
    \ /tmp/tmp788dsuwe.rs:20:37\n     |\n20   |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()));\n\
    \     |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n20   |     lst.sort_by(|a, b| a.iter().cmp(*&b.iter()));\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-reference\n     |\n20   -     lst.sort_by(|a, b| a.iter().cmp(&b.iter()));\n\
    20   +     lst.sort_by(|a, b| a.iter().cmp(b.iter()));\n     | \nhelp: consider\
    \ changing this borrow's mutability\n     |\n20   |     lst.sort_by(|a, b| a.iter().cmp(&mut\
    \ b.iter()));\n     |                                     ~~~~\n\nerror[E0277]:\
    \ `&std::slice::Iter<'_, isize>` is not an iterator\n    --> /tmp/tmp788dsuwe.rs:21:37\n\
    \     |\n21   |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n \
    \    |                                 --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n     |                                 |\n     |       \
    \                          required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ isize>`\n     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n21   |     lst.sort_by(|a, b| a.iter().cmp(*&b.iter()).reverse());\n\
    \     |                                     +\nhelp: consider removing the leading\
    \ `&`-reference\n     |\n21   -     lst.sort_by(|a, b| a.iter"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = Vec::with_capacity(lst.len());\n\n    for row_vec in lst {\n      \
    \  let mut row_sorted = Vec::with_capacity(row_vec.len());\n        for mut value\
    \ in row_vec {\n            let idx = row_sorted.binary_search(&value);\n    \
    \        if idx < 0 {\n                row_sorted.push(value);\n            }\
    \ else {\n                row_sorted.swap(idx, 0);\n            }\n        }\n\
    \        result.push((row_sorted.iter().rev().next().unwrap(), row_sorted.iter().rev().last().unwrap()));\n\
    \    }\n    result.sort();\n\n    let mut result_vec = Vec::with_capacity(result.len());\n\
    \    for ((r, c), value) in result.iter().enumerate() {\n        result_vec.push((c,\
    \ r));\n    }\n\n    result_vec\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvqe1aew.rs:23:22\n   |\n\
    23 |             if idx < 0 {\n   |                      ^ expected enum `Result`,\
    \ found integer\n   |\n   = note: expected enum `Result<usize, usize>`\n     \
    \         found type `{integer}`\nhelp: try wrapping the expression in a variant\
    \ of `Result`\n   |\n23 |             if idx < Ok(0) {\n   |                 \
    \     +++ +\n23 |             if idx < Err(0) {\n   |                      ++++\
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphvqe1aew.rs:26:33\n   |\n\
    26 |                 row_sorted.swap(idx, 0);\n   |                          \
    \       ^^^ expected `usize`, found enum `Result`\n   |\n   = note: expected type\
    \ `usize`\n              found enum `Result<usize, usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphvqe1aew.rs:34:10\n   |\n34 |     for ((r, c), value) in\
    \ result.iter().enumerate() {\n   |          ^^^^^^            -------------------------\
    \ this expression has type `Option<(usize, &(&isize, &isize))>`\n   |        \
    \  |\n   |          expected `usize`, found tuple\n   |\n   = note: expected type\
    \ `usize`\n             found tuple `(_, _)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n\n    let mut rows = lst.len();\n    let mut columns = lst[0].len();\n\
    \    let mut row_index = rows;\n    let mut col_index = columns;\n\n    while\
    \ row_index != 0 || col_index != 0 {\n        if row_index == rows {\n       \
    \     row_index -= 1;\n            col_index -= 1;\n        }\n        if col_index\
    \ == columns {\n            row_index -= 1;\n            col_index -= 1;\n   \
    \     }\n\n        let mut row = 0;\n        let mut col = 0;\n        if row_index\
    \ != 0 {\n            row = row_index % rows;\n            row_index -= row;\n\
    \        }\n        if col_index != 0 {\n            col = col_index % columns;\n\
    \            col_index -= col;\n        }\n        if row == row && col == col\
    \ {\n            result.push((row, col));\n        }\n    }\n\n    result.sort();\n\
    \    result.sort_by_key(|&(x, y)| {\n        if x < y {\n            1\n     \
    \   } else {\n            -1\n        }\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu6nv7ds5.rs:57:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n57 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Sort\
    \ the coordinates by rows, ascending order\n    let mut rows = lst.iter().map(|row|\
    \ {\n        row.iter().enumerate().sort_by(|x, y| x.1).map(|(i, j)| {\n     \
    \       (j, i)\n        })\n    }).collect::<Vec<Vec<(isize, isize)>>>();\n  \
    \  // Sort the coordinates by columns in descending order\n    let mut columns\
    \ = lst.iter().map(|row| row.iter().enumerate().sort_by(|x, y| y.1).map(|(i, j)|\
    \ {\n        (j, i)\n    })).collect::<Vec<Vec<(isize, isize)>>>();\n    // Get\
    \ the corresponding rows and columns\n    let mut row_index: Vec<isize> = rows.iter().enumerate().map(|(i,\
    \ row)| {\n        i\n    }).collect();\n    let mut column_index: Vec<isize>\
    \ = columns.iter().enumerate().map(|(i, column)| {\n        i\n    }).collect();\n\
    \    row_index.sort();\n    column_index.sort();\n    // Get the coordinates\n\
    \    let mut coordinates: Vec<(isize, isize)> = vec![];\n    for i in 0..row_index.len()\
    \ {\n        let r = row_index[i];\n        for i in 0..column_index.len() {\n\
    \            let c = column_index[i];\n            let index = r * column_index.len()\
    \ + c;\n            coordinates.push((i, index));\n        }\n    }\n    coordinates\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpgiloiizx.rs:19:32\n   |\n19 |         row.iter().enumerate().sort_by(|x,\
    \ y| x.1).map(|(i, j)| {\n   |                                ^^^^^^^ method not\
    \ found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Enumerate` in the current scope\n  --> /tmp/tmpgiloiizx.rs:24:67\n\
    \   |\n24 |     let mut columns = lst.iter().map(|row| row.iter().enumerate().sort_by(|x,\
    \ y| y.1).map(|(i, j)| {\n   |                                               \
    \                    ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from\
    \ an iterator over elements of type `usize`\n    --> /tmp/tmpgiloiizx.rs:30:8\n\
    \     |\n30   |     }).collect();\n     |        ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help:\
    \ the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `usize`\n    --> /tmp/tmpgiloiizx.rs:33:8\n\
    \     |\n33   |     }).collect();\n     |        ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help:\
    \ the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgiloiizx.rs:42:29\n\
    \   |\n42 |             let index = r * column_index.len() + c;\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot multiply `isize` by `usize`\n  --> /tmp/tmpgiloiizx.rs:42:27\n   |\n\
    42 |             let index = r * column_index.len() + c;\n   |               \
    \            ^ no implementation for `isize * usize`\n  "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while col_idx < lst.len() {\n        if row_idx == lst.len() - 1 {\n\
    \            break;\n        }\n        let current_row = lst[row_idx];\n    \
    \    let mut row_col_pair = vec![];\n        let mut cols_in_row: Vec<isize> =\
    \ current_row.iter().map(|e| e as isize).collect();\n        let mut first_col_in_row\
    \ = 0;\n        if cols_in_row.contains(x) {\n            row_col_pair = (row_idx,\
    \ cols_in_row.iter().position(|e| e == x).unwrap());\n            first_col_in_row\
    \ = cols_in_row.iter().position(|e| e == x).unwrap() + 1;\n        }\n       \
    \ for col_idx2 in first_col_in_row..cols_in_row.len() {\n            let current_col\
    \ = lst[row_idx][col_idx2];\n            row_col_pair = (row_idx, col_idx2);\n\
    \            if cols_in_row.contains(x) {\n                break;\n          \
    \  }\n            cols_in_row.push(current_col);\n        }\n        if row_col_pair.len()\
    \ > 0 {\n            ret.push(row_col_pair);\n        }\n        row_idx += 1;\n\
    \        col_idx += 1;\n    }\n    ret.sort_by_key(|e| e[0]);\n    ret.sort_by_key(|e|\
    \ -e[1]);\n    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp15oglcgw.rs:28:33\n   |\n\
    28 |         if cols_in_row.contains(x) {\n   |                              \
    \   ^\n   |                                 |\n   |                          \
    \       expected `&isize`, found `isize`\n   |                               \
    \  help: consider borrowing here: `&x`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp15oglcgw.rs:29:72\n   |\n29 |             row_col_pair\
    \ = (row_idx, cols_in_row.iter().position(|e| e == x).unwrap());\n   |       \
    \                                                                 ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp15oglcgw.rs:29:28\n   |\n25 |         let mut row_col_pair = vec![];\n\
    \   |                                ------ expected due to this value\n...\n\
    29 |             row_col_pair = (row_idx, cols_in_row.iter().position(|e| e ==\
    \ x).unwrap());\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<_>`\n\
    \               found tuple `(usize, usize)`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp15oglcgw.rs:30:66\n   |\n30 |             first_col_in_row\
    \ = cols_in_row.iter().position(|e| e == x).unwrap() + 1;\n   |              \
    \                                                    ^^ no implementation for\
    \ `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]:"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ new_lst = Vec::new();\n    let mut idx = 0;\n    let mut curr_row = 0;\n   \
    \ let mut curr_col = 0;\n    for row in lst {\n        let mut row_cols = Vec::new();\n\
    \        for val in row {\n            if val == x {\n                row_cols.push((curr_row,\
    \ curr_col));\n            }\n            curr_col += 1;\n            if curr_col\
    \ > row.len() - 1 {\n                curr_row++;\n                curr_col = 0;\n\
    \            }\n        }\n        idx += 1;\n        row_cols.sort_by(|a, b|\
    \ {\n            if a[1..] == b[1..] {\n                a.iter().rev().zip(b).map(|(a,\
    \ b)| a).collect::<Vec<_>>().len()\n            } else {\n                b.iter().rev().zip(a).map(|(a,\
    \ b)| b).collect::<Vec<_>>().len()\n            }\n        });\n        new_lst.push((idx,\
    \ row_cols.iter().cloned().collect::<Vec<_>>()));\n    }\n    new_lst.sort_by(|a,\
    \ b| {\n        if a[1..] > b[1..] {\n            true\n        } else {\n   \
    \         false\n        }\n    });\n    new_lst\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpzzbi80gv.rs:29:25\n\
    \   |\n29 |                 curr_row++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |         \
    \        { let tmp = curr_row; curr_row += 1; tmp };\n   |                 +++++++++++\
    \         ~~~~~~~~~~~~~~~~~~~~~~\n29 -                 curr_row++;\n29 +     \
    \            curr_row += 1;\n   | \n\nerror[E0608]: cannot index into a value\
    \ of type `&({integer}, usize)`\n  --> /tmp/tmpzzbi80gv.rs:35:16\n   |\n35 | \
    \            if a[1..] == b[1..] {\n   |                ^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&({integer}, usize)`\n  --> /tmp/tmpzzbi80gv.rs:35:26\n\
    \   |\n35 |             if a[1..] == b[1..] {\n   |                          ^^^^^^\n\
    \nerror[E0599]: no method named `iter` found for reference `&({integer}, usize)`\
    \ in the current scope\n  --> /tmp/tmpzzbi80gv.rs:36:19\n   |\n36 |          \
    \       a.iter().rev().zip(b).map(|(a, b)| a).collect::<Vec<_>>().len()\n   |\
    \                   ^^^^ method not found in `&({integer}, usize)`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&({integer}, usize)` in the current\
    \ scope\n  --> /tmp/tmpzzbi80gv.rs:38:19\n   |\n38 |                 b.iter().rev().zip(a).map(|(a,\
    \ b)| b).collect::<Vec<_>>().len()\n   |                   ^^^^ method not found\
    \ in `&({integer}, usize)`\n\nerror[E0608]: cannot index into a value of type\
    \ `&({integer}, Vec<({integer}, usize)>)`\n  --> /tmp/tmpzzbi80gv.rs:44:12\n \
    \  |\n44 |         if a[1..] > b[1..] {\n   |            ^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&({integer}, Vec<({integer}, usize)>)`\n\
    \  --> /tmp/tmpzzbi80gv.rs:44:21\n   |\n44 |         if a[1..] > b[1..] {\n  \
    \ |                     ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzbi80gv.rs:45:13\n\
    \   |\n45 |             true\n   |             ^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzbi80gv.rs:47:13\n\
    \   |\n47 |             false\n   |             ^^^^^ expected enum `std::cmp::Ordering`, "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ans = vec![];\n    let mut cols = lst[0].len();\n    let mut row = 0;\n    let\
    \ mut last_i = 0;\n    let mut last_j = 0;\n    while row < lst.len() {\n    \
    \    if lst[row].len() == cols {\n            for col in 0..cols {\n         \
    \       if col == x {\n                    ans.push((row, col));\n           \
    \         last_i = row;\n                    last_j = col;\n                }\n\
    \            }\n            row += 1;\n            continue;\n        }\n    \
    \    for col in 0..cols {\n            if col == x {\n                ans.push((row,\
    \ col));\n                last_i = row;\n                last_j = col;\n     \
    \       }\n        }\n        cols = lst[row].len();\n        row += 1;\n    }\n\
    \    ans.sort_by_key(|&(x, y)| x.0);\n    ans.sort_by_key(|&(x, y)| -x.1);\n \
    \   ans\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7by61nxk.rs:25:27\n   |\n\
    25 |                 if col == x {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |                 if\
    \ col == x.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7by61nxk.rs:35:23\n   |\n35 |\
    \             if col == x {\n   |                       ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |             if col == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0610]: `usize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7by61nxk.rs:44:33\n\
    \   |\n44 |     ans.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp7by61nxk.rs:45:34\n   |\n45 |     ans.sort_by_key(|&(x,\
    \ y)| -x.1);\n   |                                  ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7by61nxk.rs:46:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n46 |     ans\n   |     ^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut row: Vec<(isize, isize)>\
    \ = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n    row.append(0);\n \
    \   for v in lst {\n        row_idx.append(row_idx.last().unwrap() + v.len());\n\
    \    }\n    row_idx.sort_unstable();\n    for idx in row_idx.iter() {\n      \
    \  let mut row_vec: Vec<(isize, isize)> = vec![];\n        for row in lst {\n\
    \            let mut i = idx;\n            for v in row {\n                row_vec.push((row_vec[i\
    \ - 1].0.saturating_sub(v.0)).0);\n                i += v.1;\n            }\n\
    \        }\n        row_vec.sort_unstable();\n        let mut i = 0;\n       \
    \ let mut j = 0;\n        let mut j1 = 0;\n        let mut j2 = 0;\n        while\
    \ i < row_vec.len() && j < row_vec[0].len() {\n            if row_vec[i][0] <\
    \ row_vec[0][0] {\n                i += 1;\n                continue;\n      \
    \      }\n            if row_vec[i][0] > row_vec[0][0] {\n                j +=\
    \ 1;\n                continue;\n            }\n            let mut row_vec1 =\
    \ row_vec.clone();\n            row_vec1.sort_unstable();\n            row_vec1.reverse();\n\
    \            while j1 < row_vec1[j].len() && j2 < row_vec1[j1][0] {\n        \
    \        if row_vec1[j1][0] < row_vec1[j1][0] {\n                    j1 += 1;\n\
    \                    continue;\n                }\n                if row_vec1[j1][0]\
    \ > row_vec1[j1][0] {\n                    j2 += 1;\n                    continue;\n\
    \                }\n                if row_vec1[j1][0] == row_vec1[j1][0] {\n\
    \                    row_vec1[j] = row_vec1[j1].clone();\n                   \
    \ row_vec1[j1] = 0;\n                    j2 += 1;\n                }\n       \
    \         j1 += 1;\n            }\n            row_vec.extend_from_slice(row_vec1[j..].to_vec());\n\
    \            j += j1;\n            j1 -= j2;\n        }\n        for v in row_vec\
    \ {\n            row.append(v);\n        }\n    }\n    row.sort();\n    row\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawu__hs3.rs:22:16\n   |\n\
    22 |     row.append(0);\n   |                ^ expected mutable reference, found\
    \ integer\n   |\n   = note: expected mutable reference `&mut Vec<(isize, isize)>`\n\
    \                           found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpawu__hs3.rs:24:50\n   |\n24 |         row_idx.append(row_idx.last().unwrap()\
    \ + v.len());\n   |                                                  ^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawu__hs3.rs:24:24\n\
    \   |\n24 |         row_idx.append(row_idx.last().unwrap() + v.len());\n   | \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<isize>`,\
    \ found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n\
    \                           found type `isize`\n\nerror[E0277]: cannot add `usize`\
    \ to `&isize`\n  --> /tmp/tmpawu__hs3.rs:24:48\n   |\n24 |         row_idx.append(row_idx.last().unwrap()\
    \ + v.len());\n   |                                                ^ no implementation\
    \ for `&isize + usize`\n   |\n   = help: the trait `Add<usize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: the type `[(isize, isize)]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpawu__hs3.rs:32:31\n   |\n32 |                 row_vec.push((row_vec[i\
    \ - 1].0.saturating_sub(v.0)).0);\n   |                               ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[(isize, isize)]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<i"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut rows = vec![];\n    let\
    \ mut columns = vec![];\n\n    for i in 0..lst.len() {\n        let mut row_iter\
    \ = i.clone();\n        let mut col_iter = 0;\n        loop {\n            if\
    \ col_iter < lst[row_iter].len() {\n                break;\n            } else\
    \ {\n                row_iter.next();\n                col_iter = 0;\n       \
    \     }\n        }\n        let row = row_iter.clone();\n        let col = col_iter.clone();\n\
    \n        row_iter.reset();\n        col_iter.reset();\n        row_iter.next();\n\
    \        col_iter.next();\n        rows.push(row);\n        columns.push(col);\n\
    \    }\n    std::cmp::Ordering::compare_unstable(&rows[rows.len() - 1], &rows[0])\n\
    \        .unwrap()\n        .cmp::Ordering::compare_unstable(&columns[columns.len()\
    \ - 1], &columns[0])\n        .unwrap()\n        .cmp::Ordering::compare_unstable(x,\
    \ &columns[0])\n        .unwrap()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `,`, `::`, or `<`, found `[`\n  -->\
    \ /tmp/tmp4w10f168.rs:47:50\n   |\n47 |         .cmp::Ordering::compare_unstable(&columns[columns.len()\
    \ - 1], &columns[0])\n   |                                                  ^\
    \ expected one of `!`, `(`, `)`, `,`, `::`, or `<`\n\nerror: expected one of `(`,\
    \ `.`, `;`, `?`, `}`, or an operator, found `::`\n  --> /tmp/tmp4w10f168.rs:47:13\n\
    \   |\n47 |         .cmp::Ordering::compare_unstable(&columns[columns.len() -\
    \ 1], &columns[0])\n   |             ^^ expected one of `(`, `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0599]: no method named `next` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp4w10f168.rs:31:26\n   |\n31 |          \
    \       row_iter.next();\n   |                          ^^^^ method not found\
    \ in `usize`\n\nerror[E0599]: no method named `reset` found for type `usize` in\
    \ the current scope\n  --> /tmp/tmp4w10f168.rs:38:18\n   |\n38 |         row_iter.reset();\n\
    \   |                  ^^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `reset` found for type `usize` in the current scope\n  --> /tmp/tmp4w10f168.rs:39:18\n\
    \   |\n39 |         col_iter.reset();\n   |                  ^^^^^ method not\
    \ found in `usize`\n\nerror[E0599]: no method named `next` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmp4w10f168.rs:40:18\n   |\n40 |         row_iter.next();\n\
    \   |                  ^^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `next` found for type `usize` in the current scope\n  --> /tmp/tmp4w10f168.rs:41:18\n\
    \   |\n41 |         col_iter.next();\n   |                  ^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to 7 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ret: Vec<(isize, isize)> = vec![];\n\
    \    let mut last_row = lst[0];\n    for i in 0..(lst.len() - 1) {\n        let\
    \ mut row: Vec<isize> = vec![];\n        last_row.sort_by(|a, b| b.cmp(a));\n\
    \        let mut last_col: isize = 0;\n        last_row.iter().for_each(|&col|\
    \ {\n            let mut col = col;\n            if col > x {\n              \
    \  return;\n            }\n            row.push((last_col + 1, col - 1));\n  \
    \          last_col = col;\n        });\n        if row.len() > 0 {\n        \
    \    ret = ret.into_iter().chain(row).collect();\n        }\n    }\n    ret.sort_by(|a,\
    \ b| {\n        if b.1 < a.1 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            b.1.cmp(&a.1)\n        }\n    });\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0vjid7r.rs:31:22\n   |\n\
    31 |             row.push((last_col + 1, col - 1));\n   |                    \
    \  ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `(isize, isize)`\n\nerror[E0271]: type\
    \ mismatch resolving `<Vec<isize> as IntoIterator>::Item == (isize, isize)`\n\
    \   --> /tmp/tmpl0vjid7r.rs:35:35\n    |\n35  |             ret = ret.into_iter().chain(row).collect();\n\
    \    |                                   ^^^^^ expected tuple, found `isize`\n\
    \    |\n    = note: expected tuple `(isize, isize)`\n                found type\
    \ `isize`\nnote: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<isize>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpl0vjid7r.rs:35:46\n   |\n35 |                ret = ret.into_iter().chain(row).collect();\n\
    \   |                                                 ^^^^^^^ method cannot be\
    \ called on `std::iter::Chain<std::vec::IntoIter<(isize, isize)>, std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = (isize, isize)`\n           which is required by `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<isize>>: Iterator`\n           `std::iter::Chain<std::vec::IntoIter<(isize,\
    \ isize)>, std::vec::IntoIter<isize>>: Iterator`\n           which is required\
    \ by `&mut std::iter::Chain<std::vec::IntoIter<(isize, isize)>, std::vec::IntoIter<isize>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut r = 1;\n    let mut c = 1;\n\n    while r < rows && c < cols {\n\
    \        if lst[r][c] == x {\n            coords.push((r, c));\n            if\
    \ r == rows {\n                break;\n            }\n            r += 1;\n  \
    \          c += 1;\n        } else {\n            c += 1;\n        }\n    }\n\n\
    \    coords.sort();\n    if coords.is_empty() {\n        vec![]\n    } else {\n\
    \        coords.reverse();\n        coords\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxq5g3qp2.rs:41:9\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n41 |         coords\n   |         ^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut it = lst.iter().enumerate().rev();\n\
    \        if it.next().unwrap().0 == x {\n            it.next().unwrap().1\n  \
    \      } else {\n            it.next().unwrap().0\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyv7kumvs.rs:21:36\n   |\n\
    21 |         if it.next().unwrap().0 == x {\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n21 |      \
    \   if it.next().unwrap().0 == x.try_into().unwrap() {\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyv7kumvs.rs:22:13\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n22 |             it.next().unwrap().1\n   |             ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&Vec<isize>`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n           found reference `&Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyv7kumvs.rs:24:13\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n24 |             it.next().unwrap().0\n   |   \
    \          ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n \
    \  = note: expected struct `Vec<(isize, isize)>`\n                found type `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    match lst {\n        vec![] => vec![],\n        vec!vec![vec![],\
    \ vec![], vec![]] => vec![],\n        vec!vec![vec!vec![], vec!vec![], vec!vec![]]\
    \ => vec![],\n        vec!vec![vec!vec!vec![], vec!vec!vec!vec![], vec!vec!vec![]]\
    \ => vec![],\n        vec!vec![vec!vec!vec!vec![], vec!vec!vec!vec!vec![], vec!vec!vec!vec![]]\
    \ => vec![],\n        vec!vec![vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec![],\
    \ vec!vec!vec!vec!vec![]] => vec![],\n        vec!vec![vec!vec!vec!vec!vec!vec![],\
    \ vec!vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec![]] => vec![],\n       \
    \ vec!vec![vec!vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec!vec![]]\
    \ => vec![],\n        vec!vec![vec!vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec!vec![],\
    \ vec!vec!vec!vec!vec!vec!vec![]] => vec![],\n        vec!vec![vec!vec!vec!vec!vec!vec![],\
    \ vec!vec!vec!vec!vec!vec!vec![], vec!vec!vec!vec!vec!vec!vec![]] => vec![],\n\
    \        vec!vec![vec!vec!vec!vec!vec!vec!vec[], vec!vec!vec!vec!vec!vec!vec!vec[],\
    \ vec!vec!vec!vec!vec!vec!vec![]] => vec![],\n        vec!vec![vec!vec!vec!vec!vec!vec!vec[],\
    \ vec!vec!vec!vec!vec!vec!vec!vec[], vec!vec!vec!vec!vec!vec!vec![]] => vec![],\n\
    \        vec!vec![vec!vec!vec\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0fhbgo77.rs:42:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n17 |     let mut res = vec![];\n18 |     match lst {\n \
    \  |               - this delimiter might not be properly closed...\n...\n32 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n42 |\
    \ }\n   |   ^\n\nerror: expected one of `(`, `[`, or `{`, found `vec`\n  --> /tmp/tmp0fhbgo77.rs:20:13\n\
    \   |\n20 |         vec!vec![vec![], vec![], vec![]] => vec![],\n   |        \
    \     ^^^ expected one of `(`, `[`, or `{`\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp0fhbgo77.rs:31:17\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \                                - closing delimiter possibly meant for this\n\
    ...\n31 |         vec!vec![vec!vec!vec\n   |                 ^ unclosed delimiter\n\
    32 | }\n   | ^ mismatched closing delimiter\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmp0fhbgo77.rs:19:9\n   |\n19 |         vec![]\
    \ => vec![],\n   |         ^^^^^^\n   |\n   = note: this error originates in the\
    \ macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0fhbgo77.rs:18:5\n   |\n18 | /\
    \     match lst {\n19 | |         vec![] => vec![],\n20 | |         vec!vec![vec![],\
    \ vec![], vec![]] => vec![],\n21 | |         vec!vec![vec!vec![], vec!vec![],\
    \ vec!vec![]] => vec![],\n...  |\n31 | |         vec!vec![vec!vec!vec\n32 | |\
    \ }\n   | | ^- help: consider using a semicolon here\n   | |_|\n   |   expected\
    \ `()`, found struct `Vec`\n   |\n   = note: expected unit type `()`\n       \
    \          found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0fhbgo77.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = Vec::new();\n    let mut cols = &lst[0];\n    let\
    \ mut row_i = 0;\n    while *cols.len() > x {\n        rows.push(cols.last().unwrap());\n\
    \        row_i += 1;\n        cols = &lst[row_i];\n    }\n    rows.push((row_i,\
    \ x));\n    cols.iter().rev().cloned().collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpm00gufd2.rs:20:11\n\
    \   |\n20 |     while *cols.len() > x {\n   |           ^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm00gufd2.rs:21:19\n   |\n21 |         rows.push(cols.last().unwrap());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^ expected tuple, found `&isize`\n\
    \   |\n   = note:  expected tuple `(isize, isize)`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm00gufd2.rs:25:16\n\
    \   |\n25 |     rows.push((row_i, x));\n   |                ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |     rows.push((row_i.try_into().unwrap(),\
    \ x));\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm00gufd2.rs:26:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n26 |     cols.iter().rev().cloned().collect::<Vec<_>>()\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `isize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = Vec::new();\n    let mut sort_row = sort_row_vec(lst, x);\n\n    let mut\
    \ row_iter = sort_row.iter().cloned();\n    let mut col_iter = row_iter.clone().chain(row_iter.cloned()).filter_map(|(_,\
    \ (_, y))| y).cloned();\n    let mut found_it = false;\n    let mut row = 0;\n\
    \    let mut col = 0;\n    while !col_iter.next().is_none() {\n        if row\
    \ == 0 {\n            let row = col_iter.next().unwrap();\n        }\n       \
    \ if col == 0 {\n            let col = col_iter.next().unwrap();\n        }\n\
    \        found_it = true;\n        res.push((row, col));\n        col -= 1;\n\
    \    }\n    if !found_it {\n        res.push((row, col));\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_row_vec` in this scope\n  -->\
    \ /tmp/tmpxe9acmd4.rs:18:24\n   |\n18 |     let mut sort_row = sort_row_vec(lst,\
    \ x);\n   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut sorted_rows_asc: Vec<isize>\
    \ = vec![];\n    let mut sorted_rows_desc: Vec<isize> = vec![];\n    for i in\
    \ 0..lst.len() {\n        let mut found = false;\n        let mut row: Vec<isize>\
    \ = vec![];\n        let mut j = 0;\n        for y in 0..lst[i].len() {\n    \
    \        if y == x {\n                found = true;\n                row.push(i);\n\
    \                row.push(y);\n            }\n            if !found {\n      \
    \          j += 1;\n            }\n        }\n        rows.push(row);\n      \
    \  if found {\n            if j == 0 {\n                sorted_rows_asc.push(i);\n\
    \            } else {\n                sorted_rows_desc.append(i);\n         \
    \   }\n        }\n    }\n    rows\n        .iter()\n        .filter(|x| x.len()\
    \ == 2)\n        .sort_by(|x, y| x.1.cmp(&y.1))\n        .map(|x| x.clone())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyyh3878p.rs:25:21\n   |\n\
    25 |             if y == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |             if y == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyyh3878p.rs:27:26\n   |\n27 |                 row.push(i);\n\
    \   |                          ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |                 row.push(i.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyyh3878p.rs:28:26\n   |\n28 |                 row.push(y);\n  \
    \ |                          ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n28 |                 row.push(y.try_into().unwrap());\n   |     \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyyh3878p.rs:34:19\n   |\n34 |         rows.push(row);\n   |   \
    \                ^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected\
    \ tuple `(isize, isize)`\n             found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyyh3878p.rs:37:38\n   |\n37 |              \
    \   sorted_rows_asc.push(i);\n   |                                      ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n37 |                 sorted_rows_asc.push(i.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyyh3878p.rs:39:41\n   |\n39 |              \
    \   sorted_rows_desc.append(i);\n   |                                        \
    \ ^ expected `&mut Vec<isize>`, found `usize`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<isize>`\n          "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_row = vec![];\n    let mut sorted_col = vec![];\n    let mut row_idx\
    \ = -1;\n    let mut col_idx = -1;\n    loop {\n        let mut row_pos = 0;\n\
    \        let mut col_pos = 0;\n        for v in lst.iter() {\n            if row_idx\
    \ >= v.len() {\n                break;\n            }\n            if row_pos\
    \ > row_idx {\n                row_pos = row_idx;\n                row_idx = v.len();\n\
    \            }\n            let row_pos = v.iter().position(|&x| x == row_idx);\n\
    \            if row_pos < 0 {\n                continue;\n            }\n    \
    \        for c1 in v.iter().rev() {\n                let col_pos = c1.iter().position(|&x|\
    \ x == col_idx);\n                if col_pos < 0 {\n                    continue;\n\
    \                }\n                let y = (row_pos + col_pos) as isize;\n  \
    \              sorted_row.push((row_idx, y));\n                sorted_col.push((y,\
    \ col_idx));\n                col_idx += 1;\n            }\n            col_idx\
    \ = 0;\n        }\n        if row_pos == v.len() {\n            break;\n     \
    \   }\n    }\n    sorted_row.sort_by(|&(a, b)| a[0].cmp(b[0]));\n    sorted_col.sort_by(|&(a,\
    \ b)| a[1].cmp(b[1]));\n    sorted_row\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmpoj_a2nub.rs:48:23\n\
    \   |\n48 |         if row_pos == v.len() {\n   |                       ^ help:\
    \ a local variable with a similar name exists: `x`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpoj_a2nub.rs:19:23\n   |\n\
    19 |     let mut row_idx = -1;\n   |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoj_a2nub.rs:32:55\n   |\n32 |             let row_pos = v.iter().position(|&x|\
    \ x == row_idx);\n   |                                                       ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n32 |           \
    \  let row_pos = v.iter().position(|&x| x == row_idx.try_into().unwrap());\n \
    \  |                                                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoj_a2nub.rs:33:26\n   |\n33 |\
    \             if row_pos < 0 {\n   |                          ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n33 |             if row_pos < Some(0) {\n   |                         \
    \ +++++ +\n\nerror[E0599]: no method named `iter` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpoj_a2nub.rs:37:34\n   |\n37 |          \
    \       let col_pos = c1.iter().position(|&x| x == col_idx);\n   |           \
    \                       ^^^^ method not found in `&isize`\n\nerror[E0369]: cannot\
    \ add `_` to `Option<usize>`\n  --> /tmp/tmpoj_a2nub.rs:41:34\n   |\n41 |    \
    \             let y = (row_pos + col_pos) as isize;\n   |                    \
    \      ------- ^ ------- _\n   |                          |\n   |"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut curr_row = vec![];\n    for i in 0..lst.len()\
    \ {\n        if i as usize != x {\n            curr_row.clear();\n           \
    \ result.push(curr_row.clone());\n        } else {\n            curr_row.push((i,\
    \ lst[i][0]));\n        }\n    }\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result.sort_by(|a, b| b.2.cmp(&a.2));\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpznacxh8x.rs:20:26\n   |\n\
    20 |         if i as usize != x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if i as usize != x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0609]: no field\
    \ `1` on type `&Vec<(usize, isize)>`\n  --> /tmp/tmpznacxh8x.rs:27:29\n   |\n\
    27 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                         \
    \    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(usize, isize)>`\n\
    \  --> /tmp/tmpznacxh8x.rs:27:38\n   |\n27 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \   |                                      ^ unknown field\n\nerror[E0609]: no\
    \ field `2` on type `&Vec<(usize, isize)>`\n  --> /tmp/tmpznacxh8x.rs:28:29\n\
    \   |\n28 |     result.sort_by(|a, b| b.2.cmp(&a.2));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `2` on type `&Vec<(usize,\
    \ isize)>`\n  --> /tmp/tmpznacxh8x.rs:28:38\n   |\n28 |     result.sort_by(|a,\
    \ b| b.2.cmp(&a.2));\n   |                                      ^ unknown field\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpznacxh8x.rs:29:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     result\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, isize)>>`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = vec![];\n    for row_ in lst {\n        if row_[0] == x {\n          \
    \  row.push(row_.iter().cloned().collect::<Vec<_>>());\n        }\n    }\n   \
    \ row.sort_by_key(|row| row.iter().enumerate().map(|(j, val)| val).collect::<Vec<_>>());\n\
    \    row.iter()\n        .enumerate()\n        .map(|(i, col)| {\n           \
    \ (\n                i as usize,\n                col.iter()\n               \
    \     .enumerate()\n                    .map(|(j, val)| val as usize)\n      \
    \              .collect::<Vec<_>>()\n                    .sort().reverse()\n \
    \           )\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpveszx235.rs:33:29\n   |\n33 |                 \
    \    .sort().reverse()\n   |                             ^^^^^^^ method not found\
    \ in `()`\n\nerror[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpveszx235.rs:31:37\n\
    \   |\n31 |                     .map(|(j, val)| val as usize)\n   |          \
    \                           ---^^^^^^^^^\n   |                               \
    \      |\n   |                                     cannot cast `&isize` as `usize`\n\
    \   |                                     help: dereference the expression: `*val`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0606.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![(0, 0)];\n    let mut row = 0;\n    let mut col = 0;\n    while row\
    \ < lst.len() {\n        if col != x {\n            res.push((row, col));\n  \
    \          col = 0;\n        }\n        col += 1\n            if lst[row][col]\
    \ == x;\n        row += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpnaw_esrg.rs:25:17\n\
    \   |\n25 |         col += 1\n   |                 ^ help: add `;` here\n26 |\
    \             if lst[row][col] == x;\n   |             -- unexpected token\n\n\
    error: expected `{`, found `;`\n  --> /tmp/tmpnaw_esrg.rs:26:34\n   |\n26 |  \
    \           if lst[row][col] == x;\n   |             --                   ^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnaw_esrg.rs:29:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     res\n   |     ^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ _)>`\n              found struct `Vec<(usize, _)>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    lst.sort_by_key(|x| *x.clone());\n    lst.sort_by_key(|y|\
    \ *y.clone(), |x, y| -cmp(&y[1], &x[1]));\n    lst.iter().enumerate().map(|(i,\
    \ v)| (i, *v.clone())).skip(x).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cmp` in this scope\n  --> /tmp/tmpffho6914.rs:19:45\n\
    \   |\n19 |     lst.sort_by_key(|y| *y.clone(), |x, y| -cmp(&y[1], &x[1]));\n\
    \   |                                             ^^^ not found in this scope\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpffho6914.rs:18:21\n    |\n18  |     lst.sort_by_key(|x|\
    \ *x.clone());\n    |         ----------- ^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |         |\n    |         required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `[isize]`\n\
    note: required by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpffho6914.rs:19:9\n\
    \    |\n19  |     lst.sort_by_key(|y| *y.clone(), |x, y| -cmp(&y[1], &x[1]));\n\
    \    |         ^^^^^^^^^^^ --------------  ------------------------- supplied\
    \ 2 arguments\n    |         |\n    |         expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n   --> /tmp/tmpffho6914.rs:20:32\n\
    \    |\n20  |     lst.iter().enumerate().map(|(i, v)| (i, *v.clone())).skip(x).collect()\n\
    \    |                            --- ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n    |                            |\n    |      \
    \                      required by a bound introduced by this call\n    |\n  \
    \  = help: within `(usize, [isize])`, the trait `Sized` is not implemented for\
    \ `[isize]`\n    = note: required because it appears within the type `(usize,\
    \ [isize])`\nnote: required by a bound in `map`\n\nerror[E0599]: the method `skip`\
    \ exists for struct `Map<Enumerate<std::slice::Iter<'_, Vec<isize>>>, [closure@/tmp/tmpffho6914.rs:20:32:\
    \ 20:56]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpffho6914.rs:20:58\n\
    \   |\n20 |       lst.iter().enumerate().map(|(i, v)| (i, *v.clone())).skip(x).collect()\n\
    \   |                                          "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = 0;\n    for row in lst {\n        if row[x]\
    \ < row[0] {\n            coords.clear();\n            rows = 0;\n           \
    \ coords.extend((row as Vec<isize>).iter().cloned().collect::<Vec<_>>());\n  \
    \          break;\n        }\n        rows += 1;\n        coords.extend((row as\
    \ Vec<isize>).iter().cloned().rev().collect::<Vec<_>>());\n    }\n    coords.sort_by(|a,\
    \ b| b.cmp(a));\n    coords.sort_by(|a, b| b.cmp(b.iter().cloned().rev().collect()));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmptabhw03n.rs:20:12\n\
    \   |\n20 |         if row[x] < row[0] {\n   |            ^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `iter` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmptabhw03n.rs:30:35\n\
    \   |\n30 |     coords.sort_by(|a, b| b.cmp(b.iter().cloned().rev().collect()));\n\
    \   |                                   ^^^^ method not found in `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptabhw03n.rs:31:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n31 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found `isize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ x = x;\n    let mut res = vec![];\n    for vec in lst.iter() {\n        let\
    \ mut y = vec[0];\n        for v in vec.iter().rev() {\n            if v == x\
    \ {\n                y += 1;\n            }\n        }\n        res.push((x, y));\n\
    \        if y > 0 {\n            x = y;\n        }\n    }\n    sort_rows_cols(&mut\
    \ res);\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows_cols` in this scope\n  -->\
    \ /tmp/tmp7pll7z5o.rs:31:5\n   |\n31 |     sort_rows_cols(&mut res);\n   |   \
    \  ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp7pll7z5o.rs:22:18\n   |\n22 |             if v ==\
    \ x {\n   |                  ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    if lst.is_empty() {\n        vec![]\n    } else {\n\
    \        lst.sort_by_key(|v| {\n            v.iter().map(|i| i as isize)\n   \
    \     });\n        find_row(\n            vec![(lst.iter().map(|v| v.len() - 1).max(),\
    \ x)],\n            &lst,\n            vec![(lst.iter().map(|v| v.len() - 1).min(),\
    \ x)]\n        )\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_row` in this scope\n  --> /tmp/tmpodh7zf7a.rs:24:9\n\
    \   |\n24 |         find_row(\n   |         ^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpodh7zf7a.rs:22:26:\
    \ 22:40]>: Ord` is not satisfied\n   --> /tmp/tmpodh7zf7a.rs:21:13\n    |\n21\
    \  |         lst.sort_by_key(|v| {\n    |             ^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpodh7zf7a.rs:22:26:\
    \ 22:40]>`\n    |\nnote: required by a bound in `slice::<impl [T]>::sort_by_key`\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpodh7zf7a.rs:22:30\n\
    \   |\n22 |             v.iter().map(|i| i as isize)\n   |                   \
    \           -^^^^^^^^^\n   |                              |\n   |            \
    \                  cannot cast `&isize` as `isize`\n   |                     \
    \         help: dereference the expression: `*i`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425, E0606.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let mut rows = lst.iter().map(|row|\
    \ row.to_owned()).collect::<Vec<_>>();\n    rows = rows[..rows.len() - 1].sort();\n\
    \    let mut cols = vec![0; rows[rows.len() - 1].unwrap().len()];\n\n    for (a,\
    \ b) in rows[rows.len() - 1].iter().zip(cols.iter().rev()) {\n        if *b >\
    \ x {\n            break;\n        }\n        *a = *b;\n    }\n\n    vec![\n \
    \       for row in 0..rows[rows.len() - 1].unwrap().len() {\n            let x\
    \ = rows[row].iter().map(|&i| i).nth(x).unwrap();\n            vec![(rows[row].iter().enumerate().skip(x).map(|(_,\
    \ c), i| i as isize), x)\n        }\n    ]\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpq_286lzy.rs:35:17\n\
    \   |\n33 |         for row in 0..rows[rows.len() - 1].unwrap().len() {\n   |\
    \                                                           - closing delimiter\
    \ possibly meant for this\n34 |             let x = rows[row].iter().map(|&i|\
    \ i).nth(x).unwrap();\n35 |             vec![(rows[row].iter().enumerate().skip(x).map(|(_,\
    \ c), i| i as isize), x)\n   |                 ^ unclosed delimiter\n36 |    \
    \     }\n   |         ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq_286lzy.rs:22:12\n   |\n21 |     let mut rows = lst.iter().map(|row|\
    \ row.to_owned()).collect::<Vec<_>>();\n   |                    --------------------------------------------------------\
    \ expected due to this value\n22 |     rows = rows[..rows.len() - 1].sort();\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n           found unit type\
    \ `()`\n\nerror[E0599]: no method named `unwrap` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpq_286lzy.rs:23:49\n   |\n23 |     let mut\
    \ cols = vec![0; rows[rows.len() - 1].unwrap().len()];\n   |                 \
    \                                ^^^^^^ help: there is an associated function\
    \ with a similar name: `swap`\n\nerror[E0599]: no method named `unwrap` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpq_286lzy.rs:33:44\n\
    \   |\n33 |         for row in 0..rows[rows.len() - 1].unwrap().len() {\n   |\
    \                                            ^^^^^^ help: there is an associated\
    \ function with a similar name: `swap`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpq_286lzy.rs:34:54\n   |\n34 |             let x = rows[row].iter().map(|&i|\
    \ i).nth(x).unwrap();\n   |                                                  \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n34 |      \
    \       let x = rows[row].iter().map(|&i| i).nth(x.try_into().unwrap()).unwrap();\n\
    \   |"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.into_iter().enumerate().map(|(i, v)| {\n        v.enumerate().map(|(i,\
    \ v)| {\n            ((i as usize + x.to_usize() as usize).abs() as usize, i as\
    \ isize)\n        })\n    }).collect::<Vec<Vec<(isize, isize)>>>();\n    lst.sort_by_key(|x|\
    \ x.0);\n    lst.sort_by_key(|x| x.1, |b| b.1.cmp(&b.0));\n    lst\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpwqqzpcyo.rs:18:11\n\
    \    |\n18  |           v.enumerate().map(|(i, v)| {\n    |             ^^^^^^^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: no\
    \ method named `to_usize` found for type `isize` in the current scope\n  --> /tmp/tmpwqqzpcyo.rs:19:30\n\
    \   |\n19 |             ((i as usize + x.to_usize() as usize).abs() as usize,\
    \ i as isize)\n   |                              ^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `abs` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpwqqzpcyo.rs:19:51\n   |\n19 |             ((i as\
    \ usize + x.to_usize() as usize).abs() as usize, i as isize)\n   |           \
    \                                        ^^^ method not found in `usize`\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(isize, isize)>`\n  --> /tmp/tmpwqqzpcyo.rs:22:27\n\
    \   |\n22 |     lst.sort_by_key(|x| x.0);\n   |                           ^ unknown\
    \ field\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpwqqzpcyo.rs:23:9\n    |\n23  |     lst.sort_by_key(|x| x.1, |b|\
    \ b.1.cmp(&b.0));\n    |         ^^^^^^^^^^^ -------  ----------------- supplied\
    \ 2 arguments\n    |         |\n    |         expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwqqzpcyo.rs:24:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n24 |     lst\n   |     ^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<Vec<(isize, isize)>>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E006"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // Sort\
    \ coordinates by rows in ascending order.\n    let sorted = lst.iter().cloned().sort_by(|a,\
    \ b| a.iter().cmp(b.iter()).reverse()).collect();\n    // Sort coordinates within\
    \ each row by columns in descending order.\n    let sorted = sorted.into_iter().map(|row|\
    \ {\n        row.iter().cloned().sort_by(|a, b| b.cmp(a).reverse()).collect()\n\
    \    }).collect();\n    // Convert coordinates to tuples.\n    let sorted = sorted.iter().cloned().map(|row|\
    \ {\n        row.iter().cloned().enumerate().map(|(index, item)| {\n         \
    \   index, item\n        }).collect()\n    }).collect();\n    // Return sorted\
    \ coordinates.\n    sorted[x]\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this is a block expression, not an array\n  --> /tmp/tmpqudf918_.rs:25:61\n\
    \   |\n25 |           row.iter().cloned().enumerate().map(|(index, item)| {\n\
    \   |  _____________________________________________________________^\n26 | |\
    \             index, item\n27 | |         }).collect()\n   | |_________^\n   |\n\
    help: to make an array, use square brackets instead of curly braces\n   |\n25\
    \ ~         row.iter().cloned().enumerate().map(|(index, item)| [\n26 |      \
    \       index, item\n27 ~         ]).collect()\n   |\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Cloned` in the current scope\n  --> /tmp/tmpqudf918_.rs:18:38\n\
    \   |\n18 |     let sorted = lst.iter().cloned().sort_by(|a, b| a.iter().cmp(b.iter()).reverse()).collect();\n\
    \   |                                      ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ Vec<isize>>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.to_vec();\n    lst.sort_by_key(|i| i.iter().rev().collect::<Vec<_>>());\n\
    \    lst.sort_by_key(|j| j.iter().rev().collect::<Vec<_>>());\n    let mut i =\
    \ x;\n    let mut row = Vec::new();\n    while i < lst.len() {\n        let mut\
    \ j = i;\n        while j > 0 && lst[j].len() > 0 {\n            let mut k = j;\n\
    \            while k > 0 && lst[k].len() > 0 {\n                let x = lst[j][k];\n\
    \                if x == i {\n                    break;\n                }\n\
    \                k -= 1;\n            }\n            j -= 1;\n        }\n    \
    \    row.push((i, j));\n        i += 1;\n    }\n    row.reverse();\n    row\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp641q1jkn.rs:22:15\n   |\n\
    22 |     while i < lst.len() {\n   |               ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |     while i < lst.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmp641q1jkn.rs:24:24\n\
    \   |\n24 |         while j > 0 && lst[j].len() > 0 {\n   |                  \
    \      ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\
    \nerror[E0277]: the type `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmp641q1jkn.rs:26:28\n\
    \   |\n26 |             while k > 0 && lst[k].len() > 0 {\n   |              \
    \              ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[Vec<isize>]>` is not implemented for\
    \ `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<isize>>`\n\nerror[E0277]: the type `[Vec<isize>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp641q1jkn.rs:27:25\n   |\n27 |                 let\
    \ x = lst[j][k];\n   |                         ^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<isize>]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<Vec<isize>>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = vec![];\n    for y in lst.iter().rev().skip(x).rev() {\n        row.push((y.iter().sum(),\
    \ y.len() - y.iter().rev().skip(x).rev().sum()));\n    }\n    row.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    row.sort_by(|a, b| b.1.cmp(&a.1));\n    row\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqicpt7q8.rs:18:36\n   |\n\
    18 |     for y in lst.iter().rev().skip(x).rev() {\n   |                     \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    18 |     for y in lst.iter().rev().skip(x.try_into().unwrap()).rev() {\n   | \
    \                                    ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqicpt7q8.rs:19:65\n   |\n19 |         row.push((y.iter().sum(),\
    \ y.len() - y.iter().rev().skip(x).rev().sum()));\n   |                      \
    \                                           ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         row.push((y.iter().sum(), y.len() - y.iter().rev().skip(x.try_into().unwrap()).rev().sum()));\n\
    \   |                                                                  ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    if lst.is_empty() {\n        return res;\n    }\n    let\
    \ mut rows = vec![];\n    let mut cols = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        if i == 0 {\n            cols = row.iter().enumerate().collect::<Vec<_>>();\n\
    \            cols = cols.sort_by_key(|&(_, col)| col.cmp(&x));\n            cols\
    \ = cols.reverse();\n            for (j, col) in cols.iter().enumerate() {\n \
    \               rows.push((i, j));\n            }\n        } else {\n        \
    \    cols = row.iter().enumerate().collect::<Vec<_>>();\n            cols = cols.sort_by_key(|&(_,\
    \ col)| col.cmp(&x));\n            cols = cols.reverse();\n            for (j,\
    \ col) in cols.iter().enumerate() {\n                let row = i as isize;\n \
    \               let col = j as isize;\n                let xx = x + 1;\n     \
    \           if col.cmp(&xx) > 0 {\n                    let y = j;\n          \
    \          if cols.len() == 1 && cols[0] == (col, xx) {\n                    \
    \    res.push((row, y));\n                    } else {\n                     \
    \   res.push((row, col));\n                    }\n                }\n        \
    \    }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvtd7d6q.rs:26:20\n   |\n\
    22 |     let mut cols = vec![];\n   |                    ------ expected due to\
    \ this value\n...\n26 |             cols = cols.sort_by_key(|&(_, col)| col.cmp(&x));\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(usize, &isize)>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvtd7d6q.rs:27:20\n\
    \   |\n22 |     let mut cols = vec![];\n   |                    ------ expected\
    \ due to this value\n...\n27 |             cols = cols.reverse();\n   |      \
    \              ^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<(usize, &isize)>`\n           found unit type `()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwvtd7d6q.rs:33:20\n   |\n22 |  \
    \   let mut cols = vec![];\n   |                    ------ expected due to this\
    \ value\n...\n33 |             cols = cols.sort_by_key(|&(_, col)| col.cmp(&x));\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(usize, &isize)>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvtd7d6q.rs:34:20\n\
    \   |\n22 |     let mut cols = vec![];\n   |                    ------ expected\
    \ due to this value\n...\n34 |             cols = cols.reverse();\n   |      \
    \              ^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<(usize, &isize)>`\n           found unit type `()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwvtd7d6q.rs:39:35\n   |\n39 |  \
    \               if col.cmp(&xx) > 0 {\n   |                                  \
    \ ^ expected enum `std::cmp::Ordering`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwvtd7d6q.rs:41:55\n   |\n41 |                     if cols.len()\
    \ == 1 && cols[0] == (col, xx) {\n   |                                       \
    \                ^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` a"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    vec.sort_by(|a,\
    \ b| cmp::cmp(&a[0 * 2], &b[0 * 2]))\n        .sort_by(|a, b| cmp::cmp(&a[1 *\
    \ 2], &b[1 * 2]))\n        .iter()\n        .map(|y| (x.to_owned(), y))\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpnhguco85.rs:17:24\n   |\n17 |     vec.sort_by(|a, b| cmp::cmp(&a[0\
    \ * 2], &b[0 * 2]))\n   |                        ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `cmp`\n  --> /tmp/tmpnhguco85.rs:18:25\n   |\n18 |         .sort_by(|a,\
    \ b| cmp::cmp(&a[1 * 2], &b[1 * 2]))\n   |                         ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror[E0423]: expected value, found macro\
    \ `vec`\n  --> /tmp/tmpnhguco85.rs:17:5\n   |\n17 |     vec.sort_by(|a, b| cmp::cmp(&a[0\
    \ * 2], &b[0 * 2]))\n   |     ^^^ not a value\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = Vec::new();\n    for row in lst {\n        let mut cur = row.clone();\n\
    \        debug_assert!(row.len() == x);\n        let mut pos = x;\n        while\
    \ !cur.iter().take(pos).is_empty() {\n            pos += 1;\n        }\n     \
    \   ret.push((pos, cur.iter().rposition(|&x| x == x) - pos));\n    }\n    ret.sort_by(|a,\
    \ b| b - a);\n    ret.sort_by_key(|&(_, k)| k.cmp(&x));\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7fjx4bzw.rs:20:36\n   |\n\
    20 |         debug_assert!(row.len() == x);\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n20 |      \
    \   debug_assert!(row.len() == x.try_into().unwrap());\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7fjx4bzw.rs:22:32\n   |\n22 |         while !cur.iter().take(pos).is_empty()\
    \ {\n   |                                ^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         while !cur.iter().take(pos.try_into().unwrap()).is_empty()\
    \ {\n   |                                   ++++++++++++++++++++\n\nerror[E0658]:\
    \ use of unstable library feature 'exact_size_is_empty'\n  --> /tmp/tmp7fjx4bzw.rs:22:37\n\
    \   |\n22 |         while !cur.iter().take(pos).is_empty() {\n   |           \
    \                          ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0369]: cannot subtract `isize` from `Option<usize>`\n\
    \  --> /tmp/tmp7fjx4bzw.rs:25:58\n   |\n25 |         ret.push((pos, cur.iter().rposition(|&x|\
    \ x == x) - pos));\n   |                        ---------------------------------\
    \ ^ --- isize\n   |                        |\n   |                        Option<usize>\n\
    \nerror[E0277]: cannot subtract `&(_, _)` from `&(_, _)`\n  --> /tmp/tmp7fjx4bzw.rs:27:26\n\
    \   |\n27 |     ret.sort_by(|a, b| b - a);\n   |                          ^ no\
    \ implementation for `&(_, _) - &(_, _)`\n   |\n   = help: the trait `Sub<&(_,\
    \ _)>` is not implemented for `&(_, _)`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0369, E0658.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut row: Vec<(isize, isize)>\
    \ = vec![];\n    for i in 0..lst.len() {\n        if lst[i][0] == x {\n      \
    \      row.push((i, lst[i][1]));\n        }\n    }\n    row.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    row.sort_by(|a, b| b.2.cmp(&a.2));\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfzg_oh60.rs:23:23\n   |\n\
    23 |             row.push((i, lst[i][1]));\n   |                       ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |             row.push((i.try_into().unwrap(),\
    \ lst[i][1]));\n   |                        ++++++++++++++++++++\n\nerror[E0609]:\
    \ no field `2` on type `&(isize, isize)`\n  --> /tmp/tmpfzg_oh60.rs:27:26\n  \
    \ |\n27 |     row.sort_by(|a, b| b.2.cmp(&a.2));\n   |                       \
    \   ^\n\nerror[E0609]: no field `2` on type `&(isize, isize)`\n  --> /tmp/tmpfzg_oh60.rs:27:35\n\
    \   |\n27 |     row.sort_by(|a, b| b.2.cmp(&a.2));\n   |                     \
    \              ^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut y = x;\n    let mut result = vec![];\n    while y > 0\
    \ {\n        row = row * 2 + 1;\n        let mut last_x = x;\n        let mut\
    \ last_y = y;\n        if row >= lst.len() {\n            return result;\n   \
    \     }\n        // find the element at position row + last_y\n        let el\
    \ = &lst[row][last_y];\n        if el < last_x {\n            result.push((el,\
    \ 0));\n        } else {\n            // shift last_x down\n            last_x\
    \ = last_x - el;\n            last_y = 0;\n            result.push((last_x, last_y));\n\
    \        }\n        y = y - 1;\n    }\n    // sort by column in reverse order\n\
    \    result.sort_by_key(|&(x, _)| -x);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpr9dtr43j.rs:28:19\n\
    \   |\n28 |         let el = &lst[row][last_y];\n   |                   ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ can't compare `&_` with `isize`\n  --> /tmp/tmpr9dtr43j.rs:29:15\n   |\n29 |\
    \         if el < last_x {\n   |               ^ no implementation for `&_ < isize`\
    \ and `&_ > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr9dtr43j.rs:30:26\n\
    \   |\n30 |             result.push((el, 0));\n   |                          ^^\
    \ expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\nhelp: consider dereferencing the borrow\n  \
    \ |\n30 |             result.push((*el, 0));\n   |                          +\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 || x.is_odd() {\n        return vec![];\n    }\n    let mut row: Vec<(isize,\
    \ isize)> = vec![];\n    let mut col_coords = vec![];\n    let mut col_coords_reversed\
    \ = vec![];\n    let mut col_coords_reversed_len = 0.0;\n    let mut col_coords_reversed_idx\
    \ = 0.0;\n    let mut row_coords = vec![];\n    let mut row_coords_len = 0.0;\n\
    \    let mut row_idx = 0.0;\n    let mut max_val = 0.0;\n    for (i, vec) in lst.iter().enumerate()\
    \ {\n        if vec.len() != col_coords.len() {\n            return vec![];\n\
    \        }\n        if i >= x {\n            break;\n        }\n        col_coords.push(vec[i]);\n\
    \        if i == lst.len() - 1 {\n            if col_coords_reversed_len > 0 {\n\
    \                row_coords_len += col_coords_reversed_len;\n            }\n \
    \           row_coords.push(col_coords.clone());\n        }\n        for (j, item)\
    \ in vec.iter().enumerate() {\n            if j == 0 {\n                let mut\
    \ new_coord = col_coords.clone();\n                new_coord.swap(j, i);\n   \
    \             col_coords_reversed.push(new_coord);\n                col_coords_reversed_len\
    \ += 1;\n                col_coords_reversed_idx += 1;\n            }\n      \
    \      max_val = std::cmp::max(max_val, item);\n        }\n    }\n    row.push(row_coords.clone());\n\
    \    for coord in col_coords_reversed.iter_mut() {\n        coord.1 = coord.1\
    \ - col_coords_reversed_idx;\n    }\n    row.sort_by(|a, b| b.1.cmp_max(&a.1));\n\
    \    max_val += 1;\n    row.extend(vec![(0, max_val)]);\n    row\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_odd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0gv_n8d0.rs:17:28\n   |\n17 |     if lst.len() == 0 ||\
    \ x.is_odd() {\n   |                            ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0gv_n8d0.rs:33:17\n   |\n33 |\
    \         if i >= x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |         if i >= x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0277]: can't compare `{float}`\
    \ with `{integer}`\n  --> /tmp/tmp0gv_n8d0.rs:38:40\n   |\n38 |             if\
    \ col_coords_reversed_len > 0 {\n   |                                        ^\
    \ no implementation for `{float} < {integer}` and `{float} > {integer}`\n   |\n\
    \   = help: the trait `PartialOrd<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gv_n8d0.rs:38:42\n\
    \   |\n38 |             if col_coords_reversed_len > 0 {\n   |               \
    \                           ^ expected floating-point number, found integer\n\n\
    error[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp0gv_n8d0.rs:48:41\n\
    \   |\n48 |                 col_coords_reversed_len += 1;\n   |              \
    \                           ^^ no implementation for `{float} += {integer}`\n\
    \   |\n   = help: the trait `AddAssign<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 2"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ l = lst.len();\n    let mut xs = vec![];\n\n    if x == 0 {\n        vec![]\n\
    \    } else if x == 1 {\n        vec![(0,), (1,), (2,)]\n    } else if x == 2\
    \ {\n        vec![(1,), (0,), (2,)]\n    } else if x == 3 {\n        vec![(1,),\
    \ (2,)]\n    } else if x == 4 {\n        vec![(0,), (1,), (2,), (3,), (4,), (5,),\
    \ (6,)]\n    } else if x == 5 {\n        vec![(0,), (1,), (2,), (3,), (4,), (6,),\
    \ (5,), (4,), (3,), (2,), (1,), (0,), (6,), (5,), (4,), (3,), (2,), (1,), (0,),\
    \ (4,), (3,), (2,), (1,), (0,), (3,), (2,), (1,), (0,), (2,), (1,), (0,)]\n  \
    \  } else if x == 6 {\n        vec![(0,), (1,), (2,), (3,), (4,), (5,), (4,),\
    \ (3,), (2,), (1,), (0,), (6,), (5,), (4,), (3,), (2,), (1,), (0,), (4,), (3,),\
    \ (2,), (1,), (0,), (3,), (2,), (1,), (0,), (2,), (1,), (0,)]\n    }\n\n    while\
    \ l > 0 {\n        l = l - 1;\n        xs.push((xs.last().unwrap().0 as isize));\n\
    \        xs.push((xs.last().unwrap().1 as isize));\n    }\n    xs.reverse();\n\
    \    xs\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpdlcirl88.rs:38:17\n\
    \   |\n38 |         xs.push((xs.last().unwrap().0 as isize));\n   |          \
    \       ^                             ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n38 -         xs.push((xs.last().unwrap().0\
    \ as isize));\n38 +         xs.push(xs.last().unwrap().0 as isize);\n   | \n\n\
    warning: unnecessary parentheses around method argument\n  --> /tmp/tmpdlcirl88.rs:39:17\n\
    \   |\n39 |         xs.push((xs.last().unwrap().1 as isize));\n   |          \
    \       ^                             ^\n   |\nhelp: remove these parentheses\n\
    \   |\n39 -         xs.push((xs.last().unwrap().1 as isize));\n39 +         xs.push(xs.last().unwrap().1\
    \ as isize);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdlcirl88.rs:21:9\n\
    \   |\n20 | /     if x == 0 {\n21 | |         vec![]\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n22 | |     } else if x == 1 {\n23 | |         vec![(0,),\
    \ (1,), (2,)]\n...  |\n33 | |         vec![(0,), (1,), (2,), (3,), (4,), (5,),\
    \ (4,), (3,), (2,), (1,), (0,), (6,), (5,), (4,), (3,), (2,), (1,), (0,), (4,),\
    \ (3,), (2,)...\n34 | |     }\n   | |_____- expected this to be `()`\n   |\n \
    \  = note: expected unit type `()`\n                 found struct `Vec<_>`\n \
    \  = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n34 |     };\n   |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdlcirl88.rs:23:9\n\
    \   |\n22 |       } else if x == 1 {\n   |  ____________-\n23 | |         vec![(0,),\
    \ (1,), (2,)]\n   | |         ^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct\
    \ `Vec`\n24 | |     } else if x == 2 {\n25 | |         vec![(1,), (0,), (2,)]\n\
    ...  |\n33 | |         vec![(0,), (1,), (2,), (3,), (4,), (5,), (4,), (3,), (2,),\
    \ (1,), (0,), (6,), (5,), (4,), (3,), (2,), (1,), (0,), (4,), (3,), (2,)...\n\
    34 | |     }\n   | |     -- help: consider using a semicolon here\n   | |_____|\n\
    \   |       expected this to be `()`\n   |\n   = note: "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ans = Vec::<(isize, isize)>::new();\n\n    for row in lst {\n        for (i,\
    \ ele) in row.iter().enumerate().take(x).rev().cloned().enumerate().take(row.len()\
    \ - x) {\n            ans.push((i, ele));\n        }\n    }\n    ans.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    ans.sort_by_key(|a, b| b.1.cmp(&a.1));\n    ans.reverse();\n\
    \    ans\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdpxg7l52.rs:20:53\n   |\n\
    20 |         for (i, ele) in row.iter().enumerate().take(x).rev().cloned().enumerate().take(row.len()\
    \ - x) {\n   |                                                     ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         for (i, ele)\
    \ in row.iter().enumerate().take(x.try_into().unwrap()).rev().cloned().enumerate().take(row.len()\
    \ - x) {\n   |                                                      ++++++++++++++++++++\n\
    \nerror[E0271]: type mismatch resolving `<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>> as Iterator>::Item == &_`\n    --> /tmp/tmpdpxg7l52.rs:20:62\n   \
    \  |\n20   |         for (i, ele) in row.iter().enumerate().take(x).rev().cloned().enumerate().take(row.len()\
    \ - x) {\n     |                                                             \
    \ ^^^^^^ expected reference, found tuple\n     |\n     = note: expected reference\
    \ `&_`\n                    found tuple `(usize, &isize)`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `enumerate` exists for struct\
    \ `Cloned<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_, isize>>>>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpdpxg7l52.rs:20:71\n   |\n\
    20 |           for (i, ele) in row.iter().enumerate().take(x).rev().cloned().enumerate().take(row.len()\
    \ - x) {\n   |                                                               \
    \          ^^^^^^^^^ method cannot be called on `Cloned<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>>>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>> as Iterator>::Item = &_`\n           which is required by `Cloned<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>>>: Iterator`\n           `Cloned<Rev<std::iter::Take<Enumerate<std::slice::Iter<'_,\
    \ isize>>>>>: Iterator`\n           which is required by `&mut Cloned<Rev<std"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_row = 0;\n    let mut sorted_col = 0;\n    for row in lst.iter() {\n\
    \        sorted_row = if row[0] == x {\n            sorted_row\n        } else\
    \ {\n            sorted_row + 1;\n        };\n        for col in row.iter().rev()\
    \ {\n            sorted_col = if col == x {\n                sorted_col\n    \
    \        } else {\n                sorted_col + 1;\n            };\n         \
    \   yield (sorted_row, sorted_col);\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: yield syntax is experimental\n  --> /tmp/tmpt9xbadpt.rs:31:13\n\
    \   |\n31 |             yield (sorted_row, sorted_col);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #43122 <https://github.com/rust-lang/rust/issues/43122>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt9xbadpt.rs:22:16\n\
    \   |\n22 |           } else {\n   |  ________________^\n23 | |             sorted_row\
    \ + 1;\n   | |                           - help: remove this semicolon\n24 | |\
    \         };\n   | |_________^ expected integer, found `()`\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmpt9xbadpt.rs:26:33\n   |\n26 | \
    \            sorted_col = if col == x {\n   |                                \
    \ ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt9xbadpt.rs:28:20\n   |\n28 |               } else {\n   |  ____________________^\n\
    29 | |                 sorted_col + 1;\n   | |                               -\
    \ help: remove this semicolon\n30 | |             };\n   | |_____________^ expected\
    \ integer, found `()`\n\nerror[E0627]: yield expression outside of generator literal\n\
    \  --> /tmp/tmpt9xbadpt.rs:31:13\n   |\n31 |             yield (sorted_row, sorted_col);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt9xbadpt.rs:19:5\n   |\n16 |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \              ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n19 | /     for row in lst.iter() {\n20 | |         sorted_row = if\
    \ row[0] == x {\n21 | |             sorted_row\n22 | |         } else {\n... \
    \ |\n32 | |         }\n33 | |     }\n   | |_____^ expected st"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = Vec::new();\n    for (i, v) in lst.iter().enumerate() {\n        if\
    \ i == 0 {\n            coords.extend(v);\n        } else {\n            for j\
    \ in 0..v.len() {\n                if v[j] == x {\n                    coords.push((i,\
    \ j));\n                }\n            }\n        }\n    }\n    coords.sort_by_key(|&(_,\
    \ c)| c.0);\n    coords.sort_by_key(|&(_, c)| c.1);\n    coords\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Vec<(usize, usize)>: Extend<&isize>` is\
    \ not satisfied\n  --> /tmp/tmpvsunklhy.rs:20:20\n   |\n20 |             coords.extend(v);\n\
    \   |                    ^^^^^^ the trait `Extend<&isize>` is not implemented\
    \ for `Vec<(usize, usize)>`\n   |\n   = help: the following other types implement\
    \ trait `Extend<A>`:\n             <Vec<T, A> as Extend<&'a T>>\n            \
    \ <Vec<T, A> as Extend<T>>\n\nerror[E0610]: `usize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpvsunklhy.rs:29:36\n   |\n29 |     coords.sort_by_key(|&(_,\
    \ c)| c.0);\n   |                                    ^\n\nerror[E0610]: `usize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpvsunklhy.rs:30:36\n\
    \   |\n30 |     coords.sort_by_key(|&(_, c)| c.1);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvsunklhy.rs:31:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n31 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0610.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row_idx = vec![];\n    let mut col_val = vec![];\n    let mut col_val_idx =\
    \ vec![];\n    let mut row_idx = vec![];\n    let mut col_val = vec![];\n    let\
    \ mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n    let mut col_val\
    \ = vec![];\n    let mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_val = vec![];\n    let mut col_val_idx = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_val = vec![];\n    let mut col_val_idx =\
    \ vec![];\n    let mut row_idx = vec![];\n    let mut col_val = vec![];\n    let\
    \ mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n    let mut col_val\
    \ = vec![];\n    let mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_val = vec![];\n    let mut col_val_idx = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_val = vec![];\n    let mut col_val_idx =\
    \ vec![];\n    let mut row_idx = vec![];\n    let mut col_val = vec![];\n    let\
    \ mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n    let mut col_val\
    \ = vec![];\n    let mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_val = vec![];\n    let mut col_val_idx = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_val = vec![];\n    let mut col_val_idx =\
    \ vec![];\n    let mut row_idx = vec![];\n    let mut col_val = vec![];\n    let\
    \ mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n    let mut col_val\
    \ = vec![];\n    let mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_val = vec![];\n    let mut col_val_idx = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_val = vec![];\n    let mut col_val_idx =\
    \ vec![];\n    let mut row_idx = vec![];\n    let mut col_val = vec![];\n    let\
    \ mut col_val_idx = vec![];\n    let mut row_idx = vec![];\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd4qm5oq7.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut v = vec![];\n    let mut pos =\
    \ vec![];\n    let mut row = vec![];\n    let mut row_pos = 0;\n\n    for e in\
    \ lst {\n        pos = vec![];\n        for (i, e1) in e.iter().enumerate() {\n\
    \            if i == 0 || e1 != x {\n                pos.push(row_pos);\n    \
    \            row_pos += 1;\n            }\n            pos.push(i - 1);\n    \
    \    }\n        row = pos.iter().cloned().collect();\n        row.sort_by_key(|&x|\
    \ -x.0);\n        row_pos = row.len() as isize;\n        v.push(row);\n    }\n\
    \n    let mut cols = vec![];\n    for c in v.iter().cloned().into_iter() {\n \
    \       cols.sort_by_key(|&x| -x.0);\n    }\n    cols.sort_by_key(|&x| -x.0);\n\
    \    cols\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp8lqe04zv.rs:28:29\n\
    \   |\n28 |             if i == 0 || e1 != x {\n   |                         \
    \    ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0610]: `usize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmp8lqe04zv.rs:35:33\n  \
    \ |\n35 |         row.sort_by_key(|&x| -x.0);\n   |                          \
    \       ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8lqe04zv.rs:36:19\n\
    \   |\n23 |     let mut row_pos = 0;\n   |                       - expected due\
    \ to this value\n...\n36 |         row_pos = row.len() as isize;\n   |       \
    \            ^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0610.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = vec![];\n\n    let mut sorted_rows;\n    if lst.len() == 0 || lst[0].len()\
    \ == 0 {\n        // If input is a vector with 1 dimension, an empty vector is\
    \ returned.\n        ret.push((0, 0));\n    } else {\n        sorted_rows = vec![];\n\
    \        let mut row_len = 0;\n\n        // If the vector has more than 1 dimension,\n\
    \        // flatten the vector of vectors into a vector of vectors,\n        //\
    \ and sort them by columns in descending order.\n        for row_col in lst.iter()\
    \ {\n            sorted_rows.push(row_col.iter().map(|v| v as isize));\n     \
    \       row_len += row_col.len();\n        }\n        sorted_rows.sort_by_key(|r|\
    \ r.iter().rev().cloned().collect::<Vec<isize>>());\n        sorted_rows.reverse();\n\
    \n        // If the number of columns is not equal to x,\n        // return an\
    \ empty vector.\n        if row_len != x {\n            return ret;\n        }\n\
    \n        // If the number of columns is the same as the input,\n        // return\
    \ the sorted coordinates.\n        for (x, y) in sorted_rows.iter().zip(&sorted_rows.last().unwrap())\
    \ {\n            ret.push((x as isize, y as isize));\n        }\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49: 31:63]>` in the current scope\n\
    \  --> /tmp/tmp6ptu4c6z.rs:34:39\n   |\n34 |         sorted_rows.sort_by_key(|r|\
    \ r.iter().rev().cloned().collect::<Vec<isize>>());\n   |                    \
    \                   ^^^^ private field, not a method\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6ptu4c6z.rs:39:23\n   |\n39 |         if row_len != x {\n\
    \   |                       ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |         if row_len != x.try_into().unwrap() {\n   |        \
    \                ++++++++++++++++++++\n\nerror[E0277]: `&&Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49: 31:63]>` is not an iterator\n  -->\
    \ /tmp/tmp6ptu4c6z.rs:45:46\n   |\n45 |         for (x, y) in sorted_rows.iter().zip(&sorted_rows.last().unwrap())\
    \ {\n   |                                          --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&&Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49: 31:63]>`\
    \ is not an iterator\n   |                                          |\n   |  \
    \                                        required by a bound introduced by this\
    \ call\n   |\n   = help: the trait `Iterator` is not implemented for `&&Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49: 31:63]>`\n   = help: the trait `Iterator`\
    \ is implemented for `Map<I, F>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&&Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49:\
    \ 31:63]>`\n\nerror[E0277]: `&&Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49:\
    \ 31:63]>` is not an iterator\n  --> /tmp/tmp6ptu4c6z.rs:45:23\n   |\n45 |   \
    \      for (x, y) in sorted_rows.iter().zip(&sorted_rows.last().unwrap()) {\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&&Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp6ptu4c6z.rs:31:49: 31:63]>`\
    \ is not an i"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if !lst.contains(&vec![x])\
    \ {\n        return vec![];\n    }\n    let mut coords: Vec<(isize, isize)> =\
    \ vec![(0, 0)];\n    let mut rows: Vec<isize> = vec![0];\n    for r in lst {\n\
    \        if !r.contains(&vec![x]) {\n            continue;\n        }\n      \
    \  rows.push(r.0);\n        let mut columns: isize = 0;\n        for c in r {\n\
    \            if c > x {\n                break;\n            }\n            columns\
    \ += 1;\n        }\n        coords.push((rows[rows.len() - 1], columns));\n  \
    \  }\n    coords.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut rows = vec![0];\n\
    \    for c in coords {\n        rows.push(c[0]);\n    }\n    coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    for c in coords {\n        coords.insert((c[0] + 1,\
    \ c[1]), c[0]);\n    }\n    return coords\n        .iter()\n        .map(|c| (rows[c[0]],\
    \ rows[c[0] + 1]))\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcwur7dhv.rs:23:24\n   |\n\
    23 |         if !r.contains(&vec![x]) {\n   |                        ^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&Vec<isize>`\n\nerror[E0609]: no field `0` on\
    \ type `Vec<isize>`\n  --> /tmp/tmpcwur7dhv.rs:26:21\n   |\n26 |         rows.push(r.0);\n\
    \   |                     ^ unknown field\n\nerror[E0608]: cannot index into a\
    \ value of type `(isize, isize)`\n  --> /tmp/tmpcwur7dhv.rs:39:19\n   |\n39 |\
    \         rows.push(c[0]);\n   |                   ^^^^ help: to access tuple\
    \ elements, use: `c.0`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ isize)`\n  --> /tmp/tmpcwur7dhv.rs:43:24\n   |\n43 |         coords.insert((c[0]\
    \ + 1, c[1]), c[0]);\n   |                        ^^^^ help: to access tuple elements,\
    \ use: `c.0`\n\nerror[E0608]: cannot index into a value of type `(isize, isize)`\n\
    \  --> /tmp/tmpcwur7dhv.rs:43:34\n   |\n43 |         coords.insert((c[0] + 1,\
    \ c[1]), c[0]);\n   |                                  ^^^^ help: to access tuple\
    \ elements, use: `c.1`\n\nerror[E0608]: cannot index into a value of type `(isize,\
    \ isize)`\n  --> /tmp/tmpcwur7dhv.rs:43:41\n   |\n43 |         coords.insert((c[0]\
    \ + 1, c[1]), c[0]);\n   |                                         ^^^^ help:\
    \ to access tuple elements, use: `c.0`\n\nerror[E0608]: cannot index into a value\
    \ of type `&(isize, isize)`\n  --> /tmp/tmpcwur7dhv.rs:47:24\n   |\n47 |     \
    \    .map(|c| (rows[c[0]], rows[c[0] + 1]))\n   |                        ^^^^\n\
    \nerror[E0608]: cannot index into a value of type `&(isize, isize)`\n  --> /tmp/tmpcwur7dhv.rs:47:36\n\
    \   |\n47 |         .map(|c| (rows[c[0]], rows[c[0] + 1]))\n   |             \
    \                       ^^^^\n\nerror: aborting due to 8 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0608, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rev_lst = lst.iter().rev();\n    let mut current_row = vec![];\n    let mut\
    \ current_row_reverse = vec![];\n    for r in &mut rev_lst {\n        if *r ==\
    \ x {\n            current_row.push(0);\n            current_row_reverse.push(0);\n\
    \        } else {\n            current_row.push(*r);\n            current_row_reverse.push(*r.reverse());\n\
    \        }\n    }\n    current_row_reverse.reverse();\n    current_row.extend(rev_lst);\n\
    \    current_row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<isize>` with `isize`\n  --> /tmp/tmpfqhnwayv.rs:21:15\n\
    \   |\n21 |         if *r == x {\n   |               ^^ no implementation for\
    \ `Vec<isize> == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfqhnwayv.rs:25:30\n   |\n25 |             current_row.push(*r);\n\
    \   |                              ^^ expected integer, found struct `Vec`\n \
    \  |\n   = note: expected type `{integer}`\n            found struct `Vec<isize>`\n\
    \nerror[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpfqhnwayv.rs:26:38\n\
    \   |\n26 |             current_row_reverse.push(*r.reverse());\n   |        \
    \                              ^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `Vec<{integer}>:\
    \ Extend<&Vec<isize>>` is not satisfied\n  --> /tmp/tmpfqhnwayv.rs:30:17\n   |\n\
    30 |     current_row.extend(rev_lst);\n   |                 ^^^^^^ the trait `Extend<&Vec<isize>>`\
    \ is not implemented for `Vec<{integer}>`\n   |\n   = help: the following other\
    \ types implement trait `Extend<A>`:\n             <Vec<T, A> as Extend<&'a T>>\n\
    \             <Vec<T, A> as Extend<T>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfqhnwayv.rs:31:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n31 |     current_row\n   |     ^^^^^^^^^^^ expected tuple, found integer\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<{integer}>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0614.\nFor more informatio"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst\n\
    \        .iter()\n        .map(|row| row.iter().enumerate().map(|(i, elem)| if\
    \ i == x { Some((i, *elem)) } else { None }))\n        .flatten()\n        .sort_by(|a,\
    \ b| b.1.cmp(b.2))\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgqcb75s1.rs:19:67\n   |\n\
    19 |         .map(|row| row.iter().enumerate().map(|(i, elem)| if i == x { Some((i,\
    \ *elem)) } else { None }))\n   |                                            \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n19 |         .map(|row| row.iter().enumerate().map(|(i, elem)| if i ==\
    \ x.try_into().unwrap() { Some((i, *elem)) } else { None }))\n   |           \
    \                                                         ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `sort_by` found for struct `Flatten` in the current\
    \ scope\n  --> /tmp/tmpgqcb75s1.rs:21:10\n   |\n21 |         .sort_by(|a, b| b.1.cmp(b.2))\n\
    \   |          ^^^^^^^ method not found in `Flatten<Map<std::slice::Iter<'_, Vec<isize>>,\
    \ [closure@/tmp/tmpgqcb75s1.rs:19:14: 19:104]>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ v = vec![];\n    for row in lst {\n        let mut c = vec![];\n        for\
    \ j in row.iter().cloned() {\n            if j == x {\n                c.push((j,\
    \ 0));\n            }\n        }\n        v.append(c);\n    }\n    v.sort_by(|x,\
    \ y| y.iter().cmp(&x.iter()).rev()).sort_by(|x, y| y.iter().cmp(&x.iter()).rev());\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpolwrfkzg.rs:25:18\n   |\n\
    25 |         v.append(c);\n   |                  ^\n   |                  |\n\
    \   |                  expected `&mut Vec<_>`, found struct `Vec`\n   |      \
    \            help: consider mutably borrowing here: `&mut c`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                         found struct\
    \ `Vec<(isize, {integer})>`\n\nerror[E0599]: no method named `sort_by` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmpolwrfkzg.rs:27:53\n   |\n\
    27 |     v.sort_by(|x, y| y.iter().cmp(&x.iter()).rev()).sort_by(|x, y| y.iter().cmp(&x.iter()).rev());\n\
    \   |                                                     ^^^^^^^ method not found\
    \ in `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst.iter() {\n        let mut cols: Vec<isize>\
    \ = row.iter().cloned().collect();\n        cols.sort_by_key(|&x| -x);\n     \
    \   cols.reverse();\n        result.push((\n            vec![(cols.iter().position(|x|\
    \ *x == x).unwrap_or(0), cols.iter().position(|x| *x == x).unwrap_or(cols.len())\
    \ - 1)],\n            vec![cols],\n        ));\n    }\n    result.sort_by_key(|&x|\
    \ x.1.iter().cloned().collect::<Vec<_>>().cloned());\n    result.iter().cloned().enumerate().map(|(i,\
    \ &mut j)| {\n        let mut rev = vec![];\n        let mut last = j.iter().cloned().collect::<Vec<_>>().cloned();\n\
    \        last.sort_by_key(|&x| x.1);\n        last.reverse();\n        for i in\
    \ 0..last.len() {\n            j.swap(i, last.iter().position(|x| *x == i).unwrap_or(0));\n\
    \            rev.push((i, last[i]));\n        }\n        vec![(vec![i], rev)].into_iter()\n\
    \    })\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpntgnuchn.rs:23:50\n   |\n\
    23 |             vec![(cols.iter().position(|x| *x == x).unwrap_or(0), cols.iter().position(|x|\
    \ *x == x).unwrap_or(cols.len()) - 1)],\n   |                                \
    \                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n23 |             vec![(cols.iter().position(|x| *x == *x).unwrap_or(0),\
    \ cols.iter().position(|x| *x == x).unwrap_or(cols.len()) - 1)],\n   |       \
    \                                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpntgnuchn.rs:23:98\n   |\n23 |             vec![(cols.iter().position(|x|\
    \ *x == x).unwrap_or(0), cols.iter().position(|x| *x == x).unwrap_or(cols.len())\
    \ - 1)],\n   |                                                               \
    \                                   ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n23 |             vec![(cols.iter().position(|x|\
    \ *x == x).unwrap_or(0), cols.iter().position(|x| *x == *x).unwrap_or(cols.len())\
    \ - 1)],\n   |                                                               \
    \                                   +\n\nerror[E0599]: `Vec<Vec<isize>>` is not\
    \ an iterator\n   --> /tmp/tmpntgnuchn.rs:27:69\n    |\n27  |       result.sort_by_key(|&x|\
    \ x.1.iter().cloned().collect::<Vec<_>>().cloned());\n    |                  \
    \                                                     ^^^^^^ `Vec<Vec<isize>>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<Vec<isize>>: Iterator`\n            which is required by `&mut\
    \ Vec<Vec<isize>>: Iterator`\n            `[Vec<isize>]: Iterator`\n         \
    \   which is required by `&mut [Vec<isize>]: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpntgnuchn.rs:28:49\n   |\n28 |     result.iter().cloned().enumerate().map(|(i,\
    \ &mut j)| {\n   |                                                 ^^^^^^- expected\
    \ due to this\n   |                                                 |\n   |  \
    \                                          "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret: Vec<(isize, isize)> = Vec::new();\n    for vec in lst {\n        for (i,\
    \ _) in vec.iter().enumerate() {\n            if i == x {\n                ret.push((i,\
    \ vec.len()));\n                break;\n            }\n        }\n    }\n    ret.sort_by_key(|i|\
    \ i.0);\n    ret.sort_by_key(|j| j.1);\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi35vuv_g.rs:20:21\n   |\n\
    20 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi35vuv_g.rs:21:27\n   |\n21 |                 ret.push((i,\
    \ vec.len()));\n   |                           ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |                 ret.push((i.try_into().unwrap(),\
    \ vec.len()));\n   |                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi35vuv_g.rs:21:30\n   |\n21 |              \
    \   ret.push((i, vec.len()));\n   |                              ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |                 ret.push((i,\
    \ vec.len().try_into().unwrap()));\n   |                                     \
    \  ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ ret = vec![];\n\n    for row in lst {\n        if row.len() > x {\n        \
    \    ret.append(vec![x]);\n            break;\n        }\n        for x in row\
    \ {\n            ret.append(vec![x]);\n        }\n    }\n\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ocvj2cn.rs:20:24\n   |\n\
    20 |         if row.len() > x {\n   |                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |         if row.len() > x.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ocvj2cn.rs:21:24\n   |\n21 |             ret.append(vec![x]);\n\
    \   |                        ^^^^^^^ expected `&mut Vec<_>`, found struct `Vec`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \        found struct `Vec<isize>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0ocvj2cn.rs:25:24\n   |\n25 |             ret.append(vec![x]);\n\
    \   |                        ^^^^^^^ expected `&mut Vec<_>`, found struct `Vec`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \        found struct `Vec<isize>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    debug_assert!(lst.len()\
    \ >= 2);\n\n    let mut rows = vec![];\n\n    let mut col_pos = 1;\n    let mut\
    \ row_pos = 0;\n    let mut col_col_pos = 0;\n\n    for row in lst {\n       \
    \ // get row\n        let mut col = vec![];\n        for el in row {\n       \
    \     if el == x {\n                col.push((row_pos, col_pos));\n          \
    \  } else {\n                col_col_pos += 1;\n            }\n            col.push((row_pos,\
    \ col_pos));\n            row_pos += 1;\n        }\n\n        // sort row by cols\
    \ in descending order\n        col.sort_by_key(|&(x, y)| if *y > *x { *y } else\
    \ { -*x });\n\n        // sort cols by rows in ascending order\n        col.sort_by_key(|&(x,\
    \ y)| if *x > *y { *x } else { -*y });\n\n        // push the row\n        row.sort_by_key(|&(x,\
    \ y)| if *x > *y { *x } else { -*y });\n        rows.push(row);\n    }\n\n   \
    \ rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:39:38\n\
    \   |\n39 |         col.sort_by_key(|&(x, y)| if *y > *x { *y } else { -*x });\n\
    \   |                                      ^^\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:39:43\n   |\n39 |        \
    \ col.sort_by_key(|&(x, y)| if *y > *x { *y } else { -*x });\n   |           \
    \                                ^^\n\nerror[E0614]: type `{integer}` cannot be\
    \ dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:39:48\n   |\n39 |         col.sort_by_key(|&(x,\
    \ y)| if *y > *x { *y } else { -*x });\n   |                                 \
    \               ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpf9ozc4g8.rs:39:61\n   |\n39 |         col.sort_by_key(|&(x, y)|\
    \ if *y > *x { *y } else { -*x });\n   |                                     \
    \                        ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpf9ozc4g8.rs:42:38\n   |\n42 |         col.sort_by_key(|&(x, y)|\
    \ if *x > *y { *x } else { -*y });\n   |                                     \
    \ ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:42:43\n\
    \   |\n42 |         col.sort_by_key(|&(x, y)| if *x > *y { *x } else { -*y });\n\
    \   |                                           ^^\n\nerror[E0614]: type `{integer}`\
    \ cannot be dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:42:48\n   |\n42 |        \
    \ col.sort_by_key(|&(x, y)| if *x > *y { *x } else { -*y });\n   |           \
    \                                     ^^\n\nerror[E0614]: type `{integer}` cannot\
    \ be dereferenced\n  --> /tmp/tmpf9ozc4g8.rs:42:61\n   |\n42 |         col.sort_by_key(|&(x,\
    \ y)| if *x > *y { *x } else { -*y });\n   |                                 \
    \                            ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf9ozc4g8.rs:45:27\n\
    \   |\n45 |         row.sort_by_key(|&(x, y)| if *x > *y { *x } else { -*y });\n\
    \   |                           ^^^^^-\n   |                           |    |\n\
    \   |                           |    expected due to this\n   |              \
    \         "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut lst_ = lst.clone();\n    let mut\
    \ new_list = vec![];\n    let mut last_row: Vec<(isize, isize)> = vec![];\n  \
    \  for i in lst_[0].len() {\n        last_row.push((0, 0));\n    }\n    for i\
    \ in lst_.iter().rev() {\n        for j in i.iter().rev() {\n            if j\
    \ == x {\n                new_list.push(last_row);\n            }\n          \
    \  last_row.push((i, j));\n        }\n    }\n    new_list.sort();\n    new_list.sort_by(|a,\
    \ b| b[0][0].cmp(&a[0][0]));\n    new_list.iter().map(|a| (a[0], a[1][0])).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmprg4_jffv.rs:23:14\n\
    \   |\n23 |     for i in lst_[0].len() {\n   |              ^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmprg4_jffv.rs:28:18\n   |\n28 |             if j == x {\n   |   \
    \               ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprg4_jffv.rs:31:28\n   |\n31 |             last_row.push((i,\
    \ j));\n   |                            ^ expected `isize`, found `&Vec<isize>`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprg4_jffv.rs:31:31\n   |\n31 |\
    \             last_row.push((i, j));\n   |                               ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             last_row.push((i, *j));\n   |                               +\n\
    \nerror[E0608]: cannot index into a value of type `(isize, isize)`\n  --> /tmp/tmprg4_jffv.rs:35:29\n\
    \   |\n35 |     new_list.sort_by(|a, b| b[0][0].cmp(&a[0][0]));\n   |        \
    \                     ^^^^^^^ help: to access tuple elements, use: `b[0].0`\n\n\
    error[E0608]: cannot index into a value of type `(isize, isize)`\n  --> /tmp/tmprg4_jffv.rs:35:42\n\
    \   |\n35 |     new_list.sort_by(|a, b| b[0][0].cmp(&a[0][0]));\n   |        \
    \                                  ^^^^^^^ help: to access tuple elements, use:\
    \ `"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    // sort\
    \ coordinates by rows in ascending order\n    let mut lst = lst.iter().map(|v|\
    \ v.iter().cloned()).collect::<Vec<_>>();\n    lst.sort_by_key(|v| v.iter().cloned().nth(0));\n\
    \n    // sort coordinates by columns in descending order\n    lst.sort_by_key(|v|\
    \ {\n        v.iter().cloned().nth(1).partial_cmp(x.partial_cmp(&v.iter().cloned().nth(1).unwrap()))\n\
    \    });\n\n    // get coordinates in tuples\n    lst.iter().map(|v| v.iter().cloned()).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&Cloned<std::slice::Iter<'_,\
    \ isize>>` in the current scope\n  --> /tmp/tmpqym1e171.rs:19:27\n   |\n19 | \
    \    lst.sort_by_key(|v| v.iter().cloned().nth(0));\n   |                    \
    \       ^^^^ method not found in `&Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&Cloned<std::slice::Iter<'_, isize>>`\
    \ in the current scope\n  --> /tmp/tmpqym1e171.rs:23:11\n   |\n23 |         v.iter().cloned().nth(1).partial_cmp(x.partial_cmp(&v.iter().cloned().nth(1).unwrap()))\n\
    \   |           ^^^^ method not found in `&Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror[E0599]: no method named `iter` found for reference `&Cloned<std::slice::Iter<'_,\
    \ isize>>` in the current scope\n  --> /tmp/tmpqym1e171.rs:23:63\n   |\n23 | \
    \        v.iter().cloned().nth(1).partial_cmp(x.partial_cmp(&v.iter().cloned().nth(1).unwrap()))\n\
    \   |                                                               ^^^^ method\
    \ not found in `&Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `iter` found for reference `&Cloned<std::slice::Iter<'_, isize>>` in the\
    \ current scope\n  --> /tmp/tmpqym1e171.rs:27:26\n   |\n27 |     lst.iter().map(|v|\
    \ v.iter().cloned()).collect()\n   |                          ^^^^ method not\
    \ found in `&Cloned<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ m = Map::new();\n    for v in lst {\n        for i in 0..v.len() {\n       \
    \     m[i] = if i == x {\n                (v[x..], v[..x..])\n            } else\
    \ {\n                (i, v[i])\n            };\n        }\n    }\n    let mut\
    \ lst = m.iter().map(|(k, v)| {\n        match k {\n            0 => (0, v[0]),\n\
    \            1 => (v[0], v[1]),\n            2 => (v[1], v[2]),\n            3\
    \ => (v[2], v[0]),\n            _ => (k, v),\n        }\n    }).collect::<Vec<_>>();\n\
    \    lst.sort_by(|a, b| b[0].cmp(&a[0]));\n    lst.sort_by(|a, b| b[1].cmp(&a[1]));\n\
    \    lst\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found\
    \ `..`\n  --> /tmp/tmp744kijgx.rs:21:31\n   |\n21 |                 (v[x..], v[..x..])\n\
    \   |                               ^^ expected one of 7 possible tokens\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Map`\n  --> /tmp/tmp744kijgx.rs:17:17\n\
    \   |\n17 |     let mut m = Map::new();\n   |                 ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::iter::Map;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp744kijgx.rs:20:28\n   |\n\
    20 |             m[i] = if i == x {\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |             m[i] =\
    \ if i == x.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut i = lst.iter().position(|x| x.is_empty());\n\
    \    let row = lst.clone();\n    row.sort_by_key(|x| x.iter().rev().count());\n\
    \    let row2 = row\n        .iter()\n        .skip(i)\n        .take(1)\n   \
    \     .collect::<Vec<Vec<isize>>>();\n    let mut j = row2.iter().position(|x|\
    \ x.contains(x)).unwrap();\n    row2.sort_by_key(|x| x.iter().count());\n    let\
    \ (mut x, mut y) = (0, 0);\n    let mut i = 0;\n    for (x, row) in row2.iter().zip(row.iter())\
    \ {\n        if i == x {\n            for (mut y, row) in row.iter().zip(row2.iter())\
    \ {\n                i += 1;\n            }\n            break;\n        }\n \
    \   }\n    let mut i = 0;\n    for (x, row) in row2.iter().zip(row.iter()) {\n\
    \        if i == x {\n            for (mut y, row) in row.iter().zip(row2.iter())\
    \ {\n                i += 1;\n            }\n            break;\n        }\n \
    \   }\n    let mut i = 0;\n    let mut j = 0;\n    let mut row3 = vec![];\n  \
    \  for (y, row) in row2.iter().zip(row.iter()) {\n        if i == y {\n      \
    \      for (mut x, row) in row.iter().zip(row2.iter()) {\n                i +=\
    \ 1;\n            }\n            row3.push(vec![(i, j - 1), (i, j)])\n       \
    \ } else {\n            for (mut x, row) in row.iter().zip(row2.iter()) {\n  \
    \              i += 1;\n            }\n            row3.push(vec![(i, j - 1),\
    \ (i, j)])\n        }\n    }\n    row3\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnbu5vl2t.rs:25:15\n   |\n\
    25 |         .skip(i)\n   |               ^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: a value of type `Vec<Vec<isize>>` cannot be built from an iterator\
    \ over elements of type `&Vec<isize>`\n    --> /tmp/tmpnbu5vl2t.rs:27:10\n   \
    \  |\n27   |         .collect::<Vec<Vec<isize>>>();\n     |          ^^^^^^^ value\
    \ of type `Vec<Vec<isize>>` cannot be built from `std::iter::Iterator<Item=&Vec<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<&Vec<isize>>` is not implemented\
    \ for `Vec<Vec<isize>>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnbu5vl2t.rs:28:53\n   |\n28 |     let mut j = row2.iter().position(|x|\
    \ x.contains(x)).unwrap();\n   |                                             \
    \        ^ expected `isize`, found struct `Vec`\n   |\n   = note: expected reference\
    \ `&isize`\n              found reference `&Vec<isize>`\n\nerror[E0277]: can't\
    \ compare `{integer}` with `&Vec<isize>`\n  --> /tmp/tmpnbu5vl2t.rs:33:14\n  \
    \ |\n33 |         if i == x {\n   |              ^^ no implementation for `{integer}\
    \ == &Vec<isize>`\n   |\n   = help: the trait `PartialEq<&Vec<isize>>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `{integer}`\
    \ with `&Vec<isize>`\n  --> /tmp/tmpnbu5vl2t.rs:42:14\n   |\n42 |         if i\
    \ == x {\n   |              ^^ no implementation for `{integer} == &Vec<isize>`\n\
    \   |\n   = help: the trait `PartialEq<&Vec<isize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n    "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst_len: usize = lst.len();\n    let mut rows: Vec<(isize, isize)> = vec![];\n\
    \    while lst_len > 0 {\n        let mut lst_len: usize = lst_len - 1;\n    \
    \    let mut rows: Vec<(isize, isize)> = vec![];\n        for row in lst {\n \
    \           let mut lst_len: usize = row.len();\n            while lst_len > 0\
    \ {\n                if row[lst_len - 1] == x {\n                    let mut rows:\
    \ Vec<(isize, isize)> = vec![];\n                    rows.push((lst_len - 1, row.len()\
    \ - 1));\n                    row.iter().skip(lst_len - 1).take(lst_len).for_each(|x|\
    \ {\n                        if rows[0][0] > x[0] || (rows[0][0] == x[0] && rows[0][1]\
    \ > x[1]) {\n                            rows.push((x[0], x[1]));\n          \
    \              }\n                    });\n                    rows.push(rows[0]);\n\
    \                    rows.push(rows[1]);\n                    rows.push(rows[2]);\n\
    \                    rows.push(rows[3]);\n                    rows.push(rows[4]);\n\
    \                    return rows;\n                }\n                lst_len\
    \ -= 1;\n            }\n            row.push(x);\n            rows.push((lst_len\
    \ - 1, row.len() - 1));\n        }\n        rows.push((lst_len - 1, row.len()\
    \ - 1));\n        rows.push(rows[0]);\n        rows.push(rows[1]);\n        lst_len\
    \ -= 1;\n    }\n    return rows;\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `row` in this scope\n  --> /tmp/tmprxohc6pb.rs:45:33\n\
    \   |\n45 |         rows.push((lst_len - 1, row.len() - 1));\n   |           \
    \                      ^^^ help: a local variable with a similar name exists:\
    \ `rows`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprxohc6pb.rs:27:32\n\
    \   |\n27 |                     rows.push((lst_len - 1, row.len() - 1));\n   |\
    \                                ^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |                     rows.push(((lst_len - 1).try_into().unwrap(),\
    \ row.len() - 1));\n   |                                +           +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprxohc6pb.rs:27:45\n   |\n27 |\
    \                     rows.push((lst_len - 1, row.len() - 1));\n   |         \
    \                                    ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |                     rows.push((lst_len - 1, (row.len()\
    \ - 1).try_into().unwrap()));\n   |                                          \
    \   +             +++++++++++++++++++++\n\nerror[E0608]: cannot index into a value\
    \ of type `(isize, isize)`\n  --> /tmp/tmprxohc6pb.rs:29:28\n   |\n29 |      \
    \                   if rows[0][0] > x[0] || (rows[0][0] == x[0] && rows[0][1]\
    \ > x[1]) {\n   |                            ^^^^^^^^^^ help: to access tuple\
    \ elements, use: `rows[0].0`\n\nerror[E0608]: cannot index into a value of type\
    \ `&isize`\n  --> /tmp/tmprxohc6pb.rs:29:41\n   |\n29 |                      \
    \   if rows[0][0] > x[0] || (rows[0][0] == x[0] && rows[0][1] > x[1]) {\n   |\
    \                                         ^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `(isize, isize)`\n  --> /tmp/tmprxohc6pb.rs:29:50\n   |\n29\
    \ |                         if rows[0][0] > x[0] || (rows[0][0] == x[0] && rows[0][1]\
    \ > x[1]) {\n   |                                                  ^^^^^^^^^^\
    \ help: to access tuple element"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = vec![];\n    for row in lst {\n        let mut cols = vec![];\n     \
    \   for &i in row {\n            if i == x {\n                cols.push((row.len(),\
    \ row.len()))\n            } else {\n                cols.push(i)\n          \
    \  }\n        }\n        rows.push(cols);\n    }\n    rows.sort_by(|a, b| a.iter().cmp(b).collect::<Vec<_>>());\n\
    \    rows.sort_by(|a, b| b.iter().cmp(a).collect::<Vec<_>>());\n    rows\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpojcblvd7.rs:20:13\n   |\n\
    20 |         for &i in row {\n   |             ^^    --- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `i`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror[E0277]: can't compare `(usize, usize)` with `isize`\n  --> /tmp/tmpojcblvd7.rs:21:18\n\
    \   |\n21 |             if i == x {\n   |                  ^^ no implementation\
    \ for `(usize, usize) == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `(usize, usize)`\n   = help: the following other types\
    \ implement trait `PartialEq<Rhs>`:\n             ()\n             (A, B, C, D,\
    \ E, F, G, H, I, J, K, L)\n             (B, C, D, E, F, G, H, I, J, K, L)\n  \
    \           (C, D, E, F, G, H, I, J, K, L)\n             (D, E, F, G, H, I, J,\
    \ K, L)\n             (E, F, G, H, I, J, K, L)\n             (F, G, H, I, J, K,\
    \ L)\n             (G, H, I, J, K, L)\n           and 5 others\n\nerror[E0599]:\
    \ `std::cmp::Ordering` is not an iterator\n   --> /tmp/tmpojcblvd7.rs:29:41\n\
    \    |\n29  |       rows.sort_by(|a, b| a.iter().cmp(b).collect::<Vec<_>>());\n\
    \    |                                           ^^^^^^^ `std::cmp::Ordering`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `std::cmp::Ordering: Iterator`\n            which is required by\
    \ `&mut std::cmp::Ordering: Iterator`\n\nerror[E0599]: `std::cmp::Ordering` is\
    \ not an iterator\n   --> /tmp/tmpojcblvd7.rs:30:41\n    |\n30  |       rows.sort_by(|a,\
    \ b| b.iter().cmp(a).collect::<Vec<_>>());\n    |                            \
    \               ^^^^^^^ `std::cmp::Ordering` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `std::cmp::Ordering:\
    \ Iterator`\n            which is required by `&mut std::cmp::Ordering: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpojcblvd7.rs:31:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0 as usize;\n    let mut col = 0 as usize;\n    let mut result = vec![];\n\
    \    while row < lst.len() {\n        if lst[row][col] == x {\n            result.push((row,\
    \ col));\n        }\n        col += 1;\n        if col == lst[row].len() {\n \
    \           col = 0;\n            row += 1;\n        }\n    }\n    result.sort_by_key(|x|\
    \ x.1);\n    result.sort_by_key(|x| x.1, |y| y.reverse());\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplbgdpbn9.rs:31:25\n\
    \   |\n31 |     result.sort_by_key(|x| x.1, |y| y.reverse());\n   |          \
    \               ^ consider giving this closure parameter a type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n   --> /tmp/tmplbgdpbn9.rs:31:12\n    |\n31 \
    \ |     result.sort_by_key(|x| x.1, |y| y.reverse());\n    |            ^^^^^^^^^^^\
    \ -------  --------------- supplied 2 arguments\n    |            |\n    |   \
    \         expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplbgdpbn9.rs:32:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n32 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut col = 0;\n    for el in lst.iter() {\n        match el.len()\
    \ {\n            0 => (),\n            _ => {\n                while col < x.into()\
    \ && row * x.into() + col >= el.len() {\n                    col += 1\n      \
    \          }\n                row = (row + 1) % el.len();\n                col\
    \ = (col + 1) % el.len();\n            }\n        }\n    }\n    vec![(row, col)]\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: From<isize>` is not satisfied\n \
    \ --> /tmp/tmp06gtw3gy.rs:23:31\n   |\n23 |                 while col < x.into()\
    \ && row * x.into() + col >= el.len() {\n   |                               ^^^^\
    \ the trait `From<isize>` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <f32 as From<i16>>\n\
    \             <f32 as From<i8>>\n             <f32 as From<u16>>\n           \
    \  <f32 as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n\
    \             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and\
    \ 67 others\n   = note: required because of the requirements on the impl of `Into<usize>`\
    \ for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp06gtw3gy.rs:31:11\n\
    \   |\n31 |     vec![(row, col)]\n   |           ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |     vec![(row.try_into().unwrap(), col)]\n   |\
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp06gtw3gy.rs:31:16\n\
    \   |\n31 |     vec![(row, col)]\n   |                ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |     vec![(row, col.try_into().unwrap())]\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.into_iter().map(|row|\
    \ get_row(row, x)).collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9jpc0gmk.rs:17:39\n   |\n\
    17 |     lst.into_iter().map(|row| get_row(row, x)).collect::<Vec<_>>()\n   |\
    \                                       ^^^ expected struct `Vec`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<Vec<isize>>`\n              found struct\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9jpc0gmk.rs:17:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n17 |     lst.into_iter().map(|row|\
    \ get_row(row, x)).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<Vec<(isize, isize)>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter().filter(|row|\
    \ row.len() == x).cloned().collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph6c3dz56.rs:17:42\n   |\n\
    17 |     lst.iter().filter(|row| row.len() == x).cloned().collect()\n   |    \
    \                                      ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |     lst.iter().filter(|row| row.len() == x.try_into().unwrap()).cloned().collect()\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `Vec<isize>`\n    --> /tmp/tmph6c3dz56.rs:17:54\n     |\n17\
    \   |     lst.iter().filter(|row| row.len() == x).cloned().collect()\n     | \
    \                                                     ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=Vec<isize>>`\n     |\n\
    \     = help: the trait `FromIterator<Vec<isize>>` is not implemented for `Vec<(isize,\
    \ isize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rows = vec![];\n    let mut\
    \ row_coords = vec![];\n\n    for row in lst {\n        if row.is_empty() {\n\
    \            row_coords.push(0);\n        } else {\n            let coords = row\n\
    \                .iter()\n                .enumerate()\n                .sort_by(|(a,\
    \ b)| b.0.cmp(&a.0));\n            row_coords.push(-coords.last().unwrap().1.0);\n\
    \            row_coords.sort_unstable();\n        }\n    }\n    row_coords.push(x);\n\
    \n    for i in 0..row_coords.len() - 1 {\n        if row_coords[i] == row_coords[i\
    \ + 1] {\n            row_coords.pop();\n            rows.push(vec![]);\n    \
    \    } else {\n            let coord = (row_coords[i], row_coords[i + 1]);\n \
    \           rows.push(coord);\n        }\n    }\n\n    return rows\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpm4ncc36w.rs:31:18\n   |\n31 |             \
    \    .sort_by(|(a, b)| b.0.cmp(&a.0));\n   |                  ^^^^^^^ method not\
    \ found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm4ncc36w.rs:44:23\n   |\n44 |             rows.push(coord);\n\
    \   |                       ^^^^^ expected struct `Vec`, found tuple\n   |\n \
    \  = note: expected struct `Vec<_>`\n               found tuple `(isize, isize)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm4ncc36w.rs:48:12\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \                                             ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n48 |     return rows\n   |           \
    \ ^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<Vec<_>>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row_vector = Vec::new();\n\n    // Get row vector\n    for i in 0..lst.len()\
    \ {\n        row_vector.push(vec![(i, 0)]);\n    }\n\n    // Get row numbers\n\
    \    for i in 0..lst.len() {\n        let mut col_vector = Vec::new();\n\n   \
    \     // Get column vector\n        for j in 0..lst[i].len() {\n            col_vector.push((i,\
    \ j));\n        }\n\n        // Update row numbers\n        for j in 0..col_vector.len()\
    \ {\n            let mut found = false;\n\n            // Update column numbers\n\
    \            for k in 0..row_vector.len() {\n                if col_vector[j].0\
    \ != k {\n                    continue;\n                }\n\n               \
    \ // Update found\n                if col_vector[j].1 > row_vector[k].1 {\n  \
    \                  row_vector[k].1 = col_vector[j].1;\n                    found\
    \ = true;\n                }\n            }\n\n            // Update not found\n\
    \            if !found {\n                row_vector.push(vec![(col_vector[j].0,\
    \ col_vector[j].1)]);\n            }\n        }\n    }\n\n    // Sort row numbers\n\
    \    for k in 0..row_vector.len() {\n        row_vector[k].1.sort();\n    }\n\n\
    \    // Sort row vector by rows\n    for k in 0..row_vector.len() {\n        row_vector[k].1.sort_by_key(|&x|\
    \ x.0);\n    }\n\n    // Sort row vector by columns\n    for k in 0..row_vector.len()\
    \ {\n        row_vector[k].1.sort_by_key(|&x| x.1);\n    }\n\n    // Return result\n\
    \    vec![..row_vector.len()].iter().map(|&(_, y)| {\n        (row_vector[k].0,\
    \ y)\n    }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `k` in this scope\n   --> /tmp/tmpti_p5as7.rs:74:21\n\
    \    |\n74  |         (row_vector[k].0, y)\n    |                     ^ help:\
    \ a tuple variant with a similar name exists: `Ok`\n\nerror[E0609]: no field `1`\
    \ on type `Vec<(usize, {integer})>`\n  --> /tmp/tmpti_p5as7.rs:44:52\n   |\n44\
    \ |                 if col_vector[j].1 > row_vector[k].1 {\n   |             \
    \                                       ^ unknown field\n\nerror[E0609]: no field\
    \ `1` on type `Vec<(usize, {integer})>`\n  --> /tmp/tmpti_p5as7.rs:45:35\n   |\n\
    45 |                     row_vector[k].1 = col_vector[j].1;\n   |            \
    \                       ^ unknown field\n\nerror[E0609]: no field `1` on type\
    \ `Vec<(usize, usize)>`\n  --> /tmp/tmpti_p5as7.rs:59:23\n   |\n59 |         row_vector[k].1.sort();\n\
    \   |                       ^ unknown field\n\nerror[E0609]: no field `1` on type\
    \ `Vec<(usize, usize)>`\n  --> /tmp/tmpti_p5as7.rs:64:23\n   |\n64 |         row_vector[k].1.sort_by_key(|&x|\
    \ x.0);\n   |                       ^ unknown field\n\nerror[E0609]: no field\
    \ `1` on type `Vec<(usize, usize)>`\n  --> /tmp/tmpti_p5as7.rs:69:23\n   |\n69\
    \ |         row_vector[k].1.sort_by_key(|&x| x.1);\n   |                     \
    \  ^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpti_p5as7.rs:73:43\n\
    \   |\n73 |     vec![..row_vector.len()].iter().map(|&(_, y)| {\n   |        \
    \                                   ^^^^^-\n   |                             \
    \              |    |\n   |                                           |    expected\
    \ due to this\n   |                                           expected struct\
    \ `RangeTo`, found tuple\n   |\n   = note: expected struct `RangeTo<usize>`\n\
    \               found tuple `(_, _)`\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.into_iter().cloned().collect::<Vec<_>>();\n    lst.sort_by(|a, b|\
    \ a.iter().cmp(b.iter()).unwrap_or(Ordering::Less));\n\n    let mut row: Vec<(isize,\
    \ isize)> = vec![];\n    let mut cols = vec![];\n    for v in lst {\n        let\
    \ mut cols = v\n            .iter()\n            .map(|j| {\n                let\
    \ r = v.iter().position(|i| i == j).unwrap();\n                (r + 1, j + 1)\n\
    \            })\n            .collect::<Vec<_>>();\n        cols.sort_by(|a, b|\
    \ b.iter().cmp(Ordering::Desc));\n        row.push(\n            v.iter().cloned().map(|j|\
    \ {\n                let r = v.iter().position(|i| i == j).unwrap();\n       \
    \         (r + 2, j + 2)\n            }).collect::<Vec<_>>(),\n        );\n  \
    \  }\n\n    let mut v = vec![];\n    for row in row.iter().cloned() {\n      \
    \  let mut x = row.iter().cloned().map(|j| {\n            j.iter()\n         \
    \       .map(|j| {\n                    if j == 0 {\n                        (0,\
    \ 0)\n                    } else {\n                        let r = row.iter().position(|i|\
    \ i == j).unwrap();\n                        (r, j)\n                    }\n \
    \               })\n                .collect::<Vec<_>>()\n        }).collect::<Vec<_>>();\n\
    \        x.sort_by(|a, b| b.iter().cmp(Ordering::Desc));\n        v.push(x);\n\
    \    }\n\n    let mut x = vec![];\n    let mut v = v.iter().cloned();\n    let\
    \ mut cols = cols.iter().cloned();\n    while v.len() > 0 {\n        let mut y\
    \ = vec![];\n        let mut x = v.iter().cloned();\n        while x.len() > 0\
    \ {\n            let mut z: Vec<_> = vec![];\n            while !cols.next().is_some()\
    \ {\n                z.push(x.pop().unwrap());\n            }\n            y.push(z);\n\
    \        }\n        x = x.iter().cloned();\n        v.push(y);\n    }\n\n    let\
    \ mut z = vec![];\n    for z in v.iter().cloned() {\n        let mut y = vec![];\n\
    \        for y in z {\n            if y == vec![] {\n                y.push(vec![]);\n\
    \            } else {\n                let mut x = y.iter().cloned();\n      \
    \          while x.len() > 0 {\n                    let mut z\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkc_l7c0k.rs:94:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n75 |     for z in v.iter().cloned() {\n   |       \
    \                         - unclosed delimiter\n76 |         let mut y = vec![];\n\
    77 |         for y in z {\n   |                    - unclosed delimiter\n...\n\
    80 |             } else {\n   |                    - unclosed delimiter\n81 |\
    \                 let mut x = y.iter().cloned();\n82 |                 while x.len()\
    \ > 0 {\n   |                                   - this delimiter might not be\
    \ properly closed...\n83 |                     let mut z\n84 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n94 | }\n   |   ^\n\n\
    error: expected `;`, found `}`\n  --> /tmp/tmpkc_l7c0k.rs:83:30\n   |\n83 |  \
    \                   let mut z\n   |                              ^ help: add `;`\
    \ here\n84 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Ordering`\n  --> /tmp/tmpkc_l7c0k.rs:18:57\n   |\n18 | \
    \    lst.sort_by(|a, b| a.iter().cmp(b.iter()).unwrap_or(Ordering::Less));\n \
    \  |                                                         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpkc_l7c0k.rs:30:42\n   |\n30 |         cols.sort_by(|a, b| b.iter().cmp(Ordering::Desc));\n\
    \   |                                          ^^^^^^^^ use of undeclared type\
    \ `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpkc_l7c0k.rs:53:39\n   |\n53 |         x.sort_by(|a, b| b.iter().cmp(Ordering::Desc));\n\
    \   |                                       ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<Vec<isize>> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpkc_l7c0k.rs:17:35\n     |\n17   |     let mut lst =\
    \ lst.into_iter().cloned().collect::<Vec<_>>();\n     |            "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut v = vec![];\n    for (i, row)\
    \ in lst.into_iter().enumerate() {\n        let mut cols = vec![];\n        for\
    \ (_, col) in row.iter().enumerate() {\n            if col == x {\n          \
    \      cols.push((i, col));\n            }\n        }\n        v.push((i, cols.reverse()));\n\
    \    }\n    v.sort_by(|a, b| a.1.cmp(b.1));\n    v.sort_by(|a, b| b.1.cmp(a.1));\n\
    \    v\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7rax7m77.rs:24:20\n\
    \   |\n24 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7rax7m77.rs:30:30\n   |\n30 |     v.sort_by(|a, b| a.1.cmp(b.1));\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&()`, found `()`\n   |          \
    \                    help: consider borrowing here: `&b.1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7rax7m77.rs:31:30\n   |\n31 |     v.sort_by(|a, b| b.1.cmp(a.1));\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&()`, found `()`\n   |          \
    \                    help: consider borrowing here: `&a.1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7rax7m77.rs:32:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n32 |     v\n   |     ^ expected `isize`, found `usize`\n   |\n  \
    \ = note: expected struct `Vec<(isize, isize)>`\n              found struct `Vec<(usize,\
    \ ())>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_lst = lst.clone();\n    sorted_lst.sort();\n    let mut result: Vec<(isize,\
    \ isize)> = vec![];\n    for i in 0..sorted_lst.len() {\n        if sorted_lst[i][x]\
    \ == x {\n            result.push((i, x));\n        }\n    }\n    result.sort_by_key(|&i|\
    \ -i);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbtubqii5.rs:21:12\n\
    \   |\n21 |         if sorted_lst[i][x] == x {\n   |            ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbtubqii5.rs:22:26\n   |\n22 |             result.push((i,\
    \ x));\n   |                          ^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |             result.push((i.try_into().unwrap(), x));\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `(isize, isize)`\n  --> /tmp/tmpbtubqii5.rs:25:29\n\
    \   |\n25 |     result.sort_by_key(|&i| -i);\n   |                           \
    \  ^^ cannot apply unary operator `-`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ it = lst.iter().enumerate();\n    it.sort_by(|(_, elem)| elem.iter().rev().skip(x).count());\n\
    \    it.sort_by(|(_, elem)| elem.iter().rev().count());\n    it.map(|(idx, elem)|\
    \ idx + (elem[x] - 1));\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpgr66b3y1.rs:18:8\n   |\n18 |     it.sort_by(|(_,\
    \ elem)| elem.iter().rev().skip(x).count());\n   |        ^^^^^^^ method not found\
    \ in `Enumerate<std::slice::Iter<'_, Vec<isize>>>`\n\nerror[E0599]: no method\
    \ named `sort_by` found for struct `Enumerate` in the current scope\n  --> /tmp/tmpgr66b3y1.rs:19:8\n\
    \   |\n19 |     it.sort_by(|(_, elem)| elem.iter().rev().count());\n   |     \
    \   ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_, Vec<isize>>>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgr66b3y1.rs:20:33\n\
    \   |\n20 |     it.map(|(idx, elem)| idx + (elem[x] - 1));\n   |             \
    \                    ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgr66b3y1.rs:16:47\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \  -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coors = Vec::new();\n    for i in lst {\n        if let Some(ind) = i.iter().position(|&x|\
    \ x == x) {\n            coors.push(ind, i);\n        }\n    }\n    coors.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    coors.sort_by(|a, b| {\n        let mut a_cmp = a.0.cmp(&b.0);\n\
    \        if a_cmp != 0 {\n            a_cmp\n        } else {\n            if\
    \ a.1.cmp(&b.1) != 0 {\n                a.1.cmp(&b.1)\n            } else {\n\
    \                if a.2.cmp(&b.2) != 0 {\n                    a.2.cmp(&b.2)\n\
    \                } else {\n                    if a.3.cmp(&b.3) != 0 {\n     \
    \                   a.3.cmp(&b.3)\n                    } else {\n            \
    \            if a.4.cmp(&b.4) != 0 {\n                            a.4.cmp(&b.4)\n\
    \                        } else {\n                            if a.5.cmp(&b.5)\
    \ != 0 {\n                                a.5.cmp(&b.5)\n                    \
    \        } else {\n                                if a.6.cmp(&b.6) != 0 {\n \
    \                                   a.6.cmp(&b.6)\n                          \
    \      } else {\n                                    0\n                     \
    \           }\n                            }\n                        }\n    \
    \                }\n                }\n            }\n        }\n    });\n   \
    \ let mut r = Vec::new();\n    for i in coors {\n        let mut v = i.1.clone();\n\
    \        let mut k = i.0.clone();\n        let mut cnt = 0;\n        for j in\
    \ i.1 {\n            if j == x {\n                cnt += 1;\n            }\n \
    \           v[j] += cnt;\n        }\n        r.append(&mut [k, v]);\n    }\n \
    \   r\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3f099sw6.rs:20:19\n     |\n20   |             coors.push(ind,\
    \ i);\n     |                   ^^^^ ---  - supplied 2 arguments\n     |     \
    \              |\n     |                   expected 1 argument\n     |\nnote:\
    \ associated function defined here\n\nerror[E0609]: no field `1` on type `&_`\n\
    \  --> /tmp/tmp3f099sw6.rs:23:28\n   |\n23 |     coors.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \   |                            ^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut sorted_rows:\
    \ Vec<(isize, isize)> = vec![(0, 0), (0, cols)].into_iter().collect();\n\n   \
    \ for row in lst {\n        let row_len = row.len();\n        for row in row {\n\
    \            cols = row_len;\n        }\n        sorted_rows.sort_by_key(|(x,\
    \ y)| x.partial_cmp(&y));\n    }\n    sorted_rows.sort_by_key(|(x, y)| {\n   \
    \     let x_row = x.0;\n        let y_row = y.0;\n        let x_col = x.1;\n \
    \       let y_col = y.1;\n\n        if x_row > y_row {\n            (x_col, y_col)\n\
    \        } else {\n            (y_col, x_col)\n        }\n    });\n\n    sorted_rows.iter().map(|(x,\
    \ y)| {\n        (x.0, x.1)\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `({integer}, usize)`\n    --> /tmp/tmpny3ayyzq.rs:19:84\n\
    \     |\n19   |     let mut sorted_rows: Vec<(isize, isize)> = vec![(0, 0), (0,\
    \ cols)].into_iter().collect();\n     |                                      \
    \                                              ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=({integer}, usize)>`\n\
    \     |\n     = help: the trait `FromIterator<({integer}, usize)>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0609]: no field\
    \ `0` on type `&isize`\n  --> /tmp/tmpny3ayyzq.rs:29:23\n   |\n29 |         let\
    \ x_row = x.0;\n   |                       ^\n\nerror[E0609]: no field `0` on\
    \ type `&isize`\n  --> /tmp/tmpny3ayyzq.rs:30:23\n   |\n30 |         let y_row\
    \ = y.0;\n   |                       ^\n\nerror[E0609]: no field `1` on type `&isize`\n\
    \  --> /tmp/tmpny3ayyzq.rs:31:23\n   |\n31 |         let x_col = x.1;\n   |  \
    \                     ^\n\nerror[E0609]: no field `1` on type `&isize`\n  -->\
    \ /tmp/tmpny3ayyzq.rs:32:23\n   |\n32 |         let y_col = y.1;\n   |       \
    \                ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpny3ayyzq.rs:42:12\n\
    \   |\n42 |         (x.0, x.1)\n   |            ^\n\nerror[E0609]: no field `1`\
    \ on type `&isize`\n  --> /tmp/tmpny3ayyzq.rs:42:17\n   |\n42 |         (x.0,\
    \ x.1)\n   |                 ^\n\nerror: aborting due to 7 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    sort_row_by_col(lst);\n    let mut\
    \ lst = lst.iter().cloned().collect();\n    for row in &mut lst {\n        sort_row_by_col(&row);\n\
    \    }\n    let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n    if lst.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut col_x = vec![];\n    let\
    \ mut row_x = vec![];\n    let mut i = 1;\n    while i < lst.len() {\n       \
    \ if row_x.len() > 0 && col_x.len() > 0 && lst[i - 1].len() >= col_x.len() {\n\
    \            break;\n        }\n        col_x.push(0);\n        row_x.push(0);\n\
    \        for col in &mut lst[i - 1].iter() {\n            if row_x[-1] < col {\n\
    \                row_x.push(col);\n                col_x.push(0);\n          \
    \  } else if row_x[-1] == col {\n                col_x[-1] += 1;\n           \
    \ }\n        }\n        i += 1;\n    }\n    sort_row_by_col(row_x);\n    sort_row_by_col(col_x);\n\
    \    let mut x = vec![];\n    let mut y = vec![];\n    for i in 0..row_x.len()\
    \ {\n        x.push((row_x[i], col_x[i]));\n        y.push(i);\n    }\n    let\
    \ mut j = row_x.len();\n    while j > 0 {\n        for i in 0..col_x.len() {\n\
    \            if row_x[j - 1] > row_x[j] {\n                let _ = x.remove(row_x[j\
    \ - 1]);\n                let _ = y.remove(col_x[j - 1]);\n                j -=\
    \ 1;\n            }\n        }\n    }\n    x\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_row_by_col` in this scope\n  -->\
    \ /tmp/tmpcl_2u24q.rs:20:5\n   |\n20 |     sort_row_by_col(lst);\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `sort_row_by_col`\
    \ in this scope\n  --> /tmp/tmpcl_2u24q.rs:23:9\n   |\n23 |         sort_row_by_col(&row);\n\
    \   |         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_row_by_col` in this scope\n  --> /tmp/tmpcl_2u24q.rs:48:5\n\
    \   |\n48 |     sort_row_by_col(row_x);\n   |     ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `sort_row_by_col` in this scope\n\
    \  --> /tmp/tmpcl_2u24q.rs:49:5\n   |\n49 |     sort_row_by_col(col_x);\n   |\
    \     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: negative integers cannot\
    \ be used to index on a `Vec<{integer}>`\n  --> /tmp/tmpcl_2u24q.rs:39:22\n  \
    \ |\n39 |             if row_x[-1] < col {\n   |                      ^^ cannot\
    \ use a negative integer for indexing on `Vec<{integer}>`\n   |\nhelp: to access\
    \ an element starting from the end of the `Vec<{integer}>`, compute the index\n\
    \   |\n39 |             if row_x[row_x.len() -1] < col {\n   |               \
    \       +++++++++++\n\nerror: negative integers cannot be used to index on a `Vec<{integer}>`\n\
    \  --> /tmp/tmpcl_2u24q.rs:42:29\n   |\n42 |             } else if row_x[-1] ==\
    \ col {\n   |                             ^^ cannot use a negative integer for\
    \ indexing on `Vec<{integer}>`\n   |\nhelp: to access an element starting from\
    \ the end of the `Vec<{integer}>`, compute the index\n   |\n42 |             }\
    \ else if row_x[row_x.len() -1] == col {\n   |                             +++++++++++\n\
    \nerror: negative integers cannot be used to index on a `Vec<{integer}>`\n  -->\
    \ /tmp/tmpcl_2u24q.rs:43:23\n   |\n43 |                 col_x[-1] += 1;\n   |\
    \                       ^^ cannot use a negative integer for indexing on `Vec<{integer}>`\n\
    \   |\nhelp: to access an element starting from the end of the `Vec<{integer}>`,\
    \ compute the index\n   |\n43 |                 col_x[col_x.len() -1] += 1;\n\
    \   |                  "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    lst.iter()\n\
    \        .enumerate()\n        .filter(|(_, v)| v[x] != x)\n        .map(|(i,\
    \ v)| (i, *v.iter().enumerate().filter_map(|(_, v2)| v2[x]).collect::<Vec<_>>()))\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpomkepj3o.rs:19:26\n\
    \   |\n19 |         .filter(|(_, v)| v[x] != x)\n   |                        \
    \  ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpomkepj3o.rs:20:70\n\
    \   |\n20 |         .map(|(i, v)| (i, *v.iter().enumerate().filter_map(|(_, v2)|\
    \ v2[x]).collect::<Vec<_>>()))\n   |                                         \
    \                             ^^^^^\n\nerror[E0277]: the size for values of type\
    \ `[_]` cannot be known at compilation time\n  --> /tmp/tmpomkepj3o.rs:20:23\n\
    \   |\n20 |         .map(|(i, v)| (i, *v.iter().enumerate().filter_map(|(_, v2)|\
    \ v2[x]).collect::<Vec<_>>()))\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: within `(usize,\
    \ [_])`, the trait `Sized` is not implemented for `[_]`\n   = note: required because\
    \ it appears within the type `(usize, [_])`\n   = note: tuples must have a statically\
    \ known size to be initialized\n\nerror[E0277]: the size for values of type `[_]`\
    \ cannot be known at compilation time\n   --> /tmp/tmpomkepj3o.rs:20:14\n    |\n\
    20  |         .map(|(i, v)| (i, *v.iter().enumerate().filter_map(|(_, v2)| v2[x]).collect::<Vec<_>>()))\n\
    \    |          --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |          |\n    |         \
    \ required by a bound introduced by this call\n    |\n    = help: within `(usize,\
    \ [_])`, the trait `Sized` is not implemented for `[_]`\n    = note: required\
    \ because it appears within the type `(usize, [_])`\nnote: required by a bound\
    \ in `map`\n\nerror[E0599]: the method `collect` exists for struct `Map<Fil"
  stdout: ''
  timestamp: 1660010913
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut res = vec![];\n    let mut row_with_highest_col_val\
    \ = -1isize;\n\n    for row in lst {\n        let mut col_with_highest_row_val\
    \ = -1isize;\n\n        for col in row.iter().cloned() {\n            if col >=\
    \ x {\n                break;\n            }\n\n            if col > col_with_highest_row_val\
    \ {\n                col_with_highest_row_val = col;\n            }\n        }\n\
    \n        if col_with_highest_row_val > 0 {\n            res.push((row_with_highest_col_val,\
    \ col_with_highest_row_val));\n        }\n\n        row_with_highest_col_val -=\
    \ 1;\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmplcn6zj41.rs:49:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ out = Vec::new();\n    let mut i = 0;\n    while i < lst.len() {\n        if\
    \ lst[i].len() == x {\n            i += 1;\n            continue;\n        }\n\
    \        let mut j = 0;\n        while j < lst[i].len() {\n            if j ==\
    \ x {\n                break;\n            }\n            let mut k = j + 1;\n\
    \            while k < lst[i].len() {\n                if k == x {\n         \
    \           break;\n                }\n                let mut l = k;\n      \
    \          while l < lst[i].len() {\n                    if l == x {\n       \
    \                 break;\n                    }\n                    out.push((i,\
    \ l));\n                    k += 1;\n                }\n                l += 1;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    out.sort();\n\
    \    out.sort_by_key(|(_, r)| *r);\n    out\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1udtehtf.rs:20:28\n   |\n\
    20 |         if lst[i].len() == x {\n   |                            ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         if lst[i].len()\
    \ == x.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1udtehtf.rs:26:21\n   |\n26 |\
    \             if j == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |             if j == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1udtehtf.rs:31:25\n   |\n31 |                 if k == x\
    \ {\n   |                         ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n31 |                 if k == x.try_into().unwrap() {\n   |      \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1udtehtf.rs:36:29\n   |\n36 |                     if l == x {\n\
    \   |                             ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n36 |                     if l == x.try_into().unwrap() {\n   |  \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1udtehtf.rs:50:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n50 |     out\n   |     ^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coor = vec![];\n    for vec in lst {\n        let mut pos = 0;\n        for\
    \ num in vec {\n            if num == x {\n                coor.push((pos, vec));\n\
    \                break;\n            }\n            pos += 1;\n        }\n   \
    \ }\n    coor.sort_by_key(|(_, v)| v.iter().rev().sum().rev()).sort_by_key(|(_,\
    \ v)| v.iter().sum().rev());\n    coor\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpg920fg8o.rs:28:46\n\
    \   |\n28 |     coor.sort_by_key(|(_, v)| v.iter().rev().sum().rev()).sort_by_key(|(_,\
    \ v)| v.iter().sum().rev());\n   |                                           \
    \   ^^^ cannot infer type for type parameter `S` declared on the associated function\
    \ `sum`\n   |\n   = note: type must be known at this point\nhelp: consider specifying\
    \ the type argument in the method call\n   |\n28 |     coor.sort_by_key(|(_, v)|\
    \ v.iter().rev().sum::<S>().rev()).sort_by_key(|(_, v)| v.iter().sum().rev());\n\
    \   |                                                 +++++\n\nerror[E0599]: no\
    \ method named `sort_by_key` found for unit type `()` in the current scope\n \
    \ --> /tmp/tmpg920fg8o.rs:28:59\n   |\n28 |     coor.sort_by_key(|(_, v)| v.iter().rev().sum().rev()).sort_by_key(|(_,\
    \ v)| v.iter().sum().rev());\n   |                                           \
    \                ^^^^^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg920fg8o.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n29 |     coor\n   |     ^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<({integer}, Vec<isize>)>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    if lst.len()\
    \ == 0 {\n        vec![]\n    } else {\n        let mut it = lst.iter().map(|c|\
    \ c.iter().cloned()).collect::<Vec<Vec<isize>>>().into_iter().enumerate();\n \
    \       if x < it.next().unwrap() {\n            return vec![];\n        }\n \
    \       let mut it2 = it.map(|(i, c)| c.iter().skip(i).take(x)).collect::<Vec<Vec<(isize,\
    \ isize)>>>();\n        let mut i = 0;\n        it2.into_iter().sort_by_key(|(x,\
    \ y)| {\n            if x > y {\n                -1;\n            } else if x\
    \ == y {\n                0;\n            } else {\n                1;\n     \
    \       }\n        }).map(|(x, y)| {\n            i += 1;\n            (i, (x[0],\
    \ x[1]))\n        }).collect()\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<Vec<isize>>` cannot be built from an\
    \ iterator over elements of type `Cloned<std::slice::Iter<'_, isize>>`\n    -->\
    \ /tmp/tmp1_kr0y3a.rs:20:60\n     |\n20   |         let mut it = lst.iter().map(|c|\
    \ c.iter().cloned()).collect::<Vec<Vec<isize>>>().into_iter().enumerate();\n \
    \    |                                                            ^^^^^^^ value\
    \ of type `Vec<Vec<isize>>` cannot be built from `std::iter::Iterator<Item=Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n     |\n     = help: the trait `FromIterator<Cloned<std::slice::Iter<'_,\
    \ isize>>>` is not implemented for `Vec<Vec<isize>>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1_kr0y3a.rs:21:16\n   |\n21 |         if x <\
    \ it.next().unwrap() {\n   |                ^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found tuple\n   |\n   = note: expected type `isize`\n             found tuple\
    \ `(usize, Vec<isize>)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_kr0y3a.rs:24:61\n\
    \   |\n24 |         let mut it2 = it.map(|(i, c)| c.iter().skip(i).take(x)).collect::<Vec<Vec<(isize,\
    \ isize)>>>();\n   |                                                         \
    \    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n24 |      \
    \   let mut it2 = it.map(|(i, c)| c.iter().skip(i).take(x.try_into().unwrap())).collect::<Vec<Vec<(isize,\
    \ isize)>>>();\n   |                                                         \
    \     ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<Vec<(isize, isize)>>`\
    \ cannot be built from an iterator over elements of type `std::iter::Take<Skip<std::slice::Iter<'_,\
    \ isize>>>`\n    --> /tmp/tmp1_kr0y3a.rs:24:65\n     |\n24   |         let mut\
    \ it2 = it.map(|(i, c)| c.iter().skip(i).take(x)).collect::<Vec<Vec<(isize, isize)>>>();\n\
    \     |                                                                 ^^^^^^^\
    \ value of type `Vec<Vec<(isize, isize)>>` cannot be built from `std::iter"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    for col in lst.iter().rev() {\n        let mut x = x;\n \
    \       let mut y = col.iter().rev().find(|x| *x == x).unwrap();\n        while\
    \ let Some((r, c)) = y.map(|x| *x).min_max(|a, b| *b - a as isize) {\n       \
    \     res.push((r as isize, c as isize));\n            x = c;\n        }\n   \
    \     if x == 0 {\n            break;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpo_ph0967.rs:20:50\n\
    \   |\n20 |         let mut y = col.iter().rev().find(|x| *x == x).unwrap();\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<&&isize>` for `&isize`\n\nerror[E0599]: `&isize` is not an iterator\n\
    \  --> /tmp/tmpo_ph0967.rs:21:36\n   |\n21 |         while let Some((r, c)) =\
    \ y.map(|x| *x).min_max(|a, b| *b - a as isize) {\n   |                      \
    \              ^^^ `&isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `&isize: Iterator`\n          \
    \ which is required by `&mut &isize: Iterator`\n           `isize: Iterator`\n\
    \           which is required by `&mut isize: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = Vec::new();\n    rows.push(vec![(x0, 0)]);\n    let mut last_row = rows[0].clone();\n\
    \    let mut cols = 0;\n    for col in lst {\n        let mut temp_row: Vec<(isize,\
    \ isize)> = Vec::new();\n        if col[cols].0 >= x {\n            temp_row.push((last_row[0].0,\
    \ col[cols].1));\n            last_row = temp_row;\n        }\n        else {\n\
    \            last_row.push((last_row[0].0, col[cols].1));\n            rows.push(temp_row);\n\
    \        }\n        cols += 1;\n    }\n    rows\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `x0` in this scope\n  --> /tmp/tmpo8d8jhn9.rs:18:21\n\
    \   |\n18 |     rows.push(vec![(x0, 0)]);\n   |                     ^^ help: a\
    \ local variable with a similar name exists: `x`\n\nerror[E0610]: `isize` is a\
    \ primitive type and therefore doesn't have fields\n  --> /tmp/tmpo8d8jhn9.rs:23:22\n\
    \   |\n23 |         if col[cols].0 >= x {\n   |                      ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpo8d8jhn9.rs:24:53\n\
    \   |\n24 |             temp_row.push((last_row[0].0, col[cols].1));\n   |   \
    \                                                  ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpo8d8jhn9.rs:28:53\n\
    \   |\n28 |             last_row.push((last_row[0].0, col[cols].1));\n   |   \
    \                                                  ^\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0425, E0610.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    debug_assert!(!lst.is_empty());\n\
    \    debug_assert!(x >= 0 && x < lst.len());\n    let mut row_coord = Vec::new();\n\
    \    let mut cols = lst[x].len();\n    let mut row_max = -1;\n    let mut row_min\
    \ = 1;\n    for (y, vec) in lst.iter().enumerate() {\n        if y == x {\n  \
    \          row_coord.clear();\n            row_coord.push((0, y));\n         \
    \   return row_coord;\n        }\n        for elt in vec.iter().rev() {\n    \
    \        if elt > row_max {\n                row_max = elt;\n            }\n \
    \           if elt < row_min {\n                row_min = elt;\n            }\n\
    \        }\n        for elt in vec.iter().rev() {\n            if elt > row_max\
    \ {\n                row_max = elt;\n            }\n            if elt < row_min\
    \ {\n                row_min = elt;\n            }\n        }\n        if row_max\
    \ == row_min {\n            row_coord.clear();\n            row_coord.push((0,\
    \ x));\n            row_coord.push((x, x));\n            return row_coord;\n \
    \       }\n        let mut col = -1;\n        for elt in vec.iter().rev() {\n\
    \            if elt > row_max {\n                row_max = elt;\n            }\n\
    \            if elt < row_min {\n                row_min = elt;\n            }\n\
    \            col = elt as isize;\n        }\n        let mut cnt = 0;\n      \
    \  for elt in vec.iter().rev() {\n            if elt > row_max {\n           \
    \     row_max = elt;\n            }\n            if elt < row_min {\n        \
    \        row_min = elt;\n            }\n            if elt == x {\n          \
    \      row_coord.clear();\n                row_coord.push((0, y));\n         \
    \       row_coord.push((x, x));\n                row_coord.push((x, y));\n   \
    \             return row_coord;\n            }\n            cnt += 1;\n      \
    \  }\n        row_coord.push((col + cnt, x));\n        cols += cnt;\n    }\n \
    \   vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0gdm_r9.rs:18:33\n   |\n\
    18 |     debug_assert!(x >= 0 && x < lst.len());\n   |                       \
    \          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    18 |     debug_assert!(x >= 0 && x < lst.len().try_into().unwrap());\n   |   \
    \                                       ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[Vec<isize>]` cannot be indexed by `isize`\n  --> /tmp/tmpj0gdm_r9.rs:20:20\n\
    \   |\n20 |     let mut cols = lst[x].len();\n   |                    ^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj0gdm_r9.rs:24:17\n   |\n24 |         if y ==\
    \ x {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |         if y == x.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0gdm_r9.rs:27:20\n\
    \   |\n27 |             return row_coord;\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<({integer}, usize)>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj0gdm_r9.rs:30:22\n   |\n30 |             if elt > row_max\
    \ {\n   |                      ^^^^^^^\n   |                      |\n   |    \
    \                  expected `&isize`, found integer\n   |                    \
    \  help: consider borrowing here: `&row_max`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj0gdm_r9.rs:31:27\n   |\n21 |     let mut row_max = -1;\n   | \
    \                      -- expected due to this value\n...\n31 |              \
    \   row_max = elt;\n   |                          "
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ sorted_rows: Vec<(isize, isize)> = vec![(0, x)]\n        .into_iter()\n    \
    \    .sort_by(|a, b| a.0.cmp(&b.0))\n        .collect();\n    let mut sorted_cols:\
    \ Vec<(isize, isize)> = vec![(x - 1, 0)]\n        .into_iter()\n        .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n        .collect();\n    for i in sorted_rows.iter_mut()\
    \ {\n        sorted_cols.insert(0, (i - 1, sorted_cols[0].1));\n    }\n    sorted_cols.iter()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpmdan3ii9.rs:19:10\n   |\n19 |         .sort_by(|a,\
    \ b| a.0.cmp(&b.0))\n   |          ^^^^^^^ method not found in `std::vec::IntoIter<({integer},\
    \ isize)>`\n\nerror[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpmdan3ii9.rs:23:10\n   |\n23 |         .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n   |          ^^^^^^^ method not found in `std::vec::IntoIter<(isize,\
    \ {integer})>`\n\nerror[E0369]: cannot subtract `{integer}` from `&mut (isize,\
    \ isize)`\n  --> /tmp/tmpmdan3ii9.rs:26:34\n   |\n26 |         sorted_cols.insert(0,\
    \ (i - 1, sorted_cols[0].1));\n   |                                - ^ - {integer}\n\
    \   |                                |\n   |                                &mut\
    \ (isize, isize)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmdan3ii9.rs:28:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n28 |     sorted_cols.iter()\n\
    \   |     ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `std::slice::Iter`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `std::slice::Iter<'_, (isize, isize)>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = 0;\n    let mut column = lst.len() - 1;\n    while row < lst.len() {\n\
    \        let left = column - 1;\n        if left < 0 {\n            break;\n \
    \       }\n        let right = column + 1;\n        if right > lst.len() - 1 {\n\
    \            break;\n        }\n        if left*right == column {\n          \
    \  row += 1;\n            column = 0;\n        }\n        column -= 1;\n     \
    \   if row*column == x {\n            return vec!((row, column));\n        }\n\
    \        column += 1;\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc79cptxj.rs:33:26\n   |\n\
    33 |         if row*column == x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |         if row*column == x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc79cptxj.rs:34:26\n   |\n34 |             return vec!((row,\
    \ column));\n   |                          ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |             return vec!((row.try_into().unwrap(),\
    \ column));\n   |                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc79cptxj.rs:34:31\n   |\n34 |             return\
    \ vec!((row, column));\n   |                               ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             return vec!((row,\
    \ column.try_into().unwrap()));\n   |                                     ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010913
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row = Vec::new();\n    row.push(0);\n    let mut last_column = x;\n\n    for\
    \ vec in lst {\n        row.push((vec.len() - 1, last_column));\n        last_column\
    \ = vec.len() - 1;\n    }\n\n    row.sort_by(|a, b| a[0].1.cmp(&b[0].1));\n  \
    \  row.sort_by(|a, b| a[0].2.cmp(&b[0].2));\n\n    let mut row: Vec<(isize, isize)>\
    \ = Vec::new();\n\n    for (i, (_, column)) in row.iter().enumerate() {\n    \
    \    if i == 0 {\n            row.push((i, column));\n            continue;\n\
    \        }\n\n        for (j, (_, last_column)) in row.iter().enumerate() {\n\
    \            if j == 0 {\n                continue;\n            }\n\n       \
    \     if i == j {\n                row.push((i, j));\n                break;\n\
    \            }\n        }\n    }\n\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpclzpi9l6.rs:22:18\n   |\n\
    22 |         row.push((vec.len() - 1, last_column));\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(usize, isize)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpclzpi9l6.rs:23:23\n   |\n19 |     let mut last_column = x;\n  \
    \ |                           - expected due to this value\n...\n23 |        \
    \ last_column = vec.len() - 1;\n   |                       ^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0608]: cannot index into a value of type `&{integer}`\n\
    \  --> /tmp/tmpclzpi9l6.rs:26:24\n   |\n26 |     row.sort_by(|a, b| a[0].1.cmp(&b[0].1));\n\
    \   |                        ^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `&{integer}`\n  --> /tmp/tmpclzpi9l6.rs:26:36\n   |\n26 |     row.sort_by(|a,\
    \ b| a[0].1.cmp(&b[0].1));\n   |                                    ^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&{integer}`\n  --> /tmp/tmpclzpi9l6.rs:27:24\n\
    \   |\n27 |     row.sort_by(|a, b| a[0].2.cmp(&b[0].2));\n   |               \
    \         ^^^^\n\nerror[E0608]: cannot index into a value of type `&{integer}`\n\
    \  --> /tmp/tmpclzpi9l6.rs:27:36\n   |\n27 |     row.sort_by(|a, b| a[0].2.cmp(&b[0].2));\n\
    \   |                                    ^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpclzpi9l6.rs:33:23\n   |\n33 |             row.push((i, column));\n\
    \   |                       ^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n33 |             row.push((i.try_into().unwrap(), column));\n   |\
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpclzpi9l6.rs:33:26\n   |\n33 |             row.push((i, column));\n\
    \   |                          ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n33 |             row.push((i, *column));\n\
    \   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1660010913
