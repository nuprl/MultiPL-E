name: HumanEval_44_change_base
language: rs
prompt: "/// Change numerical base of input number x to base.\n/// return string representation\
  \ after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8,\
  \ 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\"\
  )\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize,\
  \ base: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
  \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
  ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
  \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
  1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
  \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
  ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
  \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
  ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
completions: ["    let mut s = String::new();\n    match x {\n        0 | 1 | 2 |\
    \ 3 | 4 | 5 | 6 | 7 | 8 | 9 | a => s.push('0'),\n        b | c | d | e | f | g\
    \ | h | i | j | k | l | m | n | o | p | q | r | s => s.push(x),\n        x =>\
    \ {\n            let mut y = x;\n            while y > base {\n              \
    \  y /= base;\n                s.push(*'0' + base);\n            }\n         \
    \   while y < 10 {\n                s.push(y % base);\n                y /= base;\n\
    \            }\n        }\n    }\n    s", '    String::from_str(to_str(x)).to_string(base)',
  "    if base < 2 {\n        panic!(\"base number must be less than 2\");\n    }\n\
    \    if x < base {\n        panic!(\"base number must be greater than x\");\n\
    \    }\n\n    let mut s = String::from(\"\");\n    for i in 0..base {\n      \
    \  let mut c = x;\n        while c > base {\n            c -= base;\n        }\n\
    \        s += format!(\"{}\", c);\n    }\n    s", '    format!("{}{}", x / base,
    &(x % base))', "    let mut s = String::new();\n    let mut carry = false;\n \
    \   for i in (0..x).step_by(base) {\n        let digit = x.0 % base;\n       \
    \ let digit = digit > 9 ? digit - 9 + 9 : digit;\n        if digit != 0 {\n  \
    \          s.push((digit as u32 + '0').to_string());\n        }\n        carry\
    \ += digit < 10;\n        x = x / base - 1;\n    }\n    if carry != 0 {\n    \
    \    s.push((1 as u32 + '0').to_string());\n    }\n    s", "    let mut digits\
    \ = String::new();\n    let mut remainder = 0;\n    while x >= base {\n      \
    \  remainder = x % base;\n        digits.insert(0, format!(\"{}\", remainder));\n\
    \        x /= base;\n    }\n    if x != 0 {\n        digits.insert(0, format!(\"\
    {}\", x));\n    }\n    digits", "    if base > 10 {\n        String::from(\"bases\
    \ lower than 10\")\n    } else {\n        match x {\n            0 => String::from(\"\
    0\"),\n            1 => String::from(\"1\"),\n            base if base == 10 =>\
    \ String::from(\"10\"),\n            x if x == 0 => String::from(\"0\"),\n   \
    \         x if x > 0 => String::from(\"1\"),\n            _ => String::from(\"\
    0\"),\n        }\n        .to_digits()\n        .unwrap()\n        .collect::<Vec<_>>()\n\
    \        .join(\"\")\n    }", "    if base < 10 {\n        String::from(\"0\"\
    ).to_string()\n    }\n    let mut res = String::from(\"\");\n    let mut pow =\
    \ 1;\n    while x > base {\n        res.push_str(&format!(\"{}\", x / base));\n\
    \        res.push_str(&format!(\"{}\", x%base));\n        pow *= base;\n     \
    \   x /= base;\n    }\n    res.push_str(&format!(\"{}\", x));\n    res.push_str(&format!(\"\
    {}\", pow));\n    res", "    match base {\n        1 => \"1\",\n        2 => \"\
    10\",\n        _ => format!(\"{}\", num2str(x, base)),\n    }", '    x.to_string().as_bytes()
    + base.to_string().as_bytes().to_radix(base, &mut [0; 36]).to_string()', "   \
    \ let mut result = String::new();\n    let mut x = x;\n    while x != 0 {\n  \
    \      if x < base {\n            result.push(b'0');\n        }\n        result.push(b'1');\n\
    \        x /= base;\n    }\n    if base == 2 {\n        result.reverse();\n  \
    \  }\n    result", "    let mut s = String::new();\n    let mut remainder: isize\
    \ = x;\n    let mut remainder_base: isize = 1;\n\n    if base > 10 {\n       \
    \ panic!(\"Base must less than 10\");\n    }\n\n    while remainder != 0 {\n \
    \       let mut remainder_temp: isize = 0;\n        let mut current_digit: isize\
    \ = 0;\n        let mut quotient: isize = 0;\n        quotient = remainder / base;\n\
    \        remainder = remainder % base;\n\n        while quotient != 0 {\n    \
    \        current_digit = quotient % base;\n            quotient = quotient / base;\n\
    \            remainder_temp = remainder_temp + current_digit*remainder_base;\n\
    \            remainder_base = base;\n        }\n\n        remainder = remainder_temp;\n\
    \        s.push(i);\n    }\n    s", "    match base {\n        2 => \"0{}\",\n\
    \        3 => \"00{}\",\n        4 => \"000{}\",\n        5 => \"0000{}\",\n \
    \       _ => if base == 10 {\n            format!(\"{}\", x)\n        } else {\n\
    \            let mut s = String::new();\n            let mut digits: Vec<isize>\
    \ = vec![x, 0, 1];\n            while let Some(&i) = digits.iter().nth(0) {\n\
    \                s = format!(\"{}{}\", s, i).to_string();\n                digits.pop();\n\
    \            }\n            format!(\"{}\", s)\n        },\n    }", "    let mut\
    \ digits = String::new();\n    for d in x.to_string().chars().cloned().rev() {\n\
    \        digits.push_str(d.to_string(base).chars().cloned().rev());\n    }\n \
    \   digits", "    let mut x = x;\n    let mut y = base;\n\n    let mut digits\
    \ = String::new();\n\n    while x > 0 {\n        let tmp = x % base;\n       \
    \ digits.push(&to_digit(&tmp));\n        y /= base;\n        x = x;\n    }\n\n\
    \    let mut tmp = to_digit(y);\n    while tmp.len() > 1 {\n        digits.unshift(tmp[tmp.len()\
    \ - 1]);\n        tmp = &tmp[tmp.len() - 1];\n    }\n    digits.unshift(tmp);\n\
    \n    digits", "    let mut s = String::new();\n    for i in 0..x.bit_length()\
    \ {\n        let mut binary = if x > (base * ((x as usize - 1) as isize))\n  \
    \          then base * ((x as usize - 1) as isize)\n            else (x as usize\
    \ - 1);\n        if i > 0 && (x & ((base * (i as isize)) - 1) as isize) != 0 {\n\
    \            binary += 1;\n        }\n        s += binary.to_string();\n    }\n\
    \    s", "    let mut y = x;\n    let mut carry: isize = 0;\n    let mut new_base:\
    \ isize = base;\n    let mut new_str: String = \"\";\n\n    // While x is greater\
    \ than the base and carry is non-zero, shift x by\n    // one and add carry to\
    \ the new base.\n    while y >= new_base && carry != 0 {\n        new_str = format!(\"\
    {}{}\", &new_str, &new_base);\n        y = y / new_base;\n        carry = y %\
    \ new_base;\n    }\n\n    // If x is greater than the base, add carry to the new\
    \ base.\n    while y > new_base {\n        new_str = format!(\"{}{}\", &new_str,\
    \ &new_base);\n        y = y / new_base;\n        carry = y % new_base;\n    }\n\
    \n    // If carry is not 0, add it to the new base.\n    if carry != 0 {\n   \
    \     new_str = format!(\"{}{}\", &new_str, &carry);\n    }\n\n    new_str", " \
    \   let mut string = String::new();\n    while x >= base {\n        string.push((x%base)\
    \ as char);\n        x /= base;\n    }\n    string.push((x as char) as char);\n\
    \    string.push((x) as char);\n    string", "    assert!(base < 10, \"Base must\
    \ be less than 10.\");\n    let mut s = String::new();\n    for i in 0..(x / base)\
    \ {\n        let base = i as isize;\n        let mut tmp = 1;\n        for j in\
    \ 0..(base - 1) {\n            tmp *= x;\n        }\n        let mut digit = String::from(\"\
    0\");\n        for i in 0..base.to_digit() {\n            digit.push((tmp % base)\
    \ as char);\n            tmp /= base;\n        }\n        s.push_str(&digit);\n\
    \    }\n    if x % base != 0 {\n        let mut tmp = 1;\n        for i in 0..(base.to_digit()\
    \ - 1) {\n            tmp *= x;\n        }\n        let mut digit = String::from(\"\
    0\");\n        for i in 0..base.to_digit() {\n            digit.push((tmp % base)\
    \ as char);\n            tmp /= base;\n        }\n        s.push_str(&digit);\n\
    \    }\n    s", "    let mut digits = String::new();\n    let mut x = x.to_digits(base);\n\
    \    while !x.is_empty() {\n        digits.push_str(&x[..]);\n        x = x.to_digits(base);\n\
    \    }\n    String::from(digits)", "    let mut string: String = String::new();\n\
    \n    // convert x to base 10 to get the number of digits\n    let mut num_digits\
    \ = to_base10(x);\n\n    // add the new base to the number of digits\n    num_digits\
    \ = num_digits.to_string(base).unwrap();\n\n    // now convert the number of digits\
    \ to base 10\n    let mut num_base10 = from_base10(num_digits);\n\n    // add\
    \ leading zeros if needed.\n    // this works because we know the base is less\
    \ than 10\n    while num_base10 > base {\n        num_base10 = num_base10.saturating_sub(base);\n\
    \        string.push(b'0');\n    }\n\n    // now add the number in base 10\n \
    \   string.push_str(&num_base10).unwrap();\n\n    string", "    let mut result\
    \ = String::with_capacity(x.to_string().len());\n    if base == 10 {\n       \
    \ if x >= 0 {\n            result.push_str(x.to_string());\n        } else {\n\
    \            result.push_str(\"-0\".to_string());\n        }\n    } else {\n \
    \       let mut r = x;\n        while r > 0 {\n            if r % base == 0 {\n\
    \                result.push_str(r.to_string_lossy().to_string());\n         \
    \       break;\n            }\n            r = r / base;\n        }\n    }\n \
    \   result", "    let mut s = String::new();\n    let mut n = x;\n    while n\
    \ > 0 {\n        if n < base {\n            s.push_str(&str::from_digit(n % base,\
    \ 10));\n        }\n        n /= base;\n    }\n    s", "    if base < 2 {\n  \
    \      String::from(\"0\")\n    }\n    let mut s = String::from(\"0\");\n    let\
    \ mut i = 0;\n    while i < base.to_i32() {\n        if i >= 10 {\n          \
    \  s.push('0');\n            i += 1;\n        } else {\n            s.push('1');\n\
    \            i += 1;\n        }\n    }\n    s += x.to_digits(10);\n    String::from(s)",
  "    let mut x = x as usize;\n    let mut r = String::new();\n\n    while x >= base\
    \ {\n        r.push((x % base) as char);\n        x = x / base;\n    }\n    r.push((x\
    \ as char));\n    r", "    let mut x: u64 = x;\n    let base = base;\n    let\
    \ mut result: String = String::new();\n    if x <= base {\n        if x % base\
    \ == 0 {\n            return x.to_string();\n        }\n        x.set_bit(base\
    \ - 1);\n        result.set_bit(base - 1);\n        let mut j = base;\n      \
    \  while j > 1 {\n            x.set_bit(j - 1);\n            x.set_bit(j - 2);\n\
    \            result.push((x % base).to_string());\n            x.set_bit(j - 2);\n\
    \            x.set_bit(j - 1);\n            j -= 2;\n        }\n        result.push((x\
    \ % base).to_string());\n    } else {\n        x.set_bit(base - 1);\n        result.set_bit(base\
    \ - 1);\n        let mut j = base;\n        while j > 1 {\n            x.set_bit(j\
    \ - 1);\n            x.set_bit(j - 2);\n            result.push((x % base).to_string());\n\
    \            x.set_bit(j - 2);\n            x.set_bit(j - 1);\n            j -=\
    \ 2;\n        }\n        let mut j = base - 1;\n        while j >= 1 {\n     \
    \       result.push((x % base).to_string());\n            x.set_bit(j - 1);\n\
    \            x.set_bit(j - 2);\n            j -= 2;\n        }\n    }\n    result",
  "    match base {\n        1 => String::from(\"0\"),\n        2 => String::from(\"\
    1\"),\n        3 => String::from(\"10\"),\n        4 => String::from(\"11\"),\n\
    \        5 => String::from(\"100\"),\n        6 => String::from(\"101\"),\n  \
    \      7 => String::from(\"110\"),\n        8 => String::from(\"111\"),\n    \
    \    _ => {\n            let mut s = String::from(\"0\");\n            for (i,\
    \ j) in x.chars().enumerate() {\n                let c = (i * base) + j as usize;\n\
    \                s.push_str(&from_digit(c));\n            }\n            s\n \
    \       }\n    }", "    let mut res = String::from(\"0\");\n    while x != 0 {\n\
    \        let mut div = x;\n        while div > 0 {\n            res.insert(res,\
    \ base, '0');\n            div /= base;\n        }\n        res.insert(res, base,\
    \ '1');\n        x /= base;\n    }\n    res", "    let mut s = String::from(\"\
    0\");\n    match x {\n        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | _ as v =>\
    \ s.push_str(&format!(\"{:#0{}b}\", v, base)),\n        _ => panic!(\"Input out\
    \ of base range\"),\n    }\n    s", "    if x <= base {\n        return String::from_str(&format!(\"\
    {}\", x as isize))\n    } else {\n        let mut res = String::new();\n     \
    \   for i in x.to_string().chars().rev() {\n            res.push_str(&format!(\"\
    {}{}\", base * (i as usize), i));\n        }\n        res\n    }", "    let mut\
    \ result = String::new();\n    let mut base = x;\n    let mut i = 1;\n\n    while\
    \ base >= 10 {\n        result = format!(\"{}{}\", &result, &base % 10);\n   \
    \     base /= 10;\n        i += 1;\n    }\n\n    if base > 0 {\n        result\
    \ = format!(\"{}{}\", &result, &base);\n    }\n\n    String::from(result)", " \
    \   let mut s = String::with_capacity(x.checked_mul(base).unwrap_or(x.checked_div(base).unwrap_or(10)));\n\
    \    let mut x = x;\n    while x >= base {\n        let digit = x % base;\n  \
    \      s += digit.to_string();\n        x /= base;\n    }\n    s += x.to_string();\n\
    \    s", "    let mut x = x / base;\n    let result = x.to_string();\n    while\
    \ x < 10 {\n        x += (base as isize);\n        result += (x as isize).to_string();\n\
    \    }\n    result", "    let mut x = x % base;\n    if x < base {\n        x\
    \ = base;\n    }\n    String::from(\"{}{}\".format(&x, &base))", "    use std::str::FromStr;\n\
    \    let mut result = String::new();\n    loop {\n        let digits = x.to_digits().unwrap();\n\
    \        if digits < base {\n            result.push(digits);\n            x +=\
    \ digits;\n            continue;\n        }\n        let based = digits / base;\n\
    \        let remainder = digits % base;\n        result.push(based.to_string());\n\
    \        x = base;\n        x += remainder;\n    }\n    result", "    use core::borrow::Cow;\n\
    \    let mut result: Vec<usize> = x.to_string().chars().collect();\n    let mut\
    \ base = base_from_digit(base);\n\n    for mut i = result.len() - 1; i >= 0; i\
    \ -= 1 {\n        let digit = base_to_digit(result[i]);\n        result[i] = digit\
    \ + 1;\n    }\n\n    Cow::Owned(result.into_owned())", "    let mut s = String::from(\"\
    0\");\n    for i in x.to_string().chars() {\n        if i.is_digit() {\n     \
    \       if i.to_digit() >= base {\n                s.insert(0, &format!(\"{}\"\
    , i));\n            } else {\n                s.insert(0, &format!(\"{}\", i.to_digit()\
    \ % base));\n            }\n        } else {\n            s.insert(0, \"0\");\n\
    \        }\n    }\n    s", "    let mut x = x;\n    if base == 10 {\n        return\
    \ String::from(\"0\");\n    }\n    while x >= base {\n        x /= base;\n   \
    \ }\n    let mut rep = String::from(\"\".to_string());\n    while x >= base {\n\
    \        rep.insert(0, x % base);\n        x /= base;\n    }\n    rep.insert(0,\
    \ x);\n    rep", "    let mut s = String::new();\n    x.div_rem(&base, &mut s);\n\
    \    s", "    let mut result = String::new();\n\n    let mut base_digit = x.to_digits().collect::<Vec<_>>();\n\
    \n    let mut i = 0;\n\n    while i < base_digit.len() {\n        let mut rem\
    \ = base_digit[i] - base;\n        if rem < 0 {\n            base_digit.remove(i);\n\
    \            i += 1;\n        } else {\n            base_digit[i] = rem + base;\n\
    \            i += 1;\n        }\n    }\n\n    result.set_str(base_digit, |s| s.to_string());\n\
    \    result", "    let mut s = String::new();\n    while x > 0 {\n        if x\
    \ % base == 0 {\n            s += String::from(&format!(\"{}\", x / base));\n\
    \        }\n        x = x / base;\n    }\n    s", "    let mut s = String::from(\"\
    0\");\n    match x.checked_mul(base) {\n        Some(mut v) => s += &mut to_string(v),\n\
    \        None => {}\n    }\n    s", "    let mut ret: String = \"\";\n    let\
    \ mut base_val = x;\n    let mut base_in_hex = base;\n    let mut base_in_oct\
    \ = base;\n    if x > base {\n        base_val -= base;\n        base_in_hex =\
    \ base;\n        base_in_oct = base;\n    }\n    while base_val > 0 {\n      \
    \  ret += to_digit(base_val % base_in_oct);\n        base_val = (base_val / base_in_oct).wrapping_mul(base_in_oct);\n\
    \    }\n    ret += to_digit(base_val);\n    ret", "    match x.checked_mul(base)\
    \ {\n        Some(x) => String::from(x),\n        None => String::from(x.to_string()),\n\
    \    }", "    let mut x: i32 = x;\n    let mut base: i32 = base;\n    let mut\
    \ result: i32;\n\n    // base can be negative or positive\n    if base > 0 &&\
    \ x >= 10 {\n        x = x - 10;\n        result = x;\n    }\n    if base < 0\
    \ && x <= 10 {\n        result = x * -1;\n    }\n\n    let mut s = String::new();\n\
    \    while result != 0 {\n        s = format!(\"{}{}\", result, s);\n        result\
    \ = result / base;\n    }\n    s", "    let mut new_str = String::from(\"0\");\n\
    \    for &b in x.to_digits().iter() {\n        let a = b / base;\n        if a\
    \ > 9 {\n            new_str = new_str.push_str(&format!(\"{}\", a + 10).to_string());\n\
    \        } else {\n            new_str = new_str.push_str(&format!(\"{}\", a).to_string());\n\
    \        }\n    }\n    new_str", "    let mut result = String::new();\n    for\
    \ d in x.checked_mul::<i32>().unwrap() {\n        let d = d * base;\n        if\
    \ d < 10 {\n            result.push_str(&d.to_string());\n        } else {\n \
    \           result.push_str(&format!(\"{:03}\", d).to_string());\n        }\n\
    \    }\n    result", "    let mut s = String::from(\"0\");\n    if x <= base {\n\
    \        s ++= &to_digit(x - base);\n    } else {\n        s ++= &to_digit(x /\
    \ base) as String;\n        x -= base * to_digit(x / base);\n    }\n    while\
    \ x > 0 {\n        s ++= &to_digit(x / base) as String;\n        x -= base * to_digit(x\
    \ / base);\n    }\n    s", "    let mut result = String::new();\n    while x >\
    \ 0 {\n        result.push((x / base).to_string());\n        x %= base;\n    }\n\
    \    result", "    assert!((base >= 2 && base <= 36), \"Invalid base\");\n\n \
    \   let mut numeral = String::new();\n\n    for i in x.to_digits(10) {\n     \
    \   numeral.push(i / base);\n        numeral.push(i%base);\n    }\n\n    numeral.to_owned()",
  "    if base < 2 {\n        let mut str = String::from(\"0\");\n        for x in\
    \ x.to_string().chars().rev() {\n            str = format!(\"{}{}\", str.chars().remove(x),\
    \ x.to_digit(base).to_string());\n        }\n        return str;\n    }\n    let\
    \ mut str = String::from(\"1\");\n    for i in x.to_string().chars().rev() {\n\
    \        let digit = i.to_digit(base).unwrap();\n        str = format!(\"{}{}\"\
    , str.chars().remove(0), digit);\n    }\n    str", "    if x < 10 {\n        if\
    \ base < 10 {\n            format!(\"0{}\", x)\n        } else {\n           \
    \ format!(\"{}\", x)\n        }\n    } else {\n        let mut res = String::from(\"\
    \".to_string());\n        let mut base = x % base;\n        for i in 1..10 {\n\
    \            let mut c = base / i;\n            base = i % base;\n           \
    \ res.push_str(&format!(\"{}\", c));\n        }\n        res.push_str(&format!(\"\
    {}\", base));\n        res\n    }", "    let mut s: String = \"\".to_string();\n\
    \    let mut base_num: isize = 1;\n    for y in x.divmod_mul(base) {\n       \
    \ base_num *= base;\n        if y < base_num {\n            s += char::from(\"\
    0\").to_string();\n        } else {\n            s += char::from(\"1\").to_string();\n\
    \        }\n    }\n    s += String::from_str(&x.to_string()[..base_num.digits()\
    \ - 1]).unwrap()", "    x.to_string().parse::<usize>().checked_mul(base).ok()\n\
    \        .to_string()\n        .parse::<isize>()\n        .ok()\n        .to_string()",
  "    if x != 0 && base != 0 && base < 10 {\n        let mut result = String::new();\n\
    \        if base > 10 {\n            result.push_str(&format!(\"{:#}\", x / base));\n\
    \            result.push_str(&format!(\"0{}\", base % base));\n        } else\
    \ {\n            result.push_str(&format!(\"{}\", x % base));\n        }\n   \
    \     result\n    } else {\n        \"\".to_string()\n    }", "    let mut s =\
    \ String::from(\"0\");\n    for n in x.to_string().chars().skip(base) {\n    \
    \    s.push_str(&n.to_string());\n    }\n    s", "    assert!(base < 10);\n  \
    \  let mut result = String::from(\"\".to_string());\n    if base < 10 {\n    \
    \    result = result.push_str(&x.to_string());\n    }\n    if base > 10 {\n  \
    \      let mut digits = x.to_string().chars().collect::<Vec<_>>();\n        for\
    \ i in base..10 {\n            digits.insert((base * i) - 10, i);\n        }\n\
    \        result = result.push_str(&digits.join(\"\"));\n    }\n    result", " \
    \   let mut s = String::from(x);\n    let mut result = String::new();\n    while\
    \ base > 0 {\n        let mut rem = &s[..base.digits().len()];\n        let mut\
    \ digits = &mut result[..base.digits().len()];\n        digits.copy_from_slice(rem.digits());\n\
    \        let mut carry = &mut digits[base.digits().len()];\n        let mut quotient\
    \ = x;\n        let mut remainder = 0;\n        while quotient > 0 {\n       \
    \     carry += &mut quotient % 10;\n            quotient /= 10;\n        }\n \
    \       if carry > 0 {\n            carry += 1;\n            digits.insert(0,\
    \ &mut carry);\n        }\n        result = &result[..base.digits().len()] + &digits[base.digits().len()..];\n\
    \        base /= 10;\n    }\n    result", "    let mut new_x = x;\n    while new_x\
    \ != 0 {\n        let new_base = if base > 10 { base % 10 } else { 0 };\n    \
    \    let mut new_num = new_x % base;\n        new_x /= base;\n        new_x =\
    \ new_base * new_x + new_num;\n    }\n    String::from(format!(\"{:?}\", new_x))",
  "    if base < 2 {\n        if base < 10 {\n            return String::from(\"0\"\
    .to_string(base));\n        } else {\n            return String::from(x.to_string(base));\n\
    \        }\n    }\n    let mut res = String::new();\n    for i in 0..x.len() {\n\
    \        res.extend(&x.chars().nth(i).unwrap().to_string());\n    }\n    let mut\
    \ base = BigUint::from(base);\n    while base.is_even() {\n        if res.length()\
    \ > base.len() {\n            base.negate();\n        }\n        res.insert(res.len()\
    \ - base.len(), base.to_string());\n        base.mul_mod(2, &base);\n    }\n \
    \   res", "    let mut buff = String::new();\n    let mut rem = x;\n    while\
    \ rem != 0 {\n        let q = rem / base;\n        rem = rem % base;\n       \
    \ buff.push((base * q).to_string());\n    }\n    buff", "    let mut result =\
    \ String::new();\n    x.to_string().chars().for_each(|c| {\n        let digit\
    \ = match c as char {\n            '0' | '1' => c - '0',\n            '2' | '3'\
    \ => c - '2',\n            '4' | '5' => c - '4',\n            '6' | '7' => c -\
    \ '6',\n            '8' | '9' => c - '8',\n            _ => panic!(\"Invalid character\
    \ {:?} in change base!\", c),\n        };\n        if digit < base {\n       \
    \     result.append(digit as char);\n        } else {\n            result.push((base\
    \ - digit) as char);\n        }\n    });\n    result", "    let mut s = String::from(\"\
    \");\n    loop {\n        if x >= base {\n            x -= base;\n           \
    \ s = format!(\"{}{}\", s, x);\n        } else {\n            s += &format!(\"\
    {}\", x);\n            break;\n        }\n    }\n    s", '    String::from(format!("{}{:0>+}".to_string(),
    x, base))', "    if x >= base * 10 + 1 && x <= base {\n        let mut result\
    \ = String::from(\"1\");\n        let digit = x / base % 10;\n        result.push_str(&format!(\"\
    {:0>0{}}\", digit, base - 1));\n        return result;\n    }\n    format!(\"\
    {}\", x)", "    if x <= 0 {\n        String::from(\"0\")\n    }\n    if base <\
    \ 2 {\n        String::from(\"0\")\n    }\n    if base < 10 {\n        match x\
    \ {\n            1 => String::from(\"1\"),\n            x => String::from(\n \
    \               format!(\"{}{}\", x / base, change_base((x - x / base) * base,\
    \ base).to_owned())\n            ),\n        }\n    } else {\n        match x\
    \ {\n            1 => String::from(\"10\"),\n            x => String::from(\n\
    \                format!(\"{}{}\", x / base, change_base((x - x / base) * base,\
    \ base).to_owned())\n            ),\n        }\n    }", "    let mut result =\
    \ String::with_capacity(x);\n    for &n in x.to_string().chars().take(x.len()\
    \ * 2) {\n        result.push((n % base) as char);\n    }\n    result", "    let\
    \ mut s = String::new();\n    let mut i = x;\n    while (i /= base) {\n      \
    \  *s = i.to_string().to_string()[..1];\n        s += *s;\n    }\n    s += x.to_string()[..];\n\
    \    String::from(s)", "    if x < base {\n        return String::from(\"0\".to_string(base).to_string());\n\
    \    }\n    let mut s = String::from(\"1\".to_string(base).to_string());\n   \
    \ x.to_string().reverse().iter().for_each(|&i| {\n        s.push((i as usize)\
    \ - base + 1).to_string();\n    });\n    s", "    x.to_string().chars().map(|x|\
    \ *x).collect::<String>().to_string()\n        .chars()\n        .enumerate()\n\
    \        .filter(|(i, _)| i >= base)\n        .map(|(i, _)| {\n            let\
    \ mut n = x.to_string().chars().map(|x| *x).collect::<String>();\n           \
    \ n.insert(i, *base);\n            String::from(n)\n        })\n        .collect::<Vec<String>>()\n\
    \        .to_string()", "    let mut result: String = String::new();\n    while\
    \ x > 0 {\n        let quotient = x / base;\n        x = x - quotient * base;\n\
    \        let digit = x.to_digit(base, 10);\n        result.append(&digit);\n \
    \   }\n    result", "    let mut result = \"1\";\n    for &d in x.to_string().chars()\
    \ {\n        let digit = match d { \n            '0' => 0, \n            '1' =>\
    \ 1, \n            '2' => 2, \n            '3' => 3, \n            '4' => 4, \n\
    \            '5' => 5, \n            '6' => 6, \n            '7' => 7, \n    \
    \        '8' => 8, \n            '9' => 9, \n            _ => unimplemented!()\n\
    \        };\n        result = format!(\"{}{}\", result, digit.to_string());\n\
    \    }\n    result", "    let mut string = String::new();\n    let mut remain\
    \ = x;\n    while remain > base {\n        remain = remain - base;\n        string.push((remain\
    \ / base).to_string());\n    }\n    if remain > 0 {\n        string.push((remain\
    \ / base).to_string());\n    }\n    string", "    assert!(base > 0 && base < 10);\n\
    \    match base {\n        1 => String::from(x),\n        2 => {\n           \
    \ let mut r = String::from(\"\");\n            r.push(x);\n            while r.len()\
    \ < x.len() {\n                r.push(x.chars().nth(x.len() - 1 - r.len()).unwrap().to_string());\n\
    \            }\n            r\n        }\n        _ => {\n            let mut\
    \ r = String::from(\"\");\n            r.push(x);\n            while r.len() <\
    \ x.len() {\n                r.push(x[x.len() - 1 - r.len()]);\n            }\n\
    \            r\n        }\n    }", "    let mut s = String::new();\n    let mut\
    \ tmp = x;\n    let mut power: Vec<isize> = vec![1isize; base];\n\n    while tmp\
    \ >= 10isize {\n        tmp = tmp / 10isize;\n        power = power.push(1isize);\n\
    \    }\n\n    for n in power.iter() {\n        s = s.push_str(&format!(\"{}\"\
    , tmp % 10).unwrap());\n        tmp = tmp / n;\n    }\n    s += s.push_str(&format!(\"\
    {}\", tmp).unwrap());\n    s", "    let mut s = String::new();\n    s.push_str(&x.to_string());\n\
    \    let mut pos = 0;\n    let mut digits = x.digits();\n    let mut x = digits.get(base);\n\
    \    while x >= 10 {\n        s.insert(pos, x % 10);\n        x /= 10;\n     \
    \   pos.push((x % 10) + 1);\n    }\n    s.insert(pos, x);\n    String::from(s)",
  "    if base < 2 {\n        return String::from(\"0\");\n    }\n    let mut result\
    \ = String::from(\"1\");\n    while x >= base {\n        if x > base {\n     \
    \       result += String::from(\"0\");\n        }\n        result += '0';\n  \
    \      x -= base;\n    }\n    result += '0';\n    while x >= base {\n        if\
    \ x > base {\n            result += '0';\n        }\n        result += String::from('0');\n\
    \        x -= base;\n    }\n    while x < base {\n        if x < base {\n    \
    \        result += String::from(\"0\");\n        }\n        result += '0';\n \
    \       x += base;\n    }\n    result", "    fn get_digit(digit: isize) -> String\
    \ {\n        format!(\"{:0{}}\", digit, base)\n    }\n\n    let mut result = String::from(\"\
    \");\n    let mut current_digit = x; // start with x as the value of the digit.\n\
    \    while current_digit > 0 {\n        let remain = current_digit % base;\n \
    \       result.push( get_digit(remain));\n        current_digit /= base;\n   \
    \ }\n    result", "    let mut s = String::new();\n    let mut remainder = 0;\n\
    \    while x >= base {\n        remainder = x%base;\n        x /= base;\n    \
    \    s = format!(\"{}{}\", s, &remainder);\n    }\n    if x > 0 {\n        s =\
    \ format!(\"{}{}\", s, x);\n    }\n    s", "    if base < 0 || base > 10 {\n \
    \       panic!(\"Base must be between 0 and 10\");\n    }\n    let mut s: String\
    \ = \"\";\n    for i in x.to_string().chars().rev() {\n        if base % i ==\
    \ 0 {\n            s += &i.to_string();\n            base /= i;\n        }\n \
    \   }\n    s + \"0\".to_string()", "    let mut result = String::with_capacity(10);\n\
    \    let mut temp: isize = x;\n    let mut base = base;\n    while temp > 0 {\n\
    \        let digit = temp mod base;\n        result.push((digit as char).to_string());\n\
    \        temp /= base;\n    }\n    if base > 2 {\n        result.push((base as\
    \ char).to_string());\n    }\n    result", "    format!(\n        \"{:0{}b}\"\
    ,\n        x as u32, base\n    )", "    assert!(base < 10);\n    let mut res =\
    \ String::new();\n    let mut num = x;\n    for _ in 0..base {\n        res.push_str(&num.to_string());\n\
    \        num -= 1;\n    }\n    res.push_str(&num.to_string());\n    res", "  \
    \  let mut x = x;\n    match base {\n        2 => {\n            x = x * 2;\n\
    \            String::from_str(\"100\")\n        }\n        3 => {\n          \
    \  x = x * 3;\n            String::from_str(\"1000\")\n        }\n        4 =>\
    \ {\n            x = x * 4;\n            String::from_str(\"10000\")\n       \
    \ }\n        5 => {\n            x = x * 5;\n            String::from_str(\"100000\"\
    )\n        }\n        6 => {\n            x = x * 6;\n            String::from_str(\"\
    1000000\")\n        }\n        7 => {\n            x = x * 7;\n            String::from_str(\"\
    10000000\")\n        }\n        8 => {\n            x = x * 8;\n            String::from_str(\"\
    100000000\")\n        }\n        9 => {\n            x = x * 9;\n            String::from_str(\"\
    1000000000\")\n        }\n        10 => {\n            x = x * 10;\n         \
    \   String::from_str(\"10000000000\")\n        }\n        _ => panic!(\"Base is\
    \ out of range\"),\n    }\n    String::from_str(format!(\"{}\", x))", "    if\
    \ x < base {\n        let mut s = String::from(\"\");\n        for i in 0..(base\
    \ - x) {\n            s.push(&format!(\"{}\", i));\n        }\n        s.append(&format!(\"\
    {}\", x));\n        return s;\n    }\n    let mut s = String::from(\"\");\n  \
    \  for i in 0..x {\n        s.push(&format!(\"{}\", i));\n    }\n    s.append(&format!(\"\
    {}\", base));\n    return s;", "    let mut result = String::from(\"0\");\n  \
    \  if x > base {\n        result.push_str(&format!(\"{}\", &x / &base));\n   \
    \     x = x;\n    }\n    while x > 0 {\n        if x % base == 0 {\n         \
    \   result.push_str(&format!(\"{}\", &x % base));\n        } else {\n        \
    \    result.push_str(&format!(\"{}\", &x % base));\n            result.push_front(match\
    \ x % base {\n                0 => \"0\",\n                1 => \"1\",\n     \
    \           _ => unreachable!(),\n            });\n        }\n        x = x /\
    \ base;\n    }\n    result", "    use std::cmp::min;\n    use std::cmp::max;\n\
    \n    if x < base {\n        let mut r = String::new();\n        let mut c = x;\n\
    \        while c > base {\n            c /= base;\n            r = format!(\"\
    {}{}\", r, c);\n        }\n        while c < 10 {\n            c *= base;\n  \
    \          r = format!(\"{}{}\", r, c);\n        }\n        r = format!(\"{}\"\
    , r);\n        if min (x, base) < base {\n            r = String::from(\"0\".to_string());\n\
    \        }\n        r\n    } else {\n        if base == 2 {\n            format!(\"\
    {:b}\", x)\n        } else {\n            format!(\"{}\", x)\n        }\n    }",
  "    let mut x = x;\n    let mut base = 10usize;\n    while base > 10 {\n      \
    \  x /= base;\n        base /= 10;\n    }\n    String::from_radix(x as u32, base).unwrap()",
  "    let mut s = String::from(\"0\");\n    let mut carry = false;\n    while x >=\
    \ base {\n        let digit = (x / base) as u8;\n        s = String::from(format!(\"\
    {}{}\", s, digit));\n        x = x % base;\n        carry = true;\n    }\n   \
    \ if carry {\n        s = String::from(format!(\"{}\", x));\n    }\n    s", " \
    \   match (base,x) {\n        (0,0) => String::from(\"0\"),\n        (0,x) =>\
    \ String::from(\"0\"),\n        (1,x) => String::from(\"1\"),\n        (2,x) =>\
    \ String::from(\"10\"),\n        (3,x) => String::from(\"100\"),\n        (4,x)\
    \ => String::from(\"1000\"),\n        (5,x) => String::from(\"10000\"),\n    \
    \    (6,x) => String::from(\"100000\"),\n        (7,x) => String::from(\"1000000\"\
    ),\n        (8,x) => String::from(\"10000000\"),\n        (9,x) => String::from(\"\
    100000000\"),\n        (10,x) => String::from(\"1000000000\"),\n        (11,x)\
    \ => String::from(\"10000000000\"),\n        (12,x) => String::from(\"100000000000\"\
    ),\n        (13,x) => String::from(\"1000000000000\"),\n        (14,x) => String::from(\"\
    10000000000000\"),\n        (15,x) => String::from(\"100000000000000\"),\n   \
    \     (16,x) => String::from(\"1000000000000000\"),\n        (17,x) => String::from(\"\
    10000000000000000\"),\n        (18,x) => String::from(\"100000000000000000\"),\n\
    \        (19,x) => String::from(\"1000000000000000000\"),\n        (20,x) => String::from(\"\
    10000000000000000000\"),\n        (21,x) => String::from(\"100000000000000000000\"\
    ),\n        (22,x) => String::from(\"1000000000000000000000\"),\n        (23,x)\
    \ => String::from(\"10000000000000000000000\"),\n        (24,x) => String::from(\"\
    100000000000000000000000\"),\n        (25,x) => String::from(\"1000000000000000000000000\"\
    ),\n        (26,x) => String::from(\"10000000000000000000000000\"),\n        (27,x)\
    \ => String::from(\"100000000000000000000000000\"),\n        (28,x) => String::from(\"\
    1000000000000000000000000000\"),\n        (29,x) => String::from(\"10000000000000000000000000000\"\
    ),\n        (30,x) => String::from(\"100000000000000000000000000000\"),\n    \
    \    (31,x) => String::from(\"1000000000000000000000000000000\"),\n        (32,x)\
    \ => String::from(\"10000000000000000000000000000000\"),\n        (33,x) => String::from(\"\
    100000000000000000000000000000000\"),\n        (34,x) => String::from(\"1000000000000000000000000000000000\"\
    ),\n        (35,x) => String::from(\"1000000000000000000000000000000000\"),\n\
    \        (36,x) => String::from(\"1000000000000000000000000000000000\"),\n   \
    \     (37,x) => String::from(\"1000000000000000000000000000000000\"),\n      \
    \  (38,x) => String::from(\"1000000000000000000", "    if base < 10 {\n      \
    \  String::from(x * BASE[base])\n    } else {\n        String::from(format!(\"\
    {}\", x))\n    }", "    if base < 2 {\n        let mut string = \"\";\n      \
    \  loop {\n            let mut num = x;\n            let mut remainder = num %\
    \ base;\n            while remainder == 0 {\n                remainder = num %\
    \ base;\n                num /= base;\n            }\n            string += char::to_string(num);\n\
    \            if num > 0 {\n                string += char::to_string(base);\n\
    \            }\n            if num == 0 && remainder == 0 {\n                break;\n\
    \            }\n        }\n        String::from(&string)\n    } else {\n     \
    \   let mut string = \"\";\n        for &x in char::digits(x).iter() {\n     \
    \       if x > base {\n                string += char::to_string(x - base);\n\
    \            } else {\n                string += char::to_string(x);\n       \
    \     }\n        }\n        String::from(&string)\n    }", "    assert!((base\
    \ >= 2) && (base <= 36));\n    let mut s = String::new();\n    s.push_str(&format!(\"\
    {:#0{}b}\", x, base));\n    s", "    let mut out = String::with_capacity(x.to_string().len());\n\
    \    let mut num = x;\n\n    while num > 0 {\n        out.push_str(&num % base);\n\
    \        num /= base;\n    }\n\n    out", "    let mut result = x;\n    let mut\
    \ power = 1;\n    while result >= base {\n        result = result / base;\n  \
    \      power += 1;\n    }\n    let mut base_size = base;\n    while base_size\
    \ != 1 {\n        if x % base_size == 0 {\n            result -= base_size;\n\
    \            x = x / base_size;\n        } else {\n            base_size *= base;\n\
    \        }\n    }\n    format!(\"{}\", result)", "    let mut result = String::new();\n\
    \    let mut digits = vec![String::from(\"\")];\n    while x != 0 {\n        let\
    \ digit = x % base;\n        digits.push(format!(\"{:0>2}\", digit));\n      \
    \  x = x / base;\n    }\n    for &s in &digits {\n        result = format!(\"\
    {}{}\", result, s);\n    }\n    result", "    let mut s = String::from(\"0\");\n\
    \    for i in x.checked_div(base).unwrap() {\n        s = format!(\"{}{}\", s,\
    \ i % base);\n    }\n    s", "    let mut buffer = String::new();\n    let mut\
    \ digits = 0..x;\n    loop {\n        let digit = digits % base;\n        buffer.insert(0,\
    \ digit.to_string());\n        buffer.insert(0, base);\n        buffer.insert(0,\
    \ String::from(\"0\"));\n        digits /= base;\n        if digits == 0 {\n \
    \           break;\n        }\n    }\n    buffer", "    if x < base {\n      \
    \  String::from(\"0\")\n    } else {\n        let mut s = String::from(\"1\");\n\
    \        while x != 0 {\n            s.push_str(&format!(\"{:0>{}}\", x / base,\
    \ base));\n            x %= base;\n        }\n        s\n    }", "    let mut\
    \ s = String::new();\n    if base < 10 {\n        s.push_str(&format!(\"{}\",\
    \ x).as_str().to_string());\n        return s;\n    }\n\n    for i in x.chars().skip_while(|&b|\
    \ b != 0).take(base) {\n        s.push(&format!(\"{}\", i).as_str().to_string());\n\
    \    }\n    s[..]", "    let mut s = String::new();\n    let mut ix = x;\n   \
    \ while ix != 0 {\n        let r = ix % base;\n        s = format!(\"{:b}\", r)\
    \ + s;\n        ix = ix / base;\n    }\n    s", "    let mut s = String::new();\n\
    \    let mut digits = vec![0; base];\n    format!(\"{}\", x).parse::<isize>().unwrap().unwrap()\n\
    \        .chars().enumerate().for_each(|(pos, c)| {\n            *digits[pos.0]\
    \ += usize::from(c) * usize::from(base::from(digits));\n        });\n    for digit\
    \ in digits {\n        if digit > 0 {\n            s.push_str(digit.to_string());\n\
    \        } else {\n            s.push('0');\n        }\n    }\n    s", "    if\
    \ base < 10 {\n        String::from_str(format!(\"{}\", x * base))\n    } else\
    \ {\n        let mut res = String::new();\n        res.push_str(\"0\");\n    \
    \    while res.length() < base {\n            res.push('0');\n        }\n    \
    \    res.push_str(format!(\"{}\", x));\n        res\n    }", "    let mut x =\
    \ x;\n    let mut res = String::new();\n    while x > 0 {\n        res.push_str(&to_base(x\
    \ % base));\n        x /= base;\n    }\n    res.reverse();\n    res", "    let\
    \ mut string = \"\".to_string();\n    let mut remain = x;\n    let mut digit =\
    \ base;\n    while remain > 0 {\n        remain -= digit;\n        string = &string[digit..].to_string()\
    \ + &string[digit];\n        digit *= base;\n    }\n    string", '    x.to_string().chars().take(base).collect::<String>()
    + format!("{:0{}b}", x, base)', "    let mut s = String::new();\n    if x > base\
    \ {\n        let mut t = x;\n        while t > base {\n            t /= base;\n\
    \        }\n        for i in 0..(t - 1) {\n            let mut y = i_to_base(i,\
    \ base);\n            s += &mut y;\n        }\n        s += &mut i_to_base(t -\
    \ 1, base);\n    } else if x < 0 {\n        let mut t = x;\n        while t <\
    \ 0 {\n            t *= base;\n        }\n        for i in 0..(t + 1) {\n    \
    \        let mut y = i_to_base(i, base);\n            s += &mut y;\n        }\n\
    \        s += &mut i_to_base(0, base);\n    } else {\n        for i in 0..(x +\
    \ 1) {\n            let mut y = i_to_base(i, base);\n            s += &mut y;\n\
    \        }\n    }\n    String::from(s)", '    format!("{}{}", x as usize * base,
    base)', "    let mut s = String::new();\n    let mut base = [0u8; 10];\n    let\
    \ mut i = 5;\n    match x % 10 {\n        0 => {\n            base[i] += 1;\n\
    \            i += 1;\n        }\n        _ => {\n            let mut j = 0;\n\
    \            while i > 0 {\n                base[j] += 1;\n                i /=\
    \ 10;\n                j += 1;\n            }\n        }\n    }\n    let mut result\
    \ = [0u8; base.length];\n    if base[0] > 0 {\n        base[0] -= 1;\n       \
    \ result[0] += 1;\n    }\n    for i in 0..base.length - 1 {\n        result[i]\
    \ = result[i - 1] * base[i];\n    }\n    if x < 0 {\n        result.insert(0,\
    \ '-');\n    }\n    for i in result {\n        s += i.to_string();\n    }\n  \
    \  s", "    let mut s = String::new();\n    s.push_str(&x.to_digits().to_string());\n\
    \    s.push_str(&base.to_digits().to_string());\n    s", "    let mut result =\
    \ String::new();\n    let mut remaining = x;\n    while remaining >= base {\n\
    \        result.push((remaining % base) as char);\n        remaining = remaining\
    \ / base;\n    }\n    if remaining > 0 {\n        result.push((remaining as char)\
    \ as char);\n    }\n    result", "    if base <= 0 {\n        return String::from(\"\
    \");\n    }\n    let mut result: String = \"0\";\n    let mut base_digits: Vec<&str>\
    \ = x.to_string().chars().collect();\n    let mut x = base_digits.iter().rev().take(base).collect::<Vec<_>>();\n\
    \    for &i in x {\n        result = format!(\"{}{}\", result, i);\n    }\n  \
    \  result", "    let mut number = x;\n    let mut result = String::new();\n\n\
    \    while number.is_even() {\n        number /= base;\n        result.push((base).to_string());\n\
    \    }\n\n    if number > 0 {\n        while number.is_odd() {\n            number\
    \ *= base;\n            result.push((base).to_string());\n        }\n    }\n\n\
    \    result.push_str(&number)", "    let mut digits = String::new();\n    let\
    \ mut power = 0;\n\n    for digit in digits_iter(x).by_ref() {\n        if digit\
    \ < base {\n            digits += digit.to_string();\n        } else {\n     \
    \       digits += digit.to_string() + &format!(\"{}\", base);\n            power\
    \ += 1;\n        }\n    }\n    digits += &format!(\"{}\", power);\n    digits",
  "    let mut res = String::new();\n    match x {\n        x if base == 10 => format!(\"\
    {:10}\", x).into_owned(),\n        x if base == 8 => format!(\"{:02}\", x).into_owned(),\n\
    \        x if base == 5 => format!(\"{:05}\", x).into_owned(),\n        x if base\
    \ == 2 => format!(\"{:02}\", x).into_owned(),\n        x if base == 1 => format!(\"\
    {:01}\", x).into_owned(),\n        _ => panic!(\"The base of the input number\
    \ {} must be between 2 and 10\", x),\n    }", "    let mut buf: Vec<u8> = vec![];\n\
    \    let mut carry: isize = 0;\n    let mut digits: Vec<isize> = vec![];\n   \
    \ for i in 0..(base ** x.checked_div(10).unwrap().unwrap_or(0)) {\n        digits.push(i\
    \ / base);\n        carry += i % base;\n        digits.push(&*carry as u8);\n\
    \    }\n    buf.resize(digits.pop().unwrap_or(0), 0);\n    if carry > 0 {\n  \
    \      buf.resize(digits.pop().unwrap_or(0), 0);\n    }\n    for &i in digits\
    \ {\n        buf[buf.len() - 1] = (i as u8).into();\n    }\n    String::from_utf8(buf)",
  "    if base < 10 {\n        if base == 1 {\n            return \"0\".to_string();\n\
    \        }\n        let mut s = String::new();\n        let mut carry = true;\n\
    \        for i in 0..base {\n            if x&1 != 0 {\n                s = format!(\"\
    {}{}\", s, &\"0\");\n                carry = false;\n            }\n         \
    \   s = format!(\"{}{}\", s, &(x&0) - 1);\n            x = x >> 1;\n        }\n\
    \        if carry {\n            s = format!(\"{}{}\", s, &\"1\");\n        }\n\
    \        s\n    } else {\n        format!(\"{}{}\", &x, &base)\n    }", "    let\
    \ mut res = String::from(\"\");\n    let mut remaining = x;\n\n    if base < 2\
    \ || base > 36 {\n        bail!(\"The base is not between 2 and 36\");\n    }\n\
    \n    while remaining > 0 {\n        if remaining % base == 0 {\n            res\
    \ += &format!(\"{:0{}}\", remaining / base, base).to_owned();\n        } else\
    \ {\n            res += &format!(\"{}{:0{}}\", base, remaining / base, base).to_owned();\n\
    \        }\n\n        remaining /= base;\n    }\n\n    res.to_owned()", "    let\
    \ mut out = String::new();\n    let mut digits = [0u8; (x * base) + 1];\n\n  \
    \  for _ in 0..digits.len() {\n        let mut digit = digits.iter().next().unwrap();\n\
    \n        while digit > 0 {\n            out.push((digit % base) as char);\n \
    \           digit /= base;\n        }\n    }\n\n    out", "    if x < base {\n\
    \        format!(\"{:?}\", x / base ** base)\n    } else {\n        format!(\"\
    {:?}\", x / base)\n    }", "    let mut result = String::from(\"0\");\n    match\
    \ base {\n        2 | 4 | 8 | 10 => if x <= 10 { format!(\"{}\", x) } else { result.push(\"\
    0\") },\n        _ => {\n            result.push_str(&format!(\"{}\", x / base))\n\
    \        }\n    }\n    result", "    let mut res = String::from(\"\");\n    while\
    \ x != 0 {\n        if x % base == 0 {\n            res += &format!(\"{}\", x);\n\
    \        } else {\n            res += &format!(\"{}{}\", x / base, &base);\n \
    \       }\n        x /= base;\n    }\n    res", "    match base {\n        2 =>\
    \ {\n            let mut y = x\n            while y >= base {\n              \
    \  y /= base;\n            }\n            format!(\"{}\", y)\n        }\n    \
    \    3 => {\n            let mut y = x\n            while y >= base {\n      \
    \          y /= base;\n            }\n            format!(\"{}\", y)\n       \
    \ }\n        4 => {\n            let mut y = x\n            while y >= base {\n\
    \                y /= base;\n            }\n            format!(\"{}\", y)\n \
    \       }\n        5 => {\n            let mut y = x\n            while y >= base\
    \ {\n                y /= base;\n            }\n            format!(\"{}\", y)\n\
    \        }\n        6 => {\n            let mut y = x\n            while y >=\
    \ base {\n                y /= base;\n            }\n            format!(\"{}\"\
    , y)\n        }\n        7 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        8 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        9 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        10 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        11 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        12 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        13 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        14 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        15 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        16 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)", "    let mut s = String::new();\n    let mut num = 1;\n\n    for n\
    \ in x_to_base(x % base, base).into_iter().take(base) {\n        if n == 0 {\n\
    \            num *= base;\n        } else {\n            num += n;\n        }\n\
    \    }\n\n    s += &format!(\"{}\", num).to_string();\n\n    return s;", "   \
    \ let mut string = String::from(\"0\");\n    while x > base {\n        string\
    \ = format!(\"{}{}\", string, &format!(\"{}\", x % base));\n        x /= base;\n\
    \    }\n    string = format!(\"{}\", x) + string;\n    String::from(string)",
  "    match x {\n        x if x >= 10 && x <= 36 => x.to_string().into(),\n     \
    \   _ => String::from(\"0\".to_string()),\n    }\n    .to_string()\n    .parse::<isize>()\n\
    \    .unwrap()\n    .checked_mul(base)\n    .ok()\n    .unwrap()\n    .to_string()",
  "    let mut result = String::with_capacity(x.to_string());\n    let mut n = x;\n\
    \    let mut base = base as isize;\n    while base > 10 {\n        if n % base\
    \ == 0 {\n            result.push((n - n % base) as char);\n        } else {\n\
    \            result.push('-');\n            result.push((n - n % base) as char);\n\
    \        }\n        n /= base;\n        base *= 10;\n    }\n    if base > 10 {\n\
    \        result.push('-');\n        result.push((n - n % base) as char);\n   \
    \ }\n    result", "    x.to_string().chars().map(|c| if c < base { c.to_string()\
    \ + x } else { c })\n        .collect()", "    let mut str: String = String::new();\n\
    \    let mut num: isize = x;\n    loop {\n        if num > 0 {\n            str\
    \ = format!(\"{}{}\", num, str);\n            num -= base;\n        }\n      \
    \  if num == 0 {\n            return str;\n        }\n        num = num / base;\n\
    \    }", "    use std::cmp::Ordering;\n    use std::fmt::{self, Display};\n  \
    \  use std::str::FromStr;\n    use super::Base;\n    if base < 10 {\n        return\
    \ String::from(x.to_string());\n    }\n    let mut result = x.to_string();\n \
    \   match base.cmp(&Base::base) {\n        Ordering::Less => {\n            let\
    \ mut tmp: String = String::new();\n            for i in 0..result.len() {\n \
    \               let c: char = result[i];\n                if let Some(b) = Base::base.find(c)\
    \ {\n                    let mut res = String::new();\n                    res.push(*b\
    \ as char);\n                    res.push(c);\n                    tmp = res.clone();\n\
    \                    result.push_str(&tmp);\n                } else {\n      \
    \              result.push(c);\n                }\n            }\n        }\n\
    \        Ordering::Greater => {\n            let mut tmp: String = String::new();\n\
    \            for i in 0..result.len() {\n                let c: char = result[i];\n\
    \                if let Some(b) = Base::base.find(c) {\n                    let\
    \ mut res = String::new();\n                    res.push(*b as char);\n      \
    \              res.push(c);\n                    tmp = res.clone();\n        \
    \            result.push_str(&tmp);\n                } else {\n              \
    \      result.push(c);\n                }\n            }\n        }\n        Ordering::Equal\
    \ => {\n            for i in 0..result.len() {\n                let c: char =\
    \ result[i];\n                if let Some(b) = Base::base.find(c) {\n        \
    \            let mut res = String::new();\n                    res.push(*b as\
    \ char);\n                    res.push(c);\n                    result = res.clone();\n\
    \                }\n            }\n        }\n    }\n    let mut num = x.to_string();\n\
    \    num = num.chars().enumerate().filter_map(|(i, c)| {\n        if c.is_digit()\
    \ {\n            let num = c - '0';\n            if num < 0 {\n              \
    \  let mut num = -num;\n                let mut base = Base::base;\n         \
    \       if num < 0 {\n                    num = -num;\n                    base\
    \ *= -1;\n                }\n                (num, base)\n            } else {\n\
    \                (num, base)\n            }\n        } else {\n            None\n\
    \        }\n    }).collect();\n    let mut pow = 1;\n    for (n, base) in num\
    \ {\n        pow <<= Base::base.digits();\n        if pow >= base {\n        \
    \    return String::from(num.to_string());\n        }\n        pow /= base;\n\
    \    }\n    String::from(num.to_string())", "    let mut buf = [0u8; 16];\n  \
    \  let mut result = [0u8; 3];\n    let mut powers = vec![![1u8, 2u8, 3u8, 4u8;\
    \ 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n \
    \   let mut remainder = 1;\n    let mut powers2 = vec![![1u8, 2u8, 3u8, 4u8; 5u8,\
    \ 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let\
    \ mut powers21 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8,\
    \ 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let mut powers3 = vec![![1u8, 2u8,\
    \ 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8];\
    \ 32];\n    let mut powers31 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8,\
    \ 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let mut powers4 =\
    \ vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8,\
    \ 14u8, 15u8; 16u8]; 32];\n    let mut powers41 = vec![![1u8, 2u8, 3u8, 4u8; 5u8,\
    \ 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let\
    \ mut powers5 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8,\
    \ 12u8, 13u8, 14u8, 15u8; 16u8", "    let mut s = String::new();\n    if x < base\
    \ {\n        let mut num: isize = x;\n        while num > base {\n           \
    \ num = num / base;\n            s += String::from(\"0\");\n        }\n      \
    \  s += String::from((num.to_string()));\n    } else {\n        let mut num: isize\
    \ = x;\n        while num < base {\n            num = num * base;\n          \
    \  s += String::from((num.to_string()));\n        }\n        s += String::from((num.to_string()));\n\
    \    }\n    String::from(s)", "    if x < base {\n        if x < 10 {\n      \
    \      return String::from(format!(\"{}\", x));\n        } else {\n          \
    \  return String::from(format!(\"{}{}\", x%base, base_to_string(x/base)));\n \
    \       }\n    } else {\n        return String::from(format!(\"{}{}\", x, base_to_string(x%base)));\n\
    \    }", "    let mut acc = String::new();\n    let mut s = String::from(\"1\"\
    );\n    if x < base {\n        for _ in 0..(x - base) {\n            s = format!(\"\
    {}{}\", s, base);\n        }\n    } else {\n        for _ in 0..(base - x) {\n\
    \            acc = format!(\"{}{}\", acc, s);\n        }\n    }\n    format!(\"\
    {}\", acc)", "    if base < 2 {\n        String::from(\"0\".to_string())\n   \
    \ }\n    let mut base = format!(\"{}\", base);\n    let mut result = String::from(\"\
    \");\n    for i in base.chars().cloned() {\n        if i <= '0' {\n          \
    \  result.push_str(&format!(\"{}\", x));\n            return result;\n       \
    \ }\n        x /= base;\n    }", "    match x.cmp(&base) {\n        Ordering::Less\
    \ => String::from(\"0\".to_string()),\n        Ordering::Greater => String::from(\"\
    9\".to_string()),\n        Ordering::Equal => {\n            let mut buff = String::new();\n\
    \            let mut digit: usize = 10;\n            while digit <= base.to_digits()\
    \ + 1 {\n                buff.push_str(digit.to_string());\n                digit\
    \ = (digit as usize * base) + x;\n            }\n            buff.push_str(digit.to_string());\n\
    \            buff\n        }\n    }", "    let mut s = String::from(\"0\");\n\
    \    let mut digits = x;\n    let mut power = 1;\n    while (digits > base) {\n\
    \        digits -= base;\n        power = power << 1;\n    }\n    let mut rem\
    \ = digits;\n    while rem > 0 {\n        rem = rem >> 1;\n        s = format!(\"\
    {}{}\", s, String::from(\"0\".to_string(base)));\n    }\n    format!(\"{}\", s)",
  "    let mut result = String::new();\n    let mut digits = vec![0u8; MAX_DIGITS];\n\
    \n    if x > base {\n        while x >= base {\n            digits[x / base] =\
    \ 1;\n            x -= base;\n        }\n    } else {\n        while x <= base\
    \ {\n            digits[x % base] = 1;\n            x += base;\n        }\n  \
    \  }\n\n    for i in 0..digits.len() {\n        if digits[i] != 0 {\n        \
    \    result.push(i);\n        }\n    }\n\n    result", "    let mut res = String::from(\"\
    \");\n    let mut i = x;\n    while i > 0 {\n        res = match i / base {\n\
    \            0 => String::from(\"0\"),\n            1 => String::from(\"1\"),\n\
    \            _ => String::from(\"0\") + res.clone(),\n        };\n        i %=\
    \ base;\n    }\n    res", "    let mut result = String::from(\"0\");\n    for\
    \ x in x.to_str() {\n        result += &x.chars().nth(base.to_string().chars().count()\
    \ * x as usize).to_string();\n    }\n    result", "    let mut out = String::new();\n\
    \    let mut temp = 1;\n    let mut last = 0;\n    while temp > 0 {\n        if\
    \ last + 1 < base {\n            out.push((x % base) as char);\n            last\
    \ += 1;\n        }\n        x /= base;\n        temp *= base;\n    }\n    out",
  '    String::from(format!("{}", x / base))', '    format!("{}", x as usize * base).to_string()',
  "    if base < 10 {\n        String::from(format!(\"{}\", x))\n    } else {\n  \
    \      if base == 1 {\n            String::from(\"1\")\n        } else {\n   \
    \         match x % base {\n                0 => String::from(\"\"),\n       \
    \         _ => {\n                    let mut s = String::from(\"\".to_string());\n\
    \                    s.push_str(&format!(\"{}\", x));\n                    while\
    \ x != 0 {\n                        s.push_str(&format!(\"{}\", x % base));\n\
    \                        x /= base;\n                    }\n                 \
    \   s\n                }\n            }\n        }\n    }", "    let mut s = String::with_capacity(x.to_string().len());\n\
    \    if x >= base {\n        for x in s.chars() {\n            *x = *x + (*x as\
    \ char) - base;\n        }\n    }\n    if x < base {\n        for x in s.chars().rev()\
    \ {\n            *x = *x + (*x as char) + base;\n        }\n    }\n    s", " \
    \   if base < 2 {\n        return String::from(\"0\");\n    }\n\n    if x % base\
    \ == 0 {\n        return String::from(\"0\");\n    }\n\n    let mut y = x;\n \
    \   let mut r = 1;\n\n    while y > 0 {\n        let t = y % base;\n        r\
    \ <<= 1;\n        if t > 0 {\n            r |= 1;\n        }\n\n        y /= base;\n\
    \    }\n\n    let mut result = String::from(\"0\");\n    for i in 0..r {\n   \
    \     result.push_str(&format!(\"{:0>2}\", i as u32));\n    }\n\n    result",
  "    let mut result = (0..x).collect::<String>().to_owned();\n    let mut new_base\
    \ = base;\n    for &x in result.chars() {\n        if x < new_base {\n       \
    \     let base = new_base;\n            let mut result = String::from(\"1\");\n\
    \            result += &x*(base);\n            new_base = base;\n        }\n \
    \       result += &x*(new_base);\n    }\n    result", "    let mut s = String::new();\n\
    \    let mut remainder = x; // remainder after division by base\n    while remainder\
    \ > base {\n        remainder = remainder % base;\n        s = format!(\"{}{}\"\
    , s, base);\n    }\n    s = format!(\"{}{}\", s, remainder);\n    s", "    let\
    \ mut result = String::from(\"0\");\n    for i in x.checked_mul(base.pow(i)).unwrap()\
    \ {\n        result.push_str(&*i.to_string());\n    }\n    result", "    let mut\
    \ y = x;\n    let mut base = base as usize;\n    let mut base_rev = base as usize;\n\
    \    let mut str = \"\";\n    while y > 0 {\n        if base_rev % 10 == 0 {\n\
    \            base_rev /= 10;\n            str += \"0\".to_string();\n        }\n\
    \        str += &format!(\"{}\", y % base).to_string();\n        y /= base;\n\
    \    }\n    String::from(str)", '    String::from(x.to_string().parse::<i64>().unwrap().pow(base).to_string())',
  "    if x < base {\n        let mut x = x;\n        assert!(x <= 10, \"Base must\
    \ be less than 10\");\n        let mut res = String::new();\n        while x >\
    \ 0 {\n            res.push((x - base as u32).to_string());\n            x /=\
    \ base;\n        }\n        while res.len() > 0 {\n            x.insert(0, res.pop().to_string());\n\
    \        }\n        res.to_string()\n    } else {\n        x.to_string()\n   \
    \ }", "    let mut res = String::from(\"0\");\n    let mut digits = 0;\n    let\
    \ mut tens = false;\n\n    while x != 0 {\n        let digit = x % base;\n   \
    \     digits = digits*10 + digit;\n        x /= base;\n\n        if x == 10 {\n\
    \            tens = true;\n        }\n\n        res = res.push(String::from(digits));\n\
    \n        if tens {\n            res.push_str(\" \");\n        }\n    }\n\n  \
    \  return res.trim_end();", "    if x < base {\n        String::from(format!(\"\
    {}\", x))\n    } else {\n        String::from(format!(\"{}{}\", x / base, base))\n\
    \    }", "    let mut res: String = \"\";\n    for i in x.to_string().chars().nth(base)\
    \ {\n        if i > '9' {\n            res += &format!(\"{}{}\", i as char, i\
    \ as char);\n        } else {\n            res += &format!(\"{}\", i as char);\n\
    \        }\n    }\n    res", "    let mut s = String::new();\n    if x <= base\
    \ {\n        s.push(x);\n    } else {\n        let mut x = x;\n        let mut\
    \ base = base;\n        while x > base {\n            x /= base;\n           \
    \ s.push(x)\n        }\n        s.push(x);\n    }\n    s", '    format!("{}",
    x.to_base2(base))', "    if base < 2 {\n        format!(\"{}\", x)\n    } else\
    \ {\n        let mut s = String::new();\n        for i in 0..base.abs() {\n  \
    \          let digit = x as isize / base;\n            let digits = digit as usize\
    \ * base;\n            s.push_str(&format!(\"{}\", digits));\n            x =\
    \ x - digits as isize;\n        }\n        s\n    }", "    let mut x = x.abs();\n\
    \    let mut i = base;\n    let mut result = String::with_capacity(x.to_string().len()\
    \ * base.to_string().len());\n    while i > 0{\n        if x % i == 0 {\n    \
    \        result.append(&mut x.to_string().to_owned());\n            x /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    result.append(&mut\
    \ x.to_string().to_owned());\n    result", "    String::from(\n        (format!(\"\
    {}\", x / base) as isize).to_string(),\n    )", "    let mut rep = String::new();\n\
    \    let mut digits = String::new();\n    for d in x.to_digits(base) {\n     \
    \   rep.push(*d);\n        digits.push_str(&to_string(*d));\n    }\n    if digits.len()\
    \ > 1 {\n        rep.push_str(&digits[..digits.len() - 1]);\n    }\n    if digits.len()\
    \ < base {\n        rep.push_str(&digits[base..]);\n    }\n    rep", "    let\
    \ mut x = x.to_string();\n    let mut base: String = base.to_string();\n    let\
    \ mut base: String = base.to_digits();\n    while base.len() != 0 {\n        if\
    \ base.len() < base.len() {\n            x = x.rotate_left(base);\n        } else\
    \ {\n            x = x.rotate_right(base);\n        }\n        let mut base: String\
    \ = base.to_string();\n        base.reserve(base.len() - 1);\n    }\n    x", " \
    \   // if base is less than 10 then use radix conversion\n    if base < 10 {\n\
    \        let mut s = String::new();\n        // set base as string\n        s.push_str(&bases[base\
    \ as usize]);\n        let mut x = x as isize;\n        // set x to new base\n\
    \        loop {\n            s.push_str(&xs[x as usize]);\n            if x >\
    \ 0 {\n                x /= base;\n            } else {\n                break;\n\
    \            }\n        }\n        String::from(s)\n    } else {\n        let\
    \ mut s = String::new();\n        // set base as string\n        s.push_str(&bases[base\
    \ as usize]);\n        let mut x = x as isize;\n        // set x to new base\n\
    \        loop {\n            s.push_str(&xs[x as usize]);\n            if x >\
    \ 0 {\n                x %= base;\n                if x == 0 {\n             \
    \       break;\n                }\n            }\n        }\n        String::from(s)\n\
    \    }", "    let mut s = String::new();\n    for i in 0..x.to_usize() {\n   \
    \     if i % base == 0 {\n            s.push('0');\n        }\n        s.push((x\
    \ as usize * base) + i as u8);\n    }\n    String::from(s)", "    assert!(base\
    \ < 10);\n    let mut s = String::new();\n    while x > 0 {\n        write!(s,\
    \ \"{}\", x % base).unwrap();\n        x /= base;\n    }\n    s", "    let mut\
    \ s = String::new();\n    let mut n = x;\n    while n > 0 {\n        let q = n%base;\n\
    \        s.push((&mut s[q]).to_string()[q]);\n        n = n/base;\n    }\n   \
    \ s.reverse();\n    s", "    let mut res = String::new();\n    let mut digits\
    \ = Vec::new();\n\n    while x >= base {\n        res.push_str(&format!(\"{}\"\
    , x / base).to_string());\n        digits.push(x);\n        x -= base;\n    }\n\
    \    res.push_str(&format!(\"{}\", x).to_string());\n\n    if res.length() > 0\
    \ {\n        res.push_str(&format!(\"+{}\", digits.len()).to_string());\n    \
    \    res.push_str(&digits.into_iter().collect::<String>());\n    }\n\n    res",
  "    let mut acc = String::new();\n    let mut digit = 0;\n    let mut pow = x;\n\
    \    while pow >= base {\n        digit = pow % base;\n        pow = (pow / base)\
    \ as usize;\n        acc.push(digit as char);\n    }\n    acc.push((pow % base)\
    \ as char);\n    acc", "    let mut res = String::from(\"0\");\n    while x >\
    \ 0 {\n        res.insert(0, char::to_digit(x % base));\n        x /= base;\n\
    \    }\n    res", "    let mut result: String = String::new();\n    while x >\
    \ 0 {\n        if x % base == 0 {\n            result += &x[..(base - 1)].to_string();\n\
    \        }\n        x /= base;\n    }\n    if x > 0 {\n        result += &x[..(base\
    \ - 1)].to_string();\n    }\n    result", "    if base < 10 {\n        let mut\
    \ s = String::new();\n        for (i, digit) in x.to_digits().chars().enumerate()\
    \ {\n            if i >= base {\n                s.push('0');\n            }\n\
    \            s.push(digit);\n        }\n        String::from(s)\n    } else {\n\
    \        String::from(x.to_digits().to_base10(base))\n    }", "    match base\
    \ {\n        1 => String::from(\"1\"),\n        2 => String::from(\"10\"),\n \
    \       3 => String::from(\"100\"),\n        4 => String::from(\"1000\"),\n  \
    \      5 => String::from(\"10000\"),\n        6 => String::from(\"100000\"),\n\
    \        7 => String::from(\"1000000\"),\n        8 => String::from(\"10000000\"\
    ),\n        9 => String::from(\"100000000\"),\n        10 => String::from(\"1000000000\"\
    ),\n        _ => {\n            let mut buf: Vec<String> = vec![String::new();\
    \ 12];\n            let mut base = base;\n            while base.is_positive()\
    \ {\n                let mut s = String::new();\n                let mut carry\
    \ = 0;\n                for n in x.iter().rev() {\n                    if n ==\
    \ 0 {\n                        break;\n                    }\n               \
    \     let mut q = base;\n                    if let Some(factor) = &mut carry\
    \ {\n                        if *n >= factor {\n                            q.0\
    \ += *n;\n                            carry = *n / factor;\n                 \
    \       } else {\n                            q.0 -= factor + 1;\n           \
    \                 carry = *n / factor;\n                        }\n          \
    \          } else {\n                        if *n > 0 {\n                   \
    \         q.0 += *n;\n                            carry = 1;\n               \
    \         } else if *n < 0 {\n                            q.0 -= *n;\n       \
    \                     carry = -1;\n                        } else {\n        \
    \                    q.0 += 1;\n                            carry = 0;\n     \
    \                   }\n                    }\n                    *s = String::from(format!(\"\
    {}{}\", q.0, q.1%base));\n                }\n                if carry != 0 {\n\
    \                    s.prepend(String::from(\"{}\", -carry));\n              \
    \  }\n                buf.push(*s);\n                base = q;\n            }\n\
    \            String::concat(&buf)\n        }\n    }", "    let mut s = String::from(\"\
    0\");\n    if x == 0 {\n        return s; // base case of recursion\n    }\n \
    \   if base == 0 {\n        if x > 10 {\n            // we do not need to keep\
    \ any sign for base < 10.\n            let mut tmp = s.to_string();\n        \
    \    tmp = tmp.split_last_mut(1);\n            tmp += \"0\".to_string();\n   \
    \         s = tmp;\n        }\n        return s;\n    }\n    let mut digits =\
    \ Vec::new();\n    for digit in &x.to_digits() {\n        let mut i = digit;\n\
    \        if base > 10 {\n            i = digit.to_digits();\n            i +=\
    \ 1;\n        }\n        if i >= base {\n            i += base - i;\n        }\n\
    \        digits.push(i as u8);\n    }\n    // reverse the digits so that digits\
    \ are in descending order.\n    let mut revdigits = digits.clone();\n    revdigits.rev();\n\
    \    String::from_utf8(revdigits.as_bytes()).unwrap()", "    use std::ascii::AsciiExt;\n\
    \    use std::ascii::Lower;\n\n    // TODO: handle negative numbers\n\n    use\
    \ num_traits::FromPrimitive;\n    let x = x.to_digits();\n    let mut xstr = String::new();\n\
    \    for i in x.iter() {\n        xstr.push(match i {\n            0 => \"0\"\
    ,\n            1 => \"1\",\n            2 => \"11\",\n            3 => \"12\"\
    ,\n            4 => \"13\",\n            5 => \"14\",\n            6 => \"15\"\
    ,\n            7 => \"16\",\n            8 => \"17\",\n            9 => \"18\"\
    ,\n            _ => format!(\"{}\", i).into(),\n        });\n    }\n    let xstr\
    \ = xstr.to_ascii_lowercase();\n\n    let mut basestr = String::new();\n    match\
    \ base {\n        10 => basestr.push_str(\"0\"),\n        11 => basestr.push_str(\"\
    1\"),\n        12 => basestr.push_str(\"10\"),\n        13 => basestr.push_str(\"\
    11\"),\n        14 => basestr.push_str(\"12\"),\n        15 => basestr.push_str(\"\
    13\"),\n        16 => basestr.push_str(\"14\"),\n        17 => basestr.push_str(\"\
    15\"),\n        18 => basestr.push_str(\"16\"),\n        19 => basestr.push_str(\"\
    17\"),\n        20 => basestr.push_str(\"18\"),\n        21 => basestr.push_str(\"\
    19\"),\n        22 => basestr.push_str(\"20\"),\n        23 => basestr.push_str(\"\
    21\"),\n        24 => basestr.push_str(\"22\"),\n        25 => basestr.push_str(\"\
    23\"),\n        26 => basestr.push_str(\"24\"),\n        27 => basestr.push_str(\"\
    25\"),\n        28 => basestr.push_str(\"26\"),\n        29 => basestr.push_str(\"\
    27\"),\n        30 => basestr.push_str(\"28\"),\n        31 => basestr.push_str(\"\
    29\"),\n        _ => panic!(\"base number must be 10..31\"),\n    }\n    basestr.to_ascii_lowercase()\n\
    \        .into_string()\n        .unwrap()\n        .into_ascii_lowercase()\n\
    \        .into_string()\n        .unwrap()\n        .into_digits()\n        .unwrap()\n\
    \        .to_string()", "    let mut x = x;\n    let mut base = 2**base;\n   \
    \ let mut result = String::new();\n    while x != 0 {\n        if x % base ==\
    \ 0 {\n            result.push((x % base) as char);\n        }\n        x /= base;\n\
    \    }\n    result", '    format!("{}{}", to_base(x, base), to_base(base - 1,
    base))', "    let mut s = String::new();\n    let mut number = x;\n    let mut\
    \ divisor = base;\n    while number > 0 {\n        if number % divisor == 0 {\n\
    \            s.insert(0, number as isize);\n        }\n        number /= divisor;\n\
    \        divisor /= base;\n    }\n    String::from(s)", "    let mut res = String::from(\"\
    0\");\n    for &i in x.to_string().chars().filter_map(|c| match c {\n        '0'..='9'\
    \ => {\n            let mut r = 1;\n            for i in c.to_string().chars().filter_map(|c|\
    \ match c {\n                '0'..='9' => {\n                    r = r * 10 +\
    \ c - '0';\n                }\n                _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n            }) {\n                res = res.insert(i, r as\
    \ char);\n            }\n        }\n        _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n    }) {\n        res = res.insert(i, '0');\n    }\n    for\
    \ i in base.to_string().chars().filter_map(|c| match c {\n        '0'..='9' =>\
    \ {\n            let mut r = 1;\n            for i in res.chars().filter_map(|c|\
    \ match c {\n                '0'..='9' => {\n                    r = r * 10 +\
    \ c - '0';\n                }\n                _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n            }) {\n                res = res.insert(i, r as\
    \ char);\n            }\n        }\n        _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n    }) {\n        res = res.insert(i, '0');\n    }\n    res",
  "    let mut y = x;\n    let mut z = base;\n    while y >= z {\n        let mut\
    \ i = y;\n        y = i / z;\n        z = z * base;\n    }\n    String::from_str(format!(\"\
    {}\", y)).unwrap()", "    if x < base {\n        let mut buffer = String::new();\n\
    \        for i in 0..x.log10() {\n            let num = base ** i;\n         \
    \   let digit = x % num;\n            buffer.push_str(&format!(\"{}\", digit));\n\
    \        }\n        buffer\n    } else {\n        let mut buffer = String::new();\n\
    \        for i in 0..(base.log10() - x.log10()) {\n            let num = base\
    \ ** (x.log10() - i);\n            let digit = x % num;\n            buffer.push_str(&format!(\"\
    {}\", digit));\n        }\n        buffer.push_str(&format!(\"{}\", x))\n    }",
  "    let mut res = String::with_capacity(x.to_string().len());\n    while x > 0\
    \ {\n        res.push_str(&to_base(x, base));\n        x /= base;\n    }\n   \
    \ res.push_str(&to_base(x - 1, base));\n    return res", "    if x <= 0 {\n  \
    \      String::from(\"\".to_string())\n    }\n    if base > 10 {\n        String::from(\"\
    \".to_string())\n    }\n    let mut string_res = String::new();\n    let mut base\
    \ = x;\n    let mut base_pre = 1;\n    while base != 1 {\n        let mut mul\
    \ = 1;\n        let mut div = 1;\n        let mut remainder = 0;\n        let\
    \ mut carry = 1;\n        while base != 1 {\n            let mut tmp = base;\n\
    \            tmp = tmp * mul + carry;\n            remainder %= 10;\n        \
    \    div = div * 10 + remainder;\n            carry = tmp / 10;\n            base\
    \ = tmp % 10;\n        }\n        string_res = string_res[..0].to_string() + to_string(carry)\
    \ + to_string(remainder);\n        base = base_pre * div;\n        base_pre =\
    \ base_pre * mul;\n    }\n    if base_pre * 10 == x {\n        string_res\n  \
    \  } else {\n        string_res[..0].to_string() + String::from(\"\".to_string())\n\
    \    }", "    if base == 0 {\n        String::from(\"0\")\n    } else {\n    \
    \    if x < 10 {\n            format!(\"{}\", x)\n        } else {\n         \
    \   format!(\"{}\", x / base).to_string()\n        }\n    }", '    format!("{}{}",
    digit_to_base(x, base), digit_to_base(x, base))', "    let mut x = x.to_string();\n\
    \    if base > 10 {\n        let mut x = x.trim_start();\n        if x.len() <\
    \ base.to_string().len() {\n            x = &x[..(x.len() - base.to_string().len())]\
    \ + &base.to_string()[..];\n        }\n    }\n    String::from(x)", '    format!("{}",
    x.to_digits(base))', "    let mut v = base::to_string(x);\n    while v.len() >\
    \ base {\n        v = &v[v.len() - 1];\n    }\n    v", "    if base < 2 {\n  \
    \      String::from(\"0\".to_string())\n    } else {\n        let mut result =\
    \ String::from(\"0\".to_string());\n        while x != 0 {\n            let digit\
    \ = x % base;\n            let x = x / base;\n            result = format!(\"\
    {}{}\", result, digit);\n        }\n        result\n    }", "    let mut ret =\
    \ String::with_capacity(x.to_string().len() * base.to_string().len());\n    let\
    \ mut remaining = x;\n    let mut base10 = base.pow(10);\n    while remaining\
    \ > 0 {\n        let digit = remaining.rem::<usize>();\n        remaining = remaining.div::<usize>(base10);\n\
    \        ret += digit.to_string();\n    }\n    ret.reverse();\n    ret", "   \
    \ if base < 2 {\n        return format!(\"{:?}\", x);\n    }\n\n    let mut res\
    \ = String::new();\n\n    while x > base {\n        x /= base;\n        res +=\
    \ \"0\";\n    }\n\n    res += &x.to_string()[..base];\n    res", "    let mut\
    \ s = String::new();\n    while x != 0 {\n        match x % base {\n         \
    \   0 => s.push_str(\"0\"),\n            1 => s.push_str(\"1\"),\n           \
    \ _ => s.push_str(\"0\"),\n        }\n        x /= base;\n    }\n    s", "   \
    \ let mut res = String::new();\n    while x > 0 {\n        let digit = x % base;\n\
    \        res.insert(0, digit.to_string());\n        x /= base;\n    }\n    while\
    \ res.ends_with('0') {\n        res.pop();\n    }\n    res", "    if base < 2\
    \ {\n        return String::new();\n    }\n    let mut res = String::from(\"0\"\
    );\n    match (base, x) {\n        (10, n) => {\n            res.push_str(&n.to_string());\n\
    \        }\n        (d, 10) => panic!(\"base 10 not supported\"),\n        (_,\
    \ n) => {\n            if n >= 10 {\n                res.push_str(&n.to_string());\n\
    \            } else {\n                if n >= d {\n                    res.push_str(&n.to_string()\
    \ + &\"0\".to_string());\n                } else {\n                    res.push_str(&n.to_string()\
    \ + &\"1\".to_string());\n                }\n            }\n        }\n    }\n\
    \    res", "    if base < 0 || base > 10 {\n        panic!(\"Base has to be between\
    \ 0 and 10.\");\n    }\n    let mut s = String::new();\n    let mut i = x;\n \
    \   while i > 0 {\n        s +=\n            i.to_str() + if i < 10 { char::from('0')\
    \ } else { char::from('1') };\n        i = i / base;\n    }\n    String::from(s)",
  "    use std::cmp::Ordering;\n    use std::fmt::{self, Display};\n    use std::num::One;\n\
    \    let one: One = One::new();\n    let mut s = String::with_capacity(4);\n \
    \   let mut nums = &x[..];\n    while nums.len() >= base {\n        let mut base\
    \ = &nums[..];\n        if base < base {\n            let mut base = &nums[..];\n\
    \            while base.len() < base {\n                base.push('0');\n    \
    \        }\n        }\n        let mut num = &nums[..];\n        let digits =\
    \ num.len()-base;\n        while num.len() < digits {\n            num.push('0');\n\
    \        }\n        let mut nums: Vec<_> = base\n            .iter()\n       \
    \     .zip(num.iter())\n            .map(|(a, b)| a.to_digit(base).unwrap().checked_add(&b.to_digit(base).unwrap()))\n\
    \            .collect();\n        while nums.len() > 1 {\n            let mut\
    \ bases: Vec<_> = nums\n                .iter()\n                .map(|n| n.checked_mul(base).unwrap())\n\
    \                .collect();\n            num = &bases[..];\n            nums\
    \ = num.iter()\n                .map(|a| a.to_digit(base).unwrap().clone())\n\
    \                .collect();\n        }\n        s = s.push_str(&nums.into_iter().collect());\n\
    \    }\n    if nums.len() > 4 {\n        s = s.push_str(&nums.into_iter().take(4).collect());\n\
    \    }\n    s", "    let mut digits = String::new();\n    let mut exp = 0;\n \
    \   let mut rem = 0;\n    while x >= base {\n        rem = x / base;\n       \
    \ x = x - base * rem;\n        exp++;\n        digits += format!(\"{}\", rem).to_string();\n\
    \    }\n    digits += format!(\"{}\", x).to_string();\n    if exp > 0 {\n    \
    \    digits.push_str(&format!(\"e{}\", exp).to_owned());\n    }\n    digits",
  "    let mut num = String::from(\"0\");\n    if x >= base {\n        num = x.to_str_base(base,\
    \ 0).to_string();\n        num = format!(\"{:0>#}\", num).to_string();\n    }\
    \ else {\n        while x != 0 {\n            x = x % base;\n            num =\
    \ format!(\"{:0>#}\", x).to_string();\n        }\n    }\n    String::from(num)",
  "    if base < 10 {\n        let mut digits = vec![];\n        digits.push(x % base);\n\
    \        let mut x = x / base;\n        while x != 0 {\n            digits.push(x\
    \ % base);\n            x /= base;\n        }\n        digits.reverse();\n   \
    \     return String::from(\"0\".to_string() + digits);\n    }\n    return format!(\"\
    {}\", x);", "    let mut x = x % base;\n    match x {\n        0 => return String::from(\"\
    0\"),\n        x => String::from(x.to_string()),\n    }", "    let mut s = String::new();\n\
    \    while x > 0 {\n        let remainder = x % base;\n        x += 1;\n     \
    \   s += char::to_digit(remainder + '0').to_string();\n    }\n    s"]
stop_tokens:
- "\n}"
