name: HumanEval_153_Strongest_Extension
language: rs
prompt: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
  /// The extensions are to be used to load additional classes to the class. The\n\
  /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  /// letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n/// You should find the strongest extension and return a string in this \n///\
  \ format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
  \ with the same strength, you should\n/// choose the one that comes first in the\
  \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
  \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
  my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\"\
  )])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String,\
  \ extensions: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
  Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
  eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
  Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
  YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
  ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
  t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
  ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
  __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
  Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]),\
  \ String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"),\
  \ vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"\
  -_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
  YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
  WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"\
  ));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"\
  Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]),\
  \ String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
  _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
  ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
  ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
completions: ["    let mut strength: i32 = 0;\n    let mut names: Vec<&str> = extensions.iter().map(|e|\
    \ &e.to_lowercase()).collect();\n    for &n in names {\n        let mut found\
    \ = false;\n        for e in extensions {\n            if e.to_lowercase() ==\
    \ n {\n                found = true;\n                break;\n            }\n\
    \        }\n        if !found {\n            let i = names.iter().position(|&n|\
    \ n == &n);\n            strength += i - names.len();\n        }\n    }\n    let\
    \ s = strength % class_name.len();\n    if s > 0 {\n        let s = s - class_name.len();\n\
    \        &class_name[..class_name.len()-s] + class_name + &class_name[class_name.len()..class_name.len()\
    \ + s]\n    } else {\n        class_name\n    }", "    if extensions.len() ==\
    \ 0 {\n        return class_name;\n    }\n    let mut strength = -1;\n    let\
    \ mut extension = String::from(\"\");\n    let mut extension_pos = 0;\n    for\
    \ extension in extensions {\n        let mut letter_counter = 0;\n        for\
    \ letter in extension.chars() {\n            if letter == 'C' {\n            \
    \    if letter_counter > 0 {\n                    // found C letter earlier \n\
    \                    break \n                }\n            } else {\n       \
    \         letter_counter += 1;\n            }\n        }\n        if strength\
    \ == -1 {\n            strength = letter_counter - 1;\n        } else {\n    \
    \        if letter_counter > strength {\n                strength = letter_counter\
    \ - 1;\n                extension = extension.clone();\n                extension_pos\
    \ = 0;\n            }\n        }\n    }\n    extension.clone() + String::from(class_name\
    \ + \".\") + extensions[extension_pos].clone();", "    let mut strongest_extension:\
    \ Option<String> = None;\n    \n    for i in 0..extensions.length() {\n      \
    \  let letters: usize = extensions[i].chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \        let lowercase: usize = extensions[i].chars().filter(|c| c >= 'a' && c\
    \ <= 'z').count();\n        let capital: usize = extensions[i].chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n        let sm: usize = extensions[i].chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        let strength: usize = letters - sm;\n\
    \        if strength > 0 {\n            if strongest_extension.is_none() || strength\
    \ > strongest_extension.as_ref().unwrap().chars().filter(|c| c >= 'A' && c <=\
    \ 'Z').count() {\n                strongest_extension = Some(extensions[i]);\n\
    \            }\n        }\n    }\n    \n    strongest_extension.ok().unwrap().to_owned()",
  "    let mut extenstions = extensions;\n    let mut strength: i32 = -1i32;\n   \
    \ let mut current_strength: i32 = -1i32;\n    let mut current_extenstions: Vec<String>\
    \ = extensions.clone();\n    while current_extenstions.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut extension_strength = -1;\n        while i < extensions.len()\
    \ {\n            if current_extenstions[i] == class_name {\n                extension_strength\
    \ += 1;\n            }\n            i += 1;\n        }\n        if extension_strength\
    \ > strength {\n            strength = extension_strength;\n            current_extenstions\
    \ = extenstions.clone();\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ extenstions.first())", "    extensions.iter().cloned().sort_by(|a, b| \n   \
    \     if a.to_ascii_lowercase().cmp(b.to_ascii_lowercase()) < 0 {\n          \
    \  -1\n        } else {\n            1\n        }\n    )\n    .next()\n    .unwrap()\n\
    \    .format(&class_name)", "    let mut extensions_sorted = extensions.clone();\n\
    \    extensions_sorted.sort_unstable();\n    let mut min_strength = extensions_sorted.len();\n\
    \    for extension in extensions_sorted {\n        let mut extension_length =\
    \ extension.len();\n        let mut current_strength = extension_length;\n   \
    \     for char in extension.chars() {\n            if char == '_' {\n        \
    \        current_strength -= 1;\n            } else {\n                current_strength\
    \ += 1;\n            }\n        }\n        if current_strength < min_strength\
    \ {\n            min_strength = current_strength;\n        }\n    }\n    let mut\
    \ class_name = class_name.to_string();\n    class_name.replace_range(class_name.len()\
    \ - min_strength.0, class_name.len() - min_strength.1, '_');\n    return class_name;",
  "    let mut current_strength = -1;\n    let mut best_extension: Option<String>\
    \ = None;\n    for extension in extensions {\n        let (extension_name, extension_strength)\
    \ = Extension::ParseExtension(extension);\n        let extension_strength_difference\
    \ = current_strength - extension_strength;\n        if extension_strength_difference\
    \ < 0 {\n            current_strength = extension_strength;\n            best_extension\
    \ = Some(extension_name);\n        } else if extension_strength_difference ==\
    \ 0 {\n            current_strength = extension_strength;\n            best_extension\
    \ = Some(extension_name);\n        }\n    }\n    match best_extension {\n    \
    \    Some(extension) => format!(\"{}{}.{}\", class_name, extension_name, current_strength),\n\
    \        None => format!(\"{}{}.{}\", class_name, String::from(\"XX\"), current_strength),\n\
    \    }", '    extension_strength(class_name, extensions, 0)', "    let mut class_name\
    \ = class_name.to_string();\n\n    let mut extensions = extensions.iter().map(|x|\
    \ x.to_string()).collect::<Vec<_>>();\n\n    // Initialize max extension strength.\n\
    \    let mut max_extension_strength = 0;\n\n    // Initialize max extension name.\n\
    \    let mut max_extension_name: String = \"\";\n\n    for extension in extensions\
    \ {\n        // Find the extension name by splitting it on upper case characters.\n\
    \        let mut extension_name = extension.clone();\n\n        for ch in extension_name.chars()\
    \ {\n            if ch.is_uppercase() {\n                break;\n            }\n\
    \            extension_name.push(ch);\n        }\n\n        // Find the extension\
    \ strength by splitting it on lowercase characters.\n        let mut extension_strength:\
    \ u8;\n        let mut extension_name = extension.clone();\n        for ch in\
    \ extension_name.chars() {\n            if ch.is_lowercase() {\n             \
    \   break;\n            }\n            extension_name.push(ch);\n        }\n\n\
    \        // Update the max extension strength if needed.\n        max_extension_strength\
    \ = if extension_strength > max_extension_strength { extension_strength } else\
    \ { max_extension_strength };\n        max_extension_name = extension_name if\
    \ extension_strength > max_extension_strength { extension_name } else { max_extension_name\
    \ };\n    }\n\n    // If there are multiple extensions with the same max extension\
    \ strength,\n    // choose the one that comes first in the vector (lexicographically).\n\
    \    if extensions.iter().any(|&(_, x)| x == max_extension_name) {\n        extensions\
    \ = extensions\n            .iter()\n            .filter(|&(_, x)| x == max_extension_name)\n\
    \            .cloned()\n            .collect::<Vec<_>>();\n    }\n\n    let max_extension_strength:\
    \ u8 = max_extension_strength;\n    let max_extension_name: String = max_extension_name;\n\
    \n    // Return the max extension name.\n    class_name.to_string().format(\"\
    .{0}\", max_extension_name)", "    if extensions.len() > 0 { \n        let mut\
    \ extensions = extensions.clone();\n        let mut len = extensions[0].len();\n\
    \        for element in &extensions {\n            len += element.len();\n   \
    \     }\n        let mut strength = -1;\n        let mut index = -1;\n       \
    \ for element in &extensions {\n            strength = strength.max(element.to_lowercase().chars().count());\n\
    \            index = elements.iter().position(|&x| x.to_lowercase().chars().count()\
    \ == strength);\n            if index != -1 {\n                break;\n      \
    \      }\n        }\n        let mut sliced = &extensions[index];\n        if\
    \ sliced.len() != 0 {\n            sliced = sliced.to_string();\n        }\n \
    \       let mut class_name = class_name.to_string();\n        let mut strongest_extension\
    \ = class_name.to_string();\n        for element in &extensions {\n          \
    \  if element.to_lowercase().chars().count() > strength {\n                strongest_extension\
    \ = element.to_string();\n            }\n        }\n        return strongest_extension;\n\
    \    }\n    return class_name;", "    let mut extensions_map = HashMap::new();\n\
    \    for (index, extension) in extensions.iter().enumerate() {\n        extensions_map.insert(extension.to_lowercase(),\
    \ index);\n    }\n\n    let mut strength = 0;\n    let mut extension_index = 0;\n\
    \    while extension_index < extensions.len() {\n        let extension = &extensions[extension_index];\n\
    \        let extension_index = extensions_map.get(extension.to_lowercase()).unwrap();\n\
    \n        let c = extension.chars().filter(|&c| c >= 'A' && c <= 'Z').count();\n\
    \        let s = extension.chars().filter(|&c| c >= 'a' && c <= 'z').count();\n\
    \        strength += (c - s);\n    }\n    String::from(class_name + extensions[strength].to_string().to_lowercase())",
  "    let mut extensions_map: HashMap<String, usize> = extensions.iter().map(|x|\
    \ {\n        (x.to_ascii_lowercase(), x.len() + 1)\n    }).collect();\n    \n\
    \    let mut strength = -1;\n    let mut strongest: String = class_name;\n   \
    \ for (extension_name, count) in extensions_map.iter() {\n        if count > strength\
    \ {\n            strength = count;\n            strongest = class_name + \".\"\
    \ + extension_name;\n        }\n    }\n    strongest", "    let mut extensions_map\
    \ = extensions.iter().cloned().collect::<HashMap<_, _>>();\n    extensions_map.sort_by_key(|&(k1,\
    \ _)| k1.chars().fold(0, |res, c| {\n        res + (c.to_ascii_lowercase().unwrap()\
    \ as u128 - c.to_ascii_uppercase().unwrap() as u128) as i32\n    })).into_iter().take(1).next()\n\
    \        .map(|(k1, v1)| k1 + String::from(\".\") + v1)\n        .unwrap_or_else(|_|\
    \ class_name + \".\" + extensions[0])", "  let mut strength = -1i32;\n  for ext\
    \ in extensions.iter() {\n    let cap = ext.chars().filter(|c| c.is_uppercase()).count();\n\
    \    let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n    strength\
    \ = (cap - sm) as i32 / cap as i32;\n    if strength > 0 {\n      break;\n   \
    \ }\n  }\n  let class_name = format!(\"{}.{}\", class_name, extensions.iter().cloned().sorted().first().unwrap());\n\
    \  if strength > 0 {\n    class_name.to_string()\n  } else {\n    String::from(\"\
    ErrorStrongestExtension\")\n  }", "    let mut result = vec![];\n\n    for extension\
    \ in extensions {\n        let mut class_name = class_name;\n        let mut extension\
    \ = extension;\n        let mut extension_len = extension.len();\n\n        let\
    \ mut max_strength = -1;\n        let mut max_extension = String::from(\"\");\n\
    \n        for mut i = 0; i < extension_len; i++ {\n            let mut char =\
    \ String::from(\"\");\n            let mut index = i;\n            let mut char_length\
    \ = extension.len();\n            while index > 0 && char_length > 0 {\n     \
    \           char = extension[index - char_length..index];\n                char_length\
    \ = char_length - 1;\n                index = index - 1;\n            }\n    \
    \        let mut char_digits = char.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n\
    \            let mut char_letters = char.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \            let mut strength = char_digits - char_letters;\n\n            if\
    \ strength > max_strength {\n                max_extension = extension;\n    \
    \            max_strength = strength;\n            }\n        }\n        result.push(format!(\"\
    {}.{}\", class_name, max_extension));\n    }\n\n    result.iter().fold(String::from(\"\
    \"), |mut result, _| {\n        if result.is_empty() {\n            return result;\n\
    \        }\n        let mut last_index = result.len();\n        for _ in 0..result.len()\
    \ - 1 {\n            if result.chars().any(|c| !c.is_ascii_whitespace()) {\n \
    \               last_index = result.len();\n                break;\n         \
    \   }\n        }\n        let mut last_char = result.chars().nth(last_index).unwrap();\n\
    \        if !last_char.ascii_ascii_casefold().is_ascii_ascii_whitespace() {\n\
    \            last_char = String::from(\"\");\n        }\n        result.set_len(result.len()\
    \ - 1);\n        result + last_char + String::from(\"\") + &result[..]\n    }).to_string()",
  "    let mut extensions_sorted = extensions.clone();\n    let mut max_extension_strength\
    \ = 0;\n    for (i, element) in extensions_sorted.iter().enumerate() {\n     \
    \   let c = element[..].chars().filter(|&c| c.is_upper()).count();\n        let\
    \ s = element[..].chars().filter(|&c| c.is_lower()).count();\n        if c > s\
    \ {\n            max_extension_strength = i;\n        }\n    }\n    let strength\
    \ = max_extension_strength - extensions.iter().filter(|&element| element.starts_with(class_name.as_str())).count();\n\
    \    class_name.to_string().concat(\".\").to_string(strength.to_string()).to_string(&extensions_sorted[strength])",
  "    extensions[\n        extensions.iter().filter(|x| x.chars().filter(|x| x.is_uppercase()).count()\
    \ >\n                                     x.chars().filter(|x| x.is_lowercase()).count()\n\
    \        ).min(|a, b| {\n            a.chars().filter(|x| x.is_uppercase()).count()\
    \ <\n            b.chars().filter(|x| x.is_uppercase()).count()\n        }).unwrap().to_string()\
    \ + \".\" +\n        extensions[\n            extensions.iter().filter(|x| x.chars().filter(|x|\
    \ x.is_lowercase()).count() >\n                                     x.chars().filter(|x|\
    \ x.is_lowercase()).count()\n        ).min(|a, b| {\n            a.chars().filter(|x|\
    \ x.is_lowercase()).count() <\n            b.chars().filter(|x| x.is_lowercase()).count()\n\
    \        }).unwrap().to_string()\n    ]", "    // Write your code here\n    ",
  "    let mut current_strongest_ext = \"\";\n    for ext in extensions {\n      \
    \  let strength = (ext.to_lowercase().chars().count()).saturating_sub((ext.to_uppercase().chars().count()).saturating_sub(1));\n\
    \        if strength > 0 {\n            current_strongest_ext = class_name + \"\
    .\" + ext;\n            break;\n        }\n    }\n    return current_strongest_ext;",
  "    let mut result = String::from(class_name);\n    let mut extension_vec: Vec<String>\
    \ = extensions.to_vec();\n    extension_vec.sort();\n    let mut count = 0;\n\
    \    for extension in &extension_vec {\n        let mut new_str: String = extension.clone();\n\
    \        let mut counter: isize = 0;\n        let mut last: String;\n        for\
    \ c in &new_str {\n            if c.is_uppercase() {\n                counter\
    \ = counter + 1;\n                if last != \"\" {\n                    last\
    \ = extension.clone();\n                }\n            } else if c.is_lowercase()\
    \ {\n                counter = counter - 1;\n            }\n            if counter\
    \ == 0 {\n                break;\n            }\n        }\n        if counter\
    \ == 0 {\n            break;\n        }\n        result = result.push_str(&last);\n\
    \    }\n    if result == class_name {\n        result.push_str(&extensions[0])\n\
    \    }\n    result", "    let mut min = String::new();\n    let mut max = String::new();\n\
    \    for (i, ex) in extensions.iter().enumerate() {\n        let ext: &str = ex;\n\
    \        let cap = ext\n            .chars()\n            .filter(|&c| c.is_uppercase())\n\
    \            .count();\n        let sm = ext\n            .chars()\n         \
    \   .filter(|&c| c.is_lowercase())\n            .count();\n        if cap > sm\
    \ {\n            if cap > 0 {\n                min.push_str(ext);\n          \
    \  } else {\n                max.push_str(ext);\n            }\n        } else\
    \ if sm > cap {\n            if sm > 0 {\n                min.push_str(ext);\n\
    \            } else {\n                max.push_str(ext);\n            }\n   \
    \     }\n    }\n    if min.is_empty() {\n        return max;\n    }\n    if max.is_empty()\
    \ {\n        return min;\n    }\n    let cap = min.chars().filter(|&c| c.is_uppercase()).count();\n\
    \    let sm = min.chars().filter(|&c| c.is_lowercase()).count();\n    let result\
    \ = if cap > sm {\n        min\n    } else {\n        max\n    };\n    format!(\"\
    {}.{}\", class_name, result)", "    let mut class_name = String::from(class_name);\n\
    \    let mut extensions = extensions.clone();\n    let mut index = 0;\n    let\
    \ mut highest_strength = -1;\n\n    while extensions.len() > 0 {\n        let\
    \ mut current_strength = 0;\n        let mut current_extension = extensions.remove(0);\n\
    \        \n        for i in 0..class_name.len() {\n            let letter = class_name[i];\n\
    \            \n            if letter == current_extension[0] {\n             \
    \   current_strength += 1;\n            } else {\n                break;\n   \
    \         }\n        }\n\n        if current_strength > highest_strength {\n \
    \           highest_strength = current_strength;\n            index = current_extension.len();\n\
    \        }\n    }\n    class_name.set_len(0);\n    class_name.push_str(&extensions[index]);\n\
    \    class_name", "    let mut extensions_map = HashMap::new();\n    for extension\
    \ in extensions {\n        let mut counter = 0;\n        for char in extension\
    \ {\n            if char == char.to_upper() {\n                counter++;\n  \
    \          }\n        }\n        extensions_map.insert(counter, extension);\n\
    \    }\n    extensions_map.keys().max().unwrap().to_string()", "    let mut strength\
    \ = -1;\n    for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        strength = (cap - sm) as i32;\n  \
    \  }\n\n    if strength == -1 {\n        format!(\"{}.\", class_name)\n    } else\
    \ {\n        format!(\"{}.{}\", class_name, extensions[strength].to_lowercase())\n\
    \    }", "    let extension = extensions.iter().position(|x| x.is_upper()).unwrap();\n\
    \    let extension_strength = extensions.iter().position(|x| x.chars().count(|x|\
    \ x.is_uppercase())).unwrap();\n    (class_name.to_string() + &extensions[extension].to_string()\
    \ + &extensions[extension_strength].to_string()).to_string()", "    let mut extensions_map\
    \ = HashMap::new();\n    for extension in extensions {\n        let mut ext_map\
    \ = extensions_map.entry(extension.clone());\n        if let Some(mut v) = ext_map.mutate()\
    \ {\n            v.insert(String::from(class_name.clone()));\n        }\n    }\n\
    \    \n    // sort the map by the number of extensions\n    extensions_map.sort_by(|a,\
    \ b| b.value.len());\n\n    // Return the strongest extension name\n    if let\
    \ Some((_, value)) = extensions_map.iter().next() {\n        let strength = value.len();\n\
    \        let mut strongest_name = class_name.clone();\n        let mut prev_letter:\
    \ Char = 0;\n        for letter in value {\n            if prev_letter != letter\
    \ + 32 {\n                strongest_name += &format!(\"{}\", letter);\n      \
    \      }\n            prev_letter = letter + 32;\n        }\n        return strongest_name;\n\
    \    }\n    return String::from(\"\");", "    extensions\n        .iter()\n  \
    \      .fold(String::from(class_name), |mut current, name| {\n            if let\
    \ Some(index) = class_name.iter().position(|c| c.is_uppercase())\n           \
    \         .cloned()\n                    .find(|c| c.is_lowercase())\n       \
    \     {\n                let name = &name[index..];\n                let current_strength\
    \ = current.to_lowercase().chars().count();\n                let extension_strength\
    \ = name.chars().count();\n                let strength = current_strength - extension_strength;\n\
    \                let mut current_str = String::from(current);\n              \
    \  let mut name = String::from(name);\n                if strength > 0 {\n   \
    \                 current_str.push_str(&name.chars().rev());\n               \
    \     name.push_str(&name.chars().rev());\n                }\n               \
    \ String::from(current_str)\n            } else {\n                current\n \
    \           }\n        })", "    let mut strength = 0;\n    let mut best_name\
    \ = String::from(\"\");\n    for ext in extensions {\n        let cname = class_name\
    \ + ext;\n        if strength == 0 || cname.chars().filter(|c| c.is_uppercase()).count()\
    \ > strength {\n            strength = cname.chars().filter(|c| c.is_uppercase()).count()\
    \ - ext.chars().filter(|c| c.is_lowercase()).count();\n            best_name =\
    \ cname;\n        }\n    }\n    \n    format!(\"{}.{}\", class_name, best_name)",
  '    extensions[0]', "    let mut strength = -1;\n    let mut highest_strength_extension:\
    \ Option<String> = None;\n    for ext in extensions {\n        let cap_ext = ext.to_lowercase().chars().filter(|c|\
    \ *c >= 'A').count() - ext.to_lowercase().chars().filter(|c| *c <= 'Z').count();\n\
    \        let sl_ext = ext.to_lowercase().chars().filter(|c| *c >= 'a').count()\
    \ - ext.to_lowercase().chars().filter(|c| *c <= 'z').count();\n        if cap_ext\
    \ > 0 && sl_ext > 0 {\n            let strength = cap_ext as f32 - sl_ext as f32;\n\
    \            if strength > strength {\n                strength = strength;\n\
    \                highest_strength_extension = Some(ext);\n            }\n    \
    \    }\n    }\n    if let Some(extension) = highest_strength_extension {\n   \
    \     format!(\"{}.{}\", class_name, extension)\n    } else {\n        format!(\"\
    {}\", class_name)\n    }", "    let mut strongest_extension: usize = -1;\n   \
    \ let mut num_of_lower = 0;\n    for extension in extensions {\n        let cap\
    \ = extension.chars().filter(|c| match c {\n            'A'...'Z' => true,\n \
    \           _ => false,\n        }).count();\n        let sm = extension.chars().filter(|c|\
    \ match c {\n            'a'...'z' => true,\n            _ => false,\n       \
    \ }).count();\n        if cap > sm {\n            num_of_lower += 1;\n       \
    \ } else {\n            num_of_lower -= 1;\n        }\n        strongest_extension\
    \ = if strongest_extension == -1 || cap > strongest_extension {\n            cap\n\
    \        } else {\n            strongest_extension\n        };\n    }\n    strongest_extension\
    \ = if strongest_extension == -1 || num_of_lower > strongest_extension {\n   \
    \     num_of_lower\n    } else {\n        strongest_extension\n    };\n    class_name.to_string()\
    \ + extensions[strongest_extension].to_string()", "    let mut total_extensions\
    \ = extensions.len();\n    for extension in extensions {\n        let num_upper\
    \ = extension.chars().filter(|&c| c.is_upper()).count();\n        let num_lower\
    \ = extension.chars().filter(|&c| c.is_lowercase()).count();\n        total_extensions\
    \ = (num_upper - num_lower) / num_upper as f64 + total_extensions as f64;\n  \
    \  }\n    let strength = total_extensions as f64;\n    match strength {\n    \
    \    1.0 => class_name.to_string(),\n        0.0 => \"\",\n        strength =>\
    \ format!(\"{}.{}\", class_name, extensions[total_extensions..total_extensions..-1].to_string()),\n\
    \    }", "    let mut strongest_extension = None;\n    let mut strength = -1i32;\n\
    \    for extension in extensions {\n        let c = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let s = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let cap = c + s;\n        let sm =\
    \ extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n        let strength\
    \ = if cap > sm {\n            cap - sm\n        } else {\n            sm\n  \
    \      };\n        if strength >= 0 {\n            strongest_extension = Some(extension);\n\
    \            break;\n        }\n    }\n    match strongest_extension {\n     \
    \   Some(name) => {\n            format!(\"{}.{}\", class_name, name)\n      \
    \  }\n        None => format!(\"{}.{}\", class_name, extensions[0].to_owned()),\n\
    \    }", "    let mut min_strength: i32 = std::i32::MAX;\n    let mut best_extension:\
    \ String = String::from(\"\");\n    extensions.iter().for_each(|e| {\n       \
    \ if let Ok(s) = e.to_lowercase().as_ref() {\n            if let Ok(i) = s.to_ascii_lowercase().find(|x|\
    \ *x >= 'a') {\n                min_strength = i as i32;\n            }\n    \
    \    }\n    });\n\n    for (i, e) in extensions.iter().enumerate() {\n       \
    \ if let Ok(s) = e.to_lowercase().as_ref() {\n            if let Ok(i) = s.to_ascii_lowercase().find(|x|\
    \ *x >= 'a') {\n                if min_strength == i as i32 {\n              \
    \      best_extension = e.to_owned();\n                    min_strength = std::i32::MAX;\n\
    \                }\n            }\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ best_extension)", "    let mut strength = -1;\n    let mut name_extension =\
    \ class_name;\n    for extension in extensions.iter() {\n        if extension.chars().count()\
    \ > strength {\n            strength = extension.chars().count();\n          \
    \  name_extension = &format!(\"{}.{}\", class_name, extension);\n        }\n \
    \   }\n    return name_extension;", "    let mut exts = extensions.iter().cloned();\n\
    \    let mut max_strength = -1;\n    let mut max_extension = String::from(\"\"\
    );\n    loop {\n        let mut current_strength = 0;\n        let mut current_extension\
    \ = String::from(\"\");\n        for extension in &mut exts {\n            let\
    \ cap = extension.chars().filter(|&x| x >= 'A' && x <= 'Z').count();\n       \
    \     let sm = extension.chars().filter(|&x| x >= 'a' && x <= 'z').count();\n\
    \            current_strength += cap - sm;\n            current_extension += extension;\n\
    \        }\n        if current_strength > max_strength {\n            max_strength\
    \ = current_strength;\n            max_extension = current_extension;\n      \
    \  }\n        if exts.next().is_none() {\n            break;\n        }\n    }\n\
    \    class_name.as_string() + \".\" + max_extension", "    let mut extension_strength\
    \ = Vec::new();\n    for ext in extensions {\n        let cap = ext.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = ext.chars().filter(|c| c.is_lowercase()).count();\n\
    \        let strength = cap - sm;\n        extension_strength.push(strength);\n\
    \    }\n    extension_strength.sort_by_key(|&x| x).next().unwrap().to_string()\n\
    \        + \".\" + class_name.to_string()", "    let mut strength = 0;\n    let\
    \ mut classname = class_name;\n    let mut extension = String::new();\n    \n\
    \    // Loop over each of the extensions\n    for i in 0..extensions.len() {\n\
    \        // Get the uppercase number of a certain letter \n        let cap = extensions[i].to_uppercase().chars().count();\n\
    \        // Get the lowercase number of a certain letter\n        let sm = extensions[i].to_lowercase().chars().count();\n\
    \        // Get the strength of the extension\n        let score = cap - sm;\n\
    \        // Check if there are multiple extensions with the same strength\n  \
    \      // and select the one that comes first in the vector\n        if strength\
    \ != score && strength != 0 {\n            classname += &extensions[i];\n    \
    \        extension = extensions[i];\n            strength = score;\n        }\n\
    \    }\n\n    classname + &extension", "    let mut strongest_extension: Option<String>\
    \ = None;\n    let mut max_strength: Option<usize> = None;\n    for extension\
    \ in extensions.iter() {\n        let extension_strength: usize = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count() - extension.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count();\n        if max_strength.is_none() {\n            max_strength\
    \ = Some(extension_strength);\n        } else if extension_strength > max_strength\
    \ {\n            max_strength = Some(extension_strength);\n        }\n    }\n\
    \    for extension in extensions.iter() {\n        let extension_strength: usize\
    \ = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() - extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if extension_strength == max_strength\
    \ {\n            if strongest_extension.is_none() {\n                strongest_extension\
    \ = Some(extension);\n            }\n        }\n    }\n    if strongest_extension.is_none()\
    \ {\n        return class_name;\n    }\n    match max_strength {\n        Some(strength)\
    \ => class_name.to_string() + strongest_extension.as_ref().unwrap().to_string(),\n\
    \        None => class_name\n    }", "    let mut max = -1;\n    let mut strongest\
    \ = String::from(\"\");\n    for extension in extensions.iter() {\n        let\
    \ ext = String::from(extension);\n        if ext.chars().filter(|&c| c >= 'A'\
    \ && c <= 'Z').count() > max {\n            max = ext.chars().filter(|&c| c >=\
    \ 'A' && c <= 'Z').count();\n        }\n    }\n    strongest.push_str(&class_name);\n\
    \    strongest.push_str(&extensions[extensions.iter().find_index(|&x| x.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').count() > max)]);\n    strongest", "    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut str = \"\";\n    while i < extensions.len() {\n\
    \        if i < extensions.len() - 1 {\n            if extensions[i].is_uppercase()\
    \ && extensions[i + 1].is_lowercase() {\n                if extensions.iter().find(|x|\
    \ x == &extensions[i]).is_ok() {\n                    i += 1;\n              \
    \  } else {\n                    j += 1;\n                    i += 1;\n      \
    \          }\n            } else {\n                if extensions[i].is_lowercase()\
    \ {\n                    i += 1;\n                } else {\n                 \
    \   j += 1;\n                    i += 1;\n                }\n            }\n \
    \       } else {\n            if extensions[i].is_uppercase() {\n            \
    \    i += 1;\n            } else {\n                j += 1;\n                i\
    \ += 1;\n            }\n        }\n    }\n    format!(\"{}.{}\", class_name, extensions[(j\
    \ + 1).to_string()])", "    let mut extensions_map = HashMap::new();\n    for\
    \ (index, extension) in extensions.iter().enumerate() {\n        extensions_map.insert(String::from(class_name\
    \ + extension), index);\n    }\n    let mut extensions_sorted = vec![];\n    extensions_map.sort_by_key(|key,\
    \ _| key).into_iter().for_each(|(extension, index)| {\n        extensions_sorted.push(String::from(extension\
    \ + class_name + \".\"));\n    });\n    extensions_sorted.pop();\n    extensions_sorted.reverse().join(\"\
    \")", "    let mut max_strength = -1;\n    let mut max_extension: Option<String>\
    \ = None;\n    for extension in extensions {\n        let (mut cap, mut sm) =\
    \ extension.chars().map(|c| (c as u8) - 'A').collect::<(Vec<usize>, Vec<usize>)>();\n\
    \        let sm = sm.iter().map(|&c| *c).collect::<Vec<usize>>();\n        let\
    \ cap = cap.iter().map(|&c| *c).collect::<Vec<usize>>();\n        let cap = cap.iter().fold(0,\
    \ |a, b| {\n            a > b ? a : b\n        });\n        let sm = sm.iter().fold(0,\
    \ |a, b| {\n            a > b ? a : b\n        });\n        let strength = cap\
    \ - sm;\n        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_extension = Some(extension);\n        }\n    }\n    if let Some(extension)\
    \ = max_extension {\n        format!(\"{}.{}\", class_name, extension)\n    }\
    \ else {\n        format!(\"{}\", class_name)\n    }", "    let mut strongest_extension:\
    \ String = String::from(class_name);\n\n    for extension in extensions {\n  \
    \      let c = extension.chars().count();\n        let s = extension.chars().filter(|&x|\
    \ x.is_ascii_lowercase()).count();\n        let c = c.saturating_add((s - c).saturating_add(c));\n\
    \        strongest_extension += &format!(\"{}.{}\", class_name, extension);\n\
    \    }\n\n    strongest_extension.into()", "    if extensions.is_empty() {\n \
    \       return String::from(\"\");\n    }\n\n    let mut sorted_extensions = extensions\n\
    \        .iter()\n        .cloned()\n        .sort_by(|a, b| {\n            let\
    \ mut a_strength = a.chars().filter(|c| c.is_uppercase()).count() - a.chars().filter(|c|\
    \ c.is_lowercase()).count();\n            let mut b_strength = b.chars().filter(|c|\
    \ c.is_uppercase()).count() - b.chars().filter(|c| c.is_lowercase()).count();\n\
    \            a_strength.cmp(&b_strength)\n        });\n\n    sorted_extensions.next().unwrap().to_string()\
    \ + class_name", "    let mut strongest_ext = \"\".to_string();\n    for ext in\
    \ extensions.iter() {\n        let ext = ext.to_string();\n        let mut ext_len\
    \ = 0;\n        for char in exc {\n            if char == char.to_lowercase()\
    \ {\n                ext_len += 1;\n            } else {\n                break;\n\
    \            }\n        }\n        let strength = ext_len as usize / ext.len();\n\
    \        if strength > strongest_ext.chars().nth(0).unwrap() {\n            strongest_ext\
    \ = ext.to_string();\n        }\n    }\n    class_name + \".\" + strongest_ext",
  "    let mut strongest_extension = String::from(\"\");\n    for extension in extensions\
    \ {\n        let class_name = format!(\"{}.{}\", class_name, extension);\n   \
    \     let extension_strength = extension.chars().filter(|c| c.is_uppercase().count_chars()\
    \ > c.is_lowercase().count_chars()).count() as i32 - extension.chars().filter(|c|\
    \ c.is_lowercase().count_chars() > c.is_uppercase().count_chars()).count() as\
    \ i32;\n        if extension_strength > 0 {\n            strongest_extension =\
    \ format!(\"{}.{}\", class_name, extension);\n            break;\n        }\n\
    \    }\n    strongest_extension", "    let mut strength = -1;\n    let mut strongest_name\
    \ = class_name;\n    for extension in extensions {\n        let mut length = extension.len();\n\
    \        match length {\n            0 => {\n                strength = -1;\n\
    \                strongest_name = extension;\n                break;\n       \
    \     }\n            _ => {\n                let mut fraction = (length as f64)\
    \ / (class_name.len() as f64);\n                let mut uppercase = 0;\n     \
    \           let mut lowercase = 0;\n                for letter in extension.chars()\
    \ {\n                    match letter {\n                        'A' => uppercase\
    \ = 1,\n                        'B' => lowercase = 1,\n                      \
    \  'C' => uppercase = 2,\n                        _ => {}\n                  \
    \  }\n                }\n                fraction = uppercase - lowercase;\n \
    \               if fraction < 0 {\n                    strength = -1;\n      \
    \              strongest_name = extension;\n                } else if fraction\
    \ > strength {\n                    strength = fraction;\n                   \
    \ strongest_name = extension;\n                }\n            }\n        }\n \
    \   }\n    strongest_name", "    let mut counter: usize = 0;\n\n    for extension\
    \ in extensions {\n        if extension.chars().filter(|c| c.is_upper()).count()\
    \ > counter.chars().filter(|c| c.is_upper()).count() {\n            counter =\
    \ extension.chars().filter(|c| c.is_upper()).count();\n        }\n        if extension.chars().filter(|c|\
    \ c.is_lowercase()).count() > counter.chars().filter(|c| c.is_lowercase()).count()\
    \ {\n            counter = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        }\n    }\n\n    format!(\"{}.{}\", class_name, extensions[counter])",
  "    // Your code here\n    let mut counter = 0;\n    let mut strongest_extension:\
    \ String = \"\";\n    for extension in extensions {\n        if counter == 0 {\n\
    \            strongest_extension += extension;\n        } else {\n           \
    \ let mut strength = extension.chars().filter(|x|x == 'A'..='Z').count() - extension.chars().filter(|x|x\
    \ == 'a'..='z').count();\n            if strength > counter {\n              \
    \  strongest_extension = extension;\n                counter = strength;\n   \
    \         }\n        }\n    }\n    class_name + strongest_extension", "    debug_assert!(extensions.iter().all(|&e|\
    \ e.is_ascii_uppercase()));\n    debug_assert!(extensions.iter().all(|&e| e.is_ascii_lowercase()));\n\
    \    let mut strength = vec![-1i32, -1i32];\n    for e in extensions {\n     \
    \   let cap = e.chars().filter(|c| c.is_ascii_uppercase()).count();\n        let\
    \ sm = e.chars().filter(|c| c.is_ascii_lowercase()).count();\n        let strength_\
    \ = cap - sm;\n        if strength == strength_ {\n            continue;\n   \
    \     }\n        if strength > strength_ {\n            strength = strength_;\n\
    \        }\n    }\n    let mut extension = String::from(\"\");\n    for e in extensions\
    \ {\n        let cap = e.chars().filter(|c| c.is_ascii_uppercase()).count();\n\
    \        let sm = e.chars().filter(|c| c.is_ascii_lowercase()).count();\n    \
    \    if cap == sm {\n            extension = e.to_string();\n            break;\n\
    \        }\n    }\n    extension.push_str(&class_name.to_string());\n    extension.push_str(&extensions[strength\
    \ as usize].to_string());\n    extension", "    let mut s = String::from(class_name);\n\
    \    let mut strength = 1;\n    for extension in extensions {\n        match extension.chars().collect::<Vec<char>>().count(|c|\
    \ *c.to_lowercase() <= s.chars().collect::<Vec<char>>().count(|c| *c.to_uppercase()))\
    \ {\n            1 => {},\n            2 => {\n                s = s.concat(\"\
    .\".to_owned());\n                strength = -1;\n            },\n           \
    \ _ => {}\n        }\n    }\n    s.concat(f\".{extensions[extensions.iter().position(|x|\
    \ x.to_lowercase() == extensions[0].to_lowercase()).unwrap()]}\".to_owned())",
  "  let mut strength = -1;\n  let mut extension = vec![\"\"];\n  for extension in\
    \ extensions {\n    if let Some(strength) = class_name.chars().filter(|c| c ==\
    \ extension.chars()).count() {\n      if strength >= 0 {\n        break;\n   \
    \   }\n    }\n  }\n  if strength >= 0 {\n    extension.iter().filter_map(|&x|\
    \ x.chars().count()).min().unwrap().to_string()\n  } else {\n    String::from(\"\
    \")\n  }", "    let mut result = String::from(\"\");\n    \n    for (i, extension)\
    \ in extensions.iter().enumerate() {\n        let cap = extension.chars().map(|x|x\
    \ == 'A'..='Z').filter(|x|!x.is_empty()).count() as i64;\n        let sm = extension.chars().map(|x|x\
    \ == 'a'..='z').filter(|x|!x.is_empty()).count() as i64;\n        let strength\
    \ = cap - sm;\n        if strength >= 0 {\n            if i == 0 {\n         \
    \       result = class_name+\".\"+extension;\n            } else {\n         \
    \       result = result + \".\"+extension;\n            }\n        }\n    }\n\
    \    result", "    let mut strength = -1;\n    let mut class_name_parts: Vec<String>\
    \ = class_name.splitn(2, \".\").collect();\n    for extension in extensions {\n\
    \        let extension_parts = extension.splitn(2, \".\").collect();\n       \
    \ let strength_part = extension_parts[1] - extension_parts[0];\n        if strength\
    \ > 0 {\n            if strength_part > strength {\n                class_name_parts\
    \ = class_name_parts[0..1];\n                strength = strength_part;\n     \
    \       } else {\n                continue;\n            }\n        }\n      \
    \  class_name_parts.push(extension);\n    }\n    class_name.concat(\".\").join(&class_name_parts.join(\"\
    .\"))", "    let mut num_upper = 0;\n    let mut num_lower = 0;\n    for e in\
    \ extensions {\n        if e.chars().filter(|c| *c == c.to_ascii_lowercase()).count()\
    \ > num_lower {\n            num_lower = e.chars().filter(|c| *c == c.to_ascii_uppercase()).count();\n\
    \        }\n        if e.chars().filter(|c| *c == c.to_ascii_uppercase()).count()\
    \ > num_upper {\n            num_upper = e.chars().filter(|c| *c == c.to_ascii_lowercase()).count();\n\
    \        }\n    }\n    let strength = (num_upper - num_lower) as i32;\n    let\
    \ extension = match extensions.iter().position(|x| *x == class_name).cloned()\
    \ {\n        None => String::from(\"unknown\"),\n        Some(idx) => &extensions[*idx\
    \ as usize],\n    };\n    format!(\"{}.{}\", class_name, extension)", "    let\
    \ mut strength = -1;\n    let mut longest_name = \"\";\n    for (i, ext_name)\
    \ in extensions {\n        let ext_cap = ext_name.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count();\n        let ext_sm = ext_name.chars().filter(|c| c >=\
    \ 'a' && c <= 'z').count();\n        let ext_strength = ext_cap - ext_sm;\n  \
    \      if ext_strength > strength {\n            strength = ext_strength;\n  \
    \          longest_name = ext_name;\n        }\n    }\n    format!(\"{}.{}\",\
    \ class_name, longest_name)", "    let mut map = HashMap::new();\n\n    for (index,\
    \ extension) in extensions.iter().enumerate() {\n        map.entry(extension.as_str()).or_insert(0);\n\
    \        if index == 0 {\n            map.entry(class_name.as_str()).or_insert(0);\n\
    \        }\n    }\n\n    let mut counter = map.entry(class_name.as_str()).or_insert(0);\n\
    \    let mut max = counter.clone();\n\n    map.entry(extensions[0].as_str()).or_insert(1);\n\
    \n    for (i, extension) in extensions.iter().enumerate() {\n        if i != 0\
    \ {\n            map.entry(extension.as_str()).or_insert(0);\n        }\n\n  \
    \      if map.contains_key(extension.as_str()) {\n            let counter = map.entry(extension.as_str()).or_insert(0);\n\
    \            if counter.value > max.value {\n                max = counter;\n\
    \            }\n        }\n    }\n\n    if max.value > 0 {\n        format!(\"\
    {}{}\", class_name, max.key)\n    } else {\n        class_name\n    }", "    match\
    \ extensions {\n        vec![] => \"\",\n        vec![String::new()] => \"\",\n\
    \        vec![ext] => {\n            let mut counts = HashMap::new();\n      \
    \      for ext in extensions {\n                counts.entry(ext.to_lowercase()).or_insert(0);\n\
    \            }\n            let cap = class_name.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count();\n            let sm = class_name.chars().filter(|c| *c\
    \ >= 'a' && *c <= 'z').count();\n            let strength = cap - sm;\n      \
    \      match counts.entry(strength).or_insert(0) {\n                0 => \"\"\
    .to_string(),\n                _ => extensions.iter().filter(|ext| *ext == class_name)\n\
    \                    .cloned()\n                    .filter(|c| *c >= 'A' && *c\
    \ <= 'Z').count()\n                    .to_string()\n            }\n        }\n\
    \    }", "    let mut strongest_extension = Vec::new();\n    let mut num_of_uppercase\
    \ = 0;\n    let mut num_of_lowercase = 0;\n    let mut total_num_of_uppercase\
    \ = 0;\n    let mut total_num_of_lowercase = 0;\n    extensions.iter().for_each(|e|\
    \ {\n        match e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() {\n  \
    \          1 => total_num_of_uppercase += 1,\n            2 => total_num_of_lowercase\
    \ += 1,\n            _ => (),\n        };\n        if e.chars().filter(|c| *c\
    \ >= 'a' && *c <= 'z').count() > num_of_lowercase {\n            num_of_lowercase\
    \ = e.chars().filter(|c| *c >= 'a' && *c <= 'z').count();\n        }\n       \
    \ if e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() > num_of_uppercase {\n\
    \            num_of_uppercase = e.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        }\n    });\n    strongest_extension.push(class_name);\n    if num_of_uppercase\
    \ == num_of_lowercase {\n        strongest_extension.push(class_name.to_lowercase());\n\
    \    } else {\n        strongest_extension.push(class_name.to_lowercase() + \"\
    _\" + String::from(\"_\".to_string(num_of_lowercase - num_of_uppercase)));\n \
    \   }\n    strongest_extension.join(\"\").to_owned()", "    let extension_strength\
    \ = extensions\n        .iter()\n        .zip(extensions.iter().map(|e| e.chars().count()))\n\
    \        .map(|(extension, count)| {\n            let class_name = extension.chars().collect::<Vec<_>>();\n\
    \            let letter_count = extension.chars().filter(|c| c.is_ascii_lowercase()).count();\n\
    \            (letter_count, class_name)\n        })\n        .filter_map(|(count,\
    \ class_name)| {\n            if count == extension_strength.len() {\n       \
    \         Some(class_name)\n            } else {\n                None\n     \
    \       }\n        })\n        .enumerate()\n        .max();\n    class_name\n\
    \        .to_string() + \n        extension_strength.as_ref()\n            .expect(\"\
    No extension with the given strength\")\n            .value\n            .join()",
  "    let mut s = String::from(class_name);\n    extensions.sort_by(|a, b| b.cmp(a));\n\
    \    for (i, e) in extensions.iter().enumerate() {\n        let len = e - class_name;\n\
    \        let sm = e.chars().filter(|c| c.is_ascii_lowercase).count();\n      \
    \  let cap = e.chars().filter(|c| c.is_ascii_uppercase).count();\n        let\
    \ diff = cap - sm;\n        let strength = if diff < 0 {\n            -1\n   \
    \     } else if diff == 0 {\n            0\n        } else {\n            diff\
    \ / (cap - sm)\n        };\n        let mut j = i;\n        while j > 0 && extensions[j\
    \ - 1] == e {\n            j -= 1;\n        }\n        let mut l = j;\n      \
    \  while l > 0 && extensions[l - 1] == e {\n            l -= 1;\n        }\n \
    \       let strength = (strength * (j - i) + 1) / (j - l + 1);\n        s = s.to_owned()\
    \ + &e.to_owned() + &format!(\"{}\", strength).to_string();\n    }\n    s", " \
    \   let mut max_index = 0;\n    let mut max_extension = \"\";\n    for extension\
    \ in extensions.iter() {\n        if extension.chars().filter(|c| *c >= 'A' &&\
    \ *c <= 'Z').count() == class_name.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ && extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() > 0 {\n    \
    \        let index = (extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\
    \ + class_name.chars().filter(|c| *c >= 'a' && *c <= 'z').count()).fract();\n\
    \            if index > max_index {\n                max_index = index;\n    \
    \            max_extension = extension;\n            }\n        }\n    }\n   \
    \ if max_index > 0 {\n        format!(\"{}.{}\", class_name, max_extension)\n\
    \    } else {\n        class_name\n    }", "    let mut extensions_strength: Vec<i64>\
    \ = extensions.iter().map(|e| e.chars().filter(|x| x >= 'A' && x <= 'Z').count()\
    \ - e.chars().filter(|x| x >= 'a' && x <= 'z').count()).collect();\n    let mut\
    \ extensions_strength_max = extensions_strength.iter().max().unwrap();\n    let\
    \ mut extensions_index = vec![0; extensions_strength.len()];\n    \n    for i\
    \ in 0..extensions_strength.len() {\n        if extensions_strength[i] == extensions_strength_max\
    \ {\n            extensions_index[i] = i - 1;\n        }\n    }\n    \n    let\
    \ mut extensions_strength_index = extensions_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_index\
    \ = extensions_strength_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \n    let mut extensions_strength_mut_index = extensions_strength_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    \n    for mut i in 0..extensions_strength.len()\
    \ {\n        extensions_strength_mut_index[i] = extensions_strength_index[i];\n\
    \    }\n    \n    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n\
    \    \n    let mut extensions_strength_mut_index = extensions_strength_mut_index.iter().enumerate().map(|(i,\
    \ elem)| i + elem).collect::<Vec<usize>>();\n    let mut extensions_strength_mut_index\
    \ = extensions_strength_mut_index.iter().enumerate().map(|(i, elem)| i + elem).collect::<Vec<usize>>();\n",
  "    let mut strength: i64 = 0;\n    for extension in extensions.iter().cloned()\
    \ {\n        let (letters, count) = (extension.chars().filter(|c| c.is_ascii_letter()).count(),\
    \ 1);\n        let (letters_upper, count_upper) = (extension.chars().filter(|c|\
    \ c.is_ascii_letter()).filter(|c| c.is_uppercase()).count(), 1);\n        let\
    \ (letters_lower, count_lower) = (extension.chars().filter(|c| c.is_ascii_letter()).filter(|c|\
    \ c.is_lowercase()).count(), 1);\n        \n        strength += (letters - count_lower)\
    \ * (letters - count_upper);\n    }\n    \n    if strength == 0 {\n        class_name\
    \ + \".\" + extensions[0]\n    } else {\n        let strength_upper = strength\
    \ / 2;\n        let strength_lower = strength_upper - strength;\n        match\
    \ strength_lower {\n            0 => class_name + \".\" + extensions[0],\n   \
    \         1 => class_name + \".\" + extensions[1],\n            _ => class_name\
    \ + String::from(\"_\").to_string() + extensions[(extensions.len() - 1).abs()\
    \ as usize],\n        }\n    }", "    let mut best_strength: i64 = 0;\n    let\
    \ mut best_extension: Option<String> = None;\n    for ext in extensions {\n  \
    \      let ext = ext\n            .clone()\n            .to_lowercase()\n    \
    \        .to_ascii_lowercase()\n            .to_vec();\n        let cap = ext.len();\n\
    \        let sm = ext.iter().filter(|&char| char == '_').count();\n        let\
    \ strength = cap - sm;\n        if strength > best_strength {\n            best_strength\
    \ = strength;\n            best_extension = Some(ext);\n        }\n    }\n   \
    \ match best_extension {\n        Some(ext) => format!(\"{}.{}\", class_name,\
    \ ext),\n        None => class_name,\n    }", "    let mut strength = -1;\n  \
    \  let mut name = String::from(class_name);\n    for extension in extensions {\n\
    \        let mut chars = String::from(extension);\n        if chars.chars().all(|c|\
    \ c >= 'a' && c <= 'z') {\n            chars.push_str(c.to_uppercase());\n   \
    \     } else {\n            chars.push_str(c.to_lowercase());\n        }\n   \
    \     if strength < chars.chars().count() - name.chars().count() {\n         \
    \   strength = chars.chars().count() - name.chars().count();\n            name\
    \ = chars;\n        }\n    }\n    format!(\"{}.{}\", name, strength)", "    //\
    \ Compute the length of the longest extension\n    let mut max_len = -1;\n   \
    \ for e in extensions {\n        let len = e.len();\n        if max_len < len\
    \ {\n            max_len = len;\n        }\n    }\n\n    // Compute the number\
    \ of capital letters\n    let cap_len = class_name.chars().filter(|c| *c == ('A'\
    \ as u8)).count() as u32;\n\n    // Compute the number of lowercase letters\n\
    \    let sm = class_name.chars().filter(|c| *c == ('a' as u8)).count() as u32;\n\
    \n    // Compute the strength of the extension\n    let strength = (cap_len -\
    \ sm) as f64 / cap_len;\n\n    // Find the strongest extension\n    extensions.iter().find(|e|\
    \ *e.len()*max_len >= strength).unwrap_or(\"\")", "    // Your code here\n\n \
    \   // Return result of your code\n    return \"\"", "    if extensions.len()\
    \ == 0 {\n        format!(\"{}.\", class_name)\n    } else {\n        let mut\
    \ c = class_name;\n        for i in extensions.iter().rev() {\n            let\
    \ mut x = i;\n            if let Some(y) = extensions.iter().skip(i).find(|x|\
    \ *x == x) {\n                *y = *x;\n            }\n            c = c.to_string();\n\
    \        }\n        format!(\"{}.{}\", c, &extensions.iter().take(extensions.len()\
    \ - 1).collect::<String>().unwrap())\n    }", "    let mut best_extensions: Vec<(String,\
    \ usize)> = extensions.iter().cloned().collect();\n    best_extensions.sort();\n\
    \    let mut best_strength: usize = 0;\n    for i in 0..(best_extensions.len()\
    \ - 1) {\n        let (mut extension, strength) = best_extensions[i];\n      \
    \  if strength > best_strength {\n            best_strength = strength;\n    \
    \        best_extension = extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, best_extension)", "    let mut strongest = Vec::new();\n    let\
    \ mut strength = usize::MAX;\n    for e in extensions {\n        let mut c = e.chars();\n\
    \        strength = cmp::max(strength, c.count(|&x| x.is_uppercase()));\n    \
    \    strength = cmp::max(strength, c.count(|&x| x.is_lowercase()));\n    }\n \
    \   \n    // This could throw an exception if there was a tie, but it won't anyway\
    \ because it's \n    // called after checking that no extension has strongest\
    \ strength\n    strongest.push(class_name);\n    for i in 0..extensions.len()\
    \ {\n        let strength = extensions[i].chars().count(|&x| x.is_uppercase());\n\
    \        if strength >= strength {\n            strongest.push(i.to_string() +\
    \ extensions[i]);\n        }\n    }\n    if strongest.len() > 1 {\n        let\
    \ first = strongest[0];\n        for i in 1..strongest.len() {\n            if\
    \ strongest[i] > first {\n                break;\n            }\n        }\n \
    \       strongest = strongest.clone() + strongest.clone();\n        strongest[first]\
    \ = strongest[first].to_string();\n        strongest[first + 1] = \"\";\n    \
    \    String::from(&strongest.join(\" \"))\n    } else {\n        String::from(&strongest.join(\"\
    \ \"))\n    }", "    if extensions.iter().all(|&x| x.chars().any(|y|y.is_uppercase())\
    \ && x.chars().count() > 1){\n        extensions.iter().filter(|&x| x.chars().count()\
    \ > 1).max()\n    }\n    else {\n        extensions.iter().filter(|&x| x.chars().count()\
    \ == 1).max()\n    }", "    // Your code here\n    let mut result = 0;\n    for\
    \ extension in extensions {\n        let mut count = 0;\n        let mut strongest_extension_str:\
    \ Vec<String> = Vec::new();\n        for c in extension {\n            if c.is_uppercase()\
    \ {\n                count += 1;\n            }\n            if c.is_lowercase()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ 0 {\n            return format!(\"{}.{}\", class_name, extension);\n       \
    \ }\n        if count == 1 {\n            return format!(\"{}.{}\", class_name,\
    \ extensions[0]);\n        }\n        result += count as f64 as i64;\n    }\n\
    \    format!(\"{}.{}\", class_name, extensions[result]);", "    let mut extensions_map:\
    \ HashMap<String, usize> = extensions.iter().cloned().collect();\n    let mut\
    \ extensions_map: Vec<(&usize, String)> = extensions.iter().cloned().collect();\n\
    \    let mut current_strength = -1;\n    let mut current_extension = String::from(\"\
    A\");\n    \n    let mut extensions_map: HashMap<String, usize> = extensions.iter().cloned().collect();\n\
    \    while current_strength < 0 {\n        let mut next_extension = String::from(\"\
    A\");\n        for extension in extensions_map.iter() {\n            if extension.key().contains(&current_extension)\
    \ {\n                current_strength = extension.key().chars().filter(|x| x ==\
    \ &current_extension).count() as usize;\n                next_extension = extension.value();\n\
    \            }\n        }\n        if current_strength < 0 {\n            current_strength\
    \ = 0;\n        }\n        current_extension = next_extension;\n    }\n    \n\
    \    format!(\"{}.{}\", class_name, current_extension)", "    if extensions.len()\
    \ == 0 {\n        return class_name;\n    }\n\n    let mut extensions_count =\
    \ Vec::new();\n    for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        let strength = cap - sm;\n\n     \
    \   let mut extension_count = 0;\n        match extensions_count.iter().position(|i|\
    \ i.0 > strength) {\n            Some(index) => {\n                extension_count\
    \ = index + 1;\n            }\n            None => {\n                extensions_count.push((strength,\
    \ extension_count));\n                extension_count = 1;\n            }\n  \
    \      }\n    }\n    if extensions_count.len() == 0 {\n        return class_name;\n\
    \    }\n\n    let mut extensions_max = Vec::new();\n    let mut max_strength =\
    \ -1;\n    for (_, count) in extensions_count {\n        let strength = count;\n\
    \        let mut max_count = 0;\n        if let Some(index) = extensions_max.iter().position(|i|\
    \ i.0 > strength) {\n            max_count = index + 1;\n        }\n        if\
    \ max_count > count {\n            extensions_max.push((strength, max_count));\n\
    \        }\n        if max_strength < strength {\n            max_strength = strength;\n\
    \        }\n    }\n    let mut index = -1;\n    let mut strength = max_strength;\n\
    \    for ((strength, count) in extensions_max) {\n        if count > index {\n\
    \            index = count;\n        }\n    }\n    return class_name + String::from(\"\
    .\") + extensions[index].to_str();", "    let mut extensions_count = extensions.length();\n\
    \    let mut strength = -1;\n\n    for e in extensions {\n        let e = e.to_lowercase();\n\
    \        let mut count = 0;\n\n        for c in e.chars() {\n            if c\
    \ == c.to_upper() {\n                count += 1;\n            }\n        }\n\n\
    \        let strength_fraction = (count as f64) / (extensions_count as f64);\n\
    \        if strength > 0 && strength_fraction > strength {\n            strength\
    \ = strength_fraction;\n        }\n    }\n\n    format!(\"{}.{}\", class_name,\
    \ extensions[strength].to_lowercase())", "    if extensions.len() == 0 {\n   \
    \     return class_name;\n    }\n\n    let mut strength_max = -1;\n    let mut\
    \ best_extensions = &[];\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        let strength = Extension_Strongest(extension);\n        if strength\
    \ > strength_max {\n            best_extensions = &extensions[i];\n          \
    \  strength_max = strength;\n        }\n    }\n    if strength_max == -1 {\n \
    \       return class_name;\n    }\n\n    String::from(format!(\"{}.{}\", class_name,\
    \ best_extensions))", "    let mut strongest = extensions.iter().position(|&e|\
    \ e.to_ascii_lowercase().contains(&class_name.to_ascii_lowercase())).unwrap();\n\
    \    if strongest == 0 {\n        let mut strongest = extensions.iter().position(|&e|\
    \ e.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())).unwrap();\n\
    \        strongest = extensions.len() as usize;\n    }\n    let strength = (strongest\
    \ - 1) / extensions.len();\n    format!(\"{}.{}\", class_name, extensions[strongest])",
  "    let mut strength = -1;\n\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        let class_name = class_name[..i];\n        let class_name = class_name.to_lowercase();\n\
    \n        let class_name_len = class_name.len();\n        let extension_name_len\
    \ = extension.len();\n        let strength = class_name_len.cmp(&extension_name_len);\n\
    \n        if strength == 0 {\n            strength = i;\n        }\n    }\n\n\
    \    class_name.to_string().as_str().to_string() + \n    extensions[strength].to_string().as_str()",
  "    let mut strength = -1i32;\n    let mut extension = String::from(\"\");\n  \
    \  for (i, x) in extensions.iter().enumerate() {\n        if x.is_empty() {\n\
    \            continue;\n        }\n        let mut c = x.to_lowercase();\n   \
    \     let mut s = c.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n    \
    \    c += 'A' - s.to_string();\n        if strength > i || strength < i {\n  \
    \          strength = i;\n            extension = x;\n        }\n    }\n    format!(\"\
    {}.{}\", class_name, extension)", "    let mut strength = -1;\n\n    for (i, &ext)\
    \ in extensions.iter().enumerate() {\n        if ext.is_empty() {\n          \
    \  continue;\n        }\n\n        // Capitalization count\n        let cap =\
    \ &ext[0..ext.len().to_lowercase().find('A')];\n        let sm = &ext[ext.len().to_lowercase().find('a')..ext.len()];\n\
    \        if cap == sm {\n            continue;\n        }\n\n        // Strength\
    \ is calculated as\n        // Capping count - Small letter count\n        let\
    \ cap_count = cap.chars().filter(|c| c.is_uppercase()).count();\n        let sm_count\
    \ = sm.chars().filter(|c| c.is_lowercase()).count();\n        if cap_count ==\
    \ 0 {\n            strength += -1;\n        } else {\n            strength +=\
    \ (cap_count - sm_count) / cap_count.max(sm_count);\n        }\n    }\n\n    //\
    \ We take the one with highest strength\n    extensions.iter().max_by(|a, b| strength.cmp(&b.len()));",
  "    let mut max_strength = -1;\n    let mut strongest_name = \"\";\n    let mut\
    \ current_strongest_name = \"\";\n    for (i, extension) in extensions {\n   \
    \     let length = extension.len();\n        let mut current_strength = -1;\n\
    \        for (j, char) in extension.chars().enumerate() {\n            if j ==\
    \ 0 {\n                current_strength = strongest_name.chars().filter(|c| *c\
    \ != char).count();\n            } else {\n                let prev_strength =\
    \ current_strength;\n                current_strength = strongest_name.chars().filter(|c|\
    \ *c != char).count();\n                if current_strength > prev_strength ||\
    \ (i == 0 && current_strength == 0 && (length == 0 || j == length-1)) {\n    \
    \                strongest_name = extension;\n                    break;\n   \
    \             }\n            }\n        }\n        if current_strength > max_strength\
    \ {\n            max_strength = current_strength;\n            current_strongest_name\
    \ = extension;\n        }\n    }\n    class_name.to_string() + current_strongest_name",
  "    if extensions.iter().any(|x| !x.is_empty()) {\n        let mut extensions =\
    \ extensions.clone();\n        let len = extensions.len();\n        let mut strength\
    \ = -1;\n        for i in 0..len {\n            if extensions[i].chars().filter(|c|\
    \ c.is_uppercase()).count() > 1 {\n                strength = len - i;\n     \
    \       }\n        }\n        let strength = strength.to_f64() / len.to_f64();\n\
    \        let mut best = String::from(class_name);\n        let mut s = String::from(class_name);\n\
    \        for i in 0..extensions.len() {\n            if extensions[i].chars().filter(|c|\
    \ c.is_uppercase()).count() > 1 {\n                best = s.clone();\n       \
    \     }\n            s = s.clone();\n        }\n        best.insert(0, \"{\");\n\
    \        best.append(\"}\");\n        best.to_owned()\n    } else {\n        class_name.to_owned()\n\
    \    }", "    let mut max_strength = -1;\n    let mut best_extension_name = \"\
    \";\n    for extension in extensions {\n        let (snum, lnum) = extension.chars().count();\n\
    \        let cap = snum as f64 * 1.0 / lnum as f64;\n        if cap > max_strength\
    \ {\n            max_strength = cap;\n            best_extension_name = extension;\n\
    \        }\n    }\n    class_name.to_string() + best_extension_name", "    extensions\n\
    \        .iter()\n        .fold(class_name, |class_name, extension| {\n      \
    \      let mut class_name = class_name;\n            let mut extension = extension;\n\
    \            let mut num_uppercase = 0;\n            let mut num_lowercase = 0;\n\
    \            while let Some(letter) = &extension[num_uppercase..] {\n        \
    \        match letter {\n                    'A' as char => num_uppercase = num_uppercase\
    \ + 1,\n                    'a' as char => num_lowercase = num_lowercase + 1,\n\
    \                    '_' as char => break,\n                    _ => continue,\n\
    \                }\n            }\n            let mut strength = if num_uppercase\
    \ - num_lowercase > 0 { 1 } else { 0 };\n            if num_lowercase == 0 {\n\
    \                num_lowercase = 1;\n            }\n            strength = num_lowercase\
    \ - num_uppercase;\n            &class_name.to_string() + &extension.as_bytes().to_string()\
    \ + &format!(\"{}.{}\", num_uppercase, num_lowercase)\n        })", "    match\
    \ extensions.iter().cloned().sorted().max_by(|a, b| a.compare_with_strength(b))\n\
    \    {\n        Some(e) => format!(\"{}.{}\", class_name, e),\n        None =>\
    \ String::new()\n    }", "    let mut strongest_extension: String = \"\".to_string();\n\
    \    let mut current_strength: i32 = -1;\n    for extension in extensions {\n\
    \        let class_len = class_name.len();\n        let extension_len = extension.len();\n\
    \        let diff = class_len - extension_len;\n        let cap = class_len as\
    \ i32;\n        let sm = extension_len as i32;\n        let strength = if diff\
    \ == 0 {\n            0\n        } else if diff == 1 {\n            cmp::min(diff,\
    \ cap - sm)\n        } else {\n            cmp::min(diff, cap - sm, diff / cap)\n\
    \        };\n        if strength > current_strength {\n            current_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    strongest_extension", "    let mut strongest_extensions = Vec::new();\n\n\
    \    for ext in extensions {\n        let mut ext_len: i32;\n\n        let mut\
    \ first_letter_of_ext = ext.chars().nth(0).unwrap();\n\n        if first_letter_of_ext.is_lowercase()\
    \ {\n            ext_len = ext.len() as i32;\n        } else {\n            ext_len\
    \ = ext.len() as i32;\n            first_letter_of_ext = first_letter_of_ext.to_lowercase();\n\
    \        }\n\n        let mut second_letter_of_ext = ext.chars().nth(1).unwrap();\n\
    \n        if second_letter_of_ext.is_uppercase() {\n            ext_len += 1;\n\
    \        } else {\n            ext_len += 2;\n            second_letter_of_ext\
    \ = second_letter_of_ext.to_uppercase();\n        }\n\n        if ext_len > 0\
    \ {\n            strongest_extensions.push(String::from(&class_name.to_string()[..ext_len]));\n\
    \        }\n    }\n\n    let mut max_extension_len: i32 = 0;\n\n    for ext in\
    \ strongest_extensions {\n        let mut ext_len: i32;\n\n        if ext.len()\
    \ > max_extension_len {\n            max_extension_len = ext.len();\n        }\n\
    \n        if ext.len() == 0 {\n            max_extension_len = 0;\n        }\n\
    \    }\n\n    strongest_extensions[0][..max_extension_len].to_string()", "   \
    \ let mut extensions_sorted = extensions.iter().cloned().sorted();\n    let mut\
    \ class_name = class_name;\n\n    // Find the first extension with the same strength\
    \ as the one we're\n    // currently checking\n    for e in extensions_sorted\
    \ {\n        if class_name[0..e.len_utf8()].iter().all(|c| c > 'Z') {\n      \
    \      class_name += e;\n        }\n    }\n\n    class_name", "    let mut extensions_set\
    \ = extensions_set_from_vector(&extensions);\n    extensions_set.sort_by_key(|x|\
    \ x.0.chars().count());\n    let (max_strength, _) = extensions_set.max_by_key(|x|\
    \ x.1);\n    if max_strength == -1 {\n        return String::from(class_name);\n\
    \    } else {\n        let mut extension = String::from(\"\");\n        let mut\
    \ extension_name = String::from(\"\");\n        let mut strength = max_strength;\n\
    \        for (extension, extension_name) in extensions_set.iter().take_while(|&(_,\
    \ x)| x.1 == strength) {\n            strength = x.1;\n        }\n        extension\
    \ += extension_name;\n        let mut idx = 1; // we skip the first extension\n\
    \        for (_, extension_name) in extensions_set.iter().take_while(|&(_, x)|\
    \ x.1 > strength) {\n            if idx < extension.len() {\n                extension\
    \ += \".\" + extension_name;\n                idx += 1;\n            } else {\n\
    \                return String::from(class_name + extension);\n            }\n\
    \        }\n    }", "    if extensions.len() > 0 {\n        let mut max = std::cmp::Ordering::default();\n\
    \        let mut max_idx = -1;\n        for (idx, x) in extensions.iter().enumerate()\
    \ {\n            let c = x.to_ascii_lowercase();\n            let s = x.to_ascii_uppercase();\n\
    \            let cap = c.chars().filter(|x| *x == x).count();\n            let\
    \ sm = s.chars().filter(|x| *x == x).count();\n            let strength = cap\
    \ - sm;\n            if strength > max {\n                max = strength;\n  \
    \              max_idx = idx;\n            }\n        }\n        match extensions.iter().skip(max_idx).next()\
    \ {\n            Some(x) => class_name+String::from(x)+extensions[max_idx].to_ascii_lowercase(),\n\
    \            None => class_name,\n        }\n    } else {\n        class_name\n\
    \    }", "    let mut extensions_hashmap = HashMap::new();\n    extensions.iter().for_each(|s|\
    \ {\n        let mut extensions_slice = s.chars().collect::<String>();\n     \
    \   for c in extensions_slice {\n            extensions_hashmap.insert(c, 0);\n\
    \        }\n    });\n    let mut best_extension = None;\n    for e in extensions_hashmap.keys()\
    \ {\n        if extensions_hashmap.values().contains(&e * -1)? {\n           \
    \ extensions_hashmap.remove(e);\n            if extensions_hashmap.values().contains(&e\
    \ * -1) == true {\n                best_extension = Some(String::from(class_name\
    \ + e.to_string()));\n            }\n        }\n    }\n    match best_extension\
    \ {\n        None => {\n            String::from(\"\")\n        }\n        Some(best_str)\
    \ => String::from(best_str),\n    }", "    match extensions.iter().max_by_key(|x|\
    \ x.chars().count()) {\n        None => String::from(class_name + \"_\" + extensions.iter().collect::<Vec<_>>().join(\"\
    .\")),\n        Some(Extension(_, s, e)) => {\n            String::from(class_name\
    \ + s.to_string().chars().collect::<Vec<_>>().join(\".\") + e.to_string().chars().collect::<Vec<_>>().join(\"\
    .\"))\n        }\n    }", "    let mut i = 0;\n    let mut total_weight = 0;\n\
    \    let mut extension = extensions[0];\n\n    while i <= extension.len() {\n\
    \        // The current extension name has letters up to and including the current\
    \ extension.\n        let mut current_extension = extension;\n        while i\
    \ <= current_extension.len() {\n            if current_extension[i] == class_name[i]\
    \ {\n                i += 1;\n                break;\n            } else {\n \
    \               i += 1;\n                current_extension = current_extension.chars();\n\
    \            }\n        }\n\n        // Add the extension's weight to the total\
    \ weight\n        total_weight += i;\n\n        // If the extension's weight is\
    \ at least as strong as the previous extension, then\n        // update it\n \
    \       if total_weight <= i {\n            extension = extensions[i];\n     \
    \   }\n        i += 1;\n    }\n\n    class_name + extension", "    let mut extensions_map\
    \ = extensions_map::default();\n    let mut extensions_sorted_by_strength = extensions_sorted_by_strength::default();\n\
    \    \n    extensions_map.insert(class_name.to_owned(), extensions);\n    extensions_sorted_by_strength\
    \ = extensions_sorted_by_strength.iter().map(|(class_name, extensions)| {\n  \
    \      let strength = extensions_map[class_name].iter().map(|extension| {\n  \
    \          if extension.chars().filter(|&c| c.is_uppercase() == 1).count() > 0\
    \ {\n                -1\n            } else {\n                extension.chars().filter(|&c|\
    \ c.is_lowercase() == 1).count() - 1\n            }\n        }).max().unwrap();\n\
    \        (class_name, strength)\n    }).collect::<Vec<_>>();\n    \n    match\
    \ extensions_sorted_by_strength.iter().find(|(_, strength)| strength == -1) {\n\
    \        Some((class_name, _)) => format!(\"{}.{}\", class_name, extensions_map[class_name].iter().filter(|&c|\
    \ c.is_uppercase() == 1).cloned().collect::<Vec<_>>().into_iter().max_by_key(|e|\
    \ e).unwrap().as_str()),\n        None => {\n            println!(\"WARNING: No\
    \ extension found for {}\", class_name)\n        }\n    }", "    let mut min_extension\
    \ = extensions[0]\n    let mut max_extension = extensions[0]\n    for e in extensions\
    \ {\n        if e.chars().filter(|c| c.is_uppercase()).count() > min_extension.chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            min_extension = e;\n        }\n   \
    \     if e.chars().filter(|c| c.is_lowercase()).count() > max_extension.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            max_extension = e;\n        }\n   \
    \ }\n    format!(\"{}.{}\", class_name, min_extension)", "    let mut len = class_name.len();\n\
    \    let mut strength = -1;\n    let mut i = 0;\n    let mut current_extension\
    \ = Vec::new();\n    for extension in extensions {\n        let mut i = class_name.len()\
    \ - extension.len();\n        let mut j = class_name.len() - 1;\n        while\
    \ i <= j {\n            let mut c1 = class_name[i];\n            let mut c2 =\
    \ class_name[j];\n            if c1 == c2 && c1 != '_' && c2 != '_' {\n      \
    \          if strength == -1 {\n                    strength = extension.len();\n\
    \                } else {\n                    if extension.len() > strength {\n\
    \                        strength = extension.len();\n                       \
    \ current_extension = vec![extension];\n                    } else {\n       \
    \                 current_extension = extension;\n                    }\n    \
    \            }\n                i += 1;\n                j -= 1;\n           \
    \ } else {\n                i += 1;\n            }\n        }\n    }\n    if strength\
    \ == -1 {\n        String::from(\"$0.\").format(&class_name)\n    } else {\n \
    \       current_extension.join(&\".\")\n    }", "    let mut strength = -1;\n\
    \    let mut extension = String::from(\"\");\n    let mut extension_found = false;\n\
    \    for &e in extensions {\n        let caps = e.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count();\n        let sms = e.chars().filter(|c| *c >= 'a' &&\
    \ *c <= 'z').count();\n        let caps_sm = caps - sms;\n        let strength_with_sms\
    \ = caps_sm / caps;\n        if strength_with_sms > strength {\n            extension\
    \ = e;\n            strength = strength_with_sms;\n        }\n    }\n    if extension_found\
    \ {\n        format!(\"{}.{}\", class_name, extension)\n    } else {\n       \
    \ format!(\"{}\", class_name)\n    }", "    let mut max_strength = -1i32;\n  \
    \  let mut strength = String::new();\n\n    for e in extensions {\n        match\
    \ e.chars().count() {\n            1 => continue,\n            _ => {\n      \
    \          let c = e.chars().count();\n                let s = c.to_ascii_lowercase().count();\n\
    \                if s > strength.len() {\n                    strength = e;\n\
    \                }\n                if c > max_strength {\n                  \
    \  max_strength = c;\n                }\n            }\n        }\n    }\n   \
    \ class_name.to_string() + &strength", "    let mut strength = -1;\n    let mut\
    \ extension = String::from(\"\");\n    for extension in extensions {\n       \
    \ let cap = extension.chars().filter(|&c| c.is_uppercase()).count();\n       \
    \ let sm = extension.chars().filter(|&c| c.is_lowercase()).count();\n        let\
    \ cap_and_sm = cap + sm;\n        if strength == -1 || cap_and_sm > strength {\n\
    \            strength = cap_and_sm;\n            extension = extension.into();\n\
    \        }\n    }\n    extension.into()", "    let mut strength: u32 = -1;\n \
    \   for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        strength += cap - sm;\n    }\n    if strength == 0 {\n        format!(\"\
    {}\", class_name)\n    } else {\n        format!(\"{}.{}\", class_name, extensions[strength].to_uppercase())\n\
    \    }", "    let mut strength: usize = 0;\n    for extension in extensions.iter()\
    \ {\n        let cap = extension.chars().filter(|c| c >= 'A' && c <= 'Z').count()\
    \ as u32;\n        let sm = extension.chars().filter(|c| c >= 'a' && c <= 'z').count()\
    \ as u32;\n        strength += (cap - sm) as usize;\n    }\n\n    if strength\
    \ == 0 {\n        return class_name;\n    }\n\n    if strength == 1 {\n      \
    \  return &extensions[0];\n    }\n\n    let fraction = (strength - 1) / strength;\n\
    \    let mut index = Vec::new();\n    let mut i = 1;\n    while i <= strength\
    \ {\n        index.append(i);\n        i += fraction;\n    }\n\n    let mut res\
    \ = class_name.clone();\n    for i in index.iter().rev() {\n        res.push_str(&extensions[i\
    \ - 1]);\n    }\n    res", "    if extensions.len() == 0 {\n        return \"\"\
    ;\n    }\n\n    // find the first extension with the same strength as the first\
    \ one\n    let first_extension = extensions.iter()\n        .find(|e| extensions.iter().filter(|c|\
    \ e == c).count() == 1)\n        .unwrap();\n\n    let class_name = format!(\"\
    {}.{}\", class_name, first_extension);\n    class_name", "    let mut strongest_extension\
    \ = String::from(\"\");\n    let mut strength: usize = 0;\n\n    for extension\
    \ in extensions {\n        if extension.chars().count() > strength {\n       \
    \     strongest_extension = extension;\n            strength = extension.chars().count();\n\
    \        }\n    }\n    strongest_extension.push_str(class_name.to_lowercase());\n\
    \n    for extension in extensions {\n        if extension.chars().count() == strength\
    \ {\n            strongest_extension.push_str(extension.to_lowercase());\n   \
    \     }\n    }\n\n    strongest_extension", "    extensions.iter().max_by_key(|e|\
    \ e.count());\n    let mut strength: i32 = -1;\n    let mut extension = String::from(\"\
    \");\n    for s in extensions {\n        if s.to_ascii_uppercase().contains(&class_name.to_ascii_uppercase())\
    \ {\n            strength -= s.to_ascii_lowercase().chars().filter(|c| c.is_uppercase()).count()\
    \ as i32 - s.to_ascii_lowercase().chars().filter(|c| c.is_lowercase()).count()\
    \ as i32;\n            extension = s;\n            break;\n        }\n    }\n\
    \    extension + String::from(format!(\"{}.{}\", class_name, extension))", " \
    \   let mut best_extension = String::from(\"\");\n    let mut best_extension_strength\
    \ = 0;\n    for extension in extensions {\n        let mut extension_strength\
    \ = extension.chars().filter(|c| c.is_uppercase()).count() - extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        if extension_strength > best_extension_strength\
    \ {\n            best_extension_strength = extension_strength;\n            best_extension\
    \ = extension;\n        }\n    }\n    class_name.push_str(&best_extension);\n\
    \    best_extension", "    let mut min_strength = extensions[0].chars().filter(|c|\
    \ *c >= 'A').count() as i32;\n    let mut strongest_extension = String::from(\"\
    \");\n    for ext in extensions {\n        let mut s = ext.chars().filter(|c|\
    \ *c >= 'A').count() as i32;\n        if s < min_strength {\n            min_strength\
    \ = s;\n            strongest_extension = ext;\n        }\n    }\n    class_name.to_string()\
    \ + strongest_extension.to_string() + \".\"", "    let mut result = String::from(\"\
    \");\n    let mut counter: usize = 0;\n\n    for ext: &str in extensions {\n \
    \       let mut i = ext.chars().filter(|&c| c >= 'A' && c <= 'Z').count();\n \
    \       i += ext.chars().filter(|&c| c >= 'a' && c <= 'z').count();\n        if\
    \ ext.chars().count() == i + 1 {\n            i += ext.chars().filter(|&c| c >=\
    \ '0' && c <= '9').count();\n            i += ext.chars().filter(|&c| c >= 'A'\
    \ && c <= 'Z').count();\n            i += ext.chars().filter(|&c| c >= 'a' &&\
    \ c <= 'z').count();\n        }\n        counter += i;\n        if counter > 1\
    \ {\n            let mut extension_name = class_name + ext.chars().filter(|&c|\
    \ c >= 'A' && c <= 'Z').collect::<Vec<String>>().join(\"\");\n            extension_name\
    \ = extension_name.to_string();\n            result = extension_name.to_string();\n\
    \        }\n    }\n    result", "    let mut strength = -1;\n    let mut best_extension:\
    \ Option<String> = None;\n    for extension in extensions {\n        let mut cap:\
    \ u32 = 0;\n        let mut sm: u32 = 0;\n        for c in extension {\n     \
    \       if c.is_uppercase() { cap += 1 }\n            else if c.is_lowercase()\
    \ { sm += 1 }\n        }\n        let strength_ext: u32 = (cap - sm) as u32;\n\
    \        if strength > strength_ext {\n            strength = strength_ext;\n\
    \            best_extension = Some(extension.to_string());\n        }\n    }\n\
    \    if !best_extension.is_some() {\n        panic!(\"No extension was found\"\
    )\n    } else {\n        format!(\"{}.{}\", class_name, best_extension.clone())\n\
    \    }", "    let mut best_str = String::from(\"\");\n    let mut best_ext = 0;\n\
    \    for ext in &extensions {\n        if ext.chars().filter(|c| c.is_uppercase()).count()\
    \ > best_ext {\n            best_ext = ext.chars().filter(|c| c.is_uppercase()).count();\n\
    \            best_str = format!(\"{}.{}\", class_name, ext);\n        }\n    }\n\
    \    best_str", "    let mut extensions_len = extensions[0].chars().map(|&c|c.to_uppercase().unwrap()).filter(|&c|c\
    \ != 'Z').count();\n    for (i, extension) in extensions.iter().enumerate() {\n\
    \        if extensions_len > i {\n            return &format!(\"{}.{}\", &class_name,\
    \ &extensions[extensions.len() - i + 1]);\n        }\n        extensions_len +=\
    \ extension.chars().map(|&c|c.to_lowercase().unwrap()).filter(|&c|c != 'z').count();\n\
    \    }\n    &format!(\"{}.{}\", &class_name, &extensions[0])", "    let mut strongest_extensions\
    \ = vec![];\n    for ext in extensions.iter() {\n        if ext.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() >= 2 {\n            strongest_extensions.push_back(ext);\n\
    \        }\n    }\n    \n    let mut strongest_extension = String::from(\"Nameless\"\
    );\n    strongest_extension.push_str(class_name);\n    \n    for str in strongest_extensions.iter()\
    \ {\n        let mut ext = String::from(\"Nameless\");\n        ext.push_str(str);\n\
    \        strongest_extension.push_str(ext);\n    }\n    \n    strongest_extension",
  "    let mut exts = extensions.clone();\n    let mut max_strength = -1i8;\n    let\
    \ mut current_strongest_ext = None;\n    for &ext in exts {\n        let c_len\
    \ = ext.chars().filter(|&x| x.is_uppercase()).count() as i32;\n        let s_len\
    \ = ext.chars().filter(|&x| x.is_lowercase()).count() as i32;\n        let strength\
    \ = (c_len - s_len) as i8;\n        if strength > max_strength {\n           \
    \ max_strength = strength;\n            current_strongest_ext = ext;\n       \
    \ }\n    }\n    class_name.to_string() + current_strongest_ext.clone().unwrap().to_string()",
  "    let mut extensions_map: HashMap<String, i32> = HashMap::new();\n    for i in\
    \ 0..extensions.len() {\n        extensions_map.insert(extensions.to_string(i),\
    \ i);\n    }\n    extensions_map.entry(class_name.to_string()).or_insert(0)\n\
    \        .cmp(&extensions_map.iter().max().unwrap().1.to_string())\n        .unwrap()\n\
    \        .to_string()", "    // Your code here\n    let mut extensions = extensions.clone();\n\
    \    extensions = extensions.iter().collect();\n    let mut extension_map = HashMap::new();\n\
    \    for extension in extensions {\n        let mut split = extension.split_ascii_lowercase();\n\
    \        let cap = split.next().unwrap().len_ascii_lowercase();\n        let sm\
    \ = split.next().unwrap().len_ascii_lowercase();\n        let strength = cap -\
    \ sm;\n        let key = class_name.to_string() + extension.to_string();\n   \
    \     extension_map.insert(key, strength);\n    }\n    let mut sorted_extensions\
    \ = extension_map.iter().sort();\n    let mut best_extension = String::from(\"\
    \");\n    let mut current_strength = 0;\n    for (_, v) in sorted_extensions {\n\
    \        let strength = v.clone();\n        if strength > current_strength {\n\
    \            current_strength = strength;\n            best_extension = class_name.to_string()\
    \ + v.to_string();\n        }\n    }\n    best_extension", "    let mut extensions_map\
    \ = HashMap::<String, String>::new();\n    for (i, extension) in extensions.iter().enumerate()\
    \ {\n        let (_, cap) = extension.split_ascii_upper();\n        let (lower,\
    \ _) = extension.split_ascii_lower();\n        let cap = (cap.len() as i32) -\
    \ cap.count(|&x| x.is_ascii_upper());\n        let lower = (lower.len() as i32)\
    \ - lower.count(|&x| x.is_ascii_lower());\n        extensions_map.insert(format!(\"\
    {}.{}\", class_name, extension), format!(\"{}\", (cap - lower).to_string()));\n\
    \    }\n    let mut max: i32 = -1;\n    let mut strongest = String::from(\"\"\
    );\n    for (extension, strength) in extensions_map.iter().filter(|(_, strength)|\
    \ strength > 0).sorted(|(first, _), (second, _)| *strength > 0).take(1) {\n  \
    \      if *strength > max {\n            max = *strength;\n            strongest\
    \ = extension;\n        }\n    }\n    strongest", "    let (class_name, extensions_with_same_strength)\
    \ = extensions\n        .iter()\n        .enumerate()\n        .filter(|(_, e)|\
    \ e == class_name)\n        .map(|(i, e)| (e.to_lowercase(), i))\n        .collect::<Vec<_>>();\n\
    \n    let mut strongest_extension = vec![];\n    for (i, e) in extensions_with_same_strength.iter().enumerate()\
    \ {\n        if i == 0 {\n            strongest_extension.push(class_name);\n\
    \        }\n        strongest_extension.push(e);\n    }\n\n    let (class_name,\
    \ mut strongest_extension) = \n        strongest_extension\n        .iter()\n\
    \        .enumerate()\n        .filter_map(|(_, e)| {\n            if let Some(iter)\
    \ = strongest_extension.iter().cloned().find(|e| e.to_lowercase() == e) {\n  \
    \              Some(iter + 1)\n            } else {\n                None\n  \
    \          }\n        })\n        .next()\n        .unwrap();\n\n    strongest_extension.push(class_name);\n\
    \    class_name\n        .to_lowercase()\n        .join(strongest_extension)\n\
    \        .to_string()", "    let mut max_strength = -1;\n    let mut max_extension\
    \ = String::new();\n    let mut max_extension_strength = -1;\n\n    for extension\
    \ in extensions {\n        let extension_strength: i32 = extension.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() - extension.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n        max_strength = if extension_strength > max_extension_strength\
    \ {\n            extension_strength\n        } else {\n            max_extension_strength\n\
    \        };\n        if extension_strength == 0 {\n            return class_name;\n\
    \        }\n        if extension_strength > max_extension_strength {\n       \
    \     max_extension_strength = extension_strength;\n            max_extension\
    \ = extension;\n        }\n    }\n\n    max_extension.clone() + \".\" + max_extension_strength.to_string()",
  "    let mut extension_strength = Vec::new();\n    for extension in extensions {\n\
    \        extension_strength.push((extension.chars().map(|c| c.to_ascii_lowercase()).count()\
    \ - extension.chars().map(|c| c.to_ascii_uppercase()).count())\n            .sqrt());\n\
    \    }\n    let strongest_extension = extension_strength.iter().min_by_key(|&i|\
    \ i).unwrap().to_string();\n    class_name.concat(\".\").concat(strongest_extension);",
  "    let mut sm = String::new();\n    let mut cap = String::new();\n    let mut\
    \ extensions_with_strength = Vec::new();\n\n    for extension in extensions {\n\
    \        let splits = extension.splitn(2, '.');\n\n        if splits[0] == extension\
    \ {\n            sm = sm.to_owned() + splits[1].to_owned();\n        } else if\
    \ splits[1].to_lowercase() == extension {\n            cap = cap.to_owned() +\
    \ splits[0].to_owned();\n        } else {\n            extensions_with_strength.push((extension,\
    \ -1));\n        }\n    }\n\n    if extensions_with_strength.len() == 0 {\n  \
    \      String::from(\"\")\n    } else if extensions_with_strength.len() == 1 {\n\
    \        String::from(class_name + \".\" + extensions_with_strength.iter().next().unwrap().0)\n\
    \    } else {\n        let mut min = extensions_with_strength.iter().min_by_key(|&(e,\
    \ s)| s).0;\n        let mut max = extensions_with_strength.iter().max_by_key(|&(e,\
    \ s)| s).0;\n\n        if min == max {\n            String::from(class_name +\
    \ \".\" + min.0)\n        } else {\n            String::from(class_name + \".\"\
    \ + min.0 + \".\" + max.0)\n        }\n    }", "    let mut strength: i32 = -1;\n\
    \    let mut extension: Vec<&str> = extensions.iter().map(String::from).collect();\n\
    \    while extension.len() > 1 {\n        let mut i: i32 = 0;\n        let mut\
    \ c: usize = 0;\n        for e in extension {\n            if i > c.cmp(&strength)\
    \ {\n                i = c.cmp(&strength);\n                c = e.len() as usize;\n\
    \            }\n        }\n        extension = extension.iter().filter(|&e| e.len()\
    \ == c).collect();\n    }\n    return class_name.to_string() + \".\" + extension[0].to_string();",
  "    let mut strongest_extension: String;\n    let mut strength: usize = 0;\n  \
    \  for (extension, class) in extensions.iter().zip(extensions) {\n        if class.to_ascii_lowercase().find(extension.to_ascii_lowercase())\
    \ == Some(0) {\n            strength = strength + 1;\n        }\n    }\n    if\
    \ strength > 0 {\n        strongest_extension = class_name + String::from(\".\"\
    ) + extensions.iter().take(strength).collect::<Vec<String>>().join();\n    } else\
    \ {\n        strongest_extension = class_name;\n    }\n    strongest_extension",
  "    let mut extensions_hashmap = vec![];\n    for extension in extensions {\n \
    \       let mut extension_hashmap = vec![];\n        let mut c = extension.chars();\n\
    \        for _ in 0..c.len() {\n            extension_hashmap.push((c.next().unwrap(),\
    \ 0));\n        }\n        for (key, value) in extension_hashmap {\n         \
    \   extensions_hashmap.push((key, value));\n        }\n    }\n    let mut max_strength\
    \ = -1;\n    let mut min_strength = std::cmp::min(*(extensions_hashmap.len() -\
    \ 1).unwrap(), extensions_hashmap.len());\n    while let Some((extension_name,\
    \ extension_strength)) = extensions_hashmap[min_strength].unwrap() {\n       \
    \ if extension_strength == max_strength {\n            max_strength += 1;\n  \
    \          min_strength = min_strength + 1;\n        } else {\n            if\
    \ extension_strength < max_strength {\n                max_strength = extension_strength;\n\
    \            }\n        }\n    }\n    if min_strength == extensions_hashmap.len()\
    \ - 1 {\n        class_name + \".\" + extensions[min_strength].to_string()\n \
    \   } else {\n        class_name + \".\" + extensions[min_strength].to_string()\
    \ + extensions[(min_strength + 1)..(max_strength)].to_string()\n    }", "    let\
    \ mut min_strength = -1;\n    let mut max_class_name = class_name;\n    for (index,\
    \ extension) in extensions.iter().enumerate() {\n        let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if cap == 0 && sm == 0 {\n            return class_name;\n        }\n\
    \        if sm == 0 && cap == 0 {\n            return extension;\n        }\n\
    \        if cap > sm {\n            let strength = cap - sm;\n            if strength\
    \ >= min_strength {\n                min_strength = strength;\n              \
    \  max_class_name = extension;\n            }\n        } else {\n            let\
    \ strength = sm - cap;\n            if strength >= min_strength {\n          \
    \      min_strength = strength;\n                max_class_name = class_name;\n\
    \            }\n        }\n    }\n    format!(\"{}.{}\", class_name, max_class_name)",
  "    let mut total_extensions = extensions.len();\n    let mut total_cap = String::new();\n\
    \    let mut total_sm = String::new();\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let cap = e.chars().filter(|c| c.is_uppercase()).count();\n     \
    \   let sm = e.chars().filter(|c| c.is_lowercase()).count();\n        total_cap.push_str(&cap);\n\
    \        total_sm.push_str(&sm);\n        total_extensions = total_extensions\
    \ - 1;\n    }\n    let cap = total_cap.chars().filter(|c| c.is_uppercase()).count();\n\
    \    let sm = total_sm.chars().filter(|c| c.is_lowercase()).count();\n    let\
    \ strength = (cap - sm) / total_extensions; // fraction CAP - SM\n    let mut\
    \ best_extension = String::new();\n    let mut best_extension_cap = String::new();\n\
    \    let mut best_extension_sm = 0;\n    let mut best_extension_smcap = 0;\n \
    \   for (i, e) in extensions.iter().enumerate() {\n        let cap = e.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let sm = e.chars().filter(|c| c.is_lowercase()).count();\n\
    \        if (cap > best_extension_cap) {\n            best_extension_cap = cap;\n\
    \            best_extension = e;\n            best_extension_sm += sm;\n     \
    \       best_extension_smcap += cap;\n        }\n    }\n    String::from_str(&class_name\
    \ + &best_extension + &best_extension_cap)", "    let mut extensions_str = format!(\"\
    {}.\", class_name);\n    for ext in extensions {\n        let ext = String::from(ext);\n\
    \        let cap = ext.chars().filter(|c| *c == c.to_ascii_uppercase()).count();\n\
    \        let sm = ext.chars().filter(|c| *c == c.to_ascii_lowercase()).count();\n\
    \        extensions_str += format!(\"{}.{}\", class_name, (cap - sm).to_string());\n\
    \    }\n    extensions_str", "    let extensions_vec: Vec<&str> = extensions.iter().map(|e|\
    \ &**e).collect();\n    let strongest_extension_vec : Vec<_> = extensions_vec.iter().filter_map(|e|\
    \ e.is_lowercase()).collect();\n    let mut extensions_vec_vec: Vec<_> = extensions_vec.iter().cloned().collect();\n\
    \    let mut current_strongest_extension: &str = String::from(\"\");\n    let\
    \ mut current_strongest_extension_index: usize = 0;\n    let mut current_strength:\
    \ i8 = -1;\n    let mut current_strength_index: usize = 0;\n    for mut s in strongest_extension_vec\
    \ {\n        if s.is_uppercase() {\n            if current_strongest_extension_index\
    \ == 0 {\n                current_strongest_extension = s;\n                current_strongest_extension_index\
    \ = extensions_vec_vec.iter().position(|&x| x.is_uppercase()).unwrap();\n    \
    \            current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).count();\n            }\n            elseif current_strength\
    \ > extensions_vec_vec[current_strength_index].chars().filter(|&x| x.is_uppercase()).count()\
    \ - extensions_vec_vec[current_strength_index].chars().filter(|&x| x.is_lowercase()).count()\
    \ {\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).count();\n                current_strongest_extension = s;\n\
    \                current_strongest_extension_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_uppercase()).unwrap();\n                current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n            }\n            else {\n           \
    \     current_strongest_extension = s;\n                current_strongest_extension_index\
    \ = extensions_vec_vec.iter().position(|&x| x.is_uppercase()).unwrap();\n    \
    \            current_strength_index = extensions_vec_vec.iter().position(|&x|\
    \ x.is_lowercase()).unwrap();\n                current_strength = extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_uppercase()).count() - extensions_vec_vec[current_strength_index].chars().filter(|&x|\
    \ x.is_lowercase()).", "    let mut strongest_extension = String::from(\"\");\n\
    \    for extension in extensions {\n        let cap = extension.chars().filter(|c|\
    \ *c >= 'A'|| *c <= 'Z').count();\n        let sm = extension.chars().filter(|c|\
    \ *c >= 'a'|| *c <= 'z').count();\n        let strength = cap - sm;\n        if\
    \ strongest_extension.is_empty() || strength >= 0 {\n            strongest_extension\
    \ = extension.clone();\n        }\n    }\n    class_name.to_string() + strongest_extension",
  "    if extensions.is_empty() {\n        return class_name\n    }\n    // sort extensions\
    \ by strength first\n    let mut sorted_extensions = extensions\n        .iter()\n\
    \        .enumerate()\n        .filter_map(|(i, s)| {\n            if s.chars().all(|c|\
    \ !c.is_uppercase()) { // if any character in the string is not uppercase \n \
    \               return Some(None); // then keep this extension\n            }\
    \ else if s.chars().all(|c| c.is_uppercase()) { // if all characters are uppercase\
    \ \n                // find the one that comes first in the vector\n         \
    \       let mut first_upper = i;\n                for (j, e) in extensions.iter().enumerate()\
    \ {\n                    if e.chars().all(|c| !c.is_uppercase()) {\n         \
    \               first_upper = j;\n                        break;\n           \
    \         }\n                }\n                if first_upper == i {\n      \
    \              Some(None) // if the two extensions have the same strongest strength\
    \ then choose the one that comes first in the vector \n                } else\
    \ {\n                    Some(Some((first_upper + 1).to_digit() as u32)) // otherwise,\
    \ return the number of the extension with higher strongest strength\n        \
    \        }\n            }\n        })\n        .collect::<Vec<_>>();\n\n    let\
    \ mut class_name = class_name.to_ascii_lowercase();\n    // find the index of\
    \ the first uppercase letter\n    let mut first_upper = sorted_extensions.iter().position(|e|\
    \ e.is_some());\n    // find the index of the first lowercase letter\n    let\
    \ mut first_lower = sorted_extensions.iter().position(|e| e.is_some());\n    //\
    \ loop through the sorted extensions\n    for i in sorted_extensions.iter().rev().skip(first_upper\
    \ as usize).rev().take(first_lower as usize) {\n        // if the next uppercase\
    \ letter is greater than the first lower letter\n        // then increment the\
    \ first lower letter\n        if i > first_lower\n            && (class_name.chars().nth(i\
    \ + 1).is_uppercase() || class_name.chars().nth(i + 1).is_lowercase()) {\n   \
    \         first_lower += 1;\n        } else {\n            // if the next lowercase\
    \ letter is greater than the first upper letter\n            // then increment\
    \ the first upper letter\n            if i > first_upper\n                && (class_name.chars().nth(i\
    \ + 1).is_uppercase() || class_name.chars().nth(i + 1).is_lowercase()) {\n   \
    \             first_upper += 1;\n            }\n            // if all the letters\
    \ are the same then just add an 'S'\n            if i > first_lower && i > first_upper\
    \ {\n                class_name.push(b'S');\n            }\n            break\n\
    \        }\n    }\n\n    class_name + String::from(String::from(\".\")) + sorted_extensions[first_upper\
    \ as usize].to_ascii_lowercase()", "    let mut strength: Vec<(u8, String)> =\
    \ extensions.iter().cloned().map(|e| {\n        let c = e.chars().filter(|c| *c\
    \ == c).count();\n        (c.to_ascii_lowercase().as_digit(), e)\n    }).collect();\n\
    \    strength.sort();\n    let mut extensions_names: Vec<String> = extensions.iter().cloned().map(|e|\
    \ {\n        let c = e.chars().filter(|c| *c == c).count();\n        String::from_str(&format!(\"\
    {}{}\", c, e))\n    }).collect();\n    extensions_names.sort();\n    if extensions_names.len()\
    \ == 1 {\n        if strength[0].1 == -1 {\n            return String::from(&format!(\"\
    {}.{}\", class_name, extensions_names[0]));\n        } else {\n            return\
    \ String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0], strength[0].0));\n\
    \        }\n    } else {\n        if strength[0].1 == -1 {\n            return\
    \ String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0], strength[0].0));\n\
    \        } else {\n            if strength[0].1 < strength[0].0 {\n          \
    \      return String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[0],\
    \ strength[0].0));\n            } else if strength[0].1 < strength[1].0 {\n  \
    \              return String::from(&format!(\"{}.{}.{}\", class_name, extensions_names[1],\
    \ strength[0].0));\n            } else {\n                return String::from(&format!(\"\
    {}.{}.{}.{}\", class_name, extensions_names[0], extensions_names[1], strength[0].0));\n\
    \            }\n        }\n    }", "    let mut extensions_count = extensions.len();\n\
    \    let mut extensions_name_map = Vec::new();\n    extensions_name_map.push(class_name);\n\
    \    for extension in extensions {\n        let mut extension_lowercase = extension.chars().collect::<String>().to_lowercase();\n\
    \        if extension_lowercase.chars().count() > extensions_count {\n       \
    \     extensions_count = extension_lowercase.chars().count();\n        }\n   \
    \     extensions_name_map.push(extension_lowercase);\n    }\n    let mut strongest_extension\
    \ = String::from(\"\");\n    let mut strength: i32 = -1;\n    extensions_name_map.sort_by_key(|x|\
    \ {\n        let mut s = x.chars().count() - x.chars().filter(|c| c.is_uppercase()).count();\n\
    \        if s > strength {\n            strength = s\n        }\n        x.chars().filter(|c|\
    \ c.is_lowercase()).count()\n    });\n    strongest_extension = extensions_name_map[0].to_string();\n\
    \    for extension_name in extensions_name_map {\n        if strongest_extension.chars().count()\
    \ < extension_name.chars().count() {\n            strongest_extension = extension_name\n\
    \        }\n    }\n    strongest_extension", "    let (classes, strength) = classes.strength(extensions);\n\
    \    let max_strength = max_strength(strength);\n    match max_strength {\n  \
    \      0 => format!(\"{}\", class_name),\n        1 => format!(\"{}.{}\", class_name,\
    \ extensions[0]),\n        _ => format!(\"{}.{}\", class_name, extensions[strength])\n\
    \    }", "    // Your code here\n    extension_strength(class_name, extensions).to_string()",
  "    // Get the number of uppercase letters in the class name and the number of\
    \ lowercase letters in the class name\n    let CAP = class_name.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count();\n    let SM = class_name.chars().filter(|c| c\
    \ >= 'a' && c <= 'z').count();\n\n    // Calculate the strength of the extension\n\
    \    let strength = (CAP as f64 - SM as f64).recip();\n\n    // Return the extension\
    \ that has the strongest strength\n    extensions\n        .iter()\n        .enumerate()\n\
    \        .filter_map(|(i, e)| if i == 0 { Some(e.len().saturating_sub(SM as f64).max(0)\
    \ as i32, e) } else { None })\n        .min()\n        .map(|(i, e)| class_name.split_at(i).join(e))\n\
    \        .unwrap_or_else(|_| \"\".to_owned())", "    let mut strength_map = HashMap::new();\n\
    \    for (i, s) in extensions.iter().enumerate() {\n        let l = s.len();\n\
    \        let sc = (l.to_ascii_lowercase().len() as f64) / (l.to_ascii_lowercase().len()\
    \ as f64 - 1);\n        strength_map.insert(s, sc);\n    }\n    \n    let strength\
    \ = strength_map.iter().min(|a, b| a.1.cmp(&b.1).unwrap()).unwrap().1;\n    \n\
    \    let mut index = 0.0;\n    for i in strength_map.iter() {\n        if i.1\
    \ == strength {\n            index = i.0.len() as i32;\n        }\n    }\n   \
    \ \n    class_name[..index + 1] + &extensions[strength]", "    let mut strength\
    \ = -1;\n    let mut extension = String::from(\"\");\n    let mut best_extension\
    \ = String::from(\"\");\n\n    for extension in extensions {\n        let mut\
    \ char_counter = 0;\n        for char in class_name {\n            if char ==\
    \ extension {\n                char_counter += 1;\n            }\n        }\n\
    \        if char_counter == 0 {\n            strength = 0;\n            break;\n\
    \        }\n        if char_counter > strength {\n            strength = char_counter;\n\
    \            best_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\"\
    , class_name, best_extension)", "    let mut strongest_extension: usize = 0;\n\
    \n    // iterate over all extension names and find the strongest one\n    for\
    \ (i, extension) in extensions.iter().enumerate() {\n        if extension.chars().filter(|c|\
    \ c.is_uppercase()).count() >= 1 {\n            // count the number of uppercase\
    \ letters in the extension's name\n            let cap = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n            // count the number of lowercase letters\
    \ in the extension's name\n            let sm = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \            // calculate the strength\n            let strength = (cap - sm)\
    \ as usize;\n            if strength > strongest_extension {\n               \
    \ strongest_extension = strength;\n            }\n        }\n    }\n\n    // return\
    \ the class name with the strongest extension\n    class_name.to_string() + \"\
    .\" +\n    extensions[strongest_extension].to_string()", "    let mut classes:\
    \ Vec<String> = extensions.clone();\n    let mut num_upper = 0;\n    let mut num_lower\
    \ = 0;\n    for (i, item) in classes.iter().enumerate() {\n        let c = item.to_lowercase();\n\
    \        if c.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() > num_upper {\n\
    \            num_upper = c.chars().filter(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \        }\n        if c.chars().filter(|c| *c >= 'a' && *c <= 'z').count() >\
    \ num_lower {\n            num_lower = c.chars().filter(|c| *c >= 'a' && *c <=\
    \ 'z').count();\n        }\n    }\n    if num_upper - num_lower == 0 {\n     \
    \   classes.remove(&class_name[class_name.len()..]);\n    }\n    format!(\"{}.{}\"\
    , class_name, classes.iter().filter(|&x| *x == class_name).min().unwrap_or(&class_name[class_name.len()..]))",
  "    let mut best_extension: Option<String> = None;\n    let mut strength: i32 =\
    \ 0;\n    for extension in extensions {\n        let mut extension_strength: i32\
    \ = 0;\n        for c in extension.to_lowercase().chars() {\n            if let\
    \ Ok(c) = (c as u32).wrapping_sub(&(c as u32).wrapping_mul(10)) {\n          \
    \      extension_strength += c;\n            }\n        }\n        if extension_strength\
    \ > strength {\n            best_extension = Some(extension.to_string());\n  \
    \          strength = extension_strength;\n        }\n    }\n    match best_extension\
    \ {\n        Some(best_extension) => class_name.to_string() + \".\" + best_extension.clone(),\n\
    \        None => class_name.to_string(),\n    }", "    let mut best_extension:\
    \ Option<String> = None;\n    let mut strength = -1;\n    for ext in extensions\
    \ {\n        let cap = ext.to_ascii_lowercase().len_utf8();\n        let sm =\
    \ ext.to_ascii_lowercase().len_utf8() - cap;\n        let strength = if strength\
    \ == -1 || cap > sm {\n            cap - sm\n        } else {\n            strength\n\
    \        };\n        if strength > best_extension.as_ref().unwrap().len_utf8()\
    \ {\n            best_extension = Some(ext);\n        }\n    }\n    match best_extension\
    \ {\n        Some(ext) => format!(\"{}.{}\", class_name, ext),\n        None =>\
    \ format!(\"{}\", class_name),\n    }", "    let mut extensions_set: HashSet<String>\
    \ = extensions.iter().cloned().collect();\n    let mut strength: i64 = -1;\n\n\
    \    for x in extensions_set {\n        let cap = x.chars().filter(|c| *c >= 'A'\
    \ && *c <= 'Z').count() as i64;\n        let sm = x.chars().filter(|c| *c >= 'a'\
    \ && *c <= 'z').count() as i64;\n        if cap > sm {\n            strength =\
    \ cap - sm;\n            break;\n        }\n    }\n    let mut extensions_string\
    \ = class_name;\n    if strength == -1 {\n        extensions_string = extensions_string\n\
    \            + \".\"\n            + extensions[0]\n            + \".\"\n     \
    \       + extensions[extensions_set.len()-1]\n    }\n    else {\n        extensions_string\
    \ = extensions_string\n            + \".\"\n            + extensions[0]\n    \
    \        + \".\"\n            + extensions[extensions.len() - strength - 1]\n\
    \    }\n    extensions_string", "    // Your code here\n    let mut counter: usize\
    \ = 0;\n    for e in extensions {\n        if let Some(pos) = e.find(|c| *c ==\
    \ c.to_ascii_uppercase().unwrap()) {\n            let n = pos - counter;\n   \
    \         if n > 0 {\n                counter += n\n            } else {\n   \
    \             counter += 1;\n            }\n        }\n    }\n    (class_name+\"\
    .\"+extensions[counter].to_ascii_lowercase().unwrap()).to_string()", "    let\
    \ mut min_strength: u32 = -1;\n\n    for e in extensions {\n        let cap =\
    \ e.chars().filter(|c| c >= 'A' && c <= 'Z').count();\n        let sm = e.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n        min_strength = if cap - sm < 0 {\n \
    \           min_strength\n        } else {\n            if cap - sm > min_strength\
    \ {\n                min_strength\n            } else {\n                cap -\
    \ sm\n            }\n        };\n    }\n\n    let mut max_extension = String::from(\"\
    \");\n    for e in extensions {\n        let cap = e.chars().filter(|c| c >= 'A'\
    \ && c <= 'Z').count();\n        let sm = e.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count();\n        if cap >= min_strength {\n            if cap - sm > max_extension.len()\
    \ {\n                max_extension = e;\n            }\n        }\n    }\n\n \
    \   class_name.to_string() + \".\" + max_extension", "    let mut best_extension\
    \ = -1;\n    for e in extensions {\n        if e == class_name {\n           \
    \ continue;\n        }\n        let strength = e.chars().filter(|c| !c.is_upper()).count()\
    \ - e.chars().filter(|c| c.is_upper()).count();\n        if strength >= 0 {\n\
    \            if strength > best_extension {\n                best_extension =\
    \ strength;\n            }\n        }\n    }\n    class_name.to_string() + extensions[best_extension].to_string()",
  "    let mut strength: i64 = -1i64;\n    let mut extension = String::from(\"\");\n\
    \    for extension_name in extensions {\n        if extension_name.chars().count()\
    \ > 0 {\n            let letters = extension_name.chars().count();\n         \
    \   let capitals = letters.cap_iter().count();\n            let smalls = letters.count()\
    \ - capitals;\n            let extension_strength = capitals - smalls;\n     \
    \       if extension_strength > strength {\n                strength = extension_strength;\n\
    \                extension = extension_name;\n            }\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, extension)", "    let mut strength: i64 =\
    \ 1;\n    let mut extension = String::from(\"NO_EXTENSION\");\n    let mut idx\
    \ = 0;\n\n    while idx < extension.len() {\n        let c = extension[idx].chars().next().unwrap();\n\
    \        let len = extension[idx].len();\n\n        if c.is_uppercase() {\n  \
    \          strength *= CAPITALS.len();\n            if CAPITALS.contains(&c.to_string().to_uppercase())\
    \ {\n                strength /= CAPITALS.len();\n            }\n        }\n \
    \       if c.is_lowercase() {\n            strength *= SMALLS.len();\n       \
    \     if SMALLS.contains(&c.to_string().to_lowercase()) {\n                strength\
    \ /= SMALLS.len();\n            }\n        }\n\n        idx += len;\n    }\n\n\
    \    let mut name = class_name;\n    name.push_str(\".\");\n    name.push_str(extension);\n\
    \n    name.to_string()", "    let mut min_extension = String::new();\n    for\
    \ e in extensions {\n        if e.chars().filter(|x| x >= 'A' && x <= 'Z').count()\
    \ < e.chars().filter(|x| x >= 'a' && x <= 'z').count() {\n            min_extension.push_str(&e.to_string());\n\
    \        }\n    }\n    min_extension.push_str(&class_name.to_string());\n    min_extension",
  "    let mut class_name = String::from(class_name);\n    let mut strength: i32 =\
    \ -1;\n\n    for extension in extensions {\n        let mut extension = String::from(extension);\n\
    \        \n        // find the number of uppercase letters in extension\n    \
    \    let mut num_caps = 0;\n        for c in extension.chars() {\n           \
    \ if c.is_uppercase() {\n                num_caps += 1;\n            }\n     \
    \   }\n\n        // find the number of lowercase letters in extension\n      \
    \  let mut num_lows = 0;\n        for c in extension.chars() {\n            if\
    \ c.is_lowercase() {\n                num_lows += 1;\n            }\n        }\n\
    \n        // get the number of uppercase letters and lowercase letters in extension\n\
    \        let mut num_caps_lows = num_caps + num_lows;\n\n        // get the percentage\
    \ of uppercase letters and lowercase letters in extension\n        let mut percent\
    \ = 0.0;\n        if num_caps_lows > 0 {\n            percent = (num_caps_lows.to_f()\
    \ / extension.chars().len()) * 100.0;\n        }\n\n        // use the percentage\
    \ to determine strength\n        match strength {\n            -1 => strength\
    \ = percent,\n            x if x > percent => strength = x,\n            _ =>\
    \ {}\n        }\n    }\n\n    let strength = match strength {\n        x if x\
    \ > 0.0 => x.to_string(),\n        _ => \"UNKNOWN\".to_string(),\n    };\n   \
    \ class_name.push_str(&format!(\"{}.{}\", class_name, strength))", "    let mut\
    \ strength: u32 = -1;\n    let mut extension = String::from(\"\");\n    \n   \
    \ for name in extensions {\n        let cap = name.chars().filter(|c| c.is_uppercase()).count();\n\
    \        let sml = name.chars().filter(|c| c.is_lowercase()).count();\n      \
    \  \n        if cap - sml > strength {\n            strength = cap - sml;\n  \
    \          extension = name;\n        }\n    }\n    \n    class_name.to_string()\
    \ + \".\" + extension.to_string()", "    let mut max_score = -1;\n    let mut\
    \ max_extension: Option<String> = None;\n    for extension in extensions {\n \
    \       let mut score = (class_name.length() as f64 / extension.length() as f64)\
    \ - 1f64;\n        if score > max_score {\n            max_score = score;\n  \
    \          max_extension = Some(extension);\n        }\n    }\n    max_extension.unwrap_or(class_name)",
  "    let mut strength: i32 = -1;\n\n    for extension in extensions {\n        let\
    \ CAP = extension.len();\n        let SM = class_name.len();\n\n        if CAP\
    \ - SM > strength {\n            strength = CAP - SM;\n        }\n    }\n\n  \
    \  format!(\"{}.{}\", class_name, extensions.iter().filter_map(|e| e.to_lowercase()).max(&|a,\
    \ b| a.cmp(b)).unwrap())", "    if extensions.len() == 0 {\n        return class_name;\n\
    \    }\n    let mut max_extension_strength = -1;\n    let mut min_extension_strength\
    \ = -1;\n    for i in 0..extensions.len() {\n        let extension = &extensions[i];\n\
    \        let class_name = String::from(class_name);\n        let extension_strength\
    \ = extension.chars().filter(|c| *c >= 'A' && *c <= 'Z').count() - extension.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n        if extension_strength > max_extension_strength\
    \ {\n            max_extension_strength = extension_strength;\n        }\n   \
    \     if extension_strength < min_extension_strength {\n            min_extension_strength\
    \ = extension_strength;\n        }\n    }\n    let strength = max_extension_strength\
    \ - min_extension_strength;\n    if strength != 0 {\n        return class_name.to_string()\
    \ + extensions.iter().position(|e| *e == class_name).unwrap().to_string() + String::from(\"\
    .\") + String::from(Strongest_Extension(class_name.to_string() + extensions.iter().position(|e|\
    \ *e == class_name).unwrap().to_string() + String::from(\".\" + extensions[extensions.iter().position(|e|\
    \ *e == class_name).unwrap()]), extensions)).to_string();\n    } else {\n    \
    \    return class_name;\n    }", "    let mut extensions_iter = extensions.iter();\n\
    \    let mut extensions_len = extensions.len();\n    let mut strongest_extension\
    \ = String::new();\n    let mut current_extension = String::new();\n    let mut\
    \ current_strength = 0;\n    let mut current_class_name = class_name;\n    loop\
    \ {\n        if extensions_iter.any(|e| {\n            e.chars().any(|c| *c >=\
    \ 'A' && *c <= 'Z') ||\n            e.chars().any(|c| *c >= 'a' && *c <= 'z')\
    \ ||\n            e.chars().any(|c| *c >= '0' && *c <= '9')\n        }) {\n  \
    \          if current_strength > 0 {\n                return format!(\"{}.{}\"\
    , current_class_name, strongest_extension);\n            } else {\n          \
    \      return format!(\"{}.{}\", current_class_name, current_extension);\n   \
    \         }\n        }\n        if extensions_len > 0 {\n            if current_strength\
    \ > 0 {\n                current_extension = extensions_iter.next().unwrap();\n\
    \                current_strength = extensions_iter.any(|e| e.chars().any(|c|\
    \ *c >= 'A' && *c <= 'Z')).unwrap_or(false)\n                    ? extensions_len\n\
    \                    : -1;\n            } else {\n                current_extension\
    \ = extensions_iter.next().unwrap();\n                current_strength = extensions_iter.any(|e|\
    \ e.chars().any(|c| *c >= 'a' && *c <= 'z')).unwrap_or(false)\n              \
    \      ? extensions_len\n                    : -1;\n            }\n        }\n\
    \        extensions_len -= 1;\n        if extensions_len == 0 {\n            current_strength\
    \ = extensions_iter.any(|e| e.chars().any(|c| *c >= 'A' && *c <= 'Z')).unwrap_or(false)\n\
    \                ? extensions_len\n                : -1;\n        }\n    }", " \
    \   // Write your code in Rust here.\n    let mut extensions_map = Vec::new();\n\
    \    extensions.iter().for_each(|e| {\n        extensions_map.push(e.to_lowercase());\n\
    \    });\n    let mut strength = -1;\n    for (i, e) in extensions_map.iter().enumerate()\
    \ {\n        let cap = e.chars().filter(|c| *c >= 'A').count();\n        let sm\
    \ = e.chars().filter(|c| *c <= 'Z').count();\n        strength = if cap > sm {\n\
    \            cap - sm\n        } else {\n            sm - cap\n        };\n  \
    \      if strength > i {\n            return format!(\"{}.{}\", class_name, e);\n\
    \        }\n    }\n    format!(\"{}.{}\", class_name, extensions[extensions_map.len()..extensions_map.len()\
    \ - 1].join());", "    let mut extensions_set: HashSet<&str> = extensions.iter().map(|x|\
    \ x.clone()).collect();\n    extensions_set.sort_unstable();\n    let mut best_extension:\
    \ Vec<String> = Vec::new();\n    let mut best_extension_index: usize = 0;\n  \
    \  let mut best_strongest_extension: &str = \"\";\n    for (index, extension)\
    \ in extensions_set.iter().enumerate() {\n        let strongest_extension = extension.clone();\n\
    \        let fraction = extension.chars().filter(|&x| x >= 'A' && x <= 'Z').count()\
    \ - extension.chars().filter(|&x| x >= 'a' && x <= 'z').count();\n        let\
    \ strength = if fraction < 0 {\n            -1.0\n        } else {\n         \
    \   fraction\n        };\n        if strength > 0 {\n            if best_extension_index\
    \ == index {\n                if strength > best_strongest_extension.as_num()\
    \ {\n                    best_strongest_extension = strongest_extension;\n   \
    \                 best_extension_index = index;\n                }\n         \
    \   } else {\n                if strength < best_strongest_extension.as_num()\
    \ {\n                    best_strongest_extension = strongest_extension;\n   \
    \                 best_extension_index = index;\n                }\n         \
    \   }\n        }\n    }\n    class_name.get() + \"_\" + best_strongest_extension",
  "    extensions.iter().fold(class_name, |class_name, extension| {\n        let (extension_str,\
    \ _extension_str) =\n            extension.split_at(class_name.len());\n     \
    \   let extension_strength: i32 = extension_str\n            .chars()\n      \
    \      .filter(|c| c.is_uppercase())\n            .count() as i32 - extension_str\n\
    \            .chars()\n            .filter(|c| c.is_lowercase())\n           \
    \ .count() as i32;\n        String::from(format!(\"{}.{}\", class_name, extension))\n\
    \    })", "    let mut strength: i64 = 0;\n    for (extension, weight) in extensions.iter().zip(extensions.iter().rev())\
    \ {\n        let mut len = extension.len();\n        if let Ok(mut letter_count)\
    \ = get_letter_count(&extension[..len]) {\n            len = letter_count;\n \
    \       }\n        let strength = strength.min(len.saturating_sub(&weight));\n\
    \    }\n    String::from(format!(\"{}.{}\", class_name, extensions[strength -\
    \ 1]));", "    \n    let mut best_extension: Option<String> = std::cmp::min(*extensions.iter().map(|e|\
    \ e.len() as u32).sum(), -1);\n    for (i, e) in extensions.iter().enumerate()\
    \ {\n        let current_extension = match e.len() {\n            1 => e,\n  \
    \          2 => e.to_lowercase(),\n            _ => return String::from(class_name),\n\
    \        };\n        if best_extension.is_none() || current_extension.cmp(*best_extension)\
    \ != cmp::Ordering::Less {\n            best_extension = Some(current_extension);\n\
    \        }\n    }\n    if best_extension.is_none() {\n        return String::from(class_name);\n\
    \    }\n    String::from(&format!(\"{}.{}\", class_name, best_extension.unwrap()))",
  "    let mut current_class = \"\";\n    let mut current_strength = -1;\n    for\
    \ x in extensions {\n        if x.to_lowercase() == class_name.to_lowercase()\
    \ {\n            current_strength = x.to_lowercase().chars().filter(|&c| *c ==\
    \ c).count() - x.to_lowercase().chars().filter(|&c| *c == c).count();\n      \
    \      current_class = x;\n        }\n    }\n\n    if current_strength == -1 &&\
    \ extensions.get(0) != class_name {\n        return class_name + \".\" + extensions.get(0).to_string();\n\
    \    } else if current_strength != -1 {\n        let mut strength = current_strength;\n\
    \        extensions.iter().skip(1).for_each(|x| {\n            strength += x.to_lowercase().chars().filter(|&c|\
    \ *c == c).count() - x.to_lowercase().chars().filter(|&c| *c == c).count();\n\
    \        });\n        if strength < current_strength {\n            return class_name\
    \ + \".\" + extensions.get(0).to_string();\n        } else {\n            return\
    \ class_name + \".\" + extensions.get(strength).to_string();\n        }\n    }\
    \ else {\n        return class_name + \".\" + extensions.get(0).to_string();\n\
    \    }", "    assert!(extensions.len() >= 2);\n    let mut max_strength: i32 =\
    \ -1;\n    let mut strength: i32 = 0;\n    for extension in extensions {\n   \
    \     if extension.chars().all(|c| c >= 'A' && c <= 'Z') {\n            strength\
    \ += 1;\n        }\n        if extension.chars().all(|c| c >= 'a' && c <= 'z')\
    \ {\n            strength += 1;\n        }\n        if strength > max_strength\
    \ {\n            max_strength = strength;\n        }\n    }\n    if max_strength\
    \ == 0 {\n        class_name\n    } else {\n        format!(\"{}.{}\", class_name,\
    \ extensions[max_strength])\n    }", "    let mut max_strength = -1;\n    let\
    \ mut max_extension = String::new();\n    let mut i = 0;\n    loop {\n       \
    \ let mut s = String::from(class_name);\n        for extension in &extensions\
    \ {\n            i += extension.len();\n            let mut j = i;\n         \
    \   let mut c = 1;\n            loop {\n                let (extension, extension_strength)\
    \ = Extension::from_name(extension);\n                if extension_strength >\
    \ 0 {\n                    s = &s[..j] + &extension[..j] + &s[j..];\n        \
    \            break;\n                }\n                j += 1;\n            \
    \    c += 1;\n            }\n            if max_strength < c {\n             \
    \   max_strength = c;\n                max_extension = extension;\n          \
    \  }\n        }\n        if i < class_name.len() {\n            i += 1;\n    \
    \    }\n        else {\n            break;\n        }\n    }\n    String::from(format!(\"\
    {}.{}\", class_name, max_extension))", "    let mut strength: i32 = -1;\n    let\
    \ mut best_extension: String = String::from(\"\");\n    for extension in extensions\
    \ {\n        let extension_strength = extension.chars().map(|c| c.to_ascii_uppercase().count()\
    \ as i32).sum();\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n            best_extension = extension;\n        }\n\
    \    }\n\n    format!(\"{}.{}\", class_name, best_extension)", "    let mut result:\
    \ Vec<i16> = Vec::new();\n    extensions.iter().for_each(|e| result.push((e.chars().count()\
    \ as i16) - (class_name.chars().count() as i16)));\n    let result = result.iter().enumerate().max(|a,\
    \ b| a.1.cmp(&b.1)).map(|(i, b)| b).unwrap_or(1);\n    format!(\"{}{}\", class_name,\
    \ result.to_string())", "    let mut strength: i32 = 0;\n    let mut classname:\
    \ String = class_name;\n    while classname.chars().any(|c| c.is_uppercase() &&\
    \ strength >= 0) {\n        strength += 1;\n        classname = String::from(format!(\"\
    {}.{}\", class_name, classname));\n    }\n    if extensions.iter().any(|e| e ==\
    \ classname) {\n        String::from(format!(\"{}.{}\", class_name, classname))\n\
    \    } else {\n        String::from(format!(\"{}.{}\", classname, extensions.iter().min_by_key(|e|\
    \ {\n            e.chars().filter(|c| c.is_lowercase()).count() as i32\n     \
    \   }).unwrap()))\n    }", '    extensions_with_strength(extensions).iter().max().unwrap()',
  "    let mut min = extensions[0]\n    for extension in extensions {\n        let\
    \ (strength, _) = Extension::strength(extension);\n        if strength < min.len()\
    \ {\n            min = extension;\n        }\n    }\n    let (strength, class_name)\
    \ = Extension::strength(class_name);\n    if strength < min.len() {\n        min\n\
    \    } else {\n        class_name + String::from(\".\") + extensions.iter().cloned().max_by_key(|s|\
    \ Extension::strength(s).len()).unwrap()\n    }", "    let mut res = String::from(\"\
    \");\n    \n    for s in extensions {\n        if !res.is_empty() {\n        \
    \    res.push_str(\".\")\n        }\n        res.push('.');\n        res.push(s);\n\
    \    }\n    res.push(class_name);\n\n    // If the input classes name has cap\
    \ letters in it, return the first \n    // extension with the highest strength.\n\
    \    if let Some(mut name) = name.split('.') {\n        for name in name.chars()\
    \ {\n            if !name.is_uppercase() {\n                break;\n         \
    \   }\n        }\n\n        name.truncate(name.len() - 1);\n\n        // Reverse\
    \ the extensions so they're in alphabetical order and return\n        // the first.\n\
    \        let mut extensions = extensions.iter().cloned().reverse();\n        let\
    \ mut strength = -1;\n        \n        for e in extensions {\n            let\
    \ cap = e.chars().filter(|c| c.is_uppercase()).count();\n            let sm =\
    \ e.chars().filter(|c| !c.is_uppercase()).count();\n            let strength =\
    \ cap - sm;\n            \n            if strength > 0 {\n                break;\n\
    \            }\n        }\n\n        res.push_str(&name.to_string() + \"_\" +\
    \ &extensions[extensions.len() - 1]);\n    }\n    else {\n        res.push_str(class_name\
    \ + \".\");\n    }\n\n    res", "    let mut extension_counters = HashMap::new();\n\
    \n    for &extension in extensions {\n        let mut counter = extension_counters.get(&extension);\n\
    \        counter.increment(1);\n        extension_counters.insert(extension, counter);\n\
    \    }\n\n    let extension_counters_sorted_by_strength = extension_counters.iter().enumerate().sorted();\n\
    \    let mut strength = -1;\n    let mut extension = String::from(\"\");\n\n \
    \   for (i, e) in extension_counters_sorted_by_strength {\n        if i == 0 {\n\
    \            strength = e.unwrap();\n            extension = e.unwrap();\n   \
    \     } else {\n            if e.unwrap() == strength {\n                extension\
    \ += String::from(\".\");\n            }\n            strength = e.unwrap();\n\
    \            extension = e.unwrap();\n        }\n    }\n\n    class_name + extension",
  '    extensions.iter().fold(class_name, |a, &b| a.to_string() + b.to_string())',
  "    // Your code here\n    if extensions.len() != class_name.chars().filter(|c|\
    \ c.is_uppercase()).count() - class_name.chars().filter(|c| c.is_lowercase()).count()\
    \ {\n        return String::from(\"\");\n    }\n    let mut counter = vec![0;\
    \ extensions.len()];\n    for element in extensions {\n        counter[element.chars().filter(|c|\
    \ c.is_uppercase()).count()] += 1;\n        counter[element.chars().filter(|c|\
    \ c.is_lowercase()).count()] -= 1;\n    }\n    let min_count = counter.iter().min().unwrap_or(counter.len());\n\
    \    let strength = min_count - counter.iter().filter(|c| *c == min_count).count();\n\
    \    format!(\"{}.{}\", class_name, extensions[strength].to_string())", "    if\
    \ extensions.iter().any(|x| x.contains(&class_name)) {\n        String::from(format!(\"\
    {}.{}\", class_name, extensions[0]))\n    } else {\n        let mut max = 0;\n\
    \        let mut max_index = -1;\n        for (index, extension) in extensions.iter().enumerate()\
    \ {\n            if extension.contains(&class_name) {\n                max = extension.chars().filter(|x|\
    \ x.is_uppercase() == true).count() as i32;\n                if max > max {\n\
    \                    max = index;\n                }\n            }\n        }\n\
    \        String::from(format!(\"{}.{}\", class_name, extensions[max]))\n    }",
  "    if extensions.len() == 0 {\n        return class_name\n    }\n    let mut best_extension:\
    \ String;\n    let mut best_strength: usize;\n    for extension in extensions\
    \ {\n        let mut current_strength: usize = 0;\n        let mut current_class:\
    \ String = class_name;\n        for c in extension {\n            if c.is_uppercase()\
    \ {\n                current_strength += 1;\n                current_class +=\
    \ c;\n            } else if c.is_lowercase() {\n                current_strength\
    \ += 2;\n                current_class += c;\n            } else {\n         \
    \       break;\n            }\n        }\n        if current_strength > best_strength\
    \ {\n            best_strength = current_strength;\n            best_extension\
    \ = extension;\n        }\n    }\n    return best_extension;", "    let mut extension_map\
    \ = HashMap::new();\n    for extension in extensions {\n        let mut extension_components\
    \ = extension.split(\".\");\n        let mut extension_component_length = extension_components.len();\n\
    \        \n        // if an extension has lower characters or has more then one\
    \ dots it's too bad\n        if extension_component_length > 1 {\n           \
    \ extension_component_length -= 1;\n        }\n        \n        // if extension\
    \ is empty (no class) it's too bad\n        if extension_component_length == 0\
    \ {\n            extension_component_length = 1;\n        }\n        \n      \
    \  let mut extension_component_iter: Vec<String> = extension_components.iter().map(String::from).collect();\n\
    \        let mut extension_component_length = extension_component_iter.len();\n\
    \        \n        // if component has a lower character (all uppercase) it's\
    \ too bad \n        if extension_component_length < CAP {\n            extension_component_length\
    \ += CAP - SM;\n        }\n        \n        // if component has lower characters\
    \ it's too bad \n        if extension_component_length < SM {\n            extension_component_length\
    \ += SM;\n        }\n        \n        extension_map.insert(extension_component_iter.last().to_lowercase(),\
    \ extension_component_iter);\n    }\n    \n    let mut result = class_name.clone();\n\
    \    let mut strongest_extension = String::from(\"NA\");\n    \n    for component\
    \ in extension_map.keys().cloned() {\n        if extension_map.get(component).len()\
    \ > extension_map.get(strongest_extension).len() {\n            strongest_extension\
    \ = component;\n        }\n    }\n    \n    result += \".\" + strongest_extension;\n\
    \    result", "    let mut max_extension = 0;\n    let mut current_max_extension\
    \ = 0;\n    let mut current_extension = String::new();\n\n    for e in extensions\
    \ {\n        if e.chars().filter(|c| c == '_').count() > 0 {\n            println!(\"\
    Error: You should not use an underscore in an extension name!\");\n        }\n\
    \n        let c = e.chars().filter(|c| !c.is_ascii()).count();\n        let s\
    \ = e.chars().filter(|c| c.is_ascii()).count();\n        current_extension = String::from(\"\
    {}.{}\", class_name, e);\n        current_max_extension = max(c, s, current_max_extension);\n\
    \n        if c > max_extension { max_extension = c; }\n    }\n\n    if current_max_extension\
    \ == 0 {\n        println!(\"Error: No extension with strongest extension was\
    \ found!\");\n        return String::new();\n    }\n\n    return String::from(\"\
    {}.{}\", class_name, extensions[extensions.len() - max_extension]);", "    let\
    \ mut strength = String::new();\n\n    for i in extensions.iter().cloned().filter(|&x|\
    \ x.chars().count(|c| *c >= 'A') || *c <= 'Z').sorted() {\n        let count =\
    \ (i[0..].chars().count(|c| *c >= 'A') || *c <= 'Z').to_string();\n        if\
    \ count.len() > strength.len() {\n            strength = i.to_string();\n    \
    \    }\n    }\n\n    format!(\"{}.{}\", class_name, strength)", "    // Find the\
    \ strongest extension based on number of uppercase letters\n    // and number\
    \ of lowercase letters\n    let mut strongest_extensions = Vec::new();\n    strongest_extensions.sort_by(|a,\
    \ b| {\n        match a.chars().filter(|c| c.is_uppercase()).count() - b.chars().filter(|c|\
    \ c.is_lowercase()).count() {\n            0 => 1,\n            _ => -1,\n   \
    \     }\n    });\n    \n    if extensions.iter().any(|ext| strongest_extensions.contains(ext))\
    \ {\n        // The found extension has already had its strength chosen\n    \
    \    return class_name;\n    }\n    \n    // Iterate over the list of extensions\
    \ and find the strongest one\n    for (i, ext) in extensions.iter().enumerate()\
    \ {\n        if ext.chars().filter(|c| c.is_lowercase()).count() > strongest_extensions[i].chars().filter(|c|\
    \ c.is_uppercase()).count() {\n            strongest_extensions[i] = ext;\n  \
    \      }\n    }\n    \n    // Return the class name with the strongest extension\n\
    \    format!(\"{}.{}\", class_name, strongest_extensions.iter().next()) // Use\
    \ .next() here because we don't care about the order of the extensions list",
  "    let mut classname = class_name;\n    let mut extensions = extensions;\n   \
    \ let mut extensions_copy = extensions;\n    loop {\n        if extensions.is_empty()\
    \ {\n            break;\n        }\n        let (extension, extension_strength)\
    \ = extensions.iter().cloned().max_by(|a, b| a.cmp(b));\n        classname.push_str(extension);\n\
    \        extensions.remove(&extension);\n        extensions_copy = extensions;\n\
    \    }\n    classname.push_str(extensions_copy.iter().min().unwrap());\n    classname",
  "    if extensions.is_empty() {\n        return class_name;\n    }\n    let mut\
    \ current_strength = -1;\n    let mut best_extension = String::from(\"\");\n \
    \   for extension in extensions {\n        let (classname, extension) = extension.split('.');\n\
    \        let cap_ext = extension.chars().filter(|x| x.is_uppercase()).count();\n\
    \        let sml_ext = extension.chars().filter(|x| x.is_lowercase()).count();\n\
    \        let strength = cap_ext.saturating_sub(sml_ext);\n        if strength\
    \ > current_strength {\n            current_strength = strength;\n           \
    \ best_extension = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name,\
    \ best_extension)", "    let mut strongest_extension = Vec::<String>::new();\n\
    \    let mut strength: i64 = 0;\n    let mut i = 0;\n    for extension in extensions\
    \ {\n        if extension.to_lowercase() == class_name.to_lowercase() {\n    \
    \        strength += 1;\n        } else {\n            strength -= 1;\n      \
    \  }\n        if i == 0 {\n            strongest_extension.push(extension);\n\
    \        }\n        i += 1;\n    }\n    // If there are no extensions then return\
    \ the first one \n    strongest_extension.iter().find(|&s| s == class_name).unwrap().to_lowercase()",
  "    let mut extensions = extensions.clone();\n    let mut class_name = class_name.to_ascii_lowercase();\n\
    \    let mut counter = 0;\n    let mut counter2 = 0;\n    loop {\n        if counter\
    \ > extensions.len() {\n            return class_name + String::from(\".\") +\
    \ &extensions[counter2];\n        }\n        if counter2 > extensions.len() {\n\
    \            return class_name + String::from(\".\") + &extensions[counter];\n\
    \        }\n        if counter2 == 0 {\n            let mut counter3 = (counter\
    \ + counter2) / 2;\n            while counter3 > 0 && extensions.len() > counter3\
    \ {\n                if extensions[counter3] >= &extensions[counter] {\n     \
    \               counter = counter3;\n                    break;\n            \
    \    } else {\n                    counter3 -= 1;\n                }\n       \
    \     }\n        }\n        if counter2 == 0 {\n            let mut counter3 =\
    \ (counter + counter2) / 2;\n            while counter3 > 0 && extensions.len()\
    \ > counter3 {\n                if extensions[counter3] >= &extensions[counter2]\
    \ {\n                    counter = counter3;\n                    break;\n   \
    \             } else {\n                    counter3 -= 1;\n                }\n\
    \            }\n        }\n        counter3 -= 1;\n        counter2 += 1;\n  \
    \  }", "    match extensions.iter().enumerate().max_by_key(|_, i| {\n        //\
    \ To find the strength of the extension, we count the number of \n        // upper\
    \ case letters in our extension's name.\n        let cap = String::from(extensions[i].chars().filter(|c|\
    \ match c.to_ascii_lowercase().as_ref() {\n            Some(el) => true,\n   \
    \         None => false\n        }).count());\n\n        // To find the strength\
    \ of the extension, we count the number of \n        // lower case letters in\
    \ our extension's name.\n        let sm = String::from(extensions[i].chars().filter(|c|\
    \ match c.to_ascii_lowercase().as_ref() {\n            Some(el) => true,\n   \
    \         None => false\n        }).count());\n        // Return the difference\
    \ between the capital letters and lowercase letters\n        // divided by the\
    \ total number of letters in the extension's name.\n        (cap - sm).unwrap()\
    \ / extensions.len()\n    }) {\n        // We found the strongest extension.\n\
    \        Some(e) => {\n            format!(\"{}.{}\", class_name, e)\n       \
    \ }\n        // We didn't find the strongest extension.\n        None => String::from(\"\
    NO_EXTENSION\")\n    }", "    let mut result: String = \".\".to_owned();\n   \
    \ for (i, e) in extensions.iter().enumerate() {\n        if i == 0 {\n       \
    \     continue;\n        }\n        let mut s = e;\n        if i > 0 {\n     \
    \       let mut k = i;\n            let mut c = e;\n            while k > 0 {\n\
    \                let mut j = k;\n                let mut d = e;\n            \
    \    while j > 0 {\n                    s = s.to_owned() + c.to_owned();\n   \
    \                 j -= 1;\n                }\n                k = j;\n       \
    \         c = d;\n            }\n        }\n        result = s.to_owned() + result.to_owned();\n\
    \    }\n    result + class_name", "    let mut strongest_exts = vec![];\n    for\
    \ ext in extensions {\n        let cap_extension = ext.chars().filter(|c| c >=\
    \ 'A' && c <= 'Z').count() as i32 - ext.chars().filter(|c| c >= 'a' && c <= 'z').count()\
    \ as i32;\n        let sm_extension = ext.chars().filter(|c| c >= 'a' && c <=\
    \ 'z').count() as i32;\n        let strength = cap_extension - sm_extension;\n\
    \        if strength > 0 {\n            strongest_exts.push(String::from(ext.to_string()\
    \ + f\".{ext.to_string().chars().filter(|c| c >= 'a' && c <= 'z').count().to_string()}\"\
    ));\n        }\n    }\n    strongest_exts.sort_unstable_by_key(|s| s.len());\n\
    \    strongest_exts.last().unwrap().to_string()", "    let mut extension_counter\
    \ = vec![];\n    for e in extensions {\n        let mut counter = 0;\n       \
    \ for c in &e {\n            counter += match c {\n                'A' => {\n\
    \                    1\n                }\n                'B' => {\n        \
    \            2\n                }\n                'C' => {\n                \
    \    3\n                }\n                'D' => {\n                    4\n \
    \               }\n                'E' => {\n                    5\n         \
    \       }\n                'F' => {\n                    6\n                }\n\
    \                'G' => {\n                    7\n                }\n        \
    \        'H' => {\n                    8\n                }\n                'I'\
    \ => {\n                    9\n                }\n                'J' => {\n \
    \                   10\n                }\n                'K' => {\n        \
    \            11\n                }\n                'L' => {\n               \
    \     12\n                }\n                'M' => {\n                    13\n\
    \                }\n                'N' => {\n                    14\n       \
    \         }\n                'O' => {\n                    15\n              \
    \  }\n                'P' => {\n                    16\n                }\n  \
    \              'Q' => {\n                    17\n                }\n         \
    \       'R' => {\n                    18\n                }\n                'S'\
    \ => {\n                    19\n                }\n                'T' => {\n\
    \                    20\n                }\n                'U' => {\n       \
    \             21\n                }\n                'V' => {\n              \
    \      22\n                }\n                'W' => {\n                    23\n\
    \                }\n                'X' => {\n                    24\n       \
    \         }\n                'Y' => {\n                    25\n              \
    \  }\n                'Z' => {\n                    26\n                }\n  \
    \              _ => {\n                    0\n                }\n            };\n\
    \        }\n        extension_counter.push(counter);\n    }\n    \n    // Sort\
    \ extensions by strength\n    extension_counter.sort_by_key(|x| *x);\n\n    //\
    \ Iterate through the sorted extensions and choose the one with the lowest strength\n\
    \    let mut counter = 0;\n    for (i, e) in extension_counter.iter().enumerate()\
    \ {\n        if i == 0 {\n            return String::from(&class_name.to_string().to_string())\
    \ + &e.to_string();\n        }\n        \n        // If two extensions have the\
    \ same strength we choose the one that comes first\n        if *e == *extension_counter[i\
    \ + 1] {\n            return String::from(&class_name.to_string().to_string())\
    \ + &extensions[i - 1].to_string();\n        }\n        counter += 1;\n    }\n\
    \    return String::from(&class_name.to_string().to_string()) + &extensions[counter].to_string();",
  "    let mut strength = -1;\n    let mut extension = String::from(\"\");\n    let\
    \ mut class_name = String::from(class_name);\n    for extension in extensions\
    \ {\n        let mut extension_len = extension.len();\n        let mut class_len\
    \ = 0;\n        while class_len < extension_len {\n            let cap_diff =\
    \ class_len.saturating_sub(extension_len);\n            let cap = extension.chars().filter(|c|\
    \ c.is_uppercase())\n                .filter(|c| c <= 'Z').count() as usize -\
    \ 1;\n            let sm_diff = class_len.saturating_sub(extension_len);\n   \
    \         let sm = extension.chars().filter(|c| c.is_lowercase())\n          \
    \      .filter(|c| c <= 'z').count() as usize - 1;\n            let strength_diff\
    \ = cap - sm;\n            let strength = strength_diff;\n            if strength\
    \ > 0 {\n                if strength < strength_diff {\n                    extension\
    \ = extension.to_string();\n                    break;\n                }\n  \
    \          }\n            extension = extension.clone();\n            class_len\
    \ += 1;\n        }\n    }\n    class_name.to_string() + \".\" + extension.to_string()",
  "    if extensions.len() <= 2 {\n        return format!(\"{}.{}\", class_name, extensions.last());\n\
    \    }\n\n    // count the number of upper case letters\n    let cap_num = String::from(\"\
    \").chars().filter(|c| c.is_upper()).count();\n    // count the number of lower\
    \ case letters\n    let sm_num = String::from(\"\").chars().filter(|c| c.is_lower()).count();\n\
    \n    if cap_num >= sm_num {\n        return format!(\"{}.{}\", class_name, extensions.last());\n\
    \    }\n\n    // calculate the strength of the extension\n    let strength = cap_num\
    \ - sm_num;\n\n    // sort the extensions by strength\n    let mut extensions_sorted\
    \ = extensions.iter().cloned().collect::<Vec<String>>().sort();\n    extensions_sorted.pop();\n\
    \    extensions_sorted.pop();\n\n    // pick the strongest extension\n    if extensions_sorted.len()\
    \ == 1 {\n        return format!(\"{}.{}\", class_name, extensions_sorted[0]);\n\
    \    }\n\n    // find the first extension with equal strength\n    let mut chosen_extensions\
    \ = extensions_sorted.iter().cloned().collect::<Vec<String>>();\n    for (i, &name)\
    \ in chosen_extensions.iter().enumerate() {\n        if i == 0 {\n           \
    \ continue;\n        }\n        if name == extensions_sorted[i - 1] {\n      \
    \      chosen_extensions.swap(0, i);\n        }\n    }\n\n    // return the extension\n\
    \    format!(\"{}.{}\", class_name, chosen_extensions[0])", "    let mut strength\
    \ = -1i32;\n    for ext in extensions {\n        if ext.chars().filter(|&c| c\
    \ == 'A'..'Z').count() > strength {\n            strength = ext.chars().filter(|&c|\
    \ c == 'A'..'Z').count();\n        }\n    }\n    let strength = match strength\
    \ {\n        x if x > 0 else 0 => 0,\n        x => 1,\n    };\n    class_name.chars().filter(\
    \ |&c| c.is_upper() ).collect().join(\"\") + &class_name.chars().filter( |&c|\
    \ !c.is_upper() ).collect().join(\"\").chars().filter(|&c| c == '_' || c == '.').collect().join(\"\
    \") + &class_name.chars().filter(|&c| c == 'A'..'Z').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'a'..'z').collect().join(\"\") + &class_name.chars().filter(|&c| c == 'A'..'Z'\
    \ || c == 'a'..'z' || c == '_'||c == '.').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ !c == '_' && !c == '.').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| !c == '_' && !c == '.' && c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c\
    \ == '.' || c == '_').collect().join(\"\") + &class_name.chars().filter(|&c| !c\
    \ == '_' && !c == '.' && c == '_').collect().join(\"\") + &class_name.chars().filter(|&c|\
    \ c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c == '.' || c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| !c == '_' && !c == '.' && c == '_').collect().join(\"\
    \") + &class_name.chars().filter(|&c| c == 'A'..'Z' || c == 'a'..'z' || c == '_'||c\
    \ == '.' || c == '_').collect().join(\"\") + &class_", "    let mut len = class_name\n\
    \        .chars()\n        .map(|x| x.to_ascii_lowercase().unwrap())\n       \
    \ .filter(|&x| x == x)\n        .count();\n    \n    for ext in extensions {\n\
    \        let mut len = ext.chars().map(|x| x.to_ascii_lowercase().unwrap()).filter(|&x|\
    \ x == x).count();\n        if len >= len {\n            len = len;\n        }\n\
    \    }\n    class_name\n        .get_str()\n        .to_string()\n        .to_uppercase()\n\
    \        + &extensions[extensions.iter().max_by_key(|&x| x.len()).unwrap()]\n\
    \        .get_str()\n        .to_string()\n        .to_uppercase()", "    if extensions.is_empty()\
    \ {\n        return class_name;\n    }\n\n    let mut classname = class_name;\n\
    \    let mut strength = 1;\n    let mut counter = 0;\n    while let Some(mut extension)\
    \ = extensions.iter().find(|x| x.to_lowercase().contains(classname.to_lowercase()))\
    \ {\n        strength += 1;\n        if counter > 0 {\n            return format!(\"\
    {}.{}\", classname, extension);\n        }\n        counter += 1;\n    }\n\n \
    \   format!(\"{}.{}\", classname, extensions[0])", "    let mut strength: i32\
    \ = 0;\n    for (index, extension) in extensions.iter().enumerate() {\n      \
    \  let cap = extension.chars().filter(|c| *c >= 'A').count() as i32;\n       \
    \ let sm = extension.chars().filter(|c| *c <= 'Z').count() as i32;\n        strength\
    \ = cap - sm;\n        if strength < 0 {\n            strength = -1;\n       \
    \ }\n    }\n    if strength == 0 {\n        class_name\n    } else {\n       \
    \ class_name.to_string() + format!(\"{}.{}\", Strongest_Extension_name(strength),\
    \ Strongest_Extension_name(strength))\n    }", "    let mut extension_hash: HashMap<String,\
    \ u32> = HashMap::new();\n    extensions.iter().for_each(|ext| {\n        let\
    \ ext = ext.to_lowercase().chars().collect();\n        let mut c: u32 = 1;\n \
    \       for ch in ext.iter() {\n            if *ch >= 'a' && *ch <= 'z' {\n  \
    \              *c += 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        extension_hash.insert(String::from(ext), c);\n  \
    \  });\n    let mut extension_order: Vec<(u32, String)> = extensions.iter().cloned().collect();\n\
    \    extension_order.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut best_extension:\
    \ Vec<(u32, String)> = extension_order.iter().cloned().collect();\n    let mut\
    \ strength: usize = 0;\n    for e in &mut extension_order {\n        if best_extension.iter().all(|x|\
    \ x.1.cmp(&e.1) == 0) {\n            strength = e.0;\n            break;\n   \
    \     }\n    }\n    if best_extension.len() < extensions.len() {\n        if strength\
    \ > 0 {\n            let (extension, new_strength) = best_extension[0];\n    \
    \        best_extension.sort_by(|a, b| a.1.cmp(&b.1));\n            best_extension.dedup();\n\
    \            let mut new_extensions: Vec<String> = best_extension.iter().cloned().collect();\n\
    \            new_extensions.push(\"_\".to_owned());\n            new_extensions.push(extension);\n\
    \            new_extensions.push(\"_\".to_owned());\n            Strongest_Extension(String::from(&class_name)[..],\
    \ new_extensions)\n        } else {\n            Strongest_Extension(String::from(&class_name)[..],\
    \ extensions)\n        }\n    } else {\n        Strongest_Extension(String::from(&class_name)[..],\
    \ extensions)\n    }", "    let mut strength: usize = -1;\n    let mut index =\
    \ 0;\n    while index < extensions.len() {\n        let current_extension = extensions[index];\n\
    \        let current_extension_upper = current_extension.chars().map(|c| *c).collect::<String>();\n\
    \        let current_extension_lower = current_extension.chars().map(|c| *c).collect::<String>();\n\
    \        let cap = current_extension_upper.chars().map(|c| *c).collect::<String>();\n\
    \        let sm = current_extension_lower.chars().map(|c| *c).collect::<String>();\n\
    \        strength += cap.to_string().chars().filter(|c| *c == c.to_lowercase()).count()\
    \ - sm.to_lowercase().chars().filter(|c| *c == c.to_lowercase()).count();\n  \
    \      index = index + 1;\n    }\n    \n    let strength_str = format!(\"{}.{}\"\
    , class_name, extensions[strength].to_string());\n    strength_str.to_string()",
  "    let mut max_strength = -1;\n    let mut max_extension = String::from(\"\");\n\
    \    for (index, ext) in extensions.iter().enumerate() {\n        let (ext, strength)\
    \ = ext.splitn(2, \".\").map(|x| x.parse().unwrap());\n        let (class_name,\
    \ _) = class_name.splitn(2, \".\").map(|x| x.parse().unwrap());\n        if strength\
    \ > max_strength {\n            max_strength = strength;\n            max_extension\
    \ = ext;\n        }\n    }\n    format!(\"{}.{}\", class_name, max_extension)",
  "    let mut extensions_sorted = extensions;\n    extensions_sorted.sort();\n  \
    \  let strength = extensions_sorted.iter().fold(0, |s, e| {\n        let cap =\
    \ e.chars().filter(|c| c >= 'A').count() + 1;\n        let sm = e.chars().filter(|c|\
    \ c < 'A').count() + 1;\n        (s.saturating_sub(s) + cap - sm) as i32\n   \
    \ });\n    class_name\n        + String::from(\".\") + extensions_sorted[strength].to_string()",
  "    let mut strength = -100;\n    extensions.iter().for_each(|extension| {\n  \
    \      let mut cap_extension: String;\n        let mut sm_extension: String;\n\
    \        let mut first_extension: Vec<String> = Vec::new();\n        for char\
    \ in extension {\n            if char == char.downcase() {\n                cap_extension\
    \ += char.to_string();\n            } else {\n                sm_extension +=\
    \ char.to_string();\n            }\n        }\n        if cap_extension.len()\
    \ > sm_extension.len() {\n            if cap_extension > sm_extension {\n    \
    \            first_extension.push(cap_extension);\n            } else {\n    \
    \            first_extension.push(sm_extension);\n            }\n        }\n \
    \   });\n    first_extension.iter().for_each(|extension| {\n        let mut extension_strength\
    \ = -1;\n        if extension == extension.to_ascii_lowercase() {\n          \
    \  extension_strength = 0;\n        } else if extension == extension.to_ascii_uppercase()\
    \ {\n            extension_strength = 1;\n        } else {\n            extension_strength\
    \ = 2;\n        }\n        if extension_strength > strength {\n            strength\
    \ = extension_strength;\n        }\n    });\n    String::from(format!(\"{}.{}\"\
    , class_name, extensions[strength]))", "    let mut strongest_extension = extensions[0];\n\
    \n    for extension in extensions {\n        if extension.chars().filter(|&c|\
    \ *c >= 'A' && *c <= 'Z').count() > 3 || \n            extension.chars().filter(|&c|\
    \ *c >= 'a' && *c <= 'z').count() > 3 {\n            continue;\n        }\n\n\
    \        let cap = extension.chars().filter(|&c| *c >= 'A' && *c <= 'Z').count();\n\
    \        let sm = extension.chars().filter(|&c| *c >= 'a' && *c <= 'z').count();\n\
    \        let strength = (cap - sm) as f64;\n        if strength > 0 {\n      \
    \      strongest_extension = extension;\n        }\n    }\n\n    return class_name\
    \ + strongest_extension;", "    if extensions.iter().any(|x| x.chars().count::<u32>()\
    \ <\n        (class_name.chars().count::<u32>() as u32 / extension_strength_limit)\
    \ as u32)\n    {\n        return String::from(class_name + \"_\" + extensions[0].to_string());\n\
    \    }\n\n    let mut best_extension: Option<String> = None;\n    let mut best_strength\
    \ = std::u32::MAX;\n    for (i, x) in extensions.iter().enumerate() {\n      \
    \  if x.chars().count::<u32>() < (\n            class_name.chars().count::<u32>()\
    \ /\n                (extension_strength_limit as u32 - extension_strength_limit\
    \ as u32))\n        {\n            continue;\n        }\n\n        let strength\
    \ = x.chars().count::<u32>() / (class_name.chars().count::<u32>() as u32);\n \
    \       if strength > best_strength {\n            best_strength = strength;\n\
    \            best_extension = Some(x.to_string());\n        }\n    }\n\n    if\
    \ let Some(extension) = best_extension {\n        return String::from(class_name\
    \ + extension);\n    }\n\n    String::from(class_name)", "    let mut extensions_counter:\
    \ Vec<(String, u32)> = extensions.iter().cloned().map(|s| {\n        (s, 1)\n\
    \    }).collect();\n    let mut extensions_counter: Vec<(String, u32)> = extensions.iter().cloned().map(|s|\
    \ {\n        (s, 1)\n    }).collect();\n    let mut strongest_extension: Vec<String>\
    \ = Vec::new();\n    let mut total_extensions_counter = extensions.iter().cloned().map(|s|\
    \ {\n        (s, 1)\n    }).sum();\n\n    for i in 0..extensions.len() {\n   \
    \     for j in 0..extensions.len() {\n            let mut strongest_counter: Vec<(String,\
    \ u32)> = extensions.iter().cloned().map(|s| {\n                (s, 1)\n     \
    \       }).collect();\n            let mut strongest_counter: Vec<(String, u32)>\
    \ = extensions.iter().cloned().map(|s| {\n                (s, 1)\n           \
    \ }).collect();\n            strongest_extension.clear();\n            for z in\
    \ 0..extensions.len() {\n                let mut max_extension_strength: u32 =\
    \ i32::MAX;\n                for (k, s) in strongest_counter {\n             \
    \       let mut total_strength: u32 = i32::MAX;\n                    for (l, _)\
    \ in extensions_counter {\n                        if z == l {\n             \
    \               total_strength += s;\n                        }\n            \
    \        }\n                    if total_strength > max_extension_strength {\n\
    \                        max_extension_strength = total_strength;\n          \
    \          }\n                }\n                if max_extension_strength ==\
    \ i32::MAX {\n                    break;\n                }\n                let\
    \ strength = i32::MAX - max_extension_strength;\n                strongest_extension.push(i.to_string()\
    \ + j.to_string() + z.to_string() + \"(\" + extensions[z].to_string() + \")\"\
    .to_string());\n                strongest_counter.push((extensions[z], strength));\n\
    \            }\n            if strongest_counter.len() > total_extensions_counter\
    \ {\n                extensions_counter = strongest_counter;\n               \
    \ total_extensions_counter = strongest_counter.len();\n            }\n       \
    \ }\n    }\n    extensions_counter.iter().cloned().for_each(|(extension, strength)|\
    \ {\n        let mut current_strongest_extensions: Vec<String> = vec![String::from(\"\
    \".to_string())];\n        for strongest in strongest_extension {\n          \
    \  let mut current_strongest_extension: String = String::from(\"\".to_", "   \
    \ let mut total_class_strength = Vec::new();\n\n    for e in extensions {\n  \
    \      total_class_strength.push(e.chars().filter(|c| c >= 'A').count() - e.chars().filter(|c|\
    \ c >= 'a').count());\n    }\n\n    // The class name will always have 2 capital\
    \ letters and the other\n    // extensions will have 1 capital letter\n    let\
    \ mut total_extensions_strength = total_class_strength.clone();\n    total_extensions_strength.sort();\n\
    \n    if total_extensions_strength.len() > 0 {\n        let mut total_strength\
    \ = total_extensions_strength[0];\n        for s in &total_extensions_strength\
    \ {\n            if s > total_strength {\n                total_strength = s;\n\
    \            }\n        }\n        let mut class_strength = total_strength;\n\
    \        let mut best_extension = &extensions[0];\n        for &s in &total_extensions_strength\
    \ {\n            if s == total_strength {\n                let mut extension =\
    \ &extensions[0];\n                while extension.len() > 0 {\n             \
    \       if extension.chars().filter(|c| c >= 'A').count() >= 2 && \n         \
    \               extension.chars().filter(|c| c >= 'a').count() >= 2 &&\n     \
    \                   extension.chars().filter(|c| c >= 'A').count() <= 3 &&\n \
    \                       extension.chars().filter(|c| c >= 'a').count() <= 3 {\n\
    \                        extension = &extension.split_off(1).collect::<Vec<String>>().unwrap()[0];\n\
    \                    } else {\n                        extension = &extension.split_off(1).collect::<Vec<String>>().unwrap()[1..];\n\
    \                    }\n                }\n                best_extension = extension.clone();\n\
    \                total_strength = s;\n            } else {\n                total_strength\
    \ = s;\n            }\n        }\n        format!(\"{}.{}\", class_name, best_extension)\n\
    \    } else {\n        format!(\"{}\", class_name)\n    }"]
stop_tokens:
- "\n}"
