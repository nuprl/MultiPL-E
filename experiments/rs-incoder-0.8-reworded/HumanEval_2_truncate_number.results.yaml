language: rs
name: HumanEval_2_truncate_number
results:
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        1.0\n    } else {\n        number as\
    \ f64\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpzynn49v0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // `trunc` will round and discard the decimal part, so we need\
    \ to keep\n    // it if we want to recover from roundoff. That's why we also test\
    \ for\n    // `f64::MIN` here - we can't recover from roundoff if number is negative.\n\
    \    if number < f64::MIN {\n        return 0.0;\n    }\n\n    // We divide by\
    \ 10^decimal_part so as not to lose any decimal\n    // digits we would have lost\
    \ while truncating the number.\n    let mut decimal_part = number / f64::pow(10.0,\
    \ number.bit_length() - 1);\n\n    // Now we compare the absolute value of the\
    \ number to the integer\n    // part and see if they match. If not, then we have\
    \ lost decimal\n    // part. We also divide by 10^decimal_part again to get rid\
    \ of the\n    // decimal part.\n    if f64::abs(number) - f64::ceil(number) !=\
    \ f64::abs(decimal_part) {\n        decimal_part /= f64::pow(10.0, number.bit_length()\
    \ - 1);\n    }\n\n    // Finally, we multiply by the necessary power of ten to\
    \ get back\n    // to the desired number.\n    decimal_part * f64::pow(10.0, number.bit_length()\
    \ - 1)\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `pow` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpd02lmrur.rs:17:42\n   |\n17 |    \
    \ let mut decimal_part = number / f64::pow(10.0, number.bit_length() - 1);\n \
    \  |                                          ^^^\n   |                      \
    \                    |\n   |                                          function\
    \ or associated item not found in `f64`\n   |                                \
    \          help: there is an associated function with a similar name: `powf`\n\
    \nerror[E0599]: no method named `bit_length` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpd02lmrur.rs:17:59\n   |\n17 |     let mut decimal_part\
    \ = number / f64::pow(10.0, number.bit_length() - 1);\n   |                  \
    \                                         ^^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no function or associated item named `pow` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpd02lmrur.rs:24:30\n   |\n24 |         decimal_part\
    \ /= f64::pow(10.0, number.bit_length() - 1);\n   |                          \
    \    ^^^\n   |                              |\n   |                          \
    \    function or associated item not found in `f64`\n   |                    \
    \          help: there is an associated function with a similar name: `powf`\n\
    \nerror[E0599]: no method named `bit_length` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpd02lmrur.rs:24:47\n   |\n24 |         decimal_part /= f64::pow(10.0,\
    \ number.bit_length() - 1);\n   |                                            \
    \   ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no function or associated\
    \ item named `pow` found for type `f64` in the current scope\n  --> /tmp/tmpd02lmrur.rs:29:25\n\
    \   |\n29 |     decimal_part * f64::pow(10.0, number.bit_length() - 1)\n   | \
    \                        ^^^\n   |                         |\n   |           \
    \              function or associated item not found in `f64`\n   |          \
    \               help: there is an associated function with a similar name: `powf`\n\
    \nerror[E0599]: no method named `bit_length`"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut decimal_part = 0.0;\n\n\
    \    match number.as_num() {\n        None => {\n            return 0.0;\n   \
    \     }\n        Some(number) => {\n            let mut power = 0.0;\n       \
    \     let mut digits = number.num_digits();\n\n            let mut last_digit\
    \ = 0.0;\n\n            while digits > 0 {\n                let d = number % 10.0;\n\
    \                number = number / 10.0;\n                power = power + d;\n\
    \                digits -= 1;\n            }\n            decimal_part = power.abs();\n\
    \        }\n    }\n\n    truncated = truncated.as_num().unwrap() * 10.0 + decimal_part.as_num().unwrap();\n\
    \    truncated.as_num().unwrap()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_num` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp8sx0h0s1.rs:11:18\n   |\n11 |     match number.as_num()\
    \ {\n   |                  ^^^^^^ help: there is an associated function with a\
    \ similar name: `asin`\n\nerror[E0689]: can't call method `abs` on ambiguous numeric\
    \ type `{float}`\n  --> /tmp/tmp8sx0h0s1.rs:27:34\n   |\n27 |             decimal_part\
    \ = power.abs();\n   |                                  ^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `f32`\n   |\n16 |             let mut\
    \ power: f32 = 0.0;\n   |                 ~~~~~~~~~~~~~~\n\nerror[E0599]: no method\
    \ named `as_num` found for type `{float}` in the current scope\n  --> /tmp/tmp8sx0h0s1.rs:31:27\n\
    \   |\n31 |     truncated = truncated.as_num().unwrap() * 10.0 + decimal_part.as_num().unwrap();\n\
    \   |                           ^^^^^^ method not found in `{float}`\n\nerror[E0599]:\
    \ no method named `as_num` found for type `{float}` in the current scope\n  -->\
    \ /tmp/tmp8sx0h0s1.rs:31:67\n   |\n31 |     truncated = truncated.as_num().unwrap()\
    \ * 10.0 + decimal_part.as_num().unwrap();\n   |                             \
    \                                      ^^^^^^ method not found in `{float}`\n\n\
    error[E0599]: no method named `as_num` found for type `{float}` in the current\
    \ scope\n  --> /tmp/tmp8sx0h0s1.rs:32:15\n   |\n32 |     truncated.as_num().unwrap()\n\
    \   |               ^^^^^^ method not found in `{float}`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number\n        .floor()\n        .try_into()\n        .expect(\"\
    invalid number\")\n        .trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `try_into` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpqpwf8j3m.rs:10:10\n    |\n10  |         .try_into()\n\
    \    |          ^^^^^^^^ method not found in `f64`\n    |\n    = help: items from\
    \ traits can only be used if the trait is in scope\n    = note: 'std::convert::TryInto'\
    \ is included in the prelude starting in Edition 2021\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n    |\n1   | use\
    \ std::convert::TryInto;\n    |\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpt1sco6mz.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number; // store number\n    integer.truncate();\n\
    \    if number < 1.0 {\n        let mut decimals = 0.0;\n        while integer\
    \ > 1.0 {\n            integer.truncate();\n            decimals += 1.0;\n   \
    \     }\n        integer\n    } else {\n        1.0\n    }\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp_i0_ciws.rs:9:13\n  |\n9 |     integer.truncate();\n  |\
    \             ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror[E0599]: no method named `truncate` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmp_i0_ciws.rs:13:21\n   |\n13 |             integer.truncate();\n\
    \   |                     ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Truncate to integer\n    if number - truncate_number(number\
    \ % f64::powf(10.0, 7.0)) != f64::powf(10.0, 7.0) {\n        return number;\n\
    \    }\n\n    // Truncate decimal part\n    number / f64::powf(10.0, 7.0)\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976599
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer_part = 0.0;\n    let mut decimal_part = 0.0;\n\
    \    \n    if number > 1.0 {\n        // Truncate decimal part to 0 if the number\
    \ is larger.\n        decimal_part = 0.0;\n    }\n    \n    if number > 0.0 {\n\
    \        // Divide integer part by the given number.\n        integer_part = f64::from(number);\n\
    \        // Divide decimal part by the given number.\n        decimal_part = f64::from(1.0)\
    \ / number;\n    }\n\n    // Return the integer part and decimal part.\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.7857142857142856`,\n right: `0.5`', /tmp/tmp431fq2i9.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.5 {\n        number\n    } else {\n        number\
    \ - f64::from(trunc(number))\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmp8i5s76qd.rs:11:28\n\
    \   |\n11 |         number - f64::from(trunc(number))\n   |                  \
    \          ^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer: i32 = 0;\n    let mut fraction: f64 = 0.0;\n\
    \    let mut remainder: f64 = number;\n\n    while remainder != 0.0 {\n      \
    \  if remainder < 1.0 {\n            fraction += remainder;\n            remainder\
    \ = 0;\n        } else {\n            integer += 1;\n            fraction -= remainder;\n\
    \            remainder = remainder - 1.0;\n        }\n    }\n\n    fraction *\
    \ 2.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp47iqbxgh.rs:15:25\n   |\n\
    10 |     let mut remainder: f64 = number;\n   |                        --- expected\
    \ due to this type\n...\n15 |             remainder = 0;\n   |               \
    \          ^\n   |                         |\n   |                         expected\
    \ `f64`, found integer\n   |                         help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // the number must be positive\n    if number < 0.0 {\n      \
    \  number\n    } else {\n        let mut number = number.abs();\n        let mut\
    \ remainder = 0.0;\n        let mut exponent = 0;\n        while number >= 1.0\
    \ {\n            if number % 1.0 != 0.0 {\n                exponent += 1;\n  \
    \              remainder += 1.0\n            }\n            number /= 1.0;\n \
    \       }\n        if number != 0.0 {\n            exponent += 1;\n          \
    \  remainder += number\n        }\n        number += remainder\n    }\n    number\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_og568bx.rs:10:9\n   |\n\
    9  | /     if number < 0.0 {\n10 | |         number\n   | |         ^^^^^^ expected\
    \ `()`, found `f64`\n11 | |     } else {\n12 | |         let mut number = number.abs();\n\
    ...  |\n26 | |         number += remainder\n27 | |     }\n   | |_____- expected\
    \ this to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n\
    10 |         return number;\n   |         ++++++       +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decs = number.trunc::<f64>().floor() as f64;\n    let\
    \ mut int = number.fract::<f64>() as f64;\n    if int > 0 { decs += 1.; }\n  \
    \  return decs\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n --> /tmp/tmpfp342ybr.rs:8:27\n  |\n8 |     let\
    \ mut decs = number.trunc::<f64>().floor() as f64;\n  |                      \
    \     ^^^^^------- help: remove these generics\n  |                          \
    \ |\n  |                           expected 0 generic arguments\n\nerror[E0107]:\
    \ this associated function takes 0 generic arguments but 1 generic argument was\
    \ supplied\n --> /tmp/tmpfp342ybr.rs:9:26\n  |\n9 |     let mut int = number.fract::<f64>()\
    \ as f64;\n  |                          ^^^^^------- help: remove these generics\n\
    \  |                          |\n  |                          expected 0 generic\
    \ arguments\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfp342ybr.rs:10:14\n\
    \   |\n10 |     if int > 0 { decs += 1.; }\n   |              ^\n   |        \
    \      |\n   |              expected `f64`, found integer\n   |              help:\
    \ use a float literal: `0.0`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0107, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // `number` is guaranteed to be non-zero\n    let mut decimal_part\
    \ = 0.0;\n    let mut quotient = number / 0.1;\n    while quotient != 0.0 {\n\
    \        quotient *= 10.0;\n        decimal_part += 1.0;\n    }\n    number\n\
    \        - (decimal_part as f64 / 10.0)\n        * (0.1 as f64)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976599
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut i = 0;\n    while number >= 10 {\n        number /= 10;\n\
    \        i += 1;\n    }\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8673xyhz.rs:9:21\n  |\n9 |\
    \     while number >= 10 {\n  |                     ^^\n  |                  \
    \   |\n  |                     expected `f64`, found integer\n  |            \
    \         help: use a float literal: `10.0`\n\nerror[E0277]: cannot divide-assign\
    \ `f64` by `{integer}`\n  --> /tmp/tmp8673xyhz.rs:10:16\n   |\n10 |         number\
    \ /= 10;\n   |                ^^ no implementation for `f64 /= {integer}`\n  \
    \ |\n   = help: the trait `DivAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `DivAssign<Rhs>`:\n    \
    \         <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n        \
    \     <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n            \
    \ <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n             <i16\
    \ as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    10 |         number /= 10.0;\n   |                     ++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // We can't use math::f64::trunc here as it rounds upwards.\n\
    \    let mut result = number.trunc();\n    result /= 10.0;\n    result\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.3`,\n right: `0.5`', /tmp/tmpuckzooo8.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.;\n\n    if number < 0.1 {\n        truncated\
    \ = 0.;\n    } else if number < 1.1 {\n        truncated = number;\n    } else\
    \ if number < 10.0 {\n        truncated = number;\n    } else {\n        let mut\
    \ pow10 = 1;\n        while number >= pow10 {\n            truncated = truncated\
    \ + pow10;\n            pow10 *= 10.0;\n        }\n\n        let remainder = number\
    \ - truncated;\n        truncated = truncated + remainder;\n    }\n\n    return\
    \ truncated;\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgsk712sn.rs:18:25\n   |\n\
    18 |         while number >= pow10 {\n   |                         ^^^^^ expected\
    \ `f64`, found integer\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  -->\
    \ /tmp/tmpgsk712sn.rs:19:35\n   |\n19 |             truncated = truncated + pow10;\n\
    \   |                                   ^ no implementation for `f64 + {integer}`\n\
    \   |\n   = help: the trait `Add<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Add<Rhs>`:\n            \
    \ <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ cannot multiply-assign `{integer}` by `{float}`\n  --> /tmp/tmpgsk712sn.rs:20:19\n\
    \   |\n20 |             pow10 *= 10.0;\n   |                   ^^ no implementation\
    \ for `{integer} *= {float}`\n   |\n   = help: the trait `MulAssign<{float}>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n           \
    \  <f32 as MulAssign>\n             <f64 as MulAssign<&f64>>\n             <f64\
    \ as MulAssign>\n             <i128 as MulAssign<&i128>>\n             <i128 as\
    \ MulAssign>\n             <i16 as MulAssign<&i16>>\n             <i16 as MulAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpee5mwi99.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number;\n    }\n    let mut\
    \ truncated = 0.0;\n    while number >= 1.0 {\n        truncated = truncated +\
    \ 1.0\n    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976599
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.trunc().div_f64();\n    let (quotient,\
    \ remainder) = number.div_f64();\n\n    if remainder > 1.0 {\n        number\n\
    \    } else {\n        quotient + decimal\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `div_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpih0y9rdg.rs:8:45\n  |\n8 |     let (integer, decimal) =\
    \ number.trunc().div_f64();\n  |                                             ^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `div_f64` found for\
    \ type `f64` in the current scope\n --> /tmp/tmpih0y9rdg.rs:9:40\n  |\n9 |   \
    \  let (quotient, remainder) = number.div_f64();\n  |                        \
    \                ^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // We round the number to the nearest integer, so the least significant\
    \ digit\n    // will be the integer part and the last digit will be the decimal\
    \ part.\n    number.floor() as f64 / std::f64::powf(10.0, number.fract().unwrap())\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in module `std::f64`\n  --> /tmp/tmp7jso6_e4.rs:10:39\n\
    \   |\n10 |     number.floor() as f64 / std::f64::powf(10.0, number.fract().unwrap())\n\
    \   |                                       ^^^^ not found in `std::f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp7jso6_e4.rs:10:65\n\
    \   |\n10 |     number.floor() as f64 / std::f64::powf(10.0, number.fract().unwrap())\n\
    \   |                                                                 ^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number\n    } else {\n        let mut\
    \ x = number.floor() as f64;\n        let mut dec = 0;\n        while x < 0.0\
    \ {\n            x -= 1.0;\n            dec += 1;\n        }\n        x /= 10.0;\n\
    \        dec\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5fv7skx2.rs:18:9\n   |\n\
    7  | fn truncate_number(number: f64) -> f64 {\n   |                          \
    \          --- expected `f64` because of return type\n...\n18 |         dec\n\
    \   |         ^^^ expected `f64`, found integer\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number % 1).ceil() as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmposl589g6.rs:8:13\n\
    \  |\n8 |     (number % 1).ceil() as f64\n  |             ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     (number % 1.0).ceil() as f64\n  |                ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut x = number;\n    let mut truncated = false;\n\n    if\
    \ number > 0.0 {\n        let mut decimal_part = 0.0;\n        let mut dec = 0.0;\n\
    \        let mut exponent = 0.0;\n\n        if number < 1.0 {\n            decimal_part\
    \ = number;\n            dec = 0.0;\n            exponent = 0.0;\n        }\n\
    \        else {\n            while x > 1.0 {\n                dec += 1.0;\n  \
    \              x /= 10.0;\n                exponent += 1.0;\n            }\n\n\
    \            if number < 1.0 {\n                decimal_part = number;\n     \
    \           dec = 0.0;\n                exponent = 0.0;\n            }\n     \
    \       else {\n                decimal_part = x;\n                dec = dec *\
    \ 10.0;\n                exponent = exponent;\n            }\n        }\n\n  \
    \      x = decimal_part * 10.0;\n\n        if exponent > 0.0 {\n            x\
    \ *= f64::pow(10.0, -exponent);\n        }\n\n        if dec > 0.0 {\n       \
    \     x += dec;\n        }\n\n        x = f64::round(x);\n\n        if x < 0.0\
    \ {\n            x += 1.0;\n            truncated = true;\n        }\n    }\n\n\
    \    if x < 0.0 {\n        x -= 1.0;\n        truncated = true;\n    }\n\n   \
    \ if truncated {\n        x = f64::trunc(x);\n    }\n\n    x\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `pow` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmpkh6tj7cl.rs:43:23\n   |\n43 |    \
    \         x *= f64::pow(10.0, -exponent);\n   |                       ^^^\n  \
    \ |                       |\n   |                       function or associated\
    \ item not found in `f64`\n   |                       help: there is an associated\
    \ function with a similar name: `powf`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number\n        .truncate()\n        .round() as f64\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpyg0p32vk.rs:9:10\n  |\n9 |         .truncate()\n  |    \
    \      ^^^^^^^^ help: there is an associated function with a similar name: `trunc`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.truncate()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmprzjm0slh.rs:8:12\n  |\n8 |     number.truncate()\n  |  \
    \          ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let rem_part = f64::remainder(number, 1.0) as f64;\n    let abs_part\
    \ = f64::abs(number);\n\n    if abs_part < 1.0e-18 {\n        return 0.0\n   \
    \ }\n\n    truncate_parts(abs_part, rem_part)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `truncate_parts` in this scope\n  -->\
    \ /tmp/tmptn98p4cn.rs:15:5\n   |\n15 |     truncate_parts(abs_part, rem_part)\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no function\
    \ or associated item named `remainder` found for type `f64` in the current scope\n\
    \ --> /tmp/tmptn98p4cn.rs:8:25\n  |\n8 |     let rem_part = f64::remainder(number,\
    \ 1.0) as f64;\n  |                         ^^^^^^^^^ function or associated item\
    \ not found in `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number / 10).floor() as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n --> /tmp/tmps6ipvk9j.rs:8:13\n\
    \  |\n8 |     (number / 10).floor() as f64\n  |             ^ no implementation\
    \ for `f64 / {integer}`\n  |\n  = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Div<Rhs>`:\n\
    \            <&'a f32 as Div<f32>>\n            <&'a f64 as Div<f64>>\n      \
    \      <&'a i128 as Div<i128>>\n            <&'a i16 as Div<i16>>\n          \
    \  <&'a i32 as Div<i32>>\n            <&'a i64 as Div<i64>>\n            <&'a\
    \ i8 as Div<i8>>\n            <&'a isize as Div<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     (number / 10.0).floor() as f64\n  |                 ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer_part, decimals) = (number as i64).truncate().unwrap_or(number.floor()\
    \ as f64);\n    (decimals as f64).floor()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `i64` in the current\
    \ scope\n --> /tmp/tmpf5wsxmyb.rs:8:52\n  |\n8 |     let (integer_part, decimals)\
    \ = (number as i64).truncate().unwrap_or(number.floor() as f64);\n  |        \
    \                                            ^^^^^^^^ method not found in `i64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        number\n    } else {\n        number\
    \ - f64::from(1.0) / f64::from(10.0)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.4`,\n right: `0.5`', /tmp/tmpa53o6a5c.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Take the integer part and multiply it by 10^n\n    // Where\
    \ n is the number of decimals (max 10)\n    let n = std::cmp::max(std::cmp::min(std::f64::log10(number.abs()),\
    \ 10), 2);\n    number.trunc().scaleb(n as i32, std::i32::MAX).unwrap()\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `log10` in module `std::f64`\n  -->\
    \ /tmp/tmp3f_7ce0a.rs:10:51\n   |\n10 |     let n = std::cmp::max(std::cmp::min(std::f64::log10(number.abs()),\
    \ 10), 2);\n   |                                                   ^^^^^ not found\
    \ in `std::f64`\n\nerror[E0599]: no method named `scaleb` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp3f_7ce0a.rs:11:20\n   |\n11 |     number.trunc().scaleb(n\
    \ as i32, std::i32::MAX).unwrap()\n   |                    ^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO(#1524): This requires more care with corner cases\n  \
    \  // TODO(#1523): This might fail if we have an exponent of 0 or 1\n    number\
    \ - std::f32::consts::FRAC_1\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `FRAC_1` in module `std::f32::consts`\n\
    \  --> /tmp/tmpw9foo8mq.rs:10:32\n   |\n10 |     number - std::f32::consts::FRAC_1\n\
    \   |                                ^^^^^^ not found in `std::f32::consts`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number\n    } else {\n        let (integer,\
    \ decimal) = number.floor() as f64.cmp(&0.0);\n        decimal + number\n    }\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpgd6y__e2.rs:11:34\n\
    \   |\n11 |         let (integer, decimal) = number.floor() as f64.cmp(&0.0);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: try\
    \ surrounding the expression in parentheses\n   |\n11 |         let (integer,\
    \ decimal) = (number.floor() as f64).cmp(&0.0);\n   |                        \
    \          +                     +\n\nerror[E0599]: `f64` is not an iterator\n\
    \  --> /tmp/tmpgd6y__e2.rs:11:56\n   |\n11 |         let (integer, decimal) =\
    \ number.floor() as f64.cmp(&0.0);\n   |                                     \
    \                   ^^^ `f64` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `f64: Iterator`\n           which\
    \ is required by `&mut f64: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut ipart = 0.;\n    let mut dec = 0.;\n    let mut fpart\
    \ = 0.;\n    for i in number.trunc::<f64>() {\n        ipart += i;\n        fpart\
    \ = ipart * 10.;\n        if fpart < 1.00001 {\n            dec += 1;\n      \
    \  }\n    }\n    fpart - dec * 10.\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n  --> /tmp/tmppk9nfjgr.rs:11:21\n   |\n11 | \
    \    for i in number.trunc::<f64>() {\n   |                     ^^^^^------- help:\
    \ remove these generics\n   |                     |\n   |                    \
    \ expected 0 generic arguments\n\nerror[E0277]: `f64` is not an iterator\n  -->\
    \ /tmp/tmppk9nfjgr.rs:11:14\n   |\n11 |     for i in number.trunc::<f64>() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^ `f64` is not an iterator\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `f64`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `f64`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmppk9nfjgr.rs:15:17\n\
    \   |\n15 |             dec += 1;\n   |                 ^^ no implementation for\
    \ `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is\
    \ not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0107, E0277.\nFor more information about\
    \ an error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = number.trunc();\n    if number % 1 == 0 {\n   \
    \     number\n    } else {\n        fraction\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp8jtka2z2.rs:9:15\n\
    \  |\n9 |     if number % 1 == 0 {\n  |               ^ no implementation for\
    \ `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n9\
    \ |     if number % 1.0 == 0 {\n  |                  ++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number % 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer_part, decimal_part) = number.trunc();\n    if integer_part\
    \ == number {\n        decimal_part\n    } else {\n        let int_part = number\
    \ - integer_part;\n        int_part.trunc().ln() / decimal_part\n    }\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpgl46zo50.rs:8:9\n  |\n8 |\
    \     let (integer_part, decimal_part) = number.trunc();\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `f64`\n  |         |\n  |        \
    \ expected `f64`, found tuple\n  |\n  = note: expected type `f64`\n          \
    \  found tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 1.0 {\n        number - 1.0\n    } else {\n      \
    \  number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpqok30zng.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // If the number is negative, get the largest integer smaller\
    \ than number.\n    if number < 0 {\n        number\n    } else {\n        //\
    \ Get the integer part.\n        let integer = number.floor();\n        // If\
    \ the decimal part is larger than 1, get the decimal part.\n        number - integer\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpuufcbjko.rs:9:17\n  |\n9 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (int_part, decimal) = (number % 1, number / 1);\n    (int_part\
    \ + decimal) as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmpv0_rfoj9.rs:8:39\n\
    \  |\n8 |     let (int_part, decimal) = (number % 1, number / 1);\n  |       \
    \                                ^ no implementation for `f64 % {integer}`\n \
    \ |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     let (int_part, decimal) = (number\
    \ % 1.0, number / 1);\n  |                                          ++\n\nerror[E0277]:\
    \ cannot divide `f64` by `{integer}`\n --> /tmp/tmpv0_rfoj9.rs:8:51\n  |\n8 |\
    \     let (int_part, decimal) = (number % 1, number / 1);\n  |               \
    \                                    ^ no implementation for `f64 / {integer}`\n\
    \  |\n  = help: the trait `Div<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Div<Rhs>`:\n            <&'a f32\
    \ as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n\
    \            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n      \
    \      <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a\
    \ isize as Div<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n8 |     let (int_part, decimal) = (number\
    \ % 1, number / 1.0);\n  |                                                   \
    \   ++\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut dec = number.ceil() as f64;\n    dec /= 10.0;\n    dec\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.4`,\n right: `0.5`', /tmp/tmpkmbsidrz.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (_, n) = bignum_from_f64::<BigFloating>(number);\n    n\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bignum_from_f64` in this scope\n -->\
    \ /tmp/tmpxuqkl0r5.rs:8:18\n  |\n8 |     let (_, n) = bignum_from_f64::<BigFloating>(number);\n\
    \  |                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]:\
    \ cannot find type `BigFloating` in this scope\n --> /tmp/tmpxuqkl0r5.rs:8:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |                   - help:\
    \ you might be missing a type parameter: `<BigFloating>`\n8 |     let (_, n) =\
    \ bignum_from_f64::<BigFloating>(number);\n  |                               \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp8zwk04gp.rs:8:20\n  |\n8 |     number.trunc().unwrap()\n\
    \  |                    ^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut rem = number;\n    let mut i = 0;\n    while rem > 0.0\
    \ {\n        rem -= 1.0;\n        i += 1;\n    }\n    rem -= i;\n    rem\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmp2s3phxgd.rs:14:9\n\
    \   |\n14 |     rem -= i;\n   |         ^^ no implementation for `f64 -= {integer}`\n\
    \   |\n   = help: the trait `SubAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result -= 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.0`,\n right: `0.5`', /tmp/tmpcb9_m4hy.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number <= 0.0 {\n        0.0\n    } else {\n        number\
    \ - truncate_number_down(number)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `truncate_number_down` in this scope\n\
    \  --> /tmp/tmp3apjmdj2.rs:11:18\n   |\n11 |         number - truncate_number_down(number)\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number\n        .floor()\n        .floor()\n  \
    \      .ceil()\n        .trunc();\n\n    // If number is smaller than 1 then we\
    \ must return 1 as decimal\n    if int_part < 1 {\n        return 1;\n    }\n\n\
    \    number\n        .sub(f64::from_integer(int_part))\n        .floor()\n   \
    \     .floor()\n        .ceil()\n        .trunc()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixcoc323.rs:15:19\n   |\n\
    15 |     if int_part < 1 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `f64`, found integer\n   |                  \
    \ help: use a float literal: `1.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixcoc323.rs:16:16\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n16 |       \
    \  return 1;\n   |                ^\n   |                |\n   |             \
    \   expected `f64`, found integer\n   |                help: use a float literal:\
    \ `1.0`\n\nerror[E0599]: no method named `sub` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpixcoc323.rs:20:10\n    |\n20  |         .sub(f64::from_integer(int_part))\n\
    \    |          ^^^ method not found in `f64`\n    |\n    = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Sub;\n\
    \    |\n\nerror[E0599]: no function or associated item named `from_integer` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpixcoc323.rs:20:19\n   |\n\
    20 |         .sub(f64::from_integer(int_part))\n   |                   ^^^^^^^^^^^^\
    \ function or associated item not found in `f64`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = number.trunc();\n    fraction / 10\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n --> /tmp/tmp2d5nxgbi.rs:9:14\n\
    \  |\n9 |     fraction / 10\n  |              ^ no implementation for `f64 / {integer}`\n\
    \  |\n  = help: the trait `Div<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Div<Rhs>`:\n            <&'a f32\
    \ as Div<f32>>\n            <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n\
    \            <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n      \
    \      <&'a i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a\
    \ isize as Div<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     fraction / 10.0\n  |         \
    \         ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        // Truncate negative number\n       \
    \ // We need to use some tricky integer division here:\n        // We take integer\
    \ part as the integer part of the number\n        // Then we take decimal part\
    \ as the floor of the number divided by 10\n        // Then we add 1 to the decimal\
    \ part (this is just a trick,\n        // because we are interested in the decimal\
    \ part only,\n        // not its exact value)\n        let decimal_part = number.floor();\n\
    \        let int_part = number / 10.0; // Take the integer part\n        int_part\
    \ + (decimal_part - int_part).max(1)\n    } else {\n        number\n    }\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_b30s9ru.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_b30s9ru.rs:18:50\n\
    \   |\n18 |         int_part + (decimal_part - int_part).max(1)\n   |        \
    \                                          ^\n   |                           \
    \                       |\n   |                                              \
    \    expected `f64`, found integer\n   |                                     \
    \             help: use a float literal: `1.0`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let n = number.trunc();\n    let d = number.fract();\n    n as\
    \ f64 + d as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpk65_jnga.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = number.floor() as f64;\n    if decimal_part\
    \ != number {\n        decimal_part -= 1;\n    }\n    decimal_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmpz909s3v9.rs:10:22\n\
    \   |\n10 |         decimal_part -= 1;\n   |                      ^^ no implementation\
    \ for `f64 -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n             <f32\
    \ as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n\
    \             <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n \
    \            <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n10 |         decimal_part -= 1.0;\n   |                \
    \          ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        return number - number % 1.0\n   \
    \ }\n    return number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpkn8o8s3l.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = 1.0 - decimal;\n    }\n\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmp3my_fbj7.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - number.trunc()).abs()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc() + 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp55tsgqul.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer_part, decimals) = (number - truncate_fraction(number),\
    \ 1);\n    integer_part + decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `truncate_fraction` in this scope\n\
    \ --> /tmp/tmpjsgvarby.rs:8:46\n  |\n8 |     let (integer_part, decimals) = (number\
    \ - truncate_fraction(number), 1);\n  |                                      \
    \        ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot add\
    \ `{integer}` to `f64`\n --> /tmp/tmpjsgvarby.rs:9:18\n  |\n9 |     integer_part\
    \ + decimals\n  |                  ^ no implementation for `f64 + {integer}`\n\
    \  |\n  = help: the trait `Add<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Add<Rhs>`:\n            <&'a f32\
    \ as Add<f32>>\n            <&'a f64 as Add<f64>>\n            <&'a i128 as Add<i128>>\n\
    \            <&'a i16 as Add<i16>>\n            <&'a i32 as Add<i32>>\n      \
    \      <&'a i64 as Add<i64>>\n            <&'a i8 as Add<i8>>\n            <&'a\
    \ isize as Add<isize>>\n          and 48 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpt1sco6mz.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64() / 100.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpehi35xnz.rs:8:12\n  |\n8 |     number.trunc_f64() / 100.0\n\
    \  |            ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = 0i64;\n    let mut decimals = 0.0;\n    let\
    \ mut factor: i64 = 1;\n    let mut remainder: i64 = 0;\n    loop {\n        let\
    \ next = integer + factor;\n        let remainder = number - next;\n        let\
    \ mut factor = next * factor;\n        if factor > i64::max_value() as i64 {\n\
    \            break;\n        }\n        integer += 1;\n        decimals += remainder;\n\
    \    }\n    decimals / factor\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `i64` from `f64`\n  --> /tmp/tmpwtjp1lw2.rs:14:32\n\
    \   |\n14 |         let remainder = number - next;\n   |                     \
    \           ^ no implementation for `f64 - i64`\n   |\n   = help: the trait `Sub<i64>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: cannot divide `{float}` by `i64`\n  -->\
    \ /tmp/tmpwtjp1lw2.rs:22:14\n   |\n22 |     decimals / factor\n   |          \
    \    ^ no implementation for `{float} / i64`\n   |\n   = help: the trait `Div<i64>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpee5mwi99.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = number.f64() / 0.0;\n    let integer_part = number.f64().trunc();\n\
    \    let fraction = fraction.ceil();\n    let integer_part = integer_part.ceil();\n\
    \    let remainder = number - integer_part - fraction;\n    let decimal = remainder\
    \ / (10_f64.powf(f64::from(10)).sqrt());\n    if decimal >= 10_f64::from(10) {\n\
    \        decimal - 10_f64::from(10)\n    } else {\n        decimal\n    }\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `::`\n  --> /tmp/tmply8ihwkp.rs:14:25\n   |\n\
    14 |     if decimal >= 10_f64::from(10) {\n   |     --                  ^^ expected\
    \ `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\
    \   |\nhelp: try placing this code inside a block\n   |\n14 |     if decimal >=\
    \ 10_f64{ ::from(10) } {\n   |                         +            +\n\nerror[E0599]:\
    \ no method named `f64` found for type `f64` in the current scope\n --> /tmp/tmply8ihwkp.rs:8:27\n\
    \  |\n8 |     let fraction = number.f64() / 0.0;\n  |                        \
    \   ^^^ method not found in `f64`\n\nerror[E0599]: no method named `f64` found\
    \ for type `f64` in the current scope\n --> /tmp/tmply8ihwkp.rs:9:31\n  |\n9 |\
    \     let integer_part = number.f64().trunc();\n  |                          \
    \     ^^^ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Decompose the number into the integer part and the decimal\n\
    \    // part.\n    let mut integer_part = 0.;\n    let mut decimal_part = 0.;\n\
    \    let mut next_power_of_ten = 1.;\n    while number.is_integer() {\n      \
    \  integer_part += number.remainder();\n        number = number.next_power_of_ten();\n\
    \        decimal_part += next_power_of_ten;\n        next_power_of_ten /= 10.;\n\
    \    }\n\n    // Round the decimal part to the nearest integer.\n    integer_part\
    \ += decimal_part * next_power_of_ten.round();\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpe26_x7i5.rs:13:18\n   |\n13 |     while number.is_integer()\
    \ {\n   |                  ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpe26_x7i5.rs:14:32\n   |\n14 |         integer_part += number.remainder();\n\
    \   |                                ^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `next_power_of_ten` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpe26_x7i5.rs:15:25\n   |\n15 |         number = number.next_power_of_ten();\n\
    \   |                         ^^^^^^^^^^^^^^^^^ method not found in `f64`\n\n\
    error[E0689]: can't call method `round` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpe26_x7i5.rs:21:54\n   |\n21 |     integer_part += decimal_part\
    \ * next_power_of_ten.round();\n   |                                         \
    \             ^^^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `f32`\n   |\n12 |     let mut next_power_of_ten: f32 = 1.;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0689.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut i = 0;\n    let mut remaining = number;\n    while remaining\
    \ < 1 {\n        remaining = remaining - std::f64::consts::EPSILON;\n        i\
    \ += 1;\n    }\n    if remaining < std::f64::consts::EPSILON {\n        std::f64::consts::NAN\n\
    \    } else {\n        remaining = remaining.fract();\n    }\n    remaining\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `EPSILON` in module `std::f64::consts`\n\
    \  --> /tmp/tmpdf_yati2.rs:11:51\n   |\n11 |         remaining = remaining - std::f64::consts::EPSILON;\n\
    \   |                                                   ^^^^^^^ not found in `std::f64::consts`\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::f32::EPSILON;\n\
    \   |\n1  | use std::f64::EPSILON;\n   |\nhelp: if you import `EPSILON`, refer\
    \ to it directly\n   |\n11 -         remaining = remaining - std::f64::consts::EPSILON;\n\
    11 +         remaining = remaining - EPSILON;\n   | \n\nerror[E0425]: cannot find\
    \ value `EPSILON` in module `std::f64::consts`\n  --> /tmp/tmpdf_yati2.rs:14:38\n\
    \   |\n14 |     if remaining < std::f64::consts::EPSILON {\n   |             \
    \                         ^^^^^^^ not found in `std::f64::consts`\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::f32::EPSILON;\n \
    \  |\n1  | use std::f64::EPSILON;\n   |\nhelp: if you import `EPSILON`, refer\
    \ to it directly\n   |\n14 -     if remaining < std::f64::consts::EPSILON {\n\
    14 +     if remaining < EPSILON {\n   | \n\nerror[E0425]: cannot find value `NAN`\
    \ in module `std::f64::consts`\n  --> /tmp/tmpdf_yati2.rs:15:27\n   |\n15 |  \
    \       std::f64::consts::NAN\n   |                           ^^^ not found in\
    \ `std::f64::consts`\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::f32::NAN;\n   |\n1  | use std::f64::NAN;\n   |\nhelp: if you import\
    \ `NAN`, refer to it directly\n   |\n15 -         std::f64::consts::NAN\n15 +\
    \         NAN\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdf_yati2.rs:10:23\n\
    \   |\n10 |     while remaining < 1 {\n   |                       ^\n   |    \
    \                   |\n   |                       expected `f64`, found integer\n\
    \   |                       help: use a float literal: `1.0`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncate_part = number.trunc();\n    let sign = truncate_part.is_zero()\
    \ ? std::sign::NEG : std::sign::POS;\n\n    truncate_part.abs() - (sign * truncate_part.abs()\
    \ % (sign * 100))\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `std`\n\
    \ --> /tmp/tmpo1qcytrf.rs:9:42\n  |\n9 |     let sign = truncate_part.is_zero()\
    \ ? std::sign::NEG : std::sign::POS;\n  |                                    \
    \      ^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number <= 0.0 {\n        return 0.0\n    }\n\n    // Find an\
    \ integer part\n    let mut ipart = 0.0;\n    while number > ipart {\n       \
    \ ipart += 1.0\n    }\n    ipart -= 1.0\n\n    // Find decimals\n    let mut decimals\
    \ = 0.0;\n    while number >= ipart {\n        decimals += 1.0\n        number\
    \ -= ipart\n    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmp6lvnsnf5.rs:17:17\n\
    \   |\n17 |     ipart -= 1.0\n   |                 ^ help: add `;` here\n...\n\
    20 |     let mut decimals = 0.0;\n   |     --- unexpected token\n\nerror: expected\
    \ `;`, found `number`\n  --> /tmp/tmp6lvnsnf5.rs:22:24\n   |\n22 |         decimals\
    \ += 1.0\n   |                        ^ help: add `;` here\n23 |         number\
    \ -= ipart\n   |         ------ unexpected token\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut fraction = number.trunc();\n\
    \    while fraction < 1.0 {\n        fraction = fraction * 10.0;\n        decimals\
    \ += 1.0;\n    }\n    fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpqk8rzg5e.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remaining = number;\n\
    \    while remaining > 1.0 {\n        remaining /= 10.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part += remaining;\n    decimal_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.35`,\n right: `0.5`', /tmp/tmpq8swb8ql.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    number.truncate();\n    number\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp2dl_hesl.rs:9:12\n  |\n9 |     number.truncate();\n  | \
    \           ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    let mut decimal\
    \ = number - integer;\n    decimal.truncate();\n    decimal + (integer % 1)\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpo_4aoabi.rs:10:13\n   |\n10 |     decimal.truncate();\n\
    \   |             ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpo_4aoabi.rs:11:24\n\
    \   |\n11 |     decimal + (integer % 1)\n   |                        ^ no implementation\
    \ for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n11 |     decimal + (integer % 1.0)\n   |                       \
    \    ++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number;\n    let power = f64::exp(1.0 / f64::log(number));\n\
    \    if power < 1.0 {\n        result = result / (1.0 / power)\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpmdrunrwu.rs:9:32\n    |\n9   |     let power = f64::exp(1.0 /\
    \ f64::log(number));\n    |                                ^^^^^^^^ ------ supplied\
    \ 1 argument\n    |                                |\n    |                  \
    \              expected 2 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let precision = number.trunc_f64();\n    let remainder = number.remainder_f64();\n\
    \    precision.trunc_f64() / remainder\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpx14kzkt7.rs:8:28\n  |\n8 |     let precision = number.trunc_f64();\n\
    \  |                            ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `trunc`\n\nerror[E0599]: no method named `remainder_f64`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpx14kzkt7.rs:9:28\n \
    \ |\n9 |     let remainder = number.remainder_f64();\n  |                    \
    \        ^^^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mantissa = number as f32;\n    mantissa.trunc_f64()\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f32` in the current\
    \ scope\n --> /tmp/tmpcmupeqkl.rs:9:14\n  |\n9 |     mantissa.trunc_f64()\n  |\
    \              ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() / number.abs()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.8571428571428571`,\n right: `0.5`', /tmp/tmp_twwsff9.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exponent = number.copysign(0.);\n    let mut remainder:\
    \ f64 = number.abs();\n    let mut decimal_places = 0.;\n    while remainder.is_positive()\
    \ {\n        if remainder.is_integer() {\n            exponent += 1.;\n      \
    \      remainder -= 1.;\n            decimal_places += 1.;\n        } else if\
    \ remainder.is_fraction() {\n            exponent += 1;\n            remainder\
    \ -= 1.;\n            decimal_places += 0.;\n        } else {\n            break;\n\
    \        }\n    }\n    return f64::from(f64::from(number.powf(-exponent))) / f64::from(f64::from(number.powf(-decimal_places)));\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `core::f64::<impl f64>::is_positive`:\
    \ renamed to is_sign_positive\n  --> /tmp/tmplkzbrqh1.rs:11:21\n   |\n11 |   \
    \  while remainder.is_positive() {\n   |                     ^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(deprecated)]` on by default\n\nerror[E0599]: no method named\
    \ `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmplkzbrqh1.rs:12:22\n\
    \   |\n12 |         if remainder.is_integer() {\n   |                      ^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `is_fraction` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmplkzbrqh1.rs:16:29\n   |\n\
    16 |         } else if remainder.is_fraction() {\n   |                       \
    \      ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0277]: cannot add-assign\
    \ `{integer}` to `f64`\n  --> /tmp/tmplkzbrqh1.rs:17:22\n   |\n17 |          \
    \   exponent += 1;\n   |                      ^^ no implementation for `f64 +=\
    \ {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n17 |             exponent += 1.0;\n   |                        \
    \  ++\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        let mut integer = -number;\n      \
    \  let mut decimals = 0.0;\n        while integer > 0.0 {\n            integer\
    \ -= 1.0;\n            decimals += 1.0;\n        }\n        return decimal / decimals;\n\
    \    }\n    let mut integer = number;\n    let mut decimals = 0.0;\n    while\
    \ integer > 0.0 {\n        integer -= 1.0;\n        decimals += 1.0;\n    }\n\
    \    return number * decimals + integer / decimals;\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmp0xxxokin.rs:15:16\n\
    \   |\n15 |         return decimal / decimals;\n   |                ^^^^^^^ help:\
    \ a local variable with a similar name exists: `decimals`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // FIXME: This implementation will give incorrect results for\
    \ numbers that\n    // have a fractional part that is a multiple of 10, for instance:\
    \ 10.5.\n    number.trunc().unwrap_or(number.floor())\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpzoesgbkc.rs:10:20\n   |\n10 |     number.trunc().unwrap_or(number.floor())\n\
    \   |                    ^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number.trunc();\n    let (integer, remainder)\
    \ = fraction.divmod(f64::from_bits(62));\n    return fraction.clone() as f64 /\
    \ remainder as f64;\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `divmod` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpwmdizdhk.rs:9:41\n  |\n9 |     let (integer, remainder)\
    \ = fraction.divmod(f64::from_bits(62));\n  |                                \
    \         ^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number = number.abs();\n    if number > 0 {\n        number\
    \ - (number).floor() as f64\n    } else {\n        number + (number).ceil() as\
    \ f64\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8h29f3eu.rs:9:17\n  |\n9 |\
    \     if number > 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let bits = number.abs();\n    let (acc, den) = (number % 1, number\
    \ / 1);\n    let exp = bits.trailing_zeros();\n    acc * 10.0 ** (exp - bits.trailing_zeros())\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp4dr1me2k.rs:9:30\n\
    \  |\n9 |     let (acc, den) = (number % 1, number / 1);\n  |                \
    \              ^ no implementation for `f64 % {integer}`\n  |\n  = help: the trait\
    \ `Rem<{integer}>` is not implemented for `f64`\n  = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n            <&'a f32 as Rem<f32>>\n     \
    \       <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n         \
    \   <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n            <&'a\
    \ i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a isize as\
    \ Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     let (acc, den) = (number % 1.0,\
    \ number / 1);\n  |                                 ++\n\nerror[E0277]: cannot\
    \ divide `f64` by `{integer}`\n --> /tmp/tmp4dr1me2k.rs:9:42\n  |\n9 |     let\
    \ (acc, den) = (number % 1, number / 1);\n  |                                \
    \          ^ no implementation for `f64 / {integer}`\n  |\n  = help: the trait\
    \ `Div<{integer}>` is not implemented for `f64`\n  = help: the following other\
    \ types implement trait `Div<Rhs>`:\n            <&'a f32 as Div<f32>>\n     \
    \       <&'a f64 as Div<f64>>\n            <&'a i128 as Div<i128>>\n         \
    \   <&'a i16 as Div<i16>>\n            <&'a i32 as Div<i32>>\n            <&'a\
    \ i64 as Div<i64>>\n            <&'a i8 as Div<i8>>\n            <&'a isize as\
    \ Div<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     let (acc, den) = (number % 1,\
    \ number / 1.0);\n  |                                             ++\n\nerror[E0599]:\
    \ no method named `trailing_zeros` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp4dr1me2k.rs:10:20\n   |\n10 |     let exp = bits.trailing_zeros();\n\
    \   |                    ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `trailing_zeros` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp4dr1me2k.rs:11:31\n   |\n11 |     acc * 10.0 ** (exp - bits.trailing_zer"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut dec = 0.0;\n    let mut remainder = number;\n    loop\
    \ {\n        if remainder >= 1.0f64 {\n            remainder -= 1.0f64;\n    \
    \        break;\n        }\n        dec += remainder;\n        remainder /= 10.0f64;\n\
    \    }\n    dec\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmp6dippc_x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1 {\n        // For numbers less than 1, we add one\
    \ to ensure the decimal part is 0\n        number.ceil() as f64\n    } else {\n\
    \        number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl813_2t5.rs:8:17\n  |\n8 |\
    \     if number < 1 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `1.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.floor() as f64;\n    let decimal = number.fract();\n\
    \    number * decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.75`,\n right: `0.5`', /tmp/tmpnd7k_0od.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number.abs();\n    let mut integer_part = 0;\n\
    \    if fraction.is_integer() {\n        integer_part = fraction.floor() as f64;\n\
    \        fraction -= integer_part as f64;\n    } else {\n        integer_part\
    \ = fraction;\n        fraction = 0;\n    }\n    (integer_part + fraction).div(10).round()\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmphmi6rmhv.rs:10:17\n   |\n10 |     if fraction.is_integer()\
    \ {\n   |                 ^^^^^^^^^^ method not found in `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphmi6rmhv.rs:11:24\n   |\n9  |     let mut integer_part\
    \ = 0;\n   |                            - expected due to this value\n10 |   \
    \  if fraction.is_integer() {\n11 |         integer_part = fraction.floor() as\
    \ f64;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphmi6rmhv.rs:14:24\n\
    \   |\n9  |     let mut integer_part = 0;\n   |                            - expected\
    \ due to this value\n...\n14 |         integer_part = fraction;\n   |        \
    \                ^^^^^^^^ expected integer, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphmi6rmhv.rs:15:20\n   |\n8  |     let mut fraction = number.abs();\n\
    \   |                        ------------ expected due to this value\n...\n15\
    \ |         fraction = 0;\n   |                    ^\n   |                   \
    \ |\n   |                    expected `f64`, found integer\n   |             \
    \       help: use a float literal: `0.0`\n\nerror[E0277]: cannot add `f64` to\
    \ `{integer}`\n  --> /tmp/tmphmi6rmhv.rs:17:19\n   |\n17 |     (integer_part +\
    \ fraction).div(10).round() as f64\n   |                   ^ no implementation\
    \ for `{integer} + f64`\n   |\n   = help: the trait `Add<f64>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (_, fraction) = f64::from(number).unwrap_or_else(|| {\n  \
    \      macro_rules! unwrap {\n            ($e:expr) => {\n                if let\
    \ Ok(e) = &$e {\n                    e\n                } else {\n           \
    \         panic!(\"Expected `&float` but got `{}`\", $e)\n                }\n\
    \            };\n        }\n\n        unwrap!(number.floor() as f64) / (number.floor()\
    \ as f64)\n    });\n\n    fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or_else` found for type `f64` in\
    \ the current scope\n --> /tmp/tmp5i9ikgn0.rs:8:43\n  |\n8 |     let (_, fraction)\
    \ = f64::from(number).unwrap_or_else(|| {\n  |                               \
    \            ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5i9ikgn0.rs:11:24\n   |\n11 |                 if let Ok(e)\
    \ = &$e {\n   |                        ^^^^^   --- this expression has type `&f64`\n\
    \   |                        |\n   |                        expected `f64`, found\
    \ enum `Result`\n...\n19 |         unwrap!(number.floor() as f64) / (number.floor()\
    \ as f64)\n   |         ------------------------------ in this macro invocation\n\
    \   |\n   = note: expected type `f64`\n              found enum `Result<_, _>`\n\
    \   = note: this error originates in the macro `unwrap` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = f64::MIN;\n    let mut remain = f64::MIN;\n\
    \    if number <= 0 {\n        return 0;\n    }\n    let mut last_digit = number;\n\
    \    while last_digit > 0 && last_digit % 10 != 0 {\n        last_digit /= 10.0;\n\
    \    }\n    while last_digit > 0 && remain < 1 {\n        truncated = last_digit;\n\
    \        remain = number % last_digit;\n        number /= last_digit;\n    }\n\
    \    remain\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzr0x0j_9.rs:10:18\n   |\n\
    10 |     if number <= 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `f64`, found integer\n   |                  help:\
    \ use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzr0x0j_9.rs:11:16\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n11 |       \
    \  return 0;\n   |                ^\n   |                |\n   |             \
    \   expected `f64`, found integer\n   |                help: use a float literal:\
    \ `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzr0x0j_9.rs:14:24\n \
    \  |\n14 |     while last_digit > 0 && last_digit % 10 != 0 {\n   |          \
    \              ^\n   |                        |\n   |                        expected\
    \ `f64`, found integer\n   |                        help: use a float literal:\
    \ `0.0`\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmpzr0x0j_9.rs:14:40\n\
    \   |\n14 |     while last_digit > 0 && last_digit % 10 != 0 {\n   |         \
    \                               ^ no implementation for `f64 % {integer}`\n  \
    \ |\n   = help: the trait `Rem<{integer}>` is not implemented for `f64`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n14 |     while\
    \ last_digit > 0 && last_digit % 10.0 != 0 {\n   |                           \
    \                 ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzr0x0j_9.rs:17:24\n\
    \   |\n17 |     while last_digit > 0 && remain < 1 {\n   |                   \
    \     ^\n   |                        |\n   |                        expected `f64`,\
    \ found integer\n   |                        help: u"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO: this should be a generic function for any precision\n\
    \    let mut integer_part: i32 = number.floor() as i32;\n    let mut fractional_part:\
    \ f64 = number.trunc() as f64;\n\n    if fractional_part >= 1.0 {\n        return\
    \ 1.0;\n    }\n\n    integer_part = integer_part + 1;\n\n    fractional_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmpoqrhnkpf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / f64::from(10).round()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.35`,\n right: `0.5`', /tmp/tmphcdwzd_1.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut quotient = number.trunc();\n    let mut remainder: f64\
    \ = 0.0;\n    while quotient != 0.0 {\n        remainder += 1.0 / quotient;\n\
    \        quotient = quotient - 1.0;\n    }\n    remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.8333333333333333`,\n right: `0.5`', /tmp/tmp7t7vwxs_.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number.abs() - number.floor() as f64) / number\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.14285714285714285`,\n right: `0.5`', /tmp/tmp_4dak6q_.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / (f64::powf(10, number.f64().exp2_log10())) as f64\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_uvmk0hj.rs:8:25\n  |\n8 |\
    \     number / (f64::powf(10, number.f64().exp2_log10())) as f64\n  |        \
    \                 ^^\n  |                         |\n  |                     \
    \    expected `f64`, found integer\n  |                         help: use a float\
    \ literal: `10.0`\n\nerror[E0599]: no method named `f64` found for type `f64`\
    \ in the current scope\n --> /tmp/tmp_uvmk0hj.rs:8:36\n  |\n8 |     number / (f64::powf(10,\
    \ number.f64().exp2_log10())) as f64\n  |                                    ^^^\
    \ method not found in `f64`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        0.0\n    } else {\n        number.floor()\
    \ as f64\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmprmixf3zd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimals) = number.floor() as (f64, f64);\n    integer\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0605]: non-primitive cast: `f64` as `(f64, f64)`\n --> /tmp/tmpx7rlq2dq.rs:8:31\n\
    \  |\n8 |     let (integer, decimals) = number.floor() as (f64, f64);\n  |   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can\
    \ only be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0605`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // First determine the integer part by rounding to integer and\
    \ then checking\n    // that it is non-negative.\n    let mut integer = number.ceil()\
    \ as i32;\n    if integer < 0 {\n        integer += 1;\n    }\n    number\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpjst40i4x.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (whole, decimal) = number.div_f64::<f64>() as (\n        f64,\n\
    \        f64,\n    );\n    whole\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `div_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpzqtna67r.rs:8:35\n  |\n8 |     let (whole, decimal) = number.div_f64::<f64>()\
    \ as (\n  |                                   ^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exp = 0;\n    let mut man = 0;\n    let num = number.abs();\n\
    \n    // Extract the integer part\n    while num > std::i32::MAX as f64 {\n  \
    \      num -= std::i32::MAX as f64;\n        exp += 1;\n    }\n    num = num.round()\
    \ as f64;\n\n    // Extract the decimal part\n    while num >= std::i32::MAX as\
    \ f64 {\n        man = num % std::i32::MAX as f64;\n        num = (num - man)\
    \ / std::i32::MAX as f64;\n    }\n    man = num;\n    num = num.round() as f64;\n\
    \    (man, exp)\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_f7rgm2z.rs:21:15\n   |\n\
    9  |     let mut man = 0;\n   |                   - expected due to this value\n\
    ...\n21 |         man = num % std::i32::MAX as f64;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `f64`\n\nerror[E0277]: cannot subtract `{integer}` from\
    \ `f64`\n  --> /tmp/tmp_f7rgm2z.rs:22:20\n   |\n22 |         num = (num - man)\
    \ / std::i32::MAX as f64;\n   |                    ^ no implementation for `f64\
    \ - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_f7rgm2z.rs:24:11\n\
    \   |\n9  |     let mut man = 0;\n   |                   - expected due to this\
    \ value\n...\n24 |     man = num;\n   |           ^^^ expected integer, found\
    \ `f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_f7rgm2z.rs:26:5\n  \
    \ |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                     \
    \               --- expected `f64` because of return type\n...\n26 |     (man,\
    \ exp)\n   |     ^^^^^^^^^^ expected `f64`, found tuple\n   |\n   = note: expected\
    \ type `f64`\n             found tuple `({integer}, {integer})`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number;\n    let remainder = number.f64() %\
    \ 1;\n    while remainder < 0.5 {\n        integer /= 10;\n        remainder =\
    \ number.f64() % 1;\n    }\n    integer\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpswc89mvn.rs:9:28\n  |\n9 |     let remainder = number.f64()\
    \ % 1;\n  |                            ^^^ method not found in `f64`\n\nerror[E0277]:\
    \ cannot divide-assign `f64` by `{integer}`\n  --> /tmp/tmpswc89mvn.rs:11:17\n\
    \   |\n11 |         integer /= 10;\n   |                 ^^ no implementation\
    \ for `f64 /= {integer}`\n   |\n   = help: the trait `DivAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n             <f32\
    \ as DivAssign>\n             <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n\
    \             <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n \
    \            <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer /= 10.0;\n   |                    \
    \  ++\n\nerror[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpswc89mvn.rs:12:28\n   |\n12 |         remainder = number.f64()\
    \ % 1;\n   |                            ^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number / std::f64::powf(10, std::f64::log10(number.abs())).floor()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in module `std::f64`\n --> /tmp/tmp0d36pogz.rs:8:24\n\
    \  |\n8 |     number / std::f64::powf(10, std::f64::log10(number.abs())).floor()\n\
    \  |                        ^^^^ not found in `std::f64`\n\nerror[E0425]: cannot\
    \ find function `log10` in module `std::f64`\n --> /tmp/tmp0d36pogz.rs:8:43\n\
    \  |\n8 |     number / std::f64::powf(10, std::f64::log10(number.abs())).floor()\n\
    \  |                                           ^^^^^ not found in `std::f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.floor() as f64;\n    let decimal = number\
    \ - integer as f64;\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number == 0. {\n        number\n    } else {\n        number.trunc().ok_or(\"\
    invalid number\").into()\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok_or` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpo7rydyl8.rs:11:24\n   |\n11 |         number.trunc().ok_or(\"\
    invalid number\").into()\n   |                        ^^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut quotient = number;\n\
    \    while quotient >= 10 {\n        quotient /= 10;\n        remainder *= 10;\n\
    \    }\n    quotient as f64 + remainder\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ln1b3hc.rs:10:23\n   |\n\
    10 |     while quotient >= 10 {\n   |                       ^^\n   |         \
    \              |\n   |                       expected `f64`, found integer\n \
    \  |                       help: use a float literal: `10.0`\n\nerror[E0277]:\
    \ cannot divide-assign `f64` by `{integer}`\n  --> /tmp/tmp6ln1b3hc.rs:11:18\n\
    \   |\n11 |         quotient /= 10;\n   |                  ^^ no implementation\
    \ for `f64 /= {integer}`\n   |\n   = help: the trait `DivAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n             <f32\
    \ as DivAssign>\n             <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n\
    \             <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n \
    \            <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         quotient /= 10.0;\n   |                   \
    \    ++\n\nerror[E0277]: cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmp6ln1b3hc.rs:12:19\n\
    \   |\n12 |         remainder *= 10;\n   |                   ^^ no implementation\
    \ for `f64 *= {integer}`\n   |\n   = help: the trait `MulAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n             <f32\
    \ as MulAssign>\n             <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n\
    \             <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n \
    \            <i16 as MulAssign<&i16>>\n             <i16 as MulAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |         remainder *= 10.0;\n   |                  \
    \      ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number\n        .floor()\n        .unwrap_or(number.ceil() as\
    \ f64)\n        .into()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpug7u47tn.rs:10:10\n   |\n10 |         .unwrap_or(number.ceil()\
    \ as f64)\n   |          ^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part: f64 = 0.0;\n\
    \    loop {\n        let remainder = number % 10.0;\n        if remainder > 0.0\
    \ {\n            integer_part += remainder;\n            number /= 10.0;\n   \
    \     } else {\n            decimal_part += number;\n            break;\n    \
    \    }\n    }\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer_part` is assigned to, but never used\n --> /tmp/tmpuab1ttdj.rs:9:13\n\
    \  |\n9 |     let mut integer_part: f64 = 0.0;\n  |             ^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: consider\
    \ using `_integer_part` instead\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpuab1ttdj.rs:14:13\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n14 |             number /= 10.0;\n   |         \
    \    ^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut digit = number.trunc();\n\
    \    let mut reminder = 1.0;\n    while digit > 0.0 {\n        if digit % 10.0\
    \ < 10 {\n            decimal_part += reminder;\n            reminder *= 10.0;\n\
    \        }\n        reminder *= digit;\n        digit /= 10.0;\n    }\n    decimal_part\
    \ + reminder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9f6w8dm4.rs:12:27\n   |\n\
    12 |         if digit % 10.0 < 10 {\n   |                           ^^\n   | \
    \                          |\n   |                           expected `f64`, found\
    \ integer\n   |                           help: use a float literal: `10.0`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut numerator = number;\n    if numerator >= 1.0 {\n     \
    \   numerator -= 1.0;\n    }\n    numerator\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpvlqxabec.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().ceil() as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpds2pjmyx.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number as f32;\n    let decimals_part = number\n\
    \        .sub(f32::EPSILON)\n        .round()\n        .unwrap_or(0.0);\n    //\
    \ If `number` is a subnormal number (i.e. below the rounding threshold)\n    //\
    \ then `integer_part` will be 0.\n    // This case must be handled explicitly\
    \ to return an acceptable result\n    // when `decimals_part` is non-zero (i.e.\
    \ when there is no fractional part).\n    if decimals_part > 0.0 {\n        integer_part\n\
    \    } else {\n        integer_part.trunc()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpg1bc7idw.rs:10:10\n    |\n10  |         .sub(f32::EPSILON)\n\
    \    |          ^^^ method not found in `f64`\n    |\n    = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Sub;\n\
    \    |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg1bc7idw.rs:18:9\n   |\n\
    7  | fn truncate_number(number: f64) -> f64 {\n   |                          \
    \          --- expected `f64` because of return type\n...\n18 |         integer_part\n\
    \   |         ^^^^^^^^^^^^ expected `f64`, found `f32`\n   |\nhelp: you can convert\
    \ an `f32` to an `f64`\n   |\n18 |         integer_part.into()\n   |         \
    \            +++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg1bc7idw.rs:20:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n20 |       \
    \  integer_part.trunc()\n   |         ^^^^^^^^^^^^^^^^^^^^ expected `f64`, found\
    \ `f32`\n   |\nhelp: you can convert an `f32` to an `f64`\n   |\n20 |        \
    \ integer_part.trunc().into()\n   |                             +++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.floor() as f64;\n    if result < 0 {\n\
    \        result += 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxd0rhx8q.rs:9:17\n  |\n9 |\
    \     if result < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().powf(2)\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp7kbbgj_r.rs:8:25\n  |\n8 |\
    \     number.trunc().powf(2)\n  |                         ^\n  |             \
    \            |\n  |                         expected `f64`, found integer\n  |\
    \                         help: use a float literal: `2.0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.5 {\n        number\n    } else {\n        number\
    \ - 0.5\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp7j1q8wev.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    for frac in number.frac() {\n       \
    \ leftover_part += frac;\n        if leftover_part > 1.0 {\n            integer_part\
    \ += 1.0;\n            leftover_part = 0.0;\n        } else {\n            integer_part\
    \ += frac.trunc();\n        }\n    }\n    if leftover_part > 0.0 {\n        integer_part\
    \ += 1.0;\n    }\n    integer_part += leftover_part;\n    integer_part.trunc()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `frac` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpzzh08dnn.rs:12:24\n   |\n12 |     for frac in number.frac()\
    \ {\n   |                        ^^^^ help: there is an associated function with\
    \ a similar name: `fract`\n\nerror[E0689]: can't call method `trunc` on ambiguous\
    \ numeric type `{float}`\n  --> /tmp/tmpzzh08dnn.rs:25:18\n   |\n25 |     integer_part.trunc()\n\
    \   |                  ^^^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `f32`\n   |\n9  |     let mut integer_part: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0689.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number\n    } else {\n        number\
    \ % 1.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut whole = number;\n    let decimal = if whole < 1.0 {\n\
    \        whole - 1.0\n    } else {\n        whole\n    };\n    let fraction =\
    \ decimal.floor();\n    fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpg42qog1p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer_part, decimal_part) = match number.floor() as f64\
    \ {\n        0.0 => return 0.0,\n        1.0 => return 1.0,\n        other =>\
    \ return other - f64::from(other).truncate(),\n    };\n    decimal_part\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp0hf4r_r3.rs:11:50\n   |\n11 |         other => return other\
    \ - f64::from(other).truncate(),\n   |                                       \
    \           ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nwarning: unreachable expression\n  --> /tmp/tmp0hf4r_r3.rs:13:5\n\
    \   |\n8  |       let (integer_part, decimal_part) = match number.floor() as f64\
    \ {\n   |  ________________________________________-\n9  | |         0.0 => return\
    \ 0.0,\n10 | |         1.0 => return 1.0,\n11 | |         other => return other\
    \ - f64::from(other).truncate(),\n12 | |     };\n   | |_____- any code following\
    \ this `match` expression is unreachable, as all arms diverge\n13 |       decimal_part\n\
    \   |       ^^^^^^^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0;\n    let mut integer_part = 0.0;\n\n\
    \    while number >= 1.0 {\n        number -= 1.0;\n        integer_part += 1.0;\n\
    \    }\n\n    if number > 0.0 {\n        decimal_part = f64::ceil(number as f64\
    \ - f64::abs(number as f64))\n            .unwrap_or(0.0);\n        integer_part\
    \ -= decimal_part;\n    }\n\n    integer_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpl53lhltu.rs:18:14\n   |\n18 |             .unwrap_or(0.0);\n\
    \   |              ^^^^^^^^^ method not found in `f64`\n\nerror[E0277]: cannot\
    \ subtract-assign `{integer}` from `{float}`\n  --> /tmp/tmpl53lhltu.rs:19:22\n\
    \   |\n19 |         integer_part -= decimal_part;\n   |                      ^^\
    \ no implementation for `{float} -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n           \
    \  <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64\
    \ as SubAssign>\n             <i128 as SubAssign<&i128>>\n             <i128 as\
    \ SubAssign>\n             <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n\
    \           and 20 others\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mantissa = number.to_f64();\n    let mut decimals = mantissa\
    \ % 1;\n    if decimals > 0 {\n        decimals -= 1;\n    }\n    number\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpj6at2gpl.rs:8:27\n  |\n8 |     let mantissa = number.to_f64();\n\
    \  |                           ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc();\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu3h0_so.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n8 |     number.trunc();\n  |\
    \                   - help: remove this semicolon\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    let mut i = 0;\n    while i < number.len()\
    \ {\n        let mut remainder = number.len() - i;\n        let mut scale = 1;\n\
    \        if remainder > 5 {\n            scale = 5.into();\n            remainder\
    \ -= 5;\n        }\n        number /= 10.into();\n        number -= remainder\
    \ as f64 * scale;\n        i += scale;\n    }\n    number\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpluywyvez.rs:10:22\n   |\n10 |     while i < number.len()\
    \ {\n   |                      ^^^ help: there is an associated function with\
    \ a similar name: `ln`\n\nerror[E0599]: no method named `len` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmpluywyvez.rs:11:36\n   |\n11 |         let\
    \ mut remainder = number.len() - i;\n   |                                    ^^^\
    \ help: there is an associated function with a similar name: `ln`\n\nerror[E0277]:\
    \ cannot multiply `f64` by `{integer}`\n  --> /tmp/tmpluywyvez.rs:18:36\n   |\n\
    18 |         number -= remainder as f64 * scale;\n   |                       \
    \             ^ no implementation for `f64 * {integer}`\n   |\n   = help: the\
    \ trait `Mul<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut exponent = f64::min_value();\n    let mut remainder =\
    \ f64::min_value();\n    if number < 0.0 {\n        number = -number;\n      \
    \  exponent = -1;\n        remainder = f64::min_value();\n    }\n\n    let mut\
    \ decimal_places = f64::min_value();\n    while number > f64::max_value() {\n\
    \        number = number / 10.0;\n        decimal_places += 1;\n    }\n    decimal_places\
    \ += exponent;\n    decimal_places = decimal_places.saturating_sub(f64::max_value());\n\
    \n    number / f64::pow(10.0, decimal_places)\n        .try_into()\n        .expect(\"\
    could not round number to nearest\")\n        .floor()\n        .unwrap_or(number)\n\
    \        * (f64::pow(10.0, decimal_places))\n        .try_into()\n        .expect(\"\
    could not round number to nearest\")\n        .floor()\n        .unwrap_or(f64::min_value())\n\
    \        + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `min_value` found for\
    \ type `f64` in the current scope\n --> /tmp/tmp828ply8a.rs:8:29\n  |\n8 |   \
    \  let mut exponent = f64::min_value();\n  |                             ^^^^^^^^^\
    \ function or associated item not found in `f64`\n\nerror[E0599]: no function\
    \ or associated item named `min_value` found for type `f64` in the current scope\n\
    \ --> /tmp/tmp828ply8a.rs:9:30\n  |\n9 |     let mut remainder = f64::min_value();\n\
    \  |                              ^^^^^^^^^ function or associated item not found\
    \ in `f64`\n\nerror[E0599]: no function or associated item named `min_value` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp828ply8a.rs:13:26\n   |\n\
    13 |         remainder = f64::min_value();\n   |                          ^^^^^^^^^\
    \ function or associated item not found in `f64`\n\nerror[E0599]: no function\
    \ or associated item named `min_value` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp828ply8a.rs:16:35\n   |\n16 |     let mut decimal_places = f64::min_value();\n\
    \   |                                   ^^^^^^^^^ function or associated item\
    \ not found in `f64`\n\nerror[E0599]: no function or associated item named `max_value`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp828ply8a.rs:17:25\n\
    \   |\n17 |     while number > f64::max_value() {\n   |                      \
    \   ^^^^^^^^^ function or associated item not found in `f64`\n\nerror[E0599]:\
    \ no function or associated item named `max_value` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp828ply8a.rs:22:57\n   |\n22 |     decimal_places\
    \ = decimal_places.saturating_sub(f64::max_value());\n   |                   \
    \                                      ^^^^^^^^^ function or associated item not\
    \ found in `f64`\n\nerror[E0599]: no function or associated item named `pow` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmp828ply8a.rs:24:19\n   |\n\
    24 |     number / f64::pow(10.0, decimal_places)\n   |                   ^^^\n\
    \   |                   |\n   |                   function or associated item\
    \ not found in `f64`\n   |               "
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    if number >= 1.0 {\n        //\
    \ Find the biggest integer smaller than the number.\n        let mut integer =\
    \ 0.0;\n        for &x in number.fract().to_digits(4) {\n            if x < integer\
    \ {\n                integer = x;\n            }\n        }\n\n        // Find\
    \ the leftover part (smaller than 1).\n        let mut decimal_part: f64 = number;\n\
    \        for &x in number.fract().to_digits(2) {\n            if x < decimal_part\
    \ {\n                decimal_part = x;\n            }\n        }\n    } else {\n\
    \        // If the number is 0.0 or negative, truncate it to 0.\n        decimal_part\
    \ = 0.0;\n    }\n\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp_4tmfkvr.rs:12:34\n   |\n12 |         for &x in number.fract().to_digits(4)\
    \ {\n   |                                  ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_bits`\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmp_4tmfkvr.rs:20:34\n\
    \   |\n20 |         for &x in number.fract().to_digits(2) {\n   |            \
    \                      ^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_bits`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number <= f32::max_value() {\n        number\n    } else {\n\
    \        number / f32::pow32f64(f64::max_value() / number)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `max_value` found for\
    \ type `f32` in the current scope\n --> /tmp/tmp2icyey4p.rs:8:23\n  |\n8 |   \
    \  if number <= f32::max_value() {\n  |                       ^^^^^^^^^ function\
    \ or associated item not found in `f32`\n\nerror[E0599]: no function or associated\
    \ item named `pow32f64` found for type `f32` in the current scope\n  --> /tmp/tmp2icyey4p.rs:11:23\n\
    \   |\n11 |         number / f32::pow32f64(f64::max_value() / number)\n   |  \
    \                     ^^^^^^^^\n   |                       |\n   |           \
    \            function or associated item not found in `f32`\n   |            \
    \           help: there is an associated function with a similar name: `powf`\n\
    \nerror[E0599]: no function or associated item named `max_value` found for type\
    \ `f64` in the current scope\n  --> /tmp/tmp2icyey4p.rs:11:37\n   |\n11 |    \
    \     number / f32::pow32f64(f64::max_value() / number)\n   |                \
    \                     ^^^^^^^^^ function or associated item not found in `f64`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let whole = number.floor();\n    let decimal = (number - whole).abs();\n\
    \    whole + decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpxdi8qjm9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        // \"0.5\" instead of \"0.5\"\n     \
    \   number - f64::from(0.5)\n    } else {\n        number\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpndk8he3n.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.trunc_f64();\n    if decimal <\
    \ 0.1 {\n        number\n    } else {\n        number.fract().unwrap()\n    }\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmptn6xyemr.rs:8:37\n  |\n8 |     let (integer, decimal) =\
    \ number.trunc_f64();\n  |                                     ^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `trunc`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmptn6xyemr.rs:12:24\n\
    \   |\n12 |         number.fract().unwrap()\n   |                        ^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (q, d) = number.frexp();\n    if d == 0.0 {\n        q\n \
    \   } else {\n        q * (1.0 / (f64::from(10.0) * d))\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `frexp` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpybjliwwi.rs:8:25\n  |\n8 |     let (q, d) = number.frexp();\n\
    \  |                         ^^^^^ help: there is an associated function with\
    \ a similar name: `exp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    if number\
    \ < 0.0 {\n        integer = -number;\n        decimals = -truncate_number(-number);\n\
    \    } else {\n        decimals = truncate_number(number - integer);\n       \
    \ integer += decimals;\n    }\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976600
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut i = 0;\n    let mut frac = 0;\n    if number > 0 {\n \
    \       while number >= 1.0 {\n            number -= 1.0;\n            i += 1;\n\
    \        }\n        frac = number - i;\n    }\n    frac + i as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmer92lry.rs:10:17\n   |\n\
    10 |     if number > 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `f64`, found integer\n   |                 help: use\
    \ a float literal: `0.0`\n\nerror[E0277]: cannot subtract `{integer}` from `f64`\n\
    \  --> /tmp/tmpmer92lry.rs:15:23\n   |\n15 |         frac = number - i;\n   |\
    \                       ^ no implementation for `f64 - {integer}`\n   |\n   =\
    \ help: the trait `Sub<{integer}>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add `f64` to `{integer}`\n  --> /tmp/tmpmer92lry.rs:17:10\n   |\n17 |     frac\
    \ + i as f64\n   |          ^ no implementation for `{integer} + f64`\n   |\n\
    \   = help: the trait `Add<f64>` is not implemented for `{integer}`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number as f64\n        .trunc(::std::fmt::Display::default())\n\
    \        .ceil()\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmpbufr20fi.rs:8:5\n\
    \  |\n8 |     number as f64\n  |     ^^^^^^^^^^^^^\n  |\nhelp: try surrounding\
    \ the expression in parentheses\n  |\n8 |     (number as f64)\n  |     +     \
    \        +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n\
    \ --> /tmp/tmpbufr20fi.rs:9:16\n  |\n9 |         .trunc(::std::fmt::Display::default())\n\
    \  |                ^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(bare_trait_objects)]`\
    \ on by default\n  = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    help: use `dyn`\n  |\n9 |         .trunc(<dyn (::std::fmt::Display)>::default())\n\
    \  |                ++++++                   ++\n\nerror[E0599]: no function or\
    \ associated item named `default` found for trait object `dyn std::fmt::Display`\
    \ in the current scope\n --> /tmp/tmpbufr20fi.rs:9:37\n  |\n9 |         .trunc(::std::fmt::Display::default())\n\
    \  |                                     ^^^^^^^ function or associated item not\
    \ found in `dyn std::fmt::Display`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpbufr20fi.rs:9:10\n    |\n9   | \
    \        .trunc(::std::fmt::Display::default())\n    |          ^^^^^ ------------------------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 3 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number.floor();\n    fraction -= number as\
    \ f32;\n    fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfn0yy7rp.rs:9:17\n  |\n9 |\
    \     fraction -= number as f32;\n  |                 ^^^^^^^^^^^^^ expected `f64`,\
    \ found `f32`\n\nerror[E0277]: cannot subtract-assign `f32` from `f64`\n --> /tmp/tmpfn0yy7rp.rs:9:14\n\
    \  |\n9 |     fraction -= number as f32;\n  |              ^^ no implementation\
    \ for `f64 -= f32`\n  |\n  = help: the trait `SubAssign<f32>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \            <f32 as SubAssign<&f32>>\n            <f32 as SubAssign>\n      \
    \      <f64 as SubAssign<&f64>>\n            <f64 as SubAssign>\n            <i128\
    \ as SubAssign<&i128>>\n            <i128 as SubAssign>\n            <i16 as SubAssign<&i16>>\n\
    \            <i16 as SubAssign>\n          and 20 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimals) = number.truncate() as f64.powi(10);\n\
    \    number.remainder(1) as f64 / decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n --> /tmp/tmp21ylm30w.rs:8:31\n\
    \  |\n8 |     let (integer, decimals) = number.truncate() as f64.powi(10);\n \
    \ |                               ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: try surrounding\
    \ the expression in parentheses\n  |\n8 |     let (integer, decimals) = (number.truncate()\
    \ as f64).powi(10);\n  |                               +                     \
    \   +\n\nerror[E0599]: no method named `truncate` found for type `f64` in the\
    \ current scope\n --> /tmp/tmp21ylm30w.rs:8:38\n  |\n8 |     let (integer, decimals)\
    \ = number.truncate() as f64.powi(10);\n  |                                  \
    \    ^^^^^^^^ help: there is an associated function with a similar name: `trunc`\n\
    \nerror[E0599]: no method named `remainder` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp21ylm30w.rs:9:12\n  |\n9 |     number.remainder(1) as f64\
    \ / decimals\n  |            ^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.ceil() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpqmwl5xkz.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number == 0.0 {\n        0.0\n    } else {\n        number.ceil()\
    \ as f64\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp70jxo4q6.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.trunc().ceil() as f64\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number;\n    result.truncate();\n    if number\
    \ < 1 {\n        result = result - 1;\n        result.truncate();\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpdyl5iqws.rs:9:12\n  |\n9 |     result.truncate();\n  | \
    \           ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyl5iqws.rs:10:17\n\
    \   |\n10 |     if number < 1 {\n   |                 ^\n   |                \
    \ |\n   |                 expected `f64`, found integer\n   |                \
    \ help: use a float literal: `1.0`\n\nerror[E0277]: cannot subtract `{integer}`\
    \ from `f64`\n  --> /tmp/tmpdyl5iqws.rs:11:25\n   |\n11 |         result = result\
    \ - 1;\n   |                         ^ no implementation for `f64 - {integer}`\n\
    \   |\n   = help: the trait `Sub<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Sub<Rhs>`:\n            \
    \ <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n11 |         result\
    \ = result - 1.0;\n   |                            ++\n\nerror[E0599]: no method\
    \ named `truncate` found for type `f64` in the current scope\n  --> /tmp/tmpdyl5iqws.rs:12:16\n\
    \   |\n12 |         result.truncate();\n   |                ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `trunc`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals: f64 = number.floor() as f64;\n    if decimals\
    \ > 1.0 {\n        decimals -= 1.0;\n    }\n    decimals\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.0`,\n right: `0.5`', /tmp/tmpein8u4qx.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let result = number as f64 - trunc(number) as f64;\n    result\
    \ - result % 1\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n --> /tmp/tmpi2wo_z3k.rs:8:34\n\
    \  |\n8 |     let result = number as f64 - trunc(number) as f64;\n  |        \
    \                          ^^^^^ not found in this scope\n\nerror[E0277]: cannot\
    \ mod `f64` by `{integer}`\n --> /tmp/tmpi2wo_z3k.rs:9:21\n  |\n9 |     result\
    \ - result % 1\n  |                     ^ no implementation for `f64 % {integer}`\n\
    \  |\n  = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n            <&'a f32\
    \ as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n\
    \            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n      \
    \      <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a\
    \ isize as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     result - result % 1.0\n  |   \
    \                     ++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    integer.truncate();\n\
    \    integer - integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpclf16l23.rs:9:13\n  |\n9 |     integer.truncate();\n  |\
    \             ^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc();\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsu3h0_so.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n8 |     number.trunc();\n  |\
    \                   - help: remove this semicolon\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let i = f64::from(number);\n    let decimals = i - (i % 1.0).unwrap();\n\
    \    i\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpxqg5h326.rs:9:34\n  |\n9 |     let decimals = i - (i % 1.0).unwrap();\n\
    \  |                                  ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // The algorithm is based on IEEE-754 round-to-nearest mode where\n\
    \    // rounding to nearest mode is applied before truncating to integer\n   \
    \ // part. The following code implement round-to-nearest mode\n    // and truncating\
    \ first before rounding result to integer part.\n    //\n    // See section 4.2.1\
    \ of IEEE 754-2008 page 9 for a detailed description\n    // of round-to-nearest\
    \ mode.\n    //\n    // See also IEEE 754-2008 section 4.2.4 \"Rounding toward\
    \ zero\"\n    // of IEEE 754-2008 page 16 for a detailed description of IEEE round-to-nearest\
    \ mode.\n    // See also IEEE 754-2008 section 4.2.4 \"Rounding toward +Infinity\"\
    \n    // of IEEE 754-2008 page 16 for a detailed description of IEEE round-to-nearest\
    \ mode.\n    let mut integer = 0;\n    let mut fraction = 0;\n    let mut significand\
    \ = number;\n    let mut decimal_exp = 0;\n    let mut e = 1;\n\n    loop {\n\
    \        // If remaining fraction is 0, break the loop.\n        if fraction ==\
    \ 0 {\n            break;\n        }\n\n        // Truncate to integer part and\
    \ round-to-nearest mode is applied\n        // before truncating.\n        integer\
    \ = integer * 10 + (significand % 10);\n        significand /= 10;\n\n       \
    \ // Apply round-to-nearest mode to fraction.\n        let f = significand - integer;\n\
    \        fraction = f;\n        significand += f + 1;\n\n        // Apply round-to-nearest\
    \ mode to decimal exponent.\n        decimal_exp += f - fraction;\n        e =\
    \ 10 * (f - fraction);\n        fraction = 0;\n    }\n\n    // Round the result\
    \ to an integer part and return the decimal part of\n    // the result.\n    significand\
    \ + (integer as f64 / 10 ** decimal_exp as f64)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp1a7o9mrb.rs:34:47\n\
    \   |\n34 |         integer = integer * 10 + (significand % 10);\n   |       \
    \                                        ^ no implementation for `f64 % {integer}`\n\
    \   |\n   = help: the trait `Rem<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `Rem<Rhs>`:\n            \
    \ <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\nhelp: consider\
    \ using a floating-point literal by writing it with `.0`\n   |\n34 |         integer\
    \ = integer * 10 + (significand % 10.0);\n   |                               \
    \                    ++\n\nerror[E0277]: cannot divide-assign `f64` by `{integer}`\n\
    \  --> /tmp/tmp1a7o9mrb.rs:35:21\n   |\n35 |         significand /= 10;\n   |\
    \                     ^^ no implementation for `f64 /= {integer}`\n   |\n   =\
    \ help: the trait `DivAssign<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `DivAssign<Rhs>`:\n             <f32\
    \ as DivAssign<&f32>>\n             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n\
    \             <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n  \
    \           <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n     \
    \        <i16 as DivAssign>\n           and 20 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n35 |         significand\
    \ /= 10.0;\n   |                          ++\n\nerror[E0277]: cannot subtract\
    \ `{integer}` from `f64`\n  --> /tmp/tmp1a7o9mrb.rs:38:29\n   |\n38 |        \
    \ let f = significand - integer;\n   |                             ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer_part = 0;\n    let mut remainder = 0;\n    loop\
    \ {\n        if remainder < number / 10 {\n            integer_part += 1;\n  \
    \          remainder = number % 10;\n        } else if remainder > number / 10\
    \ {\n            integer_part += 2;\n            remainder = number % 10;\n  \
    \      } else {\n            return number / 10.0;\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `f64` by `{integer}`\n  --> /tmp/tmp7ug_9aw5.rs:11:31\n\
    \   |\n11 |         if remainder < number / 10 {\n   |                       \
    \        ^ no implementation for `f64 / {integer}`\n   |\n   = help: the trait\
    \ `Div<{integer}>` is not implemented for `f64`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |         if remainder < number /\
    \ 10.0 {\n   |                                   ++\n\nerror[E0277]: cannot mod\
    \ `f64` by `{integer}`\n  --> /tmp/tmp7ug_9aw5.rs:13:32\n   |\n13 |          \
    \   remainder = number % 10;\n   |                                ^ no implementation\
    \ for `f64 % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n13 |             remainder = number % 10.0;\n   |              \
    \                      ++\n\nerror[E0277]: cannot divide `f64` by `{integer}`\n\
    \  --> /tmp/tmp7ug_9aw5.rs:14:38\n   |\n14 |         } else if remainder > number\
    \ / 10 {\n   |                                      ^ no implementation for `f64\
    \ / {integer}`\n   |\n   = help: the trait `Div<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        number.abs()\n    } else {\n        let\
    \ mut i = number.abs().floor() as i32;\n        if i >= 0 {\n            i / 10\n\
    \        } else {\n            i / 10.0\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpk526dhcu.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk526dhcu.rs:13:13\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                 --- expected `f64` because of return type\n...\n13 |       \
    \      i / 10\n   |             ^^^^^^ expected `f64`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `f64`, producing the floating point representation\
    \ of the integer\n   |\n13 |             (i / 10).into()\n   |             + \
    \     ++++++++\n\nerror[E0277]: cannot divide `i32` by `{float}`\n  --> /tmp/tmpk526dhcu.rs:15:15\n\
    \   |\n15 |             i / 10.0\n   |               ^ no implementation for `i32\
    \ / {float}`\n   |\n   = help: the trait `Div<{float}>` is not implemented for\
    \ `i32`\n   = help: the following other types implement trait `Div<Rhs>`:\n  \
    \           <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n      \
    \       <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n        \
    \     <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n            \
    \ <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        return number\n    }\n    let num\
    \ = number as i32;\n    let mantissa = num.to_i32();\n    let result = mantissa\
    \ / (10 ** mantissa.leading_zeros() as i32);\n    result as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_i32` found for type `i32` in the current\
    \ scope\n  --> /tmp/tmpvo5ih7m4.rs:12:24\n   |\n12 |     let mantissa = num.to_i32();\n\
    \   |                        ^^^^^^ method not found in `i32`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut f = (number.to_f64() / std::f64::consts::FRAC_DIGIT).floor();\n\
    \    let mut i = f as i64;\n    i -= std::f64::consts::FRAC_DIGIT;\n    f * std::f64::consts::FRAC_DIGIT\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `FRAC_DIGIT` in module `std::f64::consts`\n\
    \ --> /tmp/tmpo7tj1tk4.rs:8:54\n  |\n8 |     let mut f = (number.to_f64() / std::f64::consts::FRAC_DIGIT).floor();\n\
    \  |                                                      ^^^^^^^^^^ not found\
    \ in `std::f64::consts`\n\nerror[E0425]: cannot find value `FRAC_DIGIT` in module\
    \ `std::f64::consts`\n  --> /tmp/tmpo7tj1tk4.rs:10:28\n   |\n10 |     i -= std::f64::consts::FRAC_DIGIT;\n\
    \   |                            ^^^^^^^^^^ not found in `std::f64::consts`\n\n\
    error[E0425]: cannot find value `FRAC_DIGIT` in module `std::f64::consts`\n  -->\
    \ /tmp/tmpo7tj1tk4.rs:11:27\n   |\n11 |     f * std::f64::consts::FRAC_DIGIT\n\
    \   |                           ^^^^^^^^^^ not found in `std::f64::consts`\n\n\
    error[E0599]: no method named `to_f64` found for type `f64` in the current scope\n\
    \ --> /tmp/tmpo7tj1tk4.rs:8:25\n  |\n8 |     let mut f = (number.to_f64() / std::f64::consts::FRAC_DIGIT).floor();\n\
    \  |                         ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut int_part = 0.0;\n    let mut decimal_part = 0.0;\n   \
    \ let mut decimal_digits = 1;\n    let mut dec = 0.0;\n    let mut max_digits\
    \ = u32::MAX;\n    let mut i = 0;\n    loop {\n        if int_part >= number {\n\
    \            break;\n        }\n        let digit = number / float::powf(10.0f64,\
    \ (i - decimal_digits));\n        int_part += digit;\n        if int_part >= number\
    \ {\n            break;\n        }\n        max_digits = i;\n        decimal_digits\
    \ += 1;\n        dec = digit;\n        i += 1;\n    }\n    // Decimal part is\
    \ always less than 1.0\n    if decimal_digits > 1 {\n        return dec;\n   \
    \ }\n    if decimal_digits == 1 {\n        // Special case, e.g. truncate to 0,\
    \ when we have a negative number\n        return 0.0;\n    }\n    // Integer part\
    \ is always smaller than given number\n    if int_part >= number {\n        return\
    \ 0.0;\n    }\n    // Round up to nearest integer, discarding decimal part\n \
    \   int_part = int_part.round() as f64;\n    // Round down to nearest integer,\
    \ discarding decimal part\n    let i = u32::MAX - decimal_digits - 1;\n    int_part\
    \ = int_part.round() as f64;\n    let dec = number_digits(int_part as f64);\n\
    \    truncate_number(int_part - dec).0\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `float`\n\
    \  --> /tmp/tmp9wipok0x.rs:18:30\n   |\n18 |         let digit = number / float::powf(10.0f64,\
    \ (i - decimal_digits));\n   |                              ^^^^^ use of undeclared\
    \ crate or module `float`\n\nerror[E0425]: cannot find function `number_digits`\
    \ in this scope\n  --> /tmp/tmp9wipok0x.rs:45:15\n   |\n45 |     let dec = number_digits(int_part\
    \ as f64);\n   |               ^^^^^^^^^^^^^ not found in this scope\n\nwarning:\
    \ unnecessary parentheses around function argument\n  --> /tmp/tmp9wipok0x.rs:18:51\n\
    \   |\n18 |         let digit = number / float::powf(10.0f64, (i - decimal_digits));\n\
    \   |                                                   ^                  ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -         let digit = number / float::powf(10.0f64, (i - decimal_digits));\n\
    18 +         let digit = number / float::powf(10.0f64, i - decimal_digits);\n\
    \   | \n\nerror[E0610]: `f64` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp9wipok0x.rs:46:37\n   |\n46 |     truncate_number(int_part - dec).0\n\
    \   |                                     ^\n\nerror: aborting due to 3 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425,\
    \ E0433, E0610.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, _) = number.trunc();\n    let remainder = number\
    \ - integer;\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1h2_v1xe.rs:8:9\n  |\n8 |\
    \     let (integer, _) = number.trunc();\n  |         ^^^^^^^^^^^^   --------------\
    \ this expression has type `f64`\n  |         |\n  |         expected `f64`, found\
    \ tuple\n  |\n  = note: expected type `f64`\n            found tuple `(_, _)`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 1.0 {\n        number\n    } else {\n        number\
    \ * (f64::from(1.0) / f64::from(number))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp54h4z5jd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < std::f32::consts::FRAC_DIGITS {\n        return number\
    \ as f32;\n    }\n    let whole_digits = number / std::f32::consts::FRAC_DIGITS\
    \ as i32;\n    let fractional_part = number - whole_digits * std::f32::consts::FRAC_DIGITS\
    \ as i32;\n    fractional_part / (std::f32::consts::FRAC_DIGITS as f32)\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `FRAC_DIGITS` in module `std::f32::consts`\n\
    \ --> /tmp/tmpwbqpx76v.rs:8:35\n  |\n8 |     if number < std::f32::consts::FRAC_DIGITS\
    \ {\n  |                                   ^^^^^^^^^^^ not found in `std::f32::consts`\n\
    \nerror[E0425]: cannot find value `FRAC_DIGITS` in module `std::f32::consts`\n\
    \  --> /tmp/tmpwbqpx76v.rs:11:51\n   |\n11 |     let whole_digits = number / std::f32::consts::FRAC_DIGITS\
    \ as i32;\n   |                                                   ^^^^^^^^^^^\
    \ not found in `std::f32::consts`\n\nerror[E0425]: cannot find value `FRAC_DIGITS`\
    \ in module `std::f32::consts`\n  --> /tmp/tmpwbqpx76v.rs:12:69\n   |\n12 |  \
    \   let fractional_part = number - whole_digits * std::f32::consts::FRAC_DIGITS\
    \ as i32;\n   |                                                              \
    \       ^^^^^^^^^^^ not found in `std::f32::consts`\n\nerror[E0425]: cannot find\
    \ value `FRAC_DIGITS` in module `std::f32::consts`\n  --> /tmp/tmpwbqpx76v.rs:13:42\n\
    \   |\n13 |     fractional_part / (std::f32::consts::FRAC_DIGITS as f32)\n   |\
    \                                          ^^^^^^^^^^^ not found in `std::f32::consts`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpwbqpx76v.rs:9:16\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |                                    --- expected `f64` because\
    \ of return type\n8 |     if number < std::f32::consts::FRAC_DIGITS {\n9 |   \
    \      return number as f32;\n  |                ^^^^^^^^^^^^^ expected `f64`,\
    \ found `f32`\n  |\nhelp: you can convert an `f32` to an `f64`\n  |\n9 |     \
    \    return (number as f32).into();\n  |                +             ++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // We want to truncate as much as possible so we take as many\
    \ decimals\n    // as we can. The formula is like this:\n    //   1. Find the\
    \ position of the decimal point.\n    //   2. The fractional part of the number\
    \ is just the fractional part of it\n    //      minus the whole part.\n    //\
    \   3. We divide both parts by 10 (to get the decimal part) then we get\n    //\
    \      the integer part of the number.\n    //   4. We return the integer part\
    \ as a floating point number.\n    //\n    // Example:\n    // If the number we\
    \ were working with were 3.14159265358979323846\n    // we would take the integer\
    \ part as 3.\n    // The fractional part would be 0.14159265358979323846\n   \
    \ // which is 1.\n    // Then we would divide this by 10 to get 0.14159.\n   \
    \ // The final number would be 3.14159.\n    let integer_part = number.trunc().divf();\n\
    \    let fractional_part = number - integer_part;\n    (integer_part * 10.0).ceil()\
    \ / 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `divf` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpilb6l8m5.rs:24:39\n   |\n24 |     let integer_part = number.trunc().divf();\n\
    \   |                                       ^^^^ method not found in `f64`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.floor() as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpee5mwi99.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0 {\n        f64::from(0.0) - number\n    } else {\n\
    \        number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcxwmhmue.rs:8:17\n  |\n8 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // We use a large number as small as possible for rounding.\n\
    \    const NUM: f64 = 10.0;\n    if number >= NUM {\n        return number;\n\
    \    }\n    let mut truncated = NUM;\n    let mut result = NUM;\n    while result\
    \ > number {\n        result = result / 2.0;\n        truncated = truncated *\
    \ 2.0;\n    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `40.0`,\n right: `0.5`', /tmp/tmpyxyc3kgk.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number as f64 - number.trunc() as f64\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // Avoid division by 0.\n    number.abs() <= f64::EPSILON\n  \
    \      ? number\n        : (number / (f64::from(2.0) - f64::from(1.0)))\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `number`\n\
    \  --> /tmp/tmpzrajev4w.rs:10:11\n   |\n10 |         ? number\n   |          \
    \ ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number\n    }\n\n    if number\
    \ < 1.0 + (1.0 / 10.0) {\n        return number - (1.0 / 10.0)\n    }\n\n    if\
    \ number < 1.0 + (1.0 / 100.0) {\n        return number - (1.0 / 100.0)\n    }\n\
    \n    if number < 1.0 + (1.0 / 1000.0) {\n        return number - (1.0 / 1000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 10000.0) {\n        return number - (1.0\
    \ / 10000.0)\n    }\n\n    if number < 1.0 + (1.0 / 100000.0) {\n        return\
    \ number - (1.0 / 100000.0)\n    }\n\n    if number < 1.0 + (1.0 / 1000000.0)\
    \ {\n        return number - (1.0 / 1000000.0)\n    }\n\n    if number < 1.0 +\
    \ (1.0 / 10000000.0) {\n        return number - (1.0 / 10000000.0)\n    }\n\n\
    \    if number < 1.0 + (1.0 / 100000000.0) {\n        return number - (1.0 / 100000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 1000000000.0) {\n        return number\
    \ - (1.0 / 1000000000.0)\n    }\n\n    if number < 1.0 + (1.0 / 10000000000.0)\
    \ {\n        return number - (1.0 / 10000000000.0)\n    }\n\n    if number < 1.0\
    \ + (1.0 / 100000000000.0) {\n        return number - (1.0 / 100000000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 1000000000000.0) {\n        return number\
    \ - (1.0 / 1000000000000.0)\n    }\n\n    if number < 1.0 + (1.0 / 10000000000000.0)\
    \ {\n        return number - (1.0 / 10000000000000.0)\n    }\n\n    if number\
    \ < 1.0 + (1.0 / 100000000000000.0) {\n        return number - (1.0 / 100000000000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 1000000000000000.0) {\n        return number\
    \ - (1.0 / 1000000000000000.0)\n    }\n\n    if number < 1.0 + (1.0 / 10000000000000000.0)\
    \ {\n        return number - (1.0 / 10000000000000000.0)\n    }\n\n    if number\
    \ < 1.0 + (1.0 / 100000000000000000.0) {\n        return number - (1.0 / 100000000000000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 1000000000000000000.0) {\n        return\
    \ number - (1.0 / 1000000000000000000.0)\n    }\n\n    if number < 1.0 + (1.0\
    \ / 10000000000000000000.0) {\n        return number - (1.0 / 10000000000000000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 1000000000000000000.0) {\n        return\
    \ number - (1.0 / 1000000000000000000.0)\n    }\n\n    if number < 1.0 + (1.0\
    \ / 10000000000000000000.0) {\n        return number - (1.0 / 10000000000000000000.0)\n\
    \    }\n\n    if number < 1.0 + (1.0 / 100000000000000000000.0) {\n        return\
    \ number - (1.0 / 100000000000000000000.0)\n    }\n\n    if number < 1.0 + (1.0\
    \ / 1000000000000000000000.0) {\n        return number - (1.0 / 1000000000000000000000.0)\n\
    \    }\n\n    if number < 1.0 \n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpe_vj0ycc.rs:105:1\n    |\n\
    104 |     if number < 1.0 \n    |     -- this `if` expression has a condition,\
    \ but no block\n105 | }\n    | ^ expected `{`\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.truncate() as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `truncate` found for type `f64` in the current\
    \ scope\n --> /tmp/tmphub9arz5.rs:8:12\n  |\n8 |     number.truncate() as f64\n\
    \  |            ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trunc`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor() as f64;\n    let dec = number.fract();\n\
    \    if dec > 0 {\n        int_part + dec\n    } else {\n        int_part\n  \
    \  }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptvfm2kc2.rs:10:14\n   |\n\
    10 |     if dec > 0 {\n   |              ^\n   |              |\n   |        \
    \      expected `f64`, found integer\n   |              help: use a float literal:\
    \ `0.0`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut whole: f64 = number;\n    let fraction = if number > 0\
    \ {\n        whole % 1\n    } else {\n        -f64::from(-whole)\n    };\n   \
    \ whole - fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4gh0k1yn.rs:9:32\n  |\n9 |\
    \     let fraction = if number > 0 {\n  |                                ^\n \
    \ |                                |\n  |                                expected\
    \ `f64`, found integer\n  |                                help: use a float literal:\
    \ `0.0`\n\nerror[E0277]: cannot mod `f64` by `{integer}`\n  --> /tmp/tmp4gh0k1yn.rs:10:15\n\
    \   |\n10 |         whole % 1\n   |               ^ no implementation for `f64\
    \ % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         whole % 1.0\n   |                  ++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n\n    loop {\n        let mut\
    \ decimal_part = remainder % 10.0;\n        remainder /= 10.0;\n\n        if remainder\
    \ > 0 {\n            decimal_part += remainder;\n            remainder = 0.0;\n\
    \        }\n\n        if decimal_part == 0.0 {\n            break;\n        }\n\
    \    }\n\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `decimal_part` in this scope\n  --> /tmp/tmp0um1m8dx.rs:24:5\n\
    \   |\n24 |     decimal_part\n   |     ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0um1m8dx.rs:14:24\n   |\n14 |  \
    \       if remainder > 0 {\n   |                        ^\n   |              \
    \          |\n   |                        expected `f64`, found integer\n   |\
    \                        help: use a float literal: `0.0`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut n = number;\n    let mut decimal = 0;\n\n    // Decompose\
    \ n into integer part and fractional part.\n    loop {\n        // Add 1 to integer\
    \ part for positive n.\n        if n >= f64::from(0.) {\n            n -= f64::from(0.);\n\
    \            decimal += 1;\n        }\n\n        // Add fractional part for negative\
    \ n.\n        if n < f64::from(0.) {\n            n += f64::from(0.);\n      \
    \      decimal += 1;\n        }\n\n        // Stop if fractional part is zero.\n\
    \        if f64::from(decimal).is_zero() {\n            break;\n        }\n  \
    \  }\n\n    // Return decimal part.\n    return n / f64::from(decimal).unwrap();\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpke4emlpq.rs:26:31\n   |\n26 |         if f64::from(decimal).is_zero()\
    \ {\n   |                               ^^^^^^^ method not found in `f64`\n\n\
    error[E0599]: no method named `unwrap` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpke4emlpq.rs:32:35\n   |\n32 |     return n / f64::from(decimal).unwrap();\n\
    \   |                                   ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number;\n    }\n    if number\
    \ == 1.0 {\n        return 0.0;\n    }\n    if number == 1.0 {\n        return\
    \ 0.0;\n    }\n    let mut result = 0.0;\n    let mut remainder = number;\n  \
    \  while remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n\
    \    }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpr7h9xcir.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.fract() {\n        Some(f) => f.truncate(),\n   \
    \     None => number.floor(),\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp141mog0p.rs:9:9\n  |\n8 |\
    \     match number.fract() {\n  |           -------------- this expression has\
    \ type `f64`\n9 |         Some(f) => f.truncate(),\n  |         ^^^^^^^ expected\
    \ `f64`, found enum `Option`\n  |\n  = note: expected type `f64`\n           \
    \  found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp141mog0p.rs:10:9\n\
    \   |\n8  |     match number.fract() {\n   |           -------------- this expression\
    \ has type `f64`\n9  |         Some(f) => f.truncate(),\n10 |         None =>\
    \ number.floor(),\n   |         ^^^^ expected `f64`, found enum `Option`\n   |\n\
    \   = note: expected type `f64`\n              found enum `Option<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut digits = number.to_string().chars().take(20);\n    //\
    \ find first non-digit\n    match digits.next() {\n        Some(c) if c < '0'\
    \ || c > '9' => {\n            if !digits.is_empty() {\n                digits\n\
    \            }\n            else {\n                return 0\n            }\n\
    \        }\n        _ => return number,\n    }\n    // find first digit\n    let\
    \ mut decimal_point = digits.next().unwrap();\n    while decimal_point < '0' ||\
    \ decimal_point > '9' {\n        decimal_point = digits.next().unwrap();\n   \
    \ }\n    digits.next().unwrap().to_string().parse::<f64>().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `is_empty` exists for struct `std::iter::Take<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpqpxrxwox.rs:12:24\n \
    \  |\n12 |               if !digits.is_empty() {\n   |                       \
    \   ^^^^^^^^ method cannot be called on `std::iter::Take<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Chars<'_>: ExactSizeIterator`\n           which is required by `std::iter::Take<Chars<'_>>:\
    \ ExactSizeIterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqpxrxwox.rs:13:17\n\
    \   |\n12 | /             if !digits.is_empty() {\n13 | |                 digits\n\
    \   | |                 ^^^^^^ expected `()`, found struct `std::iter::Take`\n\
    14 | |             }\n15 | |             else {\n16 | |                 return\
    \ 0\n17 | |             }\n   | |_____________- expected this to be `()`\n   |\n\
    \   = note: expected unit type `()`\n                 found struct `std::iter::Take<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqpxrxwox.rs:16:24\n   |\n7  |\
    \ fn truncate_number(number: f64) -> f64 {\n   |                             \
    \       --- expected `f64` because of return type\n...\n16 |                 return\
    \ 0\n   |                        ^\n   |                        |\n   |      \
    \                  expected `f64`, found integer\n   |                       \
    \ help: use a float literal: `0.0`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fraction = number.fract();\n    let mut multiplier = 1;\n\
    \    let mut result = number.trunc();\n    while fraction > 1.0 {\n        result\
    \ *= multiplier;\n        multiplier += 1;\n        fraction -= 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmpu7o_3xne.rs:12:16\n\
    \   |\n12 |         result *= multiplier;\n   |                ^^ no implementation\
    \ for `f64 *= {integer}`\n   |\n   = help: the trait `MulAssign<{integer}>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `MulAssign<Rhs>`:\n             <f32 as MulAssign<&f32>>\n             <f32\
    \ as MulAssign>\n             <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n\
    \             <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n \
    \            <i16 as MulAssign<&i16>>\n             <i16 as MulAssign>\n     \
    \      and 20 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let num = number.floor();\n    let (integer, decimals) = if num\
    \ % 1 == 0 {\n        (num, 0)\n    } else {\n        (num, num % 1)\n    };\n\
    \    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp9qgoap1k.rs:9:38\n\
    \  |\n9 |     let (integer, decimals) = if num % 1 == 0 {\n  |               \
    \                       ^ no implementation for `f64 % {integer}`\n  |\n  = help:\
    \ the trait `Rem<{integer}>` is not implemented for `f64`\n  = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n            <&'a f32 as Rem<f32>>\n\
    \            <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n    \
    \        <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n          \
    \  <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a isize\
    \ as Rem<isize>>\n          and 54 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n  |\n9 |     let (integer, decimals) = if num\
    \ % 1.0 == 0 {\n  |                                         ++\n\nerror[E0277]:\
    \ cannot mod `f64` by `{integer}`\n  --> /tmp/tmp9qgoap1k.rs:12:19\n   |\n12 |\
    \         (num, num % 1)\n   |                   ^ no implementation for `f64\
    \ % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n12 |         (num, num % 1.0)\n   |                      ++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        let mut num = number.ceil();\n    \
    \    num -= 1;\n        num\n    } else {\n        let num = number;\n       \
    \ num -= 1;\n        num\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmpm7zhz02c.rs:10:13\n\
    \   |\n10 |         num -= 1;\n   |             ^^ no implementation for `f64\
    \ -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         num -= 1.0;\n   |                 ++\n\nerror[E0277]:\
    \ cannot subtract-assign `{integer}` from `f64`\n  --> /tmp/tmpm7zhz02c.rs:14:13\n\
    \   |\n14 |         num -= 1;\n   |             ^^ no implementation for `f64\
    \ -= {integer}`\n   |\n   = help: the trait `SubAssign<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n14 |         num -= 1.0;\n   |                 ++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut dec = 0;\n    let mut num = number;\n    while num > 1.0\
    \ {\n        num /= 10.0;\n        dec += 1;\n    }\n    // num can be 0, but\
    \ dec can't.\n    dec\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4pyqpawz.rs:15:5\n   |\n\
    7  | fn truncate_number(number: f64) -> f64 {\n   |                          \
    \          --- expected `f64` because of return type\n...\n15 |     dec\n   |\
    \     ^^^ expected `f64`, found integer\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as i64;\n    let decimal = number.fract()\
    \ * (1 as f64);\n    // Return number if integer is zero\n    if integer == 0\
    \ {\n        return number;\n    }\n    // Return number if decimal part is zero\n\
    \    if decimal == 0.0 {\n        return number;\n    }\n    // Return integer\
    \ part if decimal part is non-zero\n    if decimal != 0.0 {\n        return integer\
    \ + f64::from(decimal);\n    }\n    // Return integer part\n    return integer\
    \ as f64;\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `f64` to `i64`\n  --> /tmp/tmpsgqm6cne.rs:20:24\n\
    \   |\n20 |         return integer + f64::from(decimal);\n   |               \
    \         ^ no implementation for `i64 + f64`\n   |\n   = help: the trait `Add<f64>`\
    \ is not implemented for `i64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n\n   \
    \ if number < 0.0 {\n        truncated = -number;\n        remainder = -number;\n\
    \    } else {\n        let mut tmp = number;\n        while tmp > 0.0 {\n    \
    \        let tmp = tmp % 10.0;\n            truncated = truncated + tmp / 10.0;\n\
    \            remainder = tmp;\n        }\n    }\n\n    remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976599
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.5 {\n        number * 2\n    } else {\n        number\
    \ * 2 - 1\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `f64` by `{integer}`\n --> /tmp/tmptflmhfb1.rs:9:16\n\
    \  |\n9 |         number * 2\n  |                ^ no implementation for `f64\
    \ * {integer}`\n  |\n  = help: the trait `Mul<{integer}>` is not implemented for\
    \ `f64`\n  = help: the following other types implement trait `Mul<Rhs>`:\n   \
    \         <&'a f32 as Mul<f32>>\n            <&'a f64 as Mul<f64>>\n         \
    \   <&'a i128 as Mul<i128>>\n            <&'a i16 as Mul<i16>>\n            <&'a\
    \ i32 as Mul<i32>>\n            <&'a i64 as Mul<i64>>\n            <&'a i8 as\
    \ Mul<i8>>\n            <&'a isize as Mul<isize>>\n          and 49 others\nhelp:\
    \ consider using a floating-point literal by writing it with `.0`\n  |\n9 |  \
    \       number * 2.0\n  |                   ++\n\nerror[E0277]: cannot multiply\
    \ `f64` by `{integer}`\n  --> /tmp/tmptflmhfb1.rs:11:16\n   |\n11 |         number\
    \ * 2 - 1\n   |                ^ no implementation for `f64 * {integer}`\n   |\n\
    \   = help: the trait `Mul<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n11 |         number\
    \ * 2.0 - 1\n   |                   ++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = 0.0;\n    let mut fraction = number.to_f64();\n\
    \    fraction = fraction % 1.0;\n    while fraction > 1.0 {\n        integer +=\
    \ 1.0;\n        fraction -= 1.0;\n    }\n    integer\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpz4infimp.rs:9:31\n  |\n9 |     let mut fraction = number.to_f64();\n\
    \  |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut fractional = 0.0;\n    let mut integer = 0.0;\n    loop\
    \ {\n        if number > fractional + 1.0e-10 {\n            return integer;\n\
    \        }\n        fractional += 1.0e-10;\n        integer += 1.0e-10;\n    \
    \    number -= fractional;\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `number`\n  --> /tmp/tmppkut_836.rs:16:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n16 | \
    \        number -= fractional;\n   |         ^^^^^^^^^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        return number * f64::ceil() as f64\n\
    \    }\n\n    let mantissa = number.trunc();\n\n    let exponent = mantissa.exp();\n\
    \n    // Multiply mantissa by 10 until the exponent is 0.\n    // This way, we\
    \ can extract the decimal part without rounding.\n    let mut decimal_part = 0.0;\n\
    \    while exponent > 0 {\n        decimal_part += 10.0 / (mantissa.clone() as\
    \ f64);\n        mantissa /= 10.0;\n        exponent -= 1;\n    }\n\n    mantissa\
    \ * f64::powf(10.0, exponent)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \  --> /tmp/tmp5uez5zqs.rs:9:25\n   |\n9  |         return number * f64::ceil()\
    \ as f64\n   |                         ^^^^^^^^^-- supplied 0 arguments\n   |\
    \                         |\n   |                         expected 1 argument\n\
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5uez5zqs.rs:19:22\n   |\n19 |     while exponent > 0 {\n   |  \
    \                    ^\n   |                      |\n   |                    \
    \  expected `f64`, found integer\n   |                      help: use a float\
    \ literal: `0.0`\n\nerror[E0277]: cannot subtract-assign `{integer}` from `f64`\n\
    \  --> /tmp/tmp5uez5zqs.rs:22:18\n   |\n22 |         exponent -= 1;\n   |    \
    \              ^^ no implementation for `f64 -= {integer}`\n   |\n   = help: the\
    \ trait `SubAssign<{integer}>` is not implemented for `f64`\n   = help: the following\
    \ other types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n    \
    \         <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n      \
    \       <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n         \
    \    <i16 as SubAssign>\n           and 20 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n22 |         exponent -= 1.0;\n   | \
    \                     ++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpt1sco6mz.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut precision = number.as_f64().precision();\n    let mut\
    \ fraction = number.sub_f64::<f64>().truncate();\n    while fraction.is_zero()\
    \ && precision > 0 {\n        precision -= 1;\n        fraction = number.sub_f64::<f64>().truncate();\n\
    \    }\n    number.div_f64::<f64>().truncate().powf(2).sub_f64::<f64>().truncate()\n\
    \        + fraction\n        / f64::from_f32(10).powf(precision).sub_f64::<f64>().truncate()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpynioxk9e.rs:8:32\n  |\n8 |     let mut precision = number.as_f64().precision();\n\
    \  |                                ^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `sub_f64` found for type `f64` in the current scope\n --> /tmp/tmpynioxk9e.rs:9:31\n\
    \  |\n9 |     let mut fraction = number.sub_f64::<f64>().truncate();\n  |    \
    \                           ^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `sub_f64` found for type `f64` in the current scope\n  --> /tmp/tmpynioxk9e.rs:12:27\n\
    \   |\n12 |         fraction = number.sub_f64::<f64>().truncate();\n   |     \
    \                      ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `div_f64` found for type `f64` in the current scope\n  --> /tmp/tmpynioxk9e.rs:14:12\n\
    \   |\n14 |     number.div_f64::<f64>().truncate().powf(2).sub_f64::<f64>().truncate()\n\
    \   |            ^^^^^^^ method not found in `f64`\n\nerror[E0599]: no function\
    \ or associated item named `from_f32` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpynioxk9e.rs:16:16\n   |\n16 |         / f64::from_f32(10).powf(precision).sub_f64::<f64>().truncate()\n\
    \   |                ^^^^^^^^ function or associated item not found in `f64`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number\n    }\n    let mut decimals\
    \ = std::mem::size_of::<f64>() as usize;\n    number = number.trunc_f64();\n \
    \   number /= 10.0;\n    decimals -= number.trunc_f64().exp();\n    number -=\
    \ number * 10.0;\n    number.checked_div_f64(10.0)\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp76_5p35m.rs:12:21\n   |\n12 |     number = number.trunc_f64();\n\
    \   |                     ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `trunc`\n\nerror[E0599]: no method named `trunc_f64` found for\
    \ type `f64` in the current scope\n  --> /tmp/tmp76_5p35m.rs:14:24\n   |\n14 |\
    \     decimals -= number.trunc_f64().exp();\n   |                        ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `trunc`\n\nerror[E0599]:\
    \ no method named `checked_div_f64` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp76_5p35m.rs:16:12\n   |\n16 |     number.checked_div_f64(10.0)\n\
    \   |            ^^^^^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut digits = number.to_digits(10);\n    digits.truncate(digits.len()\
    \ / 2);\n    digits.reverse().par_iter().take_while(|&x| x < 1).sum::<f64>()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp4wracux5.rs:8:29\n  |\n8 |     let mut digits = number.to_digits(10);\n\
    \  |                             ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_bits`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimals) = number.floor();\n    decimal - decimal\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `decimal` in this scope\n --> /tmp/tmppb5opqm9.rs:9:5\n\
    \  |\n9 |     decimal - decimal as f64\n  |     ^^^^^^^ help: a local variable\
    \ with a similar name exists: `decimals`\n\nerror[E0425]: cannot find value `decimal`\
    \ in this scope\n --> /tmp/tmppb5opqm9.rs:9:15\n  |\n9 |     decimal - decimal\
    \ as f64\n  |               ^^^^^^^ help: a local variable with a similar name\
    \ exists: `decimals`\n\nerror[E0308]: mismatched types\n --> /tmp/tmppb5opqm9.rs:8:9\n\
    \  |\n8 |     let (integer, decimals) = number.floor();\n  |         ^^^^^^^^^^^^^^^^^^^\
    \   -------------- this expression has type `f64`\n  |         |\n  |        \
    \ expected `f64`, found tuple\n  |\n  = note: expected type `f64`\n          \
    \  found tuple `(_, _)`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number % 1)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `f64` by `{integer}`\n --> /tmp/tmp55aa9rad.rs:8:22\n\
    \  |\n8 |     number - (number % 1)\n  |                      ^ no implementation\
    \ for `f64 % {integer}`\n  |\n  = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n  |\n8\
    \ |     number - (number % 1.0)\n  |                         ++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_f64()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpt1sco6mz.rs:8:12\n  |\n8 |     number.trunc_f64()\n  | \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `trunc`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976593
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.;\n    let mut i = 0;\n    while i < number.len()\
    \ {\n        truncated = truncated.checked_add(number.iter()\n            .take(i).fold(0,\
    \ |acc, x| acc + x.checked_mul(0.1)))\n            as f64;\n        i += 1;\n\
    \    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpf2hgi3l2.rs:10:22\n   |\n10 |     while i < number.len()\
    \ {\n   |                      ^^^ help: there is an associated function with\
    \ a similar name: `ln`\n\nerror[E0689]: can't call method `checked_add` on ambiguous\
    \ numeric type `{float}`\n  --> /tmp/tmpf2hgi3l2.rs:11:31\n   |\n11 |        \
    \ truncated = truncated.checked_add(number.iter()\n   |                      \
    \         ^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `f32`\n   |\n8  |     let mut truncated: f32 = 0.;\n   |         ~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0599]: no method named `iter` found for type `f64` in the current scope\n\
    \  --> /tmp/tmpf2hgi3l2.rs:11:50\n   |\n11 |         truncated = truncated.checked_add(number.iter()\n\
    \   |                                                  ^^^^ method not found in\
    \ `f64`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0689.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number <= 0.0 {\n        return 0.0;\n    }\n    let mut result\
    \ = 0.0;\n    while number >= result {\n        result = result + 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmpmcxoq12l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc().sqrt().to_f64()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp9yapsh6m.rs:8:27\n  |\n8 |     number.trunc().sqrt().to_f64()\n\
    \  |                           ^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = 0.0;\n    let mut decimal = 0.0;\n\n    while\
    \ number > 0 {\n        if number % 1.0 < 0.5 {\n            integer += 1.0;\n\
    \            number = number - 1.0;\n        } else {\n            decimal +=\
    \ 1.0;\n            number = number - 0.5;\n        }\n    }\n\n    number\n \
    \       * (f64::from(integer) + f64::from(decimal))\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77u9uu2u.rs:11:20\n   |\n\
    11 |     while number > 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `f64`, found integer\n   |           \
    \         help: use a float literal: `0.0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = (number - truncate_float(number)).abs();\n    if\
    \ fraction.is_zero() {\n        return 0.0;\n    }\n    let mantissa = (f64::from(fraction)\
    \ - f64::from(1.0)).abs();\n    if mantissa.is_zero() {\n        return 0.0;\n\
    \    }\n    return mantissa.powi(2);\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `truncate_float` in this scope\n -->\
    \ /tmp/tmp56cyo6ri.rs:8:30\n  |\n8 |     let fraction = (number - truncate_float(number)).abs();\n\
    \  |                              ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `is_zero` found for type `f64` in the current scope\n --> /tmp/tmp56cyo6ri.rs:9:17\n\
    \  |\n9 |     if fraction.is_zero() {\n  |                 ^^^^^^^ method not\
    \ found in `f64`\n\nerror[E0599]: no method named `is_zero` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp56cyo6ri.rs:13:17\n   |\n13 |     if mantissa.is_zero()\
    \ {\n   |                 ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // If the number is negative, return the number itself.\n    if\
    \ number < 0 {\n        return number;\n    }\n\n    let number = number.floor();\n\
    \n    let mut decimal_part = number.pow(10);\n    // Remove the decimal part if\
    \ the number is even and it's smaller than 1.\n    if number % 2 == 0 && number\
    \ < 1.0 {\n        decimal_part.div_pow10();\n    }\n    number\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmppfs95w7k.rs:9:17\n  |\n9 |\
    \     if number < 0 {\n  |                 ^\n  |                 |\n  |     \
    \            expected `f64`, found integer\n  |                 help: use a float\
    \ literal: `0.0`\n\nerror[E0599]: no method named `pow` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmppfs95w7k.rs:15:35\n   |\n15 |     let mut decimal_part\
    \ = number.pow(10);\n   |                                   ^^^ help: there is\
    \ an associated function with a similar name: `powf`\n\nerror[E0277]: cannot mod\
    \ `f64` by `{integer}`\n  --> /tmp/tmppfs95w7k.rs:17:15\n   |\n17 |     if number\
    \ % 2 == 0 && number < 1.0 {\n   |               ^ no implementation for `f64\
    \ % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n17 |     if number % 2.0 == 0 && number < 1.0 {\n   |          \
    \        ++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.1 {\n        number.floor()\n    } else {\n    \
    \    number\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpx9ajvwjq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc_from_f64()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `trunc_from_f64` found for type `f64` in\
    \ the current scope\n --> /tmp/tmpw6pc25kl.rs:8:12\n  |\n8 |     number.trunc_from_f64()\n\
    \  |            ^^^^^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number as f64;\n    let mut decimal_part = 0.0;\n\
    \    loop {\n        if result < number.trunc() as f64 {\n            break;\n\
    \        }\n        result -= number.trunc();\n        decimal_part += 1.0\n \
    \   }\n    decimal_part as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.5`', /tmp/tmpzwypbtwi.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number.is_zero() {\n        number\n    } else {\n        let\
    \ mut trunc: f64 = number;\n        let mut round: f64;\n\n        // Calculate\
    \ the decimal part.\n        while trunc.is_negative() {\n            trunc -=\
    \ 1;\n            round -= 1;\n        }\n        round = round - trunc.trunc();\n\
    \n        // The decimal part should be positive.\n        // If not, just return\
    \ the number as it is.\n        if round <= 0.0 {\n            number\n      \
    \  } else {\n            trunc\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp3mxvx8xg.rs:8:15\n  |\n8 |     if number.is_zero() {\n \
    \ |               ^^^^^^^ method not found in `f64`\n\nwarning: use of deprecated\
    \ associated function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmp3mxvx8xg.rs:15:21\n   |\n15 |         while trunc.is_negative()\
    \ {\n   |                     ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0277]: cannot subtract-assign `{integer}` from `f64`\n\
    \  --> /tmp/tmp3mxvx8xg.rs:16:19\n   |\n16 |             trunc -= 1;\n   |   \
    \                ^^ no implementation for `f64 -= {integer}`\n   |\n   = help:\
    \ the trait `SubAssign<{integer}>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `SubAssign<Rhs>`:\n             <f32 as\
    \ SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\nhelp: consider using a\
    \ floating-point literal by writing it with `.0`\n   |\n16 |             trunc\
    \ -= 1.0;\n   |                       ++\n\nerror[E0277]: cannot subtract-assign\
    \ `{integer}` from `f64`\n  --> /tmp/tmp3mxvx8xg.rs:17:19\n   |\n17 |        \
    \     round -= 1;\n   |                   ^^ no implementation for `f64 -= {integer}`\n\
    \   |\n   = help: the trait `SubAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    17 |             round -= 1.0;\n   |                     "
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 1.0 {\n        return number\n    }\n\n    if number\
    \ == 0.0 && number.is_nan() {\n        return number\n    }\n\n    let mut num\
    \ = number.abs();\n    let mut decimal_part = num - trunc(num);\n    decimal_part\
    \ += 0.5;\n    return decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `trunc` in this scope\n  --> /tmp/tmp9ri3488i.rs:17:34\n\
    \   |\n17 |     let mut decimal_part = num - trunc(num);\n   |               \
    \                   ^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976594
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = f64::truncate(number);\n    let frac_part = f64::trunc(number);\n\
    \    int_part + frac_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `truncate` found for\
    \ type `f64` in the current scope\n --> /tmp/tmpcg9t48ky.rs:8:25\n  |\n8 |   \
    \  let int_part = f64::truncate(number);\n  |                         ^^^^^^^^\n\
    \  |                         |\n  |                         function or associated\
    \ item not found in `f64`\n  |                         help: there is an associated\
    \ function with a similar name: `trunc`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976594
