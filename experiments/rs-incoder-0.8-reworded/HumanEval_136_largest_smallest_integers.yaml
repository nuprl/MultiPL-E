name: HumanEval_136_largest_smallest_integers
language: rs
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a vector.\n/// If there is no negative or positive integers, return them as\
  \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\
  /// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n///\
  \ >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
  \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ["    match lst.iter().cloned() {\n        None => (None, None),\n  \
    \      Some(x) => {\n            let mut min: Option<isize> = None;\n        \
    \    let mut max: Option<isize> = None;\n            for y in lst {\n        \
    \        if x < y {\n                    if min.is_none() {\n                \
    \        min = Some(y);\n                    } else {\n                      \
    \  if x < max {\n                            max = Some(y);\n                \
    \        }\n                    }\n                } else if x > y {\n       \
    \             if max.is_none() {\n                        max = Some(y);\n   \
    \                 } else {\n                        if x > min {\n           \
    \                 min = Some(y);\n                        }\n                \
    \    }\n                }\n            }\n            (min, max)\n        }\n\
    \    }", "    let mut max_negative: Option<isize> = None;\n    let mut min_positive:\
    \ Option<isize> = None;\n\n    for x in lst {\n        if x < 0 {\n          \
    \  if max_negative.is_some() {\n                return (max_negative, max_positive);\n\
    \            }\n            max_negative = Some(x);\n        } else {\n      \
    \      if min_positive.is_some() {\n                return (min_positive, max_negative);\n\
    \            }\n            min_positive = Some(x);\n        }\n    }\n\n    (min_positive,\
    \ max_negative)", "    let mut largest_negative = None;\n    let mut largest_positive\
    \ = None;\n    for i in lst.iter() {\n        if i > 0 {\n            if largest_positive\
    \ is None or i > largest_positive {\n                largest_positive = i;\n \
    \           }\n        } else {\n            if largest_negative is None or i\
    \ < largest_negative {\n                largest_negative = i;\n            }\n\
    \        }\n    }\n    (largest_negative, largest_positive)", "    largest_integer(vec![-lst[0],\
    \ -lst[0]..]).map(|a| {\n        largest_integer(vec![lst[0]..]).map(|b| {\n \
    \           Some(max(a, b))\n        })\n    })", "    if lst.is_empty() {\n \
    \       (None, None)\n    }\n    let mut smallest = lst.iter().min_by_key(|&x|\
    \ x);\n    let mut largest = lst.iter().max_by_key(|&x| x);\n    if smallest ==\
    \ Some(smallest) {\n        return (None, None);\n    }\n    if largest == Some(largest)\
    \ {\n        return (None, None)\n    }\n    return (Some(largest), Some(smallest));",
  "    // Find the max and min elements\n    let max_value = lst.iter().max();\n \
    \   let min_value = lst.iter().min();\n\n    // If the max and min values were\
    \ equal, return None\n    if max_value == min_value {\n        return (None, None);\n\
    \    }\n\n    // Return the max value as the smallest and the min value as the\
    \ largest\n    (Some(min_value), Some(max_value))", "    match lst.len() {\n \
    \       0 => (None, None),\n        _ => {\n            let mut min_val = vec![lst.iter().max().unwrap()];\n\
    \            let mut max_val = vec![lst.iter().min().unwrap()];\n            min_val.iter().cloned().cloned().for_each(|&x|\
    \ *x = *x.abs());\n            max_val.iter().cloned().cloned().for_each(|&x|\
    \ *x = *x.abs());\n            (Some(min_val.iter().min().unwrap()), Some(max_val.iter().max().unwrap()))\n\
    \        }\n    }", "    if lst.len() < 2 {\n        return (None, None)\n   \
    \ }\n    let mut lowest = lst.iter().min().unwrap();\n    let mut highest = lst.iter().max().unwrap();\n\
    \    if lowest < 0 {\n        lowest = None;\n    }\n    if highest > 0 {\n  \
    \      highest = None;\n    }\n    (lowest, highest)", "    let mut min_negative\
    \ = None;\n    let mut min_positive = None;\n\n    for i in lst {\n        if\
    \ i < 0 {\n            if min_negative.is_some() {\n                panic!(\"\
    Vector's smallest integer is greater than any negative integer.\");\n        \
    \    }\n            min_negative = Some(i);\n        } else {\n            if\
    \ min_positive.is_some() {\n                panic!(\"Vector's smallest integer\
    \ is greater than any positive integer.\");\n            }\n            min_positive\
    \ = Some(i);\n        }\n    }\n\n    (min_negative, min_positive)", "    let\
    \ mut min = None;\n    let mut max = None;\n    for n in lst {\n        if n <\
    \ 0 {\n            if min == None {\n                min = Some(n);\n        \
    \    } else {\n                min = Some(n.min(min.as_ref()));\n            }\n\
    \        } else {\n            if max == None {\n                max = Some(n);\n\
    \            } else {\n                max = Some(n.max(max.as_ref()));\n    \
    \        }\n        }\n    }\n    (min, max)", "    let mut max = lst[0];\n  \
    \  let mut min = lst[0];\n    for (i, e) in lst.iter().enumerate() {\n       \
    \ if e > max {\n            max = e;\n        }\n        if e < min {\n      \
    \      min = e;\n        }\n    }\n    (max, min)", "    let mut a = lst.iter().filter_map(|&x|\
    \ Some(*x).ok()).max();\n    let mut b = lst.iter().filter_map(|&x| Some(*x).ok()).min();\n\
    \    Some((a, b)) if a.is_none() && b.is_none() else None", "    let mut max_so_far\
    \ = isize::max_value();\n    let mut min_so_far = isize::min_value();\n    for\
    \ (i, x) in lst.iter().enumerate() {\n        let max_pos = max_so_far.wrapping_add(x);\n\
    \        let min_pos = min_so_far.wrapping_sub(x);\n        max_so_far = max_pos;\n\
    \        min_so_far = min_pos;\n        if max_pos < min_pos {\n            (Some(x),\
    \ Some(x))\n        } else {\n            (None, None)\n        }\n    }", " \
    \   // Sort by absolute value, and take the absolute value of the\n    // sign\
    \ bit.\n    let min_value = lst.iter().min_by_key(|x| x.abs()).unwrap();\n   \
    \ let max_value = lst.iter().max_by_key(|x| x.abs()).unwrap();\n    (Some(max_value.clone()),\
    \ Some(min_value.clone()))", '    largest_smallest_integer(&lst, |a, b| a > b)',
  "    let mut min_int = i32::MAX;\n    let mut max_int = i32::MIN;\n    let mut min_idx\
    \ = None;\n    let mut max_idx = None;\n    for i in lst.iter() {\n        if\
    \ i < min_int {\n            min_int = i;\n            min_idx = Some(i);\n  \
    \      }\n        if i > max_int {\n            max_int = i;\n            max_idx\
    \ = Some(i);\n        }\n    }\n    (min_idx, max_idx)", "    let mut smallest\
    \ = isize::MIN;\n    let mut largest = isize::MAX;\n\n    for x in lst {\n   \
    \     if x < smallest {\n            smallest = x;\n        }\n\n        if x\
    \ > largest {\n            largest = x;\n        }\n    }\n\n    (Some(largest),\
    \ Some(smallest))", "    if lst.len() <= 1 {\n        return (None, None)\n  \
    \  }\n\n    let mut min = 0isize;\n    let mut max = isize::MAX;\n\n    for elem\
    \ in lst {\n        if elem < min {\n            min = elem;\n        }\n    \
    \    if elem > max {\n            max = elem;\n        }\n    }\n\n    return\
    \ (Some(max), Some(min))", "    if lst.len() == 0 {\n        return (None, None)\n\
    \    }\n    let mut min_val = i32::MAX;\n    let mut max_val = i32::MIN;\n   \
    \ for i in lst {\n        let val = if i < 0 {\n            None\n        } else\
    \ {\n            Some(i)\n        };\n        if val.is_none() {\n           \
    \ continue;\n        }\n        if min_val > i {\n            min_val = i;\n \
    \       }\n        if max_val < i {\n            max_val = i;\n        }\n   \
    \ }\n    return (Some(max_val), Some(min_val))", "    if lst.len() <= 1 {\n  \
    \      return (None, None)\n    }\n    let mut max_i = lst.iter().max_by_key(|&x|\
    \ -x);\n    let mut min_i = lst.iter().min_by_key(|&x| -x);\n    if max_i.is_none()\
    \ || min_i.is_none() {\n        return (None, None)\n    }\n    loop {\n     \
    \   if lst.iter().any(|&x| x > max_i.unwrap()) {\n            max_i = lst.iter().max_by_key(|&x|\
    \ -x);\n        } else if lst.iter().any(|&x| x < min_i.unwrap()) {\n        \
    \    min_i = lst.iter().min_by_key(|&x| -x);\n        } else {\n            break;\n\
    \        }\n    }\n    return (Some(max_i.unwrap()), Some(min_i.unwrap()));",
  "    if lst.len() < 2 {\n        (None, None)\n    } else {\n        let mut max\
    \ = None;\n        let mut min = None;\n        for n in lst {\n            if\
    \ n < 0 {\n                max = Some(n);\n            } else {\n            \
    \    min = Some(n);\n            }\n        }\n        (max, min)\n    }", " \
    \   let mut smallest = Some(0);\n    let mut largest = Some(std::isize::MAX);\n\
    \    for &i in &lst {\n        if i >= 0 {\n            largest = Some(i);\n \
    \       } else if i < 0 {\n            smallest = Some(i);\n        }\n    }\n\
    \    (smallest, largest)", "    let max_neg = lst.iter().fold(-std::i64::MAX,\
    \ (i, &i));\n    let max_pos = lst.iter().fold(std::i64::MAX, (i, &i));\n    (max_neg,\
    \ max_pos)", "    let mut largest: Option<isize> = None;\n    let mut smallest:\
    \ Option<isize> = None;\n    for elem in lst {\n        if elem.is_none() {\n\
    \            smallest = Some(elem);\n            largest = Some(elem);\n     \
    \   } else if elem.is_some() {\n            if elem > largest {\n            \
    \    smallest = Some(elem);\n            } else {\n                largest = Some(elem);\n\
    \            }\n        }\n    }\n    (largest, smallest)", "    // Return largest\
    \ and smallest items in list\n    lst\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, item)| {\n            // If item is negative, return None\n\
    \            if item < 0 {\n                (None, item)\n            } else {\n\
    \                (Some(item), i)\n            }\n        })\n        .max_by(|(first,\
    \ second)| *second)\n        .map(|(_, item)| item)\n        .unwrap_or(None,\
    \ None)", "    let mut largest = std::isize::MIN;\n    let mut smallest = std::isize::MAX;\n\
    \    for element in lst.iter() {\n        if element > largest {\n           \
    \ largest = element;\n        }\n        if element < smallest {\n           \
    \ smallest = element;\n        }\n    }\n    (None, Some(smallest)) if largest\
    \ <= std::isize::MAX\n    else (Some(largest), None)", "    let mut min_neg =\
    \ min_negative_int(&lst);\n    let mut min_pos = max_positive_int(&lst);\n   \
    \ if let (Some(a), Some(b)) = (min_neg, min_pos) {\n        if *a > *b {\n   \
    \         (a, b)\n        } else {\n            (b, a)\n        }\n    } else\
    \ {\n        (None, None)\n    }", "    // Find any negative integers\n    let\
    \ neg_ints = lst\n        .iter()\n        .cloned()\n        .filter(|x| x <\
    \ 0)\n        .cloned()\n        .collect::<Vec<_>>();\n    if let Some(neg_ints_len)\
    \ = (neg_ints.len()) {\n        // If there are negative integers then find the\
    \ smallest positive one\n        let pos_ints = lst\n            .iter()\n   \
    \         .cloned()\n            .filter(|x| x > 0)\n            .cloned()\n \
    \           .collect::<Vec<_>>();\n        let mut min = (neg_ints_len * isize::MAX)\
    \ + isize::MAX;\n        for pos in pos_ints.iter().rev() {\n            if min\
    \ > pos {\n                min = pos;\n            }\n        }\n        return\
    \ (Some(min), None);\n    }\n    // If there are no negative integers then return\
    \ None\n    return (None, None)", "    use std::cmp::Ordering;\n\n    let mut\
    \ min_i = std::i32::MAX;\n    let mut max_i = std::i32::MIN;\n\n    for elt in\
    \ lst.iter() {\n        let i = if elt < 0 { -elt } else { elt };\n        if\
    \ i < min_i {\n            min_i = i;\n        }\n        if i > max_i {\n   \
    \         max_i = i;\n        }\n    }\n\n    let min_i = if min_i == std::i32::MAX\
    \ { None } else { Some(min_i) };\n    let max_i = if max_i == std::i32::MIN {\
    \ None } else { Some(max_i) };\n\n    (min_i, max_i)", "    debugln!(\"largest_smallest_integers({:?})\"\
    , lst);\n    // We use a binary search to find the largest and smallest integers\n\
    \    let mut largest = Some(-1);\n    let mut smallest = Some(1);\n    for x in\
    \ lst {\n        debugln!(\"largest_smallest_integers: {:?} < {:?}\", x, largest);\n\
    \        if x < smallest {\n            debugln!(\"smaller\");\n            smallest\
    \ = Some(x);\n        }\n        if x > largest {\n            debugln!(\"larger\"\
    );\n            largest = Some(x);\n        }\n    }\n    (largest, smallest)",
  "    let mut smallest = i32::MAX;\n    let mut largest = i32::MIN;\n    for x in\
    \ lst {\n        if x < smallest {\n            smallest = x;\n        }\n   \
    \     if x > largest {\n            largest = x;\n        }\n    }\n    (Some(largest),\
    \ Some(smallest))", "    let mut largest = None;\n    let mut smallest = None;\n\
    \    for i in lst {\n        if i.is_negative() {\n            if let Some(v)\
    \ = smallest {\n                if v < i {\n                    smallest = Some(i);\n\
    \                }\n            } else {\n                smallest = Some(i);\n\
    \            }\n        } else {\n            if let Some(v) = largest {\n   \
    \             if v > i {\n                    largest = Some(i);\n           \
    \     }\n            } else {\n                largest = Some(i);\n          \
    \  }\n        }\n    }\n    (largest, smallest)", "    match (lst.iter().filter_map(|v|\
    \ {\n        if v < 0 {\n            Some(v)\n        } else {\n            None\n\
    \        }\n    }), lst.iter().cloned().max_by_key(|v| v)) {\n        (Some((a,\
    \ b)), Some((c, d))) if a < c || (a < d && b > c) => Some((a, b)),\n        (Some((a,\
    \ b)), Some((c, d))) => Some((b, a)),\n        (Some((a, _)), Some((_, b))) =>\
    \ Some((a,b)),\n        _ => None,\n    }", "    let mut largest = None;\n   \
    \ let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n         \
    \   largest = Some(x);\n        } else if x > 0 {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)", "    let mut first_positive = None;\n\
    \    let mut first_negative = None;\n\n    for v in lst {\n        if v < 0 {\n\
    \            if first_negative.is_none() {\n                first_negative = Some(v);\n\
    \            }\n        } else {\n            if first_positive.is_none() {\n\
    \                first_positive = Some(v);\n            }\n        }\n    }\n\n\
    \    (first_negative, first_positive)", "    let mut a = Some(0);\n    let mut\
    \ b = Some(0);\n    for i in lst {\n        if i.is_negative() {\n           \
    \ if a.is_none() {\n                a = Some(i);\n            }\n        } else\
    \ {\n            if b.is_none() {\n                b = Some(i);\n            }\n\
    \        }\n    }\n    if a.is_none() && b.is_none() {\n        return None, None;\n\
    \    }\n    (Some(Max::max_value(a), Some(Min::min_value(b))), None)", "    if\
    \ lst.is_empty() {\n        (None, None)\n    } else {\n        let mut m = lst.iter().min_by_key(|&x|\
    \ x);\n        let mut s = lst.iter().max_by_key(|&x| x);\n        (Some(m.unwrap()),\
    \ Some(s.unwrap()))\n    }", "    if lst.is_empty() {\n        return (None, None);\n\
    \    }\n    let mut min_val = isize::MAX;\n    let mut max_val = isize::MIN;\n\
    \    let mut max_idx = None;\n    for (i, v) in lst.into_iter().enumerate() {\n\
    \        if v < min_val {\n            min_val = v;\n        }\n        if v >\
    \ max_val {\n            max_val = v;\n            max_idx = Some(i);\n      \
    \  }\n    }\n    (max_idx, max_val)", "    let mut smallest: Option<isize> = None;\n\
    \    let mut largest: Option<isize> = None;\n    let mut neg: Vec<isize> = Vec::new();\n\
    \    let mut pos: Vec<isize> = Vec::new();\n    for i in lst.iter() {\n      \
    \  if i < 0 {\n            neg.push(i);\n        }\n        if i >0 {\n      \
    \      pos.push(i);\n        }\n    }\n    if neg.len() > 0 {\n        let mut\
    \ min: Option<isize> = None;\n        for i in neg.iter() {\n            if i\
    \ == smallest {\n                min = Some(i);\n                break;\n    \
    \        }\n        }\n        if min.is_some() {\n            smallest = Some(min.unwrap());\n\
    \        }\n    }\n    if pos.len() > 0 {\n        let mut max: Option<isize>\
    \ = None;\n        for i in pos.iter() {\n            if i == largest {\n    \
    \            max = Some(i);\n                break;\n            }\n        }\n\
    \        if max.is_some() {\n            largest = Some(max.unwrap());\n     \
    \   }\n    }\n    (smallest, largest)", "    let mut max = None;\n    let mut\
    \ min = None;\n    for i in lst {\n        if i.is_negative() {\n            if\
    \ let Some(x) = max {\n                return (Some(x), i);\n            } else\
    \ {\n                max = Some(i);\n            }\n        } else {\n       \
    \     if let Some(x) = min {\n                return (Some(x), i);\n         \
    \   } else {\n                min = Some(i);\n            }\n        }\n    }\n\
    \    (max, min).unwrap_or(None, None)", "    let mut min_idx = -1;\n    let mut\
    \ max_idx = 1;\n    for (i, elt) in lst.iter().enumerate() {\n        if elt <\
    \ min_idx {\n            min_idx = elt;\n        }\n        if elt > max_idx {\n\
    \            max_idx = elt;\n        }\n    }\n    (Some(min_idx), Some(max_idx))",
  "    let mut max_num = Some(-1);\n    let mut min_num = Some(1);\n\n    for num\
    \ in lst {\n        if num < 0 {\n            max_num = Some(-1);\n        }\n\
    \        if num > 0 {\n            min_num = Some(1);\n        }\n\n        if\
    \ max_num.is_none() {\n            max_num = Some(num);\n        }\n        if\
    \ min_num.is_none() {\n            min_num = Some(num);\n        }\n\n       \
    \ if max_num.is_some() && min_num.is_some() && num > max_num.unwrap() {\n    \
    \        max_num = Some(num);\n        }\n\n        if max_num.is_some() && min_num.is_some()\
    \ && num < min_num.unwrap() {\n            min_num = Some(num);\n        }\n \
    \   }\n\n    (max_num, min_num)", "    if lst.is_empty() {\n        return (None,\
    \ None);\n    }\n    let mut min: isize = 0;\n    let mut max: isize = 0;\n  \
    \  for num in lst {\n        if num < min {\n            min = num;\n        }\n\
    \        if num > max {\n            max = num;\n        }\n    }\n    return\
    \ (Some(min), Some(max));", "    if lst.len() < 2 {\n        return (None, Some(0));\n\
    \    }\n    if lst.len() == 0 {\n        return (None, None)\n    }\n    let mut\
    \ min_i = Some(0);\n    let mut max_i = Some(0);\n    for i in lst {\n       \
    \ if i < min_i {\n            min_i = Some(i);\n        }\n        if i > max_i\
    \ {\n            max_i = Some(i);\n        }\n    }\n    (max_i, min_i)", "  \
    \  if lst.is_empty() {\n        return (None, None)\n    }\n\n    let mut a =\
    \ None;\n    let mut b = None;\n    for i in lst {\n        if a is None || (*i\
    \ < *a) {\n            a = Some(i);\n        } else {\n            b = Some(i);\n\
    \        }\n    }\n\n    (Some(b), a)", "    let mut max_value = isize::MAX;\n\
    \    let mut min_value = isize::MIN;\n\n    for x in lst {\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n        if x > max_value {\n     \
    \       max_value = x;\n        }\n    }\n\n    (Some(min_value), Some(max_value))",
  "    let mut largest_neg = None;\n    let mut smallest_pos = None;\n\n    for v\
    \ in lst {\n        if v < 0 {\n            largest_neg = Some(v);\n        }\
    \ else {\n            smallest_pos = Some(v);\n        }\n    }\n\n    (largest_neg,\
    \ smallest_pos)", "    let mut max_negative = Option::None;\n    let mut min_positive\
    \ = Option::None;\n\n    for num in lst {\n        if num < 0 {\n            if\
    \ max_negative.is_some() {\n                continue;\n            }\n       \
    \     max_negative = Some(num);\n        } else {\n            if min_positive.is_some()\
    \ {\n                continue;\n            }\n            min_positive = Some(num);\n\
    \        }\n    }\n\n    (max_negative, min_positive)", "    let smallest_one\
    \ = vec![0; lst.len()];\n    let max_one = vec![0; lst.len()];\n\n    for x in\
    \ lst {\n        if x < 0 {\n            smallest_one[x] = Some(-x);\n       \
    \ } else {\n            max_one[x] = Some(x);\n        }\n    }\n\n    if smallest_one.is_empty()\
    \ || max_one.is_empty() {\n        (None, None)\n    } else {\n        let (smallest,\
    \ max) = smallest_one.iter().max_by_key(|x| x).unwrap_or(max_one.iter().min_by_key(|x|\
    \ x).unwrap_or(0));\n        (Some(max), Some(smallest))\n    }", "    let mut\
    \ max_negative = None;\n    let mut min_positive = None;\n\n    for x in lst {\n\
    \        if x >= 0 {\n            if min_positive.is_none() {\n              \
    \  min_positive = Some(x);\n            }\n            else {\n              \
    \  if x < min_positive.unwrap() {\n                    min_positive = Some(x);\n\
    \                }\n            }\n        } else {\n            if max_negative.is_none()\
    \ {\n                max_negative = Some(x);\n            }\n            else\
    \ {\n                if x > max_negative.unwrap() {\n                    max_negative\
    \ = Some(x);\n                }\n            }\n        }\n    }\n\n    (max_negative,\
    \ min_positive)", "    let mut max = vec![Int::MIN; 2];\n    let mut min = vec![Int::MAX;\
    \ 2];\n    for x in lst {\n        if x <= min.clone() {\n            min.clone_from(vec![x]);\n\
    \        }\n        if x >= max.clone() {\n            max.clone_from(vec![x]);\n\
    \        }\n    }\n    return (Some(max.clone()), Some(min.clone()));", "    let\
    \ mut max_neg_int = None;\n    let mut min_pos_int = None;\n    let mut max_neg_int\
    \ = None;\n    for x in lst {\n        if x >= 0 {\n            if min_pos is\
    \ None || x < min_pos {\n                min_pos = x;\n            }\n       \
    \ } else {\n            if max_neg is None || x > max_neg {\n                max_neg\
    \ = x\n            }\n        }\n    }\n    (max_neg, min_pos)", "    let mut\
    \ min = Option::None;\n    let mut max = Option::None;\n    for i in lst {\n \
    \       if i >= 0 {\n            if min.is_none() {\n                min = Some(i);\n\
    \            }\n            max = Some(i);\n        }\n        if i < 0 {\n  \
    \          if max.is_none() {\n                max = Some(i);\n            }\n\
    \            min = Some(i);\n        }\n    }\n    (min, max)", "    let mut smallest\
    \ = Some(Vec::new());\n    let mut largest = Some(Vec::new());\n    for n in lst\
    \ {\n        if n < 0 {\n            smallest.push(n);\n        } else {\n   \
    \         largest.push(n);\n        }\n    }\n    smallest.sort_unstable();\n\
    \    largest.sort_unstable();\n    (Some(smallest.nth(smallest.len())), Some(largest.nth(largest.len())))",
  "    if lst.is_empty() {\n        return (None, Some(0));\n    }\n\n    let mut\
    \ max_negative = Some(std::i32::MIN);\n    let mut min_positive = Some(std::i32::MAX);\n\
    \n    for i in lst.iter() {\n        let cmp = i.cmp(&mut max_negative);\n   \
    \     if cmp > 0 {\n            max_negative = Some(i);\n        } else if cmp\
    \ < 0 {\n            min_positive = Some(i);\n        }\n    }\n\n    (max_negative,\
    \ min_positive)", "    let mut largest_negative = None;\n    let mut largest_positive\
    \ = None;\n    for i in lst.iter() {\n        if i < 0 {\n            largest_negative\
    \ = Some(i);\n        } else {\n            largest_positive = Some(i);\n    \
    \    }\n    }\n    (largest_negative, largest_positive)", "    let mut smallest\
    \ = Some(1);\n    let mut largest = Some(-1);\n    for x in lst {\n        if\
    \ x < 0 {\n            smallest = Some(std::cmp::min(smallest, x));\n        }\
    \ else {\n            largest = Some(std::cmp::max(largest, x));\n        }\n\
    \    }\n    (smallest, largest)", "    let mut min_val = i32::MAX;\n    let mut\
    \ max_val = i32::MIN;\n\n    for v in lst.iter() {\n        if v <= 0 {\n    \
    \        continue;\n        }\n        if min_val > v {\n            min_val =\
    \ v;\n        }\n        if max_val < v {\n            max_val = v;\n        }\n\
    \    }\n\n    (Some(min_val), Some(max_val))", "    if lst.len() == 0 {\n    \
    \    return (None, None)\n    }\n\n    let mut largest = Some(0);\n    let mut\
    \ smallest = Some(0);\n    for x in lst {\n        if x < 0 {\n            largest\
    \ = Some(x);\n        } else if x > 0 {\n            smallest = Some(x);\n   \
    \     } else {\n            None\n        }\n    }\n    (largest, smallest)",
  "    let mut largest_one = Some(vec![vec![0]; lst.len()]);\n    let mut smallest_one\
    \ = Some(vec![vec![0]; lst.len()]);\n    for i in lst {\n        if i <= 0 {\n\
    \            smallest_one = Some(vec![vec![0]; lst.len()]);\n        } else {\n\
    \            largest_one = Some(vec![vec![0]; lst.len()]);\n            smallest_one.unwrap()[i\
    \ as usize - 1] = i;\n        }\n    }\n    return (largest_one.unwrap(), smallest_one.unwrap());",
  "    let mut max_val = std::isize::MIN;\n    let mut min_val = std::isize::MAX;\n\
    \    for i in lst.iter() {\n        if *i <= 0 {\n            return None, None;\n\
    \        }\n        if *i > max_val {\n            max_val = *i;\n        }\n\
    \        if *i < min_val {\n            min_val = *i;\n        }\n    }\n    return\
    \ (Some(max_val), Some(min_val));", "    let mut largest = isize::MAX;\n    let\
    \ mut smallest = isize::MIN;\n\n    for x in lst {\n        if x < smallest {\n\
    \            largest = x;\n        } else if x > largest {\n            smallest\
    \ = x;\n        }\n    }\n\n    (Some(largest), Some(smallest))", "    let mut\
    \ smallest_int = isize::max_value();\n    let mut largest_int = isize::min_value();\n\
    \    for v in lst {\n        if v < smallest_int {\n            smallest_int =\
    \ v;\n        }\n        if v > largest_int {\n            largest_int = v;\n\
    \        }\n    }\n    (Some(smallest_int), Some(largest_int))", "    if lst.is_empty()\
    \ {\n        return (None, None)\n    }\n\n    let mut min_ = i32::MAX;\n    let\
    \ mut max_ = i32::MIN;\n    for e in lst {\n        if *e < min_ {\n         \
    \   min_ = *e;\n        }\n        if *e > max_ {\n            max_ = *e;\n  \
    \      }\n    }\n    (Some(min_), Some(max_))", "    let mut largest = None;\n\
    \    let mut smallest = None;\n    for num in lst {\n        if num > 0 {\n  \
    \          if largest == None || num > largest {\n                largest = Some(num);\n\
    \            }\n        } else {\n            if smallest == None || num < smallest\
    \ {\n                smallest = Some(num);\n            }\n        }\n    }\n\
    \    (largest, smallest)", "    let mut smallest = Some(-1);\n    let mut largest\
    \ = Some(1);\n    for n in lst {\n        if n < smallest {\n            smallest\
    \ = Some(n);\n        }\n        if n > largest {\n            largest = Some(n);\n\
    \        }\n    }\n    (smallest, largest)", "    if lst.len() > 0 {\n       \
    \ let mut lst_iter = lst.iter().cloned().enumerate();\n        let first = &mut\
    \ lst_iter.next();\n        let second = &mut lst_iter.next();\n        if first.is_none()\
    \ {\n            return (None, None);\n        }\n        if second.is_none()\
    \ {\n            return (first.unwrap(), None);\n        }\n        let first\
    \ = first.ok().unwrap_or(0);\n        let second = second.ok().unwrap_or(0);\n\
    \        if first < second {\n            return (None, Some(first));\n      \
    \  }\n        return (Some(second), None);\n    }\n    return (None, None)", " \
    \   let mut largest_num = isize::MAX;\n    let mut smallest_num = isize::MIN;\n\
    \n    let mut i = lst.len() - 1;\n    let mut current_small = isize::MIN;\n\n\
    \    while i >= 0 {\n        let ele = lst[i];\n        let biggest = if ele <\
    \ current_small {\n            ele + current_small\n        } else {\n       \
    \     current_small\n        };\n\n        let smallest = if ele > current_small\
    \ {\n            ele - current_small\n        } else {\n            current_small\n\
    \        };\n\n        if biggest > largest_num {\n            largest_num = biggest;\n\
    \        }\n        if smallest < smallest_num {\n            smallest_num = smallest;\n\
    \        }\n        i -= 1;\n    }\n\n    (None, Some(smallest_num))", "    let\
    \ mut min = vec![None; 2];\n    let mut max = vec![None; 2];\n    for i in lst\
    \ {\n        if i < min[0].unwrap() {\n            min[0] = Some(i);\n       \
    \ }\n        if i > max[0].unwrap() {\n            max[0] = Some(i);\n       \
    \ }\n        if i < min[1].unwrap() {\n            min[1] = Some(i);\n       \
    \ }\n        if i > max[1].unwrap() {\n            max[1] = Some(i);\n       \
    \ }\n    }\n    (min[0], max[1])", "    let mut lower = Some(-1);\n    let mut\
    \ higher = Some(1);\n\n    for elem in lst.iter().rev() {\n        if elem.is_some()\
    \ {\n            if *elem < lower.unwrap() {\n                lower = Some(*elem);\n\
    \            }\n        }\n        if elem.is_some() {\n            if *elem >\
    \ higher.unwrap() {\n                higher = Some(*elem);\n            }\n  \
    \      }\n    }\n\n    (lower, higher)", "    if lst.is_empty() {\n        return\
    \ (None, None)\n    }\n    let mut min = isize::MIN;\n    let mut max = isize::MAX;\n\
    \    for elem in lst {\n        if elem < min {\n            min = elem;\n   \
    \     }\n        if elem > max {\n            max = elem;\n        }\n    }\n\
    \    (Some(max), Some(min))", "    if lst.is_empty() {\n        return None, None;\n\
    \    }\n    let mut a = None as Option<isize>;\n    let mut b = None as Option<isize>;\n\
    \    let mut largest = None;\n    let mut smallest = None;\n    for v in lst {\n\
    \        if v < 0 {\n            if a.is_some() {\n                let tmp = b.take();\n\
    \                b.take();\n                a = Some(v);\n                b =\
    \ Some(tmp);\n            } else {\n                a = Some(v);\n           \
    \ }\n        } else if v > 0 {\n            if b.is_some() {\n               \
    \ let tmp = a.take();\n                a.take();\n                b = Some(v);\n\
    \                a = Some(tmp);\n            } else {\n                b = Some(v);\n\
    \            }\n        } else {\n            if largest == Some(None) {\n   \
    \             largest = Some(v);\n            } else if v > largest {\n      \
    \          largest = Some(v);\n            }\n        }\n    }\n    (largest,\
    \ smallest)", "    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\
    \n    for (i, elem) in lst.iter().enumerate() {\n        if elem < min {\n   \
    \         min = elem;\n        } else if elem > max {\n            max = elem;\n\
    \        }\n    }\n    (Some(max), Some(min))", "    let mut min: Option<isize>\
    \ = None;\n    let mut max: Option<isize> = None;\n    for x in lst {\n      \
    \  if x >= 0 {\n            max = Some(x);\n        } else {\n            min\
    \ = Some(x);\n        }\n    }\n\n    (min, max)", "    let max_val = match lst.iter().rfold(isize::max_value,\
    \ |max, _| max) {\n        Some(v) => v,\n        None => return (None, None),\n\
    \    };\n    let min_val = match lst.iter().rfold(isize::min_value, |min, _| min)\
    \ {\n        Some(v) => v,\n        None => return (None, None),\n    };\n   \
    \ (Some(max_val), Some(min_val))", "    let mut smallest = isize::MAX;\n    let\
    \ mut largest = isize::MIN;\n    for i in lst {\n        if i > largest {\n  \
    \          largest = i;\n        }\n        if i < smallest {\n            smallest\
    \ = i;\n        }\n    }\n    (Some(largest), Some(smallest))", "    let mut positives\
    \ = Vec::new();\n    let mut negatives = Vec::new();\n    for x in lst {\n   \
    \     if x > 0 {\n            positives.push(x);\n        } else {\n         \
    \   negatives.push(x);\n        }\n    }\n    match positives.len() {\n      \
    \  0 => (None, None),\n        1 => (Some(positives.last().unwrap()), Some(negatives.first().unwrap())),\n\
    \        _ => (\n            largest_smallest_integers(negatives),\n         \
    \   largest_smallest_integers(positives),\n        ),\n    }", "    let mut min_neg\
    \ = Some(std::isize::MAX);\n    let mut max_pos = Some(std::isize::MIN);\n   \
    \ for x in lst {\n        if x < 0 {\n            min_neg = x\n        } else\
    \ if x > 0 {\n            max_pos = x;\n        }\n    }\n    (min_neg, max_pos)",
  "    // TODO: if there are duplicate elements, we need to get all the elements\n\
    \    // and sort them\n    let mut min_num = lst.iter().min().unwrap_or(lst.iter().max().unwrap_or(-1));\n\
    \    let mut max_num = lst.iter().max().unwrap_or(lst.iter().min().unwrap_or(-1));\n\
    \n    // if min_num > max_num, swap them, so their min and max values are both\
    \ correct\n    if min_num > max_num {\n        let tmp = min_num;\n        min_num\
    \ = max_num;\n        max_num = tmp;\n    }\n\n    (Some(min_num), Some(max_num))",
  "    if lst.len() == 0 {\n        (None, None);\n    }\n\n    let min_element =\
    \ lst.iter().min().unwrap();\n    let max_element = lst.iter().max().unwrap();\n\
    \    let min_val = min_element < 0 ? None : Some(min_element);\n    let max_val\
    \ = max_element < 0 ? None : Some(max_element);\n    (min_val, max_val)", "  \
    \  let mut min_val = lst[0];\n    let mut max_val = lst[0];\n    let mut min_pos_val\
    \ = &lst[0];\n    let mut max_pos_val = &lst[0];\n\n    for v in lst.iter() {\n\
    \        if v < min_val {\n            min_val = v;\n            min_pos_val =\
    \ v;\n        } else if v > max_val {\n            max_val = v;\n            max_pos_val\
    \ = v;\n        }\n    }\n\n    (min_pos_val, max_pos_val)", "    let mut a: Option<isize>\
    \ = None;\n    let mut b: Option<isize> = None;\n    for x in lst {\n        if\
    \ a is None or x < a.unwrap() {\n            a = Some(x);\n        }\n       \
    \ if b is None or x > b.unwrap() {\n            b = Some(x);\n        }\n    }\n\
    \    (a, b)", "    let mut largest = Vec::with_capacity(lst.len());\n    let mut\
    \ smallest = Vec::with_capacity(lst.len());\n    for (i, isize) in lst.into_iter().enumerate()\
    \ {\n        if isize < 0 {\n            smallest.push(isize);\n        } else\
    \ {\n            largest.push(isize);\n        }\n    }\n    match (smallest.len(),\
    \ largest.len()) {\n        (Some(1), Some(1)) => return (None, None),\n     \
    \   (Some(0), Some(0)) => return (None, None),\n        (Some(_), Some(_)) =>\
    \ return (None, None),\n        (None, None) => {\n            return Some(smallest),\
    \ Some(largest)\n        }\n    }\n    let mut small = smallest.clone();\n   \
    \ let mut large = largest.clone();\n    if small.len() > 0 {\n        // Swap\
    \ smallest and largest\n        let (_, largest) = largest_smallest_integers(large);\n\
    \        let (_, smallest) = largest_smallest_integers(small);\n    }\n    return\
    \ (Some(smallest), Some(largest));", "    let mut max = None;\n    let mut min\
    \ = None;\n\n    for (i, v) in lst.iter().enumerate() {\n        if v < 0 {\n\
    \            if let Some(i) = max {\n                return (Some(i), min);\n\
    \            }\n            max = Some(i);\n        } else if v > 0 {\n      \
    \      if let Some(i) = min {\n                return (max, Some(i));\n      \
    \      }\n            min = Some(i);\n        } else {\n            if let Some(i)\
    \ = max {\n                return (Some(i), min);\n            }\n        }\n\
    \    }\n\n    (max, min)", "    let mut min_int = *lst.iter().min().unwrap();\n\
    \    let mut max_int = *lst.iter().max().unwrap();\n    let mut has_min = false;\n\
    \    let mut has_max = false;\n    for num in lst {\n        if num < min_int\
    \ {\n            min_int = num;\n            has_min = true;\n        } else if\
    \ num > max_int {\n            max_int = num;\n            has_max = true;\n \
    \       }\n    }\n    (if has_min && has_max && (min_int == max_int) => (None,\
    \ None), (Some(min_int), Some(max_int))\n    else if has_min && has_max => (None,\
    \ None), (Some(min_int), Some(max_int))\n    else if has_min && !has_max => (Some(min_int),\
    \ None), (Some(min_int), Some(max_int))\n    else if has_max && !has_min => (Some(max_int),\
    \ None), (Some(min_int), Some(max_int))\n    else if !has_max && !has_min => (None,\
    \ None), (Some(min_int), Some(max_int))\n    else if !has_max && !has_min && !(min_int\
    \ == max_int) => (None, None), (Some(min_int), Some(max_int))\n    else if !has_max\
    \ && !has_min && !(min_int == max_int) => (None, None), (None, None), (Some(min_int),\
    \ Some(max_int))\n    else if !has_max && !has_min && !(min_int == max_int) =>\
    \ (None, None), (None, None), (None, None), (Some(min_int), Some(max_int))\n \
    \   else if has_max && !has_min && !(min_int == max_int) => (None, None), (None,\
    \ None), (None, None), (None, None), (Some(min_int), Some(max_int))\n    else\
    \ if has_max && !has_min && !(min_int == max_int) => (None, None), (None, None),\
    \ (None, None), (None, None), (None, None), (Some(min_int), Some(max_int))\n \
    \   else if !has_max && !has_min && !(min_int == max_int) => (None, None), (None,\
    \ None), (None, None), (None, None), (None, None), (None, None), (Some(min_int),\
    \ Some(max_int))\n    else if !has_max && !has_min && !(min_int == max_int) =>\
    \ (None, None), (None, None), (None, None), (None, None), (None, None), (None,\
    \ None), (None, None), (Some(min_int), Some(max_int))\n    else if has_max &&\
    \ !has_min && !(min_int == max_int) => (None, None), (None, None), (None, None),\
    \ (None, None), (None, None), (None, None), (None, None), (Some(min_int), Some",
  "    let mut l: Vec<isize> = lst;\n    let mut lmax: Option<isize> = None;\n   \
    \ let mut lmin: Option<isize> = None;\n    for el in l {\n        if el < 0 {\n\
    \            lmax = Some(el);\n        } else if el > 0 {\n            lmin =\
    \ Some(el);\n        }\n    }\n    (lmax, lmin)", "    if lst.len() < 2 {\n  \
    \      return (None, None)\n    }\n    let mut min = (i32::MIN, i32::MAX);\n \
    \   let mut max = (i32::MAX, i32::MIN);\n    for i in lst {\n        if i > min\
    \ {\n            max = i;\n        }\n        if i < max {\n            min =\
    \ i;\n        }\n    }\n    (Some(max), Some(min))", "    if lst.is_empty() {\n\
    \        return (None, None);\n    }\n\n    let mut largest_value = isize::MAX;\n\
    \    let mut smallest_value = isize::MIN;\n\n    for i in lst {\n        if i\
    \ < 0 {\n            if smallest_value >= i {\n                smallest_value\
    \ = i;\n            }\n        } else {\n            if largest_value <= i {\n\
    \                largest_value = i;\n            }\n        }\n    }\n\n    (Some(largest_value),\
    \ Some(smallest_value))", "    let mut max_positive = None;\n    let mut min_negative\
    \ = None;\n    for num in lst {\n        if num > 0 {\n            if max_positive.is_some()\
    \ {\n                max_positive = Some(num);\n            } else {\n       \
    \         max_positive = Some(num);\n            }\n        } else {\n       \
    \     if min_negative.is_some() {\n                min_negative = Some(num);\n\
    \            } else {\n                min_negative = Some(num);\n           \
    \ }\n        }\n    }\n    (max_positive, min_negative)", "    let mut largest_positive\
    \ = None;\n    let mut largest_negative = None;\n\n    for number in lst.iter()\
    \ {\n        if number > 0 {\n            if largest_negative.is_none() {\n  \
    \              largest_negative = Some(number);\n            } else {\n      \
    \          if number > largest_negative {\n                    largest_negative\
    \ = Some(number);\n                }\n            }\n        } else {\n      \
    \      if largest_positive.is_none() {\n                largest_positive = Some(number);\n\
    \            } else {\n                if number > largest_positive {\n      \
    \              largest_positive = Some(number);\n                }\n         \
    \   }\n        }\n    }\n    (largest_negative, largest_positive)", "    let mut\
    \ min_i = None;\n    let mut max_i = None;\n    for &i in lst {\n        min_i\
    \ = i.min(min_i).unwrap_or(min_i);\n        max_i = i.max(max_i).unwrap_or(max_i);\n\
    \    }\n    (min_i, max_i)", "    if lst.is_empty() {\n        return (None, None);\n\
    \    }\n\n    let mut smallest = -std::isize::MAX;\n    let mut largest = std::isize::MIN;\n\
    \    for i in lst {\n        if i < smallest {\n            smallest = i;\n  \
    \      }\n        if i > largest {\n            largest = i;\n        }\n    }\n\
    \n    Some(largest), Some(smallest)", "    if lst.is_empty() {\n        return\
    \ (None, None)\n    }\n\n    if lst.len() == 1 {\n        if lst[0] >= 0 {\n \
    \           return (Some(lst[0]), None)\n        } else {\n            return\
    \ (None, Some(lst[0]))\n        }\n    }\n\n    let mut smallest = Some(lst.iter().min().unwrap());\n\
    \    let mut largest = Some(lst.iter().max().unwrap());\n\n    for (i, e) in lst.iter().enumerate()\
    \ {\n        let mut smallest_i = i;\n        let mut largest = i;\n\n       \
    \ for j in 0..(i - 1) {\n            if e < smallest[j] {\n                smallest_i\
    \ = j;\n                smallest = Some(smallest);\n            }\n          \
    \  if e > largest[j] {\n                largest = Some(largest);\n           \
    \ }\n        }\n\n        if i == 0 {\n            return (smallest, largest)\n\
    \        }\n\n        if smallest_i >= 0 {\n            smallest = None;\n   \
    \         smallest[smallest_i] = e;\n        } else {\n            smallest =\
    \ Some(vec![smallest_i, e]);\n        }\n    }\n    return (smallest, largest)",
  "    let mut max_val = vec![];\n    let mut min_val = vec![];\n    for el in lst.iter()\
    \ {\n        if el < 0 {\n            max_val.push(el);\n        } else {\n  \
    \          min_val.push(el);\n        }\n    }\n    (max_val.iter().max_by_key(|&x|\
    \ x).map(|&x| x.clone()), min_val.iter().min_by_key(|&x| x).map(|&x| x.clone()))",
  "    if lst.is_empty() {\n        return (None, None);\n    }\n\n    let mut largest\
    \ = vec![std::i32::MAX as isize; 2];\n    let mut smallest = vec![std::i32::MIN\
    \ as isize; 2];\n\n    for val in lst {\n        if val < 0 || val > std::i32::MAX\
    \ {\n            continue;\n        }\n\n        let largest = val.saturating_add::<isize>(largest[0]);\n\
    \        let smallest = val.saturating_sub::<isize>(smallest[0]);\n    }\n\n \
    \   match largest {\n        None => (None, None),\n        Some(largest) => match\
    \ smallest {\n            None => (None, None),\n            Some(smallest) =>\
    \ (Some(largest), Some(smallest)),\n        },\n    }", "    // Create a function\
    \ that returns the largest\n    // of negative integers plus the smallest of positive\
    \ integers\n    let min_smaller = |i|\n        if i > 0 {\n            Some(i\
    \ as isize)\n        } else {\n            None\n        };\n    // Create a function\
    \ that returns the smallest\n    // of negative integers plus the largest\n  \
    \  // of positive integers\n    let max_larger = |i|\n        if i < 0 {\n   \
    \         Some(i as isize)\n        } else {\n            None\n        };\n\n\
    \    // Iterate over the list and check which of both\n    // functions is defined\
    \ on each element\n    let (min_value, max_value) = lst.iter().map(|i| {\n   \
    \     let v = if min_smaller.contains(i) {\n            min_smaller(i)\n     \
    \   } else {\n            max_larger(i)\n        };\n        (v, i) // Return\
    \ the value and the index\n    }).min_max_unordered(|a, b| a.1.cmp(&b.1));\n\n\
    \    // Return the value that was returned by the minimum function\n    match\
    \ (min_value, max_value) {\n        (Some(a), Some(b)) => Some((a, b)),\n    \
    \    _ => None,\n    }", '    largest_smallest_integer(&lst)', "    let mut smallest\
    \ = isize::MAX;\n    let mut largest = isize::MIN;\n    let mut none_positives\
    \ = false;\n    let mut none_negatives = false;\n\n    for x in lst.iter() {\n\
    \        if x < smallest {\n            none_negatives = true;\n        }\n  \
    \      if x > largest {\n            none_positives = true;\n        }\n     \
    \   largest = std::cmp::max(largest, x);\n        smallest = std::cmp::min(smallest,\
    \ x);\n    }\n    (none_negatives, none_positives)", "    if lst.len() == 0 {\n\
    \        (None, None)\n    }\n    let mut smallest_idx = std::mem::size_of::<isize>()\
    \ * -1;\n    let mut largest_idx = std::mem::size_of::<isize>() * -1;\n    let\
    \ mut min_val = None;\n    let mut max_val = None;\n    for idx in lst.iter().rev()\
    \ {\n        let val = idx.0 as isize;\n        if val < min_val {\n         \
    \   min_val = val;\n        }\n        if val > max_val {\n            max_val\
    \ = val;\n        }\n        if val < smallest_idx {\n            smallest_idx\
    \ = val;\n        }\n        if val > largest_idx {\n            largest_idx =\
    \ val;\n        }\n    }\n    (min_val, max_val)", "    let min_val = lst.iter().min();\n\
    \    let max_val = lst.iter().max();\n    Some(min_val), Some(max_val)", "   \
    \ if lst.is_empty() {\n        return (None, None)\n    }\n\n    let (first, second)\
    \ = lst.iter().partition(|x| *x < * *x.add(1, Ordering::Greater))\n        .cloned()\n\
    \        .collect();\n\n    if first.is_none() {\n        return (None, None)\n\
    \    }\n\n    if second.is_none() {\n        return (None, None)\n    }\n\n  \
    \  return (Some(*first), Some(*second))", "    let mut smallest_positive = None;\n\
    \    let mut largest_negative = None;\n    for x in lst {\n        if x < 0 {\n\
    \            largest_negative = Some(x);\n        } else if x > 0 {\n        \
    \    smallest_positive = Some(x);\n        } else {\n            (None, None)\n\
    \        }\n    }\n    (smallest_positive, largest_negative)", "    let mut largest_value\
    \ = i32::MAX;\n    let mut smallest_value = i32::MIN;\n    for value in lst {\n\
    \        if value < 0 {\n            if value < largest_value {\n            \
    \    largest_value = value;\n            }\n        } else if value > 0 {\n  \
    \          if value > smallest_value {\n                smallest_value = value;\n\
    \            }\n        }\n    }\n    (Some(largest_value), Some(smallest_value))",
  "    let mut max = Some(*lst.iter().max().unwrap());\n    let mut min = Some(*lst.iter().min().unwrap());\n\
    \n    for v in lst {\n        if v < min {\n            min = Some(v);\n     \
    \   }\n        if v > max {\n            max = Some(v);\n        }\n    }\n  \
    \  (max, min)", "    debug_assert!(lst.len() > 0, \"Must have at least 1 integer\
    \ to get the smallest and largest values\")\n    let mut largest = None;\n   \
    \ let mut smallest = None;\n    for elem in lst {\n        if largest == None\
    \ {\n            if elem < 0 {\n                largest = Some(elem);\n      \
    \      } else {\n                smallest = Some(elem);\n            }\n     \
    \   } else {\n            if elem > 0 {\n                if largest == Some(elem)\
    \ {\n                    largest = Some(elem);\n                } else {\n   \
    \                 smallest = Some(elem);\n                }\n            }\n \
    \       }\n    }\n    (largest, smallest)", "    let mut max = None;\n    let\
    \ mut min = None;\n    for x in lst {\n        if x < 0 {\n            if max\
    \ != None {\n                return (Some(max), None);\n            } else {\n\
    \                max = Some(x);\n            }\n        } else if max != None\
    \ {\n            if x < min {\n                min = Some(x);\n            } else\
    \ {\n                return (max, Some(min));\n            }\n        } else {\n\
    \            if x < min {\n                min = Some(x);\n            } else\
    \ {\n                return (Some(x), None);\n            }\n        }\n    }\n\
    \    (max, min);", "    let mut smallest = isize::MIN;\n    let mut largest =\
    \ isize::MAX;\n    for e in lst {\n        if e > largest {\n            largest\
    \ = e;\n        }\n        if e < smallest {\n            smallest = e;\n    \
    \    }\n    }\n    (Some(largest), Some(smallest))", "    if lst.len() == 0 {\n\
    \        return (None, None)\n    }\n\n    let mut largest = None;\n    let mut\
    \ smallest = None;\n\n    for i in lst.iter() {\n        if largest == None ||\
    \ largest > i {\n            largest = Some(i);\n        }\n\n        if smallest\
    \ == None || i < smallest {\n            smallest = Some(i);\n        }\n    }\n\
    \n    (largest, smallest)", "    let mut max_value = isize::MAX;\n    let mut\
    \ min_value = isize::MIN;\n    for i in lst.iter() {\n        if i < min_value\
    \ {\n            min_value = i;\n        }\n        if i > max_value {\n     \
    \       max_value = i;\n        }\n    }\n    (Some(min_value), Some(max_value))",
  "    // Find the largest negative number\n    let max = lst.rev().iter().skip(1).max_by(|a,\
    \ b| {\n        match a.cmp(b) {\n            Ordering::Less => true,\n      \
    \      _ => false,\n        }\n    });\n    let min = lst.rev().iter().skip(1).min_by(|a,\
    \ b| {\n        match a.cmp(b) {\n            Ordering::Less => false,\n     \
    \       _ => true,\n        }\n    });\n    (max, min)", "    let mut min_val\
    \ = vec![None; lst.len()];\n    let mut max_val = vec![None; lst.len()];\n   \
    \ for i in 0..lst.len() {\n        if min_val[i] < 0 || max_val[i] > 0 {\n   \
    \         min_val[i] = Some(*min(*lst.iter().cloned().skip(i).min().unwrap(),\
    \ 0));\n            max_val[i] = Some(*max(*lst.iter().cloned().skip(i).max().unwrap(),\
    \ 0));\n        } else {\n            min_val[i] = None;\n            max_val[i]\
    \ = None;\n        }\n    }\n    match (min_val[0], max_val[0]) {\n        (Some(a),\
    \ Some(b)) if b > a => (Some(a), Some(b)),\n        _ => (None, None),\n    }",
  "    let mut max = None;\n    let mut min = None;\n    for x in lst {\n        if\
    \ max < x {\n            max = x;\n        }\n        if min > x {\n         \
    \   min = x;\n        }\n    }\n    (max, min)", "    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))", "    let mut min_value\
    \ = i32::MAX;\n    let mut max_value = i32::MIN;\n\n    for x in lst {\n     \
    \   let value = x.abs();\n        if value < min_value {\n            min_value\
    \ = value;\n        }\n\n        if value > max_value {\n            max_value\
    \ = value;\n        }\n    }\n\n    if min_value >= i32::MIN as isize {\n    \
    \    (Some(min_value), Some(max_value))\n    } else {\n        (None, None)\n\
    \    }", "    if lst.is_empty() {\n        return (None, None);\n    }\n\n   \
    \ let mut positive = lst.iter().filter_map(|v| {\n        if v < 0 {\n       \
    \     Some(v)\n        } else {\n            None\n        }\n    });\n\n    let\
    \ mut negative = lst.iter().filter_map(|v| {\n        if v < 0 {\n           \
    \ None\n        } else {\n            Some(v)\n        }\n    });\n\n    if let\
    \ Some(positive) = positive {\n        if let Some(negative) = negative {\n  \
    \          if positive.iter().any(|v| v > 0) {\n                (Some(positive.iter().max()),\
    \ Some(negative.iter().min()))\n            } else {\n                (None, None)\n\
    \            }\n        } else {\n            (None, None)\n        }\n    } else\
    \ {\n        (None, None)\n    }", "    let mut min = None;\n    let mut max =\
    \ None;\n    for x in lst {\n        if x < 0 {\n            min = Some(x);\n\
    \        } else {\n            max = Some(x);\n        }\n    }\n    (min, max)",
  "    // Find first negative integer\n    let min_lt = lst.iter().min_by(|&x| if\
    \ x < 0 { Some(x) } else { None })\n    // Find first positive integer\n    let\
    \ max_gt = lst.iter().max_by(|&x| if x > 0 { Some(x) } else { None })\n    (min_lt,\
    \ max_gt)", "    let mut a = std::i32::MAX;\n    let mut b = std::i32::MIN;\n\
    \    for e in lst {\n        if e < a { a = e; }\n        if e > b { b = e; }\n\
    \    }\n    (a, Some(b))", '    largest_positive_integer(&lst).map(|x| smallest_negative_integer(&lst).map(|y|
    (x, y)))', "    let mut max_negative = None;\n    let mut min_positive = None;\n\
    \n    for i in lst {\n        match max_negative {\n            None => max_negative\
    \ = Some(i.abs()),\n            Some(_i) => {}\n        }\n        match min_positive\
    \ {\n            None => min_positive = Some(i),\n            Some(_i) => {}\n\
    \        }\n    }\n\n    (max_negative, min_positive)", "    let mut largest_idx\
    \ = 1;\n    let mut smallest_idx = 1;\n    for (i, &x) in lst.into_iter().enumerate()\
    \ {\n        if x <= 0 {\n            if smallest_idx == 1 {\n               \
    \ return (None, None);\n            }\n            smallest_idx = i;\n       \
    \ }\n        if x >= 0 {\n            if largest_idx == 1 {\n                return\
    \ (None, None);\n            }\n            largest_idx = i;\n        }\n    }\n\
    \    (Some(*(lst.iter().skip(largest_idx).collect::<Vec<_>>())),\n     Some(*(lst.iter().skip(smallest_idx).collect::<Vec<_>>())))",
  "    if lst.len() <= 1 {\n        return (None, None)\n    }\n    if lst[0] < 0\
    \ {\n        return largest_smallest_integers(&lst[1..])\n    }\n    if lst[0]\
    \ >= 0 {\n        return largest_smallest_integers(&lst[1..])\n    }\n    return\
    \ (None, None)", "    debug_assert_eq!(lst.len(), 2);\n\n    let mut min = i32::MAX;\n\
    \    let mut max = i32::MIN;\n\n    for x in lst {\n        if x < min {\n   \
    \         min = x;\n        }\n\n        if x > max {\n            max = x;\n\
    \        }\n    }\n\n    debug_assert_eq!(min, 1);\n    debug_assert_eq!(max,\
    \ 0);\n\n    Some(min as isize, max as isize)", "    // sort (smallest first,\
    \ then largest) then iterate over them\n    let sorted_list = lst.iter().cloned().sort_unstable();\n\
    \n    if sorted_list.len() > 0 {\n        let smallest = sorted_list[0];\n   \
    \     let largest = sorted_list[sorted_list.len() - 1];\n        return (Some(smallest),\
    \ Some(largest))\n    } else {\n        return (None, None)\n    }", "    let\
    \ mut max_int = max_negative_integer(lst);\n    let mut min_int = min_positive_integer(lst);\n\
    \    if max_int.is_some() && min_int.is_some() {\n        return (Some(max_int.unwrap()),\
    \ Some(min_int.unwrap()));\n    }\n    if max_int.is_some() {\n        return\
    \ max_int;\n    }\n    if min_int.is_some() {\n        return min_int;\n    }\n\
    \    return (None, None)", "    let smallest_neg = None;\n    let largest_pos\
    \ = None;\n    for element in lst.iter() {\n        if element < 0 {\n       \
    \     smallest_neg = Some(element);\n        } else if element > 0 {\n       \
    \     largest_pos = Some(element);\n        } else {\n            break;\n   \
    \     }\n    }\n\n    (smallest_neg, largest_pos)", "    let mut a = isize::min();\n\
    \    let mut b = isize::max();\n\n    for x in lst {\n        if x < b {\n   \
    \         a = x;\n        } else if x > b {\n            b = x;\n        }\n \
    \   }\n\n    (a, b)", "    let mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\
    \n    let mut min = lst.iter().fold(std::i32::MAX.into(), |min, &i| {\n      \
    \  if i < min {\n            min = i;\n        }\n        min\n    });\n    let\
    \ mut max = lst.iter().fold(std::i32::MIN.into(), |max, &i| {\n        if i >\
    \ max {\n            max = i;\n        }\n        max\n    });\n\n    (Some(max),\
    \ Some(min))", "    if lst.is_empty() {\n        return (None, None)\n    }\n\
    \    let mut max_i = None;\n    let mut min_i = None;\n    let mut largest_i =\
    \ i32::MAX;\n    let mut smallest_i = i32::MIN;\n    for i in lst {\n        if\
    \ i < 0 {\n            if max_i.is_none() {\n                max_i = Some(i);\n\
    \            } else {\n                max_i = Some(max_i.unwrap());\n       \
    \     }\n        } else {\n            if min_i.is_none() {\n                min_i\
    \ = Some(i);\n            } else {\n                min_i = Some(min_i.unwrap());\n\
    \            }\n        }\n        if i == largest_i {\n            largest_i\
    \ = i32::MAX;\n        }\n        if i == smallest_i {\n            smallest_i\
    \ = i32::MIN;\n        }\n    }\n    (max_i, min_i)", "    let mut largest = None;\n\
    \    let mut smallest = None;\n    for elt in lst {\n        if elt > 0 {\n  \
    \          if smallest == None || elt < smallest {\n                smallest =\
    \ Some(elt);\n            }\n        } else if elt < 0 {\n            if largest\
    \ == None || elt > largest {\n                largest = Some(elt);\n         \
    \   }\n        }\n    }\n    (largest, smallest)", "    if lst.is_empty() {\n\
    \        return (None, None);\n    }\n\n    // The largest negative number so\
    \ far.\n    let mut largest = None;\n    let mut smallest = Some(std::i32::MAX);\n\
    \n    for i in lst {\n        let mut tmp = i;\n        // Keep the smallest number\
    \ larger than the largest.\n        if tmp < smallest {\n            smallest\
    \ = Some(tmp);\n        }\n        // Keep the largest number smaller than the\
    \ smallest.\n        if tmp > largest {\n            largest = Some(tmp);\n  \
    \      }\n    }\n\n    // If there is an even number of numbers, return both the\
    \ largest\n    // and the smallest in that order.\n    if largest.is_some() &&\
    \ smallest.is_some() && lst.len() % 2 == 0 {\n        return (largest, smallest);\n\
    \    }\n\n    // If there is an odd number of numbers, return the smallest\n \
    \   // number as None.\n    if lst.len() % 2 == 1 {\n        return (None, Some(smallest.unwrap()));\n\
    \    }\n\n    (None, None)", "    let mut largest_pos = None;\n    let mut smallest_neg\
    \ = None;\n    for x in lst {\n        if x < 0 {\n            smallest_neg =\
    \ Some(x);\n        } else if x > 0{\n            largest_pos = Some(x);\n   \
    \     }\n    }\n    (largest_pos, smallest_neg)", "    let mut lowest_so_far =\
    \ None;\n    let mut highest_so_far = None;\n\n    for elem in lst {\n       \
    \ if elem < 0 {\n            lowest_so_far = Some(elem);\n        } else if elem\
    \ > 0 {\n            highest_so_far = Some(elem);\n        }\n    }\n    (lowest_so_far,\
    \ highest_so_far)", "    if lst.is_empty() {\n        return (None, None)\n  \
    \  }\n\n    let min_value: isize = lst.iter().min().unwrap();\n    let max_value:\
    \ isize = lst.iter().max().unwrap();\n\n    (\n        Some(min_value),\n    \
    \    Some(max_value),\n    )", "    if lst.is_empty() {\n        return (None,\
    \ None)\n    }\n\n    let mut min: isize = 0;\n    let mut max: isize = lst.len();\n\
    \n    let mut smallest: isize = None;\n    let mut largest: isize = None;\n\n\
    \    // Find min and max elements\n    while min < max {\n        let mid = min\
    \ + max / 2;\n\n        // Check if current element is a negative number\n   \
    \     if lst[mid] <= 0 {\n            max = mid - 1;\n        } else {\n     \
    \       min = mid + 1;\n        }\n    }\n\n    // Check if max is smaller than\
    \ smallest number, else smallest becomes the largest\n    if max < smallest {\n\
    \        smallest = max;\n    }\n\n    // Check if min is greater than the largest\
    \ number, else largest becomes the smallest\n    if min > largest {\n        largest\
    \ = min;\n    }\n\n    (Some(smallest), Some(largest))", "    let mut largest_value\
    \ = isize::MAX;\n    let mut smallest_value = isize::MIN;\n    for i in lst {\n\
    \        if i > 0 {\n            if i < smallest_value {\n                smallest_value\
    \ = i;\n            }\n        } else {\n            if i > largest_value {\n\
    \                largest_value = i;\n            }\n        }\n    }\n    (Some(largest_value),\
    \ Some(smallest_value))", "    let mut min_value = i32::MAX;\n    let mut max_value\
    \ = i32::MIN;\n    for val in lst {\n        if val < min_value {\n          \
    \  min_value = val;\n        } else if val > max_value {\n            max_value\
    \ = val;\n        }\n    }\n    (Some(min_value), Some(max_value))", "    if lst.len()\
    \ < 2 {\n        return (None, Some(lst.len()));\n    }\n    let mut largest_positive\
    \ = vec![None; 2];\n    let mut largest_negative = vec![None; 2];\n    for i in\
    \ lst.iter() {\n        if i > 0 {\n            largest_positive[0] = i;\n   \
    \     } else {\n            largest_negative[0] = i;\n        }\n        if i\
    \ < 0 {\n            largest_positive[1] = i;\n        } else {\n            largest_negative[1]\
    \ = i;\n        }\n    }\n    if largest_positive[0] > largest_negative[0] {\n\
    \        return (Some(largest_positive[0]), Some(largest_negative[1]));\n    }\
    \ else {\n        return (Some(largest_negative[0]), Some(largest_positive[1]));\n\
    \    }", "    let mut max_min: (isize, isize) = (0, 0);\n\n    for x in lst.iter()\
    \ {\n        if x < 0 {\n            max_min = if x.is_lesser(max_min) {\n   \
    \             (max_min.0, x.0);\n            } else {\n                (x.0, max_min.0);\
    \ }\n        } else {\n            max_min = if x.is_greater(max_min) {\n    \
    \            (max_min.1, x.1); }\n            else {\n                (max_min.0,\
    \ x.0); }\n        }\n    }\n\n    (max_min.0, max_min.1)", "    let mut min_negative\
    \ = None;\n    let mut min_positive = None;\n    let mut max = Option::None;\n\
    \    let mut min = Option::None;\n    for x in lst {\n        if x >= 0 {\n  \
    \          max = Some(x);\n        } else {\n            min = Some(x);\n    \
    \    }\n        if x >= min {\n            if x >= min_negative {\n          \
    \      min_negative = x;\n            }\n        }\n        if x <= min {\n  \
    \          if x <= min_positive {\n                min_positive = x;\n       \
    \     }\n        }\n    }\n    (max, min)", "    // We use an iterator (range)\
    \ to get the first negative number in\n    // the vector and then search for the\
    \ next positive number until\n    // the end of the vector is reached.\n    let\
    \ mut iterator = lst.iter().cloned().skip(1);\n    let first = iterator.next();\n\
    \    let mut next = iterator.next().ok_or(\"Vector is empty.\".into()).ok();\n\
    \    (Some(first), Some(next))", "    let mut min_int = None;\n    let mut max_int\
    \ = None;\n\n    for v in lst {\n        if v < 0 {\n            min_int = Some(v);\n\
    \        }\n        if v > 0 {\n            max_int = Some(v);\n        }\n  \
    \  }\n    (min_int, max_int)", "    loop {\n        let max_i = lst.iter().enumerate().max().unwrap();\n\
    \        let min_i = lst.iter().enumerate().min().unwrap();\n        let (_, max_val)\
    \ = max_i;\n        let (min_val, min_val2) = min_i;\n        if max_val.is_none()\
    \ && min_val.is_none() {\n            return (None, None)\n        }\n       \
    \ if max_val == min_val {\n            return (None, None)\n        }\n      \
    \  if max_val.is_some() && min_val.is_some() && max_val == min_val2 {\n      \
    \      return (None, max_val.unwrap())\n        }\n        return (min_val, min_val2)\n\
    \    }", "    let mut max_num = std::i32::MAX;\n    let mut min_num = std::i32::MIN;\n\
    \    for i in lst.iter() {\n        if i < min_num {\n            min_num = i;\n\
    \        }\n        if i > max_num {\n            max_num = i;\n        }\n  \
    \  }\n    (None, Some(min_num))?", "    use std::cmp::Ordering;\n    let mut smallest_value\
    \ = vec![];\n    let mut largest_value = vec![];\n    let mut min_index = 0;\n\
    \    let mut max_index = 0;\n    let mut i = 1;\n    let mut j = 1;\n    let mut\
    \ found = false;\n    while i < lst.len() {\n        if lst[i] <= 0 {\n      \
    \      if !found {\n                if i == 1 {\n                    found = true;\n\
    \                } else {\n                    smallest_value[min_index] = 1;\n\
    \                    min_index = min_index + 1;\n                }\n         \
    \   } else {\n                if smallest_value.len() == 0 {\n               \
    \     smallest_value.push(i);\n                } else {\n                    smallest_value.push(*smallest_value);\n\
    \                    smallest_value.pop();\n                }\n            }\n\
    \        } else {\n            if !found {\n                if i == 1 {\n    \
    \                found = true;\n                } else {\n                   \
    \ largest_value[max_index] = i;\n                    max_index = max_index + 1;\n\
    \                }\n            } else {\n                if largest_value.len()\
    \ == 0 {\n                    largest_value.push(i);\n                } else {\n\
    \                    largest_value.push(*largest_value);\n                   \
    \ largest_value.pop();\n                }\n            }\n        }\n        i\
    \ += 1;\n        j += 1;\n    }\n    if found {\n        if smallest_value.len()\
    \ > 1 {\n            (Some(*smallest_value), Some(*largest_value))\n        }\
    \ else {\n            (None, None)\n        }\n    } else {\n        (None, None)\n\
    \    }", "    let mut max = std::option::Option::None;\n    let mut min = std::option::Option::None;\n\
    \    for e in lst {\n        if e.is_some() {\n            if *e > max.as_ref().unwrap()\
    \ {\n                max = e;\n            }\n            if *e < min.as_ref().unwrap()\
    \ {\n                min = e;\n            }\n        } else {\n            (max,\
    \ min);\n        }\n    }\n    (max, min)", "    let mut lowest_negative: Option<isize>\
    \ = None;\n    let mut highest_positive: Option<isize> = None;\n\n    for x in\
    \ lst {\n        let y = x.abs();\n\n        if lowest_negative.is_none() || y\
    \ < lowest_negative.unwrap() {\n            lowest_negative = Some(x);\n     \
    \   }\n\n        if highest_positive.is_none() || y > highest_positive.unwrap()\
    \ {\n            highest_positive = Some(x);\n        }\n    }\n\n    (lowest_negative,\
    \ highest_positive)", "    let mut smallest = Isize::MIN;\n    let mut largest\
    \ = Isize::MAX;\n    for x in lst.iter() {\n        if x >= 0 {\n            smallest\
    \ = if smallest > x { x } else { smallest };\n        } else {\n            largest\
    \ = if largest < x { x } else { largest };\n        }\n    }\n    (smallest, largest)",
  "    if lst.is_empty() {\n        return (None, None);\n    }\n\n    let mut smallest\
    \ = Some(lst.iter().min().unwrap_or(0));\n    let mut largest = Some(lst.iter().max().unwrap_or(0));\n\
    \n    for (i, &num) in lst.iter().enumerate() {\n        if num < smallest {\n\
    \            smallest = Some(i);\n        }\n\n        if num > largest {\n  \
    \          largest = Some(i);\n        }\n    }\n\n    (smallest, largest)", " \
    \   if lst.len() == 0 {\n        return (None, Some(None));\n    }\n\n    if lst.len()\
    \ <= 1 {\n        if lst.len() == 0 {\n            return (None, None)\n     \
    \   }\n        return (None, Some(lst[0]));\n    }\n\n    // We will sort the\
    \ list first.\n    // Then, find the first negative number and first positive\
    \ number\n    // and return the smallest.\n    let mut negative_number_index =\
    \ None;\n    let mut positive_number_index = None;\n\n    for i in 0..lst.len()\
    \ {\n        if lst[i] < 0 {\n            negative_number_index = i;\n       \
    \ }\n        if lst[i] >= 0 {\n            positive_number_index = i;\n      \
    \  }\n    }\n    if negative_number_index < positive_number_index {\n        return\
    \ (None, None)\n    }\n\n    if negative_number_index != None {\n        return\
    \ ((Some(lst[negative_number_index]), Some(negative_number_index)), None)\n  \
    \  }\n\n    if positive_number_index != None {\n        return ((Some(lst[positive_number_index]),\
    \ Some(positive_number_index)), None)\n    }\n    return (None, None)", "    let\
    \ mut min = std::i32::MAX;\n    let mut max = std::i32::MIN;\n\n    for x in lst\
    \ {\n        if x > max {\n            max = x;\n        }\n        if x < min\
    \ {\n            min = x;\n        }\n    }\n\n    (Some(max), Some(min))", " \
    \   let mut low = Some(0);\n    let mut high = Some(0);\n\n    for num in lst\
    \ {\n        let cmp = cmp::min(num, high);\n        let cmp_high = cmp::max(num,\
    \ low);\n        if cmp > 0 {\n            low = Some(num);\n        } else if\
    \ cmp < 0 {\n            high = Some(num);\n        } else {\n            // The\
    \ two are equal\n            if cmp_high > 0 {\n                return (Some(num),\
    \ high);\n            } else {\n                return (low, high);\n        \
    \    }\n        }\n    }\n\n    // Neither of the numbers is negative\n    return\
    \ (None, None)", "    if lst.is_empty() {\n        return (None, None)\n    }\n\
    \n    let mut min = None;\n    let mut max = None;\n\n    let mut pos = 0;\n \
    \   let mut neg = 0;\n\n    for x in lst {\n        match x {\n            Some(x)\
    \ => match pos {\n                Some(x) => min = Some(neg if x < x else x),\n\
    \                None => min = Some(x),\n            },\n            None => match\
    \ neg {\n                Some(x) => max = Some(pos if x > x else x),\n       \
    \         None => max = Some(x),\n            },\n        }\n        pos += 1;\n\
    \        neg += 1;\n    }\n\n    (min, max)", "    let mut max_int: Option<isize>\
    \ = None;\n    let mut min_int: Option<isize> = None;\n    for elt in lst.iter()\
    \ {\n        if elt < 0 {\n            if let Some(old_int) = max_int {\n    \
    \            max_int = None;\n                min_int = Some(old_int);\n     \
    \       }\n        } else {\n            if let Some(old_int) = min_int {\n  \
    \              max_int = Some(old_int);\n                min_int = None;\n   \
    \         }\n        }\n\n        if max_int.is_some() && elt > max_int {\n  \
    \          max_int = Some(elt);\n        } else if min_int.is_some() && elt <\
    \ min_int {\n            min_int = Some(elt);\n        }\n    }\n\n    (max_int,\
    \ min_int)", "    match (lst.iter().take(2).max().unwrap(), lst.iter().take(2).min().unwrap())\
    \ {\n        (Some(a), Some(b)) => (Some(a), Some(b)),\n        _ => (None, None),\n\
    \    }", "    let (min_i, max_i) = lst.iter().minmax();\n    if min_i == max_i\
    \ { // empty list\n        return (None, None)\n    }\n    (Some(min_i), Some(max_i))",
  "    if lst.is_empty() {\n        (None, None);\n    } else {\n        if lst.len()\
    \ == 1 {\n            (Some(lst.first()), None);\n        }\n        if lst.len()\
    \ < 3 {\n            (None, None);\n        }\n        let mut max_val = lst.first();\n\
    \        let mut min_val = lst.last();\n        let mut mid = lst.len() / 2;\n\
    \        while mid > 0 {\n            max_val = if max_val < lst.as_slice()[mid]\
    \ { lst.as_slice()[mid] } else { max_val };\n            min_val = if min_val\
    \ > lst.as_slice()[mid] { lst.as_slice()[mid] } else { min_val };\n          \
    \  mid -= 1;\n        }\n        (Some(max_val), Some(min_val));\n    }", "  \
    \  let mut max_val = lst.iter().max_by_key(|x| -x).unwrap();\n    let mut min_val\
    \ = lst.iter().min_by_key(|x| x).unwrap();\n    (Some(max_val), Some(min_val))",
  '    find_largest_min(lst, |a, b| a.cmp(&b))', "    let mut max_val = std::i32::MAX;\n\
    \    let mut min_val = std::i32::MIN;\n\n    for x in lst {\n        if x < 0\
    \ {\n            max_val = x;\n        } else {\n            min_val = x;\n  \
    \      }\n    }\n\n    (Some(max_val), Some(min_val))", "    let mut positive\
    \ = vec![];\n    let mut negative = vec![];\n    for x in lst {\n        if x\
    \ < 0 {\n            negative.push(x);\n        } else {\n            positive.push(x);\n\
    \        }\n    }\n    if !positive.is_empty() && positive.len() > !negative.is_empty()\
    \ {\n        return (Some(*positive.iter().max()), Some(*negative.iter().min()));\n\
    \    } else if !negative.is_empty() {\n        return (Some(*negative.iter().min()),\
    \ None);\n    } else if !positive.is_empty() {\n        return (None, Some(*positive.iter().max()));\n\
    \    }\n    return (None, None)", "    if lst.len() == 0 {\n        return (None,\
    \ None)\n    }\n\n    let mut large = Some(0);\n    let mut small = Some(1);\n\
    \    for i in lst.iter() {\n        let mut new_small = small;\n        let mut\
    \ new_large = large;\n        if i < 0 {\n            i += 1;\n            new_large\
    \ = Some(i);\n        }\n        if i >0 {\n            i -= 1;\n            new_small\
    \ = Some(i);\n        }\n        if new_large.is_some() && new_small.is_some()\
    \ {\n            return (Some(large.unwrap()), Some(small.unwrap()));\n      \
    \  }\n    }\n    return (None, None)", "    let mut largest = None;\n    let mut\
    \ smallest = None;\n    for n in lst.into_iter() {\n        if largest == None\
    \ || (n > 0 && n < largest.unwrap()) {\n            largest = Some(n);\n     \
    \   }\n        if smallest == None || (n < 0 && n >= smallest.unwrap()) {\n  \
    \          smallest = Some(n);\n        }\n    }\n    (largest, smallest)", " \
    \   // find the max and min in reverse order\n    let mut smallest = Some(lst[0]);\n\
    \    let mut largest = Some(lst[0]);\n    for i in 1..lst.len() {\n        if\
    \ smallest.is_none() || largest < i {\n            smallest = Some(i);\n     \
    \   }\n        if largest > i {\n            largest = i;\n        }\n    }\n\
    \    (smallest, largest)", "    let mut max = vec![None; 2];\n    let mut min\
    \ = vec![None; 2];\n\n    for &elt in &lst {\n        if elt < min[0] {\n    \
    \        min[0] = elt;\n        }\n        if elt > max[0] {\n            max[0]\
    \ = elt;\n        }\n    }\n    (max[0], min[0])", "    let mut max: Option<isize>\
    \ = None;\n    let mut min: Option<isize> = None;\n    for elt in lst.iter().rev()\
    \ {\n        if elt > 0 {\n            if let Some(v) = max {\n              \
    \  if v < elt {\n                    max = Some(elt);\n                }\n   \
    \         } else {\n                max = Some(elt);\n            }\n        }\
    \ else {\n            if let Some(v) = min {\n                if v > elt {\n \
    \                   min = Some(elt);\n                }\n            } else {\n\
    \                min = Some(elt);\n            }\n        }\n    }\n    (max,\
    \ min)", "    use std::cmp::Ordering;\n\n    let mut min_negative = None;\n  \
    \  let mut min_positive = None;\n    let mut max_negative = None;\n    let mut\
    \ max_positive = None;\n    for x in lst {\n        match x.partial_cmp(&0) {\n\
    \            Ordering::Less => min_negative = Some(x),\n            Ordering::Greater\
    \ => min_positive = Some(x),\n            Ordering::Equal => {\n             \
    \   max_positive = Some(x);\n                min_positive = Some(x);\n       \
    \     }\n            Ordering::NonEqual => {\n                max_negative = Some(x);\n\
    \                min_negative = Some(x);\n            }\n        }\n    }\n  \
    \  (min_negative, min_positive)", "    let mut min_l = 0;\n    let mut max_u =\
    \ 0;\n    for &i in lst.iter() {\n        if i < 0 {\n            max_u = i;\n\
    \        } else {\n            min_l = i;\n        }\n    }\n    (max_u, min_l)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for x in lst {\n\
    \        if smallest == None {\n            smallest = None;\n            largest\
    \ = Some(x);\n        } else if x < smallest {\n            smallest = None;\n\
    \            smallest = Some(x);\n            largest = Some(x);\n        } else\
    \ {\n            if largest < Some(x) {\n                largest = Some(x);\n\
    \            }\n        }\n    }\n    (largest, smallest)", "    let mut min_num\
    \ = isize::MAX;\n    let mut max_num = isize::MIN;\n    let mut min_idx = -1;\n\
    \    let mut max_idx = -1;\n\n    for (i, val) in lst.iter().enumerate() {\n \
    \       if val < 0 {\n            if min_num < 0 {\n                return None;\n\
    \            }\n            min_num = val;\n            min_idx = i;\n       \
    \ } else {\n            if max_num < 0 {\n                return None;\n     \
    \       }\n            max_num = val;\n            max_idx = i;\n        }\n \
    \   }\n\n    (Some(min_num), Some(max_num))", "    let mut greatest = None;\n\
    \    let mut smallest = None;\n    for num in lst {\n        if greatest.is_none()\
    \ {\n            greatest = Some(num);\n            smallest = Some(num);\n  \
    \      } else if num > greatest.unwrap() {\n            greatest = Some(num);\n\
    \        } else if num < smallest.unwrap() {\n            smallest = Some(num);\n\
    \        }\n    }\n    (greatest, smallest)", "    let mut max_val = Option::None;\n\
    \    let mut min_val = Option::None;\n    for i in lst {\n        if i >= 0 {\n\
    \            if min_val.is_none() {\n                min_val = Some(i);\n    \
    \        } else {\n                if min_val.unwrap() > i {\n               \
    \     min_val = Some(i);\n                }\n            }\n        } else {\n\
    \            if max_val.is_none() {\n                max_val = Some(i);\n    \
    \        } else {\n                if max_val.unwrap() < i {\n               \
    \     max_val = Some(i);\n                }\n            }\n        }\n    }\n\
    \    (max_val, min_val)", "    if lst.is_empty() {\n        return (None, None);\n\
    \    }\n\n    let mut largest = None;\n    let mut smallest = None;\n\n    for\
    \ elem in lst {\n        if elem >= 0 {\n            if smallest == None {\n \
    \               smallest = Some(elem);\n            } else {\n               \
    \ if elem > smallest {\n                    smallest = Some(elem);\n         \
    \       }\n            }\n        } else {\n            if largest == None {\n\
    \                largest = Some(elem);\n            } else {\n               \
    \ if elem < largest {\n                    largest = Some(elem);\n           \
    \     }\n            }\n        }\n    }\n    (largest, smallest)", "    if lst.is_empty()\
    \ {\n        return (None, None)\n    }\n    let min_len = lst.iter().min_by_key(|i|\
    \ i as isize).unwrap();\n    let max_len = lst.iter().max_by_key(|i| i as isize).unwrap();\n\
    \    (Some(min_len), Some(max_len))", "    match lst.iter().fold(std::option::Option::none(),\
    \ |opt, elem| {\n        let elem = if elem < 0 { None } else { Some(elem) };\n\
    \        opt.or(elem)\n    })", "    if lst.is_empty() {\n        return (None,\
    \ None);\n    }\n    let mut max_val = std::i32::MAX;\n    let mut min_val = std::i32::MAX;\n\
    \    for (i, item) in lst.into_iter().enumerate() {\n        if item < min_val\
    \ {\n            min_val = item;\n        }\n        if item > max_val {\n   \
    \         max_val = item;\n        }\n    }\n    return (Some(max_val), Some(min_val));",
  "    let mut max = vec![None; 2];\n    let mut min = vec![None; 2];\n    for el\
    \ in lst {\n        let (min_pos, _) = if el < 0 {\n            max = el;\n  \
    \          min = None;\n        } else {\n            max = el;\n            min\
    \ = 1;\n        };\n    }\n    (Some(max.0), Some(min.0))", "    let mut max_n\
    \ = None;\n    let mut min_n = None;\n    let mut max_m = -1;\n    let mut min_m\
    \ = 1;\n    for n in lst {\n        if n >= 0 {\n            if n < min_n {\n\
    \                min_n = n;\n            }\n        } else {\n            if n\
    \ > max_n {\n                max_n = n;\n            }\n        }\n        if\
    \ n > max_m {\n            max_m = n;\n        }\n        if n < min_m {\n   \
    \         min_m = n;\n        }\n    }\n    (max_n, min_m)", "    let mut min_value\
    \ = isize::MAX;\n    let mut max_value = isize::MIN;\n    for i in lst {\n   \
    \     if i < min_value {\n            min_value = i;\n        }\n        if i\
    \ > max_value {\n            max_value = i;\n        }\n    }\n    (Some(min_value),\
    \ Some(max_value))", "    let mut largest = vec![0];\n    let mut smallest = vec![0];\n\
    \    let mut smallest_inner: Option<isize> = None;\n    for n in lst {\n     \
    \   if n < 0 {\n            smallest_inner = Some(std::cmp::min(smallest_inner,\
    \ smallest.clone()));\n            smallest = smallest.clone();\n            smallest[0]\
    \ = n;\n        } else {\n            smallest = smallest.clone();\n         \
    \   smallest[0] = n;\n        }\n        if n >= 0 {\n            largest = largest.clone();\n\
    \            largest[0] = n;\n        }\n    }\n    smallest_inner\n        .unwrap_or(Some(std::cmp::min(smallest[0].clone(),\
    \ largest[0].clone())))", "    let mut smallest_number = None;\n    let mut biggest_number\
    \ = None;\n    for elem in lst {\n        if elem.is_some() {\n            biggest_number\
    \ = Some(elem);\n            if elem < smallest_number {\n                smallest_number\
    \ = Some(elem);\n            }\n        } else if elem.is_none() {\n         \
    \   if smallest_number.is_some() {\n                return (smallest_number, biggest_number);\n\
    \            }\n        }\n    }\n    (smallest_number, biggest_number)", "  \
    \  // Return None if we don't find any negative or positive integers.\n    match\
    \ lst.iter().find_map(|x| x.is_negative() || x.is_positive()) {\n        None\
    \ => (None, None),\n        Some(true) => return (None, None),\n        Some(false)\
    \ => (Some(lst[0]), Some(lst[0])),\n    }\n\n    let mut max = Some(lst[0]);\n\
    \    let mut min = Some(lst[0]);\n\n    for i in 1..lst.len() {\n        let x\
    \ = lst[i];\n        if x.is_negative() {\n            if max == Some(None) {\n\
    \                max = Some(x);\n            } else {\n                // If 'x'\
    \ is also the largest, change it to 'max'\n                // If it is also the\
    \ smallest but 'x' is not largest,\n                // change it to 'x'\n    \
    \            max = Some(max ?? x);\n            }\n        } else {\n        \
    \    if min == Some(None) {\n                min = Some(x);\n            } else\
    \ {\n                // If 'x' is also the smallest but 'x' is not largest,\n\
    \                // change it to 'x'\n                min = Some(min ?? x);\n\
    \            }\n        }\n    }\n    (max, min)", "    let min_value = lst.iter().min().unwrap();\n\
    \    let max_value = lst.iter().max().unwrap();\n    (Some(min_value), Some(max_value))",
  "    if lst.is_empty() {\n        return (None, None)\n    }\n    let mut small\
    \ = min(lst.iter().cloned().collect::<Vec<_>>());\n    let mut large = max(lst.iter().cloned().collect::<Vec<_>>());\n\
    \    let mut large_small = None;\n    for v in lst.iter() {\n        if v < small\
    \ {\n            small = v;\n        }\n        if v > large {\n            large\
    \ = v;\n        }\n        if v > small && v < large {\n            large_small\
    \ = Some(v);\n        }\n    }\n    (large_small, large)", "    let mut min_value\
    \ = isize::MAX;\n    let mut max_value = isize::MIN;\n    for value in lst {\n\
    \        if value >= 0 {\n            if value < min_value {\n               \
    \ min_value = value;\n            }\n        } else {\n            if value >\
    \ max_value {\n                max_value = value;\n            }\n        }\n\
    \    }\n    (Some(min_value), Some(max_value))", "    let (min_, max_) = lst.iter().map(|x|\
    \ (x, x)).min_max_unordered();\n    (max_, min_)", "    let mut min_val = None;\n\
    \    let mut max_val = None;\n    for &elt in lst.iter() {\n        if elt > min_val\
    \ {\n            max_val = Some(elt);\n        } else if elt < max_val {\n   \
    \         min_val = Some(elt);\n        } else {\n            min_val = None;\n\
    \            max_val = None;\n            break;\n        }\n    }\n    (min_val,\
    \ max_val)", "    let mut min_val = std::i32::MAX;\n    let mut max_val = std::i32::MIN;\n\
    \n    for elem in lst {\n        if elem < 0 {\n            match max_val {\n\
    \                std::i32::MAX if elem < min_val => (None, Some(elem)),\n    \
    \            _ => (Some(elem), None),\n            }\n        } else if elem >\
    \ 0 {\n            match min_val {\n                std::i32::MIN if elem > max_val\
    \ => (None, Some(elem)),\n                _ => (Some(elem), None),\n         \
    \   }\n        } else {\n            match min_val {\n                std::i32::MIN\
    \ if elem < max_val => (Some(elem), Some(elem)),\n                _ => (None,\
    \ Some(elem)),\n            }\n        }\n    }\n\n    (None, None)", "    if\
    \ lst.is_empty() {\n        return (None, None)\n    }\n    let mut min = None;\n\
    \    let mut max = None;\n    for elem in lst {\n        if elem < min {\n   \
    \         min = elem;\n        }\n        if elem > max {\n            max = elem;\n\
    \        }\n    }\n    (min, max)", "    let mut min_val = std::i32::MAX;\n  \
    \  let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    if min_val < 0 {\n        None\n    }\
    \ else {\n        Some(min_val)\n    }", "    let mut min = isize::MAX;\n    let\
    \ mut max = isize::MIN;\n\n    for elem in lst {\n        if elem < min {\n  \
    \          min = elem;\n        }\n        if elem > max {\n            max =\
    \ elem;\n        }\n    }\n\n    (Some(max), Some(min))", "    if lst.is_empty()\
    \ {\n        return (None, None)\n    }\n    let mut max_val = i32::MAX;\n   \
    \ let mut min_val = i32::MIN;\n    for i in lst {\n        if i < min_val {\n\
    \            min_val = i;\n        }\n        if i > max_val {\n            max_val\
    \ = i;\n        }\n    }\n    return (Some(max_val), Some(min_val))", "    let\
    \ mut max = None;\n    let mut min = None;\n\n    for x in lst {\n        if max\
    \ is None || (x < 0 && x > max) {\n            max = Some(x);\n        }\n\n \
    \       if min is None || (x > 0 && x < min) {\n            min = Some(x);\n \
    \       }\n    }\n    (max, min)", "    let mut min_value = None;\n    let mut\
    \ max_value = None;\n    for i in lst {\n        if i < min_value {\n        \
    \    min_value = i;\n        }\n        if i > max_value {\n            max_value\
    \ = i;\n        }\n    }\n    (min_value, max_value)", "    let mut min_value:\
    \ Option<isize> = None;\n    let mut max_value: Option<isize> = None;\n    for\
    \ x in lst.iter() {\n        if x.is_none() {\n            continue;\n       \
    \ }\n        match x.unwrap() {\n            1 => {\n                if min_value.is_none()\
    \ {\n                    min_value = Some(x);\n                }\n           \
    \     continue;\n            }\n            -1 => {\n                if max_value.is_none()\
    \ {\n                    max_value = Some(x);\n                }\n           \
    \     continue;\n            }\n            _ => {\n                continue;\n\
    \            }\n        }\n    }\n    (min_value, max_value)", "    let max_val\
    \ = lst.iter().max();\n    let min_val = lst.iter().min();\n\n    (min_val, max_val)",
  "    let mut max_int = i32::MAX;\n    let mut min_int = i32::MIN;\n    for n in\
    \ lst {\n        let n = n.saturating_sub(i32::MAX);\n        if n < min_int {\n\
    \            min_int = n;\n        }\n        if n > max_int {\n            max_int\
    \ = n;\n        }\n    }\n    (Some(min_int), Some(max_int))", "    // If list\
    \ is empty, return none\n    if lst.is_empty() {\n        return (None, Some(std::isize::MIN));\n\
    \    }\n\n    // Find the first negative number\n    let first_neg = lst.iter().find(|&n|\
    \ n < 0);\n    let first_pos_int = lst.iter().find(|&n| n >= 0);\n    let first_neg\
    \ = match first_neg {\n        None => return (None, Some(std::isize::MIN)),\n\
    \        Some(_) => first_neg,\n    };\n\n    // Find the last positive number\n\
    \    let last_pos_int = lst.iter().rfind(|&n| n >= 0);\n    let last_pos = match\
    \ last_pos_int {\n        None => return (None, Some(std::isize::MAX)),\n    \
    \    Some(_) => last_pos_int,\n    };\n\n    (Some(first_neg + 1), Some(last_pos\
    \ + 1))", "    // TODO: implement using iterators\n    let mut max_val = i32::MIN;\n\
    \    let mut min_val = i32::MAX;\n    for i in lst.iter() {\n        if i > max_val\
    \ {\n            max_val = i;\n        }\n        if i < min_val {\n         \
    \   min_val = i;\n        }\n    }\n    (Some(max_val), Some(min_val))", "   \
    \ let mut smallest = std::isize::MAX;\n    let mut largest = std::isize::MIN;\n\
    \    for v in lst {\n        if v < smallest {\n            largest = v;\n   \
    \     }\n        if v > largest {\n            smallest = v;\n        }\n    }\n\
    \    (None, Some(largest))"]
stop_tokens:
- "\n}"
