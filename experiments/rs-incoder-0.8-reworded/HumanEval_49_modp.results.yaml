language: rs
name: HumanEval_49_modp
results:
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p + p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpe8sbolnv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut i = p;\n    while i >= n {\n        i -= n;\n    }\n    i\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpbgpka4vm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = p * (p - 1) * (p - 2) / 6;\n    for _ in 0..n {\n       \
    \ m = ((m + p) % p);\n    }\n    m\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpjhc_opel.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) % n + 1\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp7n8dayev.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut x = n;\n    let mut y = p;\n    while x > y {\n        y -= x;\n\
    \        x &= y - 1;\n    }\n    y\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpzy4l5gz8.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) % n + (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpojbqdphs.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n % p;\n    while n1 < 0 {\n        n1 += p;\n    }\n  \
    \  let mut n2 = n / p;\n    while n2 > 1 {\n        n2 -= p;\n    }\n    n1 *\
    \ n2\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmppwbl9mp1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = p;\n    while n > 0 && !(res % n ==\
    \ 0) {\n        res /= n;\n    }\n    res + 1\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpocc7s_1l.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p { n } else { p }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `101`,\n right: `2`', /tmp/tmppyr_45jv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n2 = n * 2;\n    while n2 > p + 1 {\n        n2 -= p + 1;\n \
    \   }\n    n2 % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpaa_fekkt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n - p\n    } else {\n        (p + (n - p)) % p\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1000`,\n right: `2`', /tmp/tmpy40v27iy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut a = p;\n    let mut b = p;\n    while n > 0 {\n        let t\
    \ = a % b;\n        a = b;\n        b = t;\n        n -= 1;\n    }\n    a\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp4ul1igg9.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n -= 1;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if p < 0 {\n        p = 0\n    }\n    p as isize * pow(2, n - 1)\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpyezcnggl.rs:16:18\n\
    \   |\n16 |     p as isize * pow(2, n - 1)\n   |                  ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n::mod_mul(p) == 0);\n    n::mod_mul(p)\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `n`\n\
    \  --> /tmp/tmplkb9ajj1.rs:13:19\n   |\n13 |     debug_assert!(n::mod_mul(p) ==\
    \ 0);\n   |                   ^ use of undeclared crate or module `n`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `n`\n  --> /tmp/tmplkb9ajj1.rs:14:5\n\
    \   |\n14 |     n::mod_mul(p)\n   |     ^ use of undeclared crate or module `n`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p % n) as usize % p\n}\n\nfn main() {\n    let candidate = modp;\n \
    \   assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixkgelnd.rs:13:24\n   |\n\
    13 |     (p % n) as usize % p\n   |                        ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpixkgelnd.rs:13:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n13 |     (p % n) as\
    \ usize % p\n   |     ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     ((p % n) as usize % p).try_into().unwrap()\n\
    \   |     +                    +++++++++++++++++++++\n\nerror[E0277]: cannot mod\
    \ `usize` by `isize`\n  --> /tmp/tmpixkgelnd.rs:13:22\n   |\n13 |     (p % n)\
    \ as usize % p\n   |                      ^ no implementation for `usize % isize`\n\
    \   |\n   = help: the trait `Rem<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0);\n    assert!(p);\n    let mut res = 1;\n    for _ in\
    \ 0..n {\n        res *= p;\n        res %= p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgov8ytk9.rs:14:5\n   |\n\
    14 |     assert!(p);\n   |     ^^^^^^^^^^ expected `bool`, found `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    mod {\n        fn modp(mut n: isize, mut p: isize) -> isize {\n     \
    \       n = n + (p - 1) / p;\n            if n % p == 0 {\n                n -=\
    \ p + 1;\n            }\n            n\n        }\n    }\n    modp(n, p)\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `{`\n  --> /tmp/tmpyut5stm3.rs:13:9\n\
    \   |\n13 |     mod {\n   |         ^ expected identifier\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n2 = pow2n(n);\n    let mut p2 = pow2n(p);\n    let mut res =\
    \ n2;\n    while p2 > 0 {\n        if n2 % p2 > 0 {\n            n2 -= p2;\n \
    \           res -= p2;\n        } else {\n            n2 -= p2;\n        }\n \
    \       p2 /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2n` in this scope\n  --> /tmp/tmpcv0v6so5.rs:13:18\n\
    \   |\n13 |     let mut n2 = pow2n(n);\n   |                  ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow2n` in this scope\n\
    \  --> /tmp/tmpcv0v6so5.rs:14:18\n   |\n14 |     let mut p2 = pow2n(p);\n   |\
    \                  ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let d = n%p;\n    if d == 0 {\n        d\n    } else {\n        p + d\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `3`', /tmp/tmpe5eg1uy8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    fn gcd(mut n: isize, mut p: isize) -> isize {\n        if n == 0 {\n\
    \            p\n        } else {\n            gcd(n % p, p)\n        }\n    }\n\
    \n    fn div_rec(mut n: isize, mut p: isize, mut r: isize) -> isize {\n      \
    \  if n == 0 {\n            return r\n        }\n        div_rec(n, (n % p), r)\n\
    \    }\n\n    if p != 1 {\n        if p == 2 {\n            return 1;\n      \
    \  }\n        return gcd(n, p) * div_rec(n, p * 2, 1)\n    }\n\n    if n == 0\
    \ {\n        return 1\n    }\n\n    gcd(n, p)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976529
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n as usize) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg9e2hak6.rs:13:20\n   |\n\
    13 |     (n as usize) % p\n   |                    ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg9e2hak6.rs:13:5\n   |\n12 | fn\
    \ modp(n: isize, p: isize) -> isize {\n   |                                -----\
    \ expected `isize` because of return type\n13 |     (n as usize) % p\n   |   \
    \  ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |     ((n as usize) % p).try_into().unwrap()\n   |     +                +++++++++++++++++++++\n\
    \nerror[E0277]: cannot mod `usize` by `isize`\n  --> /tmp/tmpg9e2hak6.rs:13:18\n\
    \   |\n13 |     (n as usize) % p\n   |                  ^ no implementation for\
    \ `usize % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    mod {\n        use num_bigint::{BigInt, Sign};\n        use std::cmp::Ordering;\n\
    \        use std::ops::{Add, Sub};\n\n        let n = n as usize;\n        let\
    \ p = p as usize;\n\n        // n is >= p, thus modular inverses are unique\n\
    \        if n == 0 {\n            1\n        } else if n > p {\n            n\
    \ & !p\n        } else if n < p {\n            n | !p\n        } else {\n    \
    \        let m = if n < p { p } else { p };\n\n            // m is odd, m has\
    \ at most n factors\n            if m % 2 == 1 {\n                n / 2\n    \
    \        } else {\n                let mut m = m / 2;\n                while m\
    \ % 2 == 0 {\n                    m /= 2;\n                }\n               \
    \ m + 1\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `{`\n  --> /tmp/tmpvruhvhmp.rs:13:9\n\
    \   |\n13 |     mod {\n   |         ^ expected identifier\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n > p {\n        n - p\n    } else {\n        p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpgv4uwgm_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let s = n;\n    while s > 0 && (s & 1) != 0 {\n        s /= 2;\n    }\n\
    \    return s * p % n;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `s`\n  --> /tmp/tmplvif3dgt.rs:15:9\n\
    \   |\n13 |     let s = n;\n   |         -\n   |         |\n   |         first\
    \ assignment to `s`\n   |         help: consider making this binding mutable:\
    \ `mut s`\n14 |     while s > 0 && (s & 1) != 0 {\n15 |         s /= 2;\n   |\
    \         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976523
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n * p % p).ceil() as isize\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ceil` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp1diuqd1y.rs:13:17\n   |\n13 |     (n * p % p).ceil() as\
    \ isize\n   |                 ^^^^ help: there is an associated function with\
    \ a similar name: `div_ceil`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) & n as isize\n}\n\nfn main() {\n    let candidate = modp;\n \
    \   assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpzqyi2wsd.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        _ => n,\n    }\n    n & ((p - 1)\
    \ << 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt1h47k72.rs:13:5\n   |\n\
    13 | /     match n {\n14 | |         0 => 1,\n15 | |         _ => n,\n16 | | \
    \    }\n   | |     ^- help: consider using a semicolon here\n   | |_____|\n  \
    \ |       expected `()`, found `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n + p - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpartgaoup.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) * (2 * n + 1) + (2 * n - 1)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `33`,\n right: `3`', /tmp/tmpxxvyf6h1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p + 1 - n\n    } else {\n        n % p\n    }\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp4z40p5gh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 1 {\n        1\n    }\n    else if n == 1 {\n        0\n    }\n\
    \    else if n == p {\n        n\n    }\n    else {\n        n\n    }\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpk2rbdau9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let rem = n % p;\n    n - rem\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp4coo4zun.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp4nnmrpa5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr8gcswqk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 { return 1; }\n    n - (n % p) % p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpfsg2fyjy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr8gcswqk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p * n + n) % p as isize\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp53wune3t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n as isize;\n    n %= p;\n    if n == 0 {\n        n = 1\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpnz6m5fyy.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n > 0);\n    assert!(p > 0);\n    assert!(p < modq(n));\n   \
    \ if n < 2 {\n        return n;\n    }\n    if n == 1 {\n        return p;\n \
    \   }\n    if n == 2 {\n        return n + (p - 1) / p;\n    }\n    if n % 2 ==\
    \ 0 {\n        if n % p == 0 {\n            return n;\n        }\n        if p\
    \ % n == 0 {\n            return n + (p - 1) / p;\n        }\n    }\n    if p\
    \ % n == 0 {\n        return n - p / n;\n    }\n    n + (p - 1)\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `modq` in this scope\n  --> /tmp/tmps8pjrrpa.rs:15:17\n\
    \   |\n15 |     assert!(p < modq(n));\n   |                 ^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p) as isize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp3p3pqhoi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n % p == 0 {\n        n\n    } else {\n        n + p - n % p\n   \
    \ }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpzc2codpp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let a = n / p;\n    let b = n % p;\n    if b < 0 {\n        b - p\n \
    \   } else {\n        b\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmprzaf2nvb.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 || (n & (n - 1)) == 0 {\n        return 1;\n    }\n    if p\
    \ > n {\n        return 0;\n    }\n    let mut t = p + (p - 1) * (p - 1) / 2;\n\
    \    while t < n {\n        if t % p == 0 {\n            return 0;\n        }\n\
    \        t += p;\n    }\n    return 1;\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcchmmuf3.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n % p == 0);\n    (n / p).floor() as isize\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7n899k83.rs:14:13\n   |\n14 |     (n / p).floor() as isize\n\
    \   |             ^^^^^ help: there is an associated function with a similar name:\
    \ `div_floor`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut mod = 0;\n    let mut result = 1;\n    while n > 0 {\n      \
    \  mod += n % p;\n        n /= p;\n    }\n    if n == 1 {\n        mod -= 1;\n\
    \    }\n    mod += 1;\n    if mod < 2 {\n        mod += p;\n    }\n    if mod\
    \ > p {\n        mod -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmpluzsh3b7.rs:13:13\n\
    \   |\n13 |     let mut mod = 0;\n   |             ^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n13 |   \
    \  let mut r#mod = 0;\n   |             ++\n\nerror: expected identifier, found\
    \ `+=`\n  --> /tmp/tmpluzsh3b7.rs:16:13\n   |\n16 |         mod += n % p;\n  \
    \ |             ^^ expected identifier\n\nerror: expected identifier, found `-=`\n\
    \  --> /tmp/tmpluzsh3b7.rs:20:13\n   |\n20 |         mod -= 1;\n   |         \
    \    ^^ expected identifier\n\nerror: expected identifier, found `+=`\n  --> /tmp/tmpluzsh3b7.rs:22:9\n\
    \   |\n22 |     mod += 1;\n   |         ^^ expected identifier\n\nerror: aborting\
    \ due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    mod_lt(p, n).unwrap_or(p)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `mod_lt` in this scope\n  --> /tmp/tmpquvcys8c.rs:13:5\n\
    \   |\n13 |     mod_lt(p, n).unwrap_or(p)\n   |     ^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n as usize % (p as usize)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb6eq9k7i.rs:13:5\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n13 |     n as usize % (p as\
    \ usize)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |     (n as usize % (p as usize)).try_into().unwrap()\n\
    \   |     +                         +++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        1 => p,\n        n => n % p\n   \
    \ }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpu6u23zjc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n %= p;\n    if n < 0 {\n        n += p;\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpwalv6pfq.rs:13:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n13 |     n %= p;\n   |     ^^^^^^ cannot\
    \ assign to immutable argument\n\nerror[E0384]: cannot assign to immutable argument\
    \ `n`\n  --> /tmp/tmpwalv6pfq.rs:15:9\n   |\n12 | fn modp(n: isize, p: isize)\
    \ -> isize {\n   |         - help: consider making this binding mutable: `mut\
    \ n`\n...\n15 |         n += p;\n   |         ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p *= -1;\n        n *= -1;\n    }\n    if p < 2 {\n\
    \        return n;\n    }\n\n    if n & (n - 1) == 0 {\n        // x is power\
    \ of two\n        if p == 1 {\n            return n;\n        }\n        // n\
    \ is power of two\n        if n == 1 {\n            return p;\n        }\n\n \
    \       // n is odd and p is even\n        if ((n >> 1) & p == 1) {\n        \
    \    return n + (n - 1) * (n - 1) / 2;\n        }\n        // n is even and p\
    \ is odd\n        if ((n >> 1) & p == 0) {\n            return n - 1 - (n - 1)\
    \ / 2;\n        }\n\n        // n is odd and p is odd\n        if ((n >> 1) &\
    \ p == 1) {\n            return n + (n - 1) * (n - 1) / 2;\n        }\n      \
    \  // n is even and p is even\n        if ((n >> 1) & p == 0) {\n            return\
    \ n - 1 - (n - 1) / 2;\n        }\n\n        // n is odd and p is even and x is\
    \ power of two\n        if ((n >> 1) & p == 1) {\n            return n + (n -\
    \ 1) * (n - 1) / 2;\n        }\n        // n is even and p is odd and x is power\
    \ of two\n        if ((n >> 1) & p == 0) {\n            return n - 1 - (n - 1)\
    \ / 2;\n        }\n\n        // n is even and p is even and x is power of two\
    \ and y is power of two\n        if ((n >> 1) & p == 1) {\n            return\
    \ n + (n - 1) * (n - 1) / 2;\n        }\n        // n is even and p is even and\
    \ x is power of two and y is odd.\n        if ((n >> 1) & p == 0) {\n        \
    \    return n - 1 - (n - 1) / 2;\n        }\n\n        // n is even and p is even\
    \ and x is power of two and y is even and y is power of two.\n        if ((n >>\
    \ 1) & p == 1) {\n            return n + (n - 1) * (n - 1) / 2;\n        }\n \
    \       // n is even and p is even and x is power of two and y is even and y is\
    \ odd.\n        if ((n >> 1) & p == 0) {\n            return n - 1 - (n - 1) /\
    \ 2;\n        }\n    }\n\n    // n is odd and p is odd\n    if n == 1 {\n    \
    \    return p;\n    }\n\n    // n is odd and p is even\n    if n == 0 {\n    \
    \    return n;\n    }\n\n    // n is even and p is odd\n    if p == 1 {\n    \
    \    return n - (n >> 1);\n    }\n\n    // n is even and p is even\n    if p ==\
    \ 0 {\n        return n - 1;\n    }\n\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk401solc.rs:32:12\n\
    \   |\n32 |         if ((n >> 1) & p == 1) {\n   |            ^              \
    \   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n32 -         if ((n >> 1) & p == 1) {\n32 +         if (n\
    \ >> 1) & p == 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n\
    \  --> /tmp/tmpk401solc.rs:36:12\n   |\n36 |         if ((n >> 1) & p == 0) {\n\
    \   |            ^                 ^\n   |\nhelp: remove these parentheses\n \
    \  |\n36 -         if ((n >> 1) & p == 0) {\n36 +         if (n >> 1) & p == 0\
    \ {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk401solc.rs:41:12\n\
    \   |\n41 |         if ((n >> 1) & p == 1) {\n   |            ^              \
    \   ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if ((n >> 1) &\
    \ p == 1) {\n41 +         if (n >> 1) & p == 1 {\n   | \n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmpk401solc.rs:45:12\n   |\n45\
    \ |         if ((n >> 1) & p == 0) {\n   |            ^                 ^\n  \
    \ |\nhelp: remove these parentheses\n   |\n45 -         if ((n >> 1) & p == 0)\
    \ {\n45 +         if (n >> 1) & p == 0 {\n   | \n\nwarning: unnecessary parentheses\
    \ around `if` condition\n  --> /tmp/tmpk401solc.rs:50:12\n   |\n50 |         if\
    \ ((n >> 1) & p == 1) {\n   |            ^                 ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n50 -         if ((n >> 1) & p == 1) {\n50 +       \
    \  if (n >> 1) & p == 1 {\n   | \n\nwarning: unnecessary parentheses around `if`\
    \ condition\n  --> /tmp/tmpk401solc.rs:54:12\n   |\n54 |         if ((n >> 1)\
    \ & p == 0) {\n   |            ^                 ^\n   |\nhelp: remove these parentheses\n\
    \   |\n54 -         if ((n >> 1) & p == 0) {\n54 +         if (n >> 1) & p ==\
    \ 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  -->\
    \ /tmp/tmpk401solc.rs:59:12\n   |\n59 |         if ((n >> 1) & p == 1) {\n   |\
    \            ^                 ^\n   |\nhelp: remove these parentheses\n   |\n\
    59 -         if ((n >> 1) & p == 1) {\n59 +         if (n >> 1) "
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p == p || p < 2);\n    n + p - 1\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `3`', /tmp/tmp8vv_3xiw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n - (p - 1)\n    } else {\n        p - (n - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-999`,\n right: `2`', /tmp/tmpv37cpirt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n * p <= ::std::i128::MAX);\n    let mut n = (n as i128)\
    \ % p;\n    if n == 0 {\n        n = p - 1;\n    }\n    n\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoyn2xf7k.rs:13:28\n   |\n\
    13 |     debug_assert!(n * p <= ::std::i128::MAX);\n   |                     \
    \       ^^^^^^^^^^^^^^^^ expected `isize`, found `i128`\n   |\nhelp: you can convert\
    \ an `i128` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |     debug_assert!(n * p <= ::std::i128::MAX.try_into().unwrap());\n   | \
    \                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoyn2xf7k.rs:14:31\n   |\n14 |     let mut n\
    \ = (n as i128) % p;\n   |                               ^ expected `i128`, found\
    \ `isize`\n\nerror[E0277]: cannot mod `i128` by `isize`\n  --> /tmp/tmpoyn2xf7k.rs:14:29\n\
    \   |\n14 |     let mut n = (n as i128) % p;\n   |                           \
    \  ^ no implementation for `i128 % isize`\n   |\n   = help: the trait `Rem<isize>`\
    \ is not implemented for `i128`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoyn2xf7k.rs:16:13\n\
    \   |\n14 |     let mut n = (n as i128) % p;\n   |                 ---------------\
    \ expected due to this value\n15 |     if n == 0 {\n16 |         n = p - 1;\n\
    \   |             ^^^^^ expected `i128`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoyn2xf7k.rs:18:5\n   |\n12 | fn modp(n: isize, p: isize)\
    \ -> isize {\n   |                                ----- expected `isize` because\
    \ of return type\n...\n18 |     n\n   |     ^ expected `isize`, found `i128`\n\
    \   |\nhelp: you can convert an `i128` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     n.try_into().unwrap()\n   |      ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more informati"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - ((p - 1) & (n - 1))\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1033`,\n right: `2`', /tmp/tmpl98hoigc.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // This could be sped up a bit by using a lookup table instead\n    //\
    \ of division repeatedly.\n    let mut mod = p;\n    let mut nn = n as isize;\n\
    \    while nn != 0 {\n        mod -= 1;\n        mod |= mod >> 1;\n        mod\
    \ |= mod >> 2;\n        mod |= mod >> 4;\n        mod |= mod >> 8;\n        mod\
    \ |= mod >> 16;\n        mod |= mod >> 32;\n        mod &= (mod - 1) as isize;\n\
    \        nn >>= 1;\n    }\n    mod\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmpl29kmyga.rs:15:13\n\
    \   |\n15 |     let mut mod = p;\n   |             ^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n15 |   \
    \  let mut r#mod = p;\n   |             ++\n\nerror: expected identifier, found\
    \ `-=`\n  --> /tmp/tmpl29kmyga.rs:18:13\n   |\n18 |         mod -= 1;\n   |  \
    \           ^^ expected identifier\n\nerror: expected identifier, found `}`\n\
    \  --> /tmp/tmpl29kmyga.rs:29:1\n   |\n29 | }\n   | ^ expected identifier\n\n\
    error: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p) as usize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp874rbbxj.rs:13:5\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n13 |     (n % p) as usize\n\
    \   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n13 |     ((n % p) as usize).try_into().unwrap()\n   |     +           \
    \     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    if n % p != 0 {\n        result = n - p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmpea1ntohr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n_inv = pow2n(n);\n    let mut result = 0;\n    while ((n_inv\
    \ % p) != 0) {\n        result += 1;\n        n_inv /= p;\n    }\n    if n_inv.is_zero()\
    \ {\n        1\n    } else {\n        result + n_inv\n    }\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2n` in this scope\n  --> /tmp/tmp9njc_mae.rs:13:21\n\
    \   |\n13 |     let mut n_inv = pow2n(n);\n   |                     ^^^^^ not\
    \ found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n\
    \  --> /tmp/tmp9njc_mae.rs:15:11\n   |\n15 |     while ((n_inv % p) != 0) {\n\
    \   |           ^                ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n15 -     while ((n_inv\
    \ % p) != 0) {\n15 +     while (n_inv % p) != 0 {\n   | \n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 0;\n    }\n    let mut a = p % n;\n    if\
    \ a < 0 {\n        a += n;\n    }\n    a\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpc13r6p4m.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ndiv: isize = n; // TODO: remove this ugly cast\n    while ndiv\
    \ > 0 {\n        if ndiv % p == 0 {\n            ndiv -= p;\n        } else {\n\
    \            break;\n        }\n    }\n    ndiv\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpdov2qc1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p) as usize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp874rbbxj.rs:13:5\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n13 |     (n % p) as usize\n\
    \   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n13 |     ((n % p) as usize).try_into().unwrap()\n   |     +           \
    \     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 0;\n    while n >= p {\n        n -= p;\n        result\
    \ += 1\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdib1ru2u.rs:15:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n15 |         n -= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p * n) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3zp665uw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n - p) % (p + 1) + (p + 1) % (p + 1) // mod p\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmpkaezuiv8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n > p { return n }\n    if p == 0 { return 0 }\n    if n == p { return\
    \ 1 }\n    if n >= p { return modp(n - p, p) }\n    let mut n2 = n;\n    let mut\
    \ n1 = n - p;\n    let mut r = n1;\n    while n1 % p == 0 && n1 != 0 {\n     \
    \   n1 /= p;\n        n2 /= p;\n        r += 1;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmp9yhnzonp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n % p != 0 {\n        n - n - p\n    } else {\n        n\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-5`,\n right: `3`', /tmp/tmpu43k08w1.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n <= 0 {\n        return 0;\n    }\n    if p <= 0 {\n        return\
    \ 1;\n    }\n    // We need to use |p - n| to make sure that p - n >= 0 for positive\
    \ integers.\n    let mut i = p - 1;\n    // We use |i & (p - 1)| instead of |p|\
    \ since |p| is guaranteed to be positive.\n    while i < n {\n        i = (i <<\
    \ 1) + 1;\n    }\n    i & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp4wxu1avh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    while n >= 2 {\n        result %= p;\n     \
    \   result *= 2;\n        n -= 1;\n    }\n    n % 2 != 0 ? result % p : result\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `result`\n\
    \  --> /tmp/tmppj0gjso3.rs:19:18\n   |\n19 |     n % 2 != 0 ? result % p : result\n\
    \   |                  ^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // return 0 if n < 0\n    if n < 0 {\n        return 0;\n    }\n\n  \
    \  if n < p {\n        return n;\n    }\n\n    let mut result = 1;\n    let mut\
    \ p = p;\n\n    while n > p {\n        result *= p;\n        p /= 2;\n    }\n\n\
    \    result % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976529
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p + 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp0dktzuau.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n != 0);\n    debug_assert!(p != 0);\n    if n % p == 0\
    \ {\n        n - p\n    } else {\n        n\n    }\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpf7oh45cl.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if p < 0 {\n        p *= -1\n\
    \    }\n    if p > n*n+n {\n        p %= n*n+n\n    }\n    let mut q = p - 1;\n\
    \    let mut r = n % p;\n    while q > 0 {\n        if r >= n {\n            q\
    \ %= r\n        } else {\n            r %= q\n        }\n    }\n    return r\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `p`\n  --> /tmp/tmpzxhkfsi2.rs:17:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                   - help:\
    \ consider making this binding mutable: `mut p`\n...\n17 |         p *= -1\n \
    \  |         ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `p`\n  --> /tmp/tmpzxhkfsi2.rs:20:9\n   |\n12 |\
    \ fn modp(n: isize, p: isize) -> isize {\n   |                   - help: consider\
    \ making this binding mutable: `mut p`\n...\n20 |         p %= n*n+n\n   |   \
    \      ^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n + (p - 1)) % (p + 1)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmptebcz3wv.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = p;\n    let mut mod = p;\n    while n > 0 {\n        mod\
    \ += 1;\n        res %= mod;\n        n -= 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmphl4gofgr.rs:14:13\n\
    \   |\n14 |     let mut mod = p;\n   |             ^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n14 |   \
    \  let mut r#mod = p;\n   |             ++\n\nerror: expected identifier, found\
    \ `+=`\n  --> /tmp/tmphl4gofgr.rs:16:13\n   |\n16 |         mod += 1;\n   |  \
    \           ^^ expected identifier\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) * (n % p + p) % p\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpb76lt1qn.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1) as isize\n}\n\nfn main() {\n    let candidate = modp;\n \
    \   assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmprjrb1x0i.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // We start by computing floor(log2(p)). If p is even, we use n and\n\
    \    // modpow(2, n, p) to get the final result. Otherwise, we can use p and\n\
    \    // modpow(2, p, n) to get the final result.\n    let log2_ = p::isize::log2();\n\
    \    let log2 = if p & 1 != 0 {\n        p >> 1\n    } else {\n        p\n   \
    \ };\n\n    let mut result = n;\n    let (log2, newp) = (log2, p >> 1);\n\n  \
    \  // Do binary search:\n    while log2 < log2_ {\n        // Compute the midpoint\
    \ of our range (2**(log2-log2)):\n        let mut mid = result + (result >> 1);\n\
    \        // And check whether it's less than p\n        if p > mid {\n       \
    \     result = mid;\n            (log2, newp) = (log2, p >> 1);\n        } else\
    \ {\n            result = mid;\n            (log2, newp) = (log2, newp << 1);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `p`\n\
    \  --> /tmp/tmprzo2t70h.rs:16:20\n   |\n16 |     let log2_ = p::isize::log2();\n\
    \   |                    ^^^^^ not found in `p`\n   |\nhelp: consider importing\
    \ this builtin type\n   |\n1  | use std::primitive::isize;\n   |\nhelp: if you\
    \ import `isize`, refer to it directly\n   |\n16 -     let log2_ = p::isize::log2();\n\
    16 +     let log2_ = isize::log2();\n   | \n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n + (p - 1)) as isize\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `3`', /tmp/tmpkzi8k2tc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= p);\n    let mut n2 = n;\n    n2 %= p;\n    while\
    \ n2 == 0 {\n        n2 += p;\n    }\n    if n2 > p {\n        n2 -= p;\n    }\n\
    \    n2\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n >= p'', /tmp/tmpk6t3h26b.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n * n / p;\n    let mut n2 = n - n1;\n    n1 += n2 % p;\n\
    \    n2 -= n2 % p;\n    n1 += n2 % p;\n    n2 -= n2 % p;\n    n1 += n2 % p;\n\
    \    n2 -= n2 % p;\n    n1 %= p;\n    n2 %= p;\n    n1 + n2\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpiqrij7gf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n & (n - 1) as isize == 0 {\n        return n - p;\n    }\n    n &\
    \ (n - 1) as isize + (p - 1) + (n - 1) & (p - 1)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpd2sgmxh6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n + p + 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmppshpo4ty.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        modp(n - p, p)\n    } else {\n        n % (p + 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `81`,\n right: `2`', /tmp/tmpadx9ynqx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n\n    } else {\n        n - p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmp7kov50dt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - p * n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-12`,\n right: `3`', /tmp/tmpv7hunk2s.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut i = n;\n    while i > 0 {\n        if n % p == 0 {\n        \
    \    return i;\n        }\n        i -= 1;\n    }\n    1\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpae7guf5w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match p {\n        0 => 1,\n        1 => n,\n        2 => n % p,\n  \
    \      _ => {\n            assert!(n != 0);\n            p % n\n        }\n  \
    \  }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpp8sm2vku.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1) + (((n / p) & !p) as isize)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpfjh4m8cz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match p.checked_mul(n as usize) {\n        Some(x) => x.checked_mod(p\
    \ as usize),\n        None => n,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpopg54zyv.rs:13:25\n   |\n\
    13 |     match p.checked_mul(n as usize) {\n   |                         ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n13 |     match p.checked_mul((n\
    \ as usize).try_into().unwrap()) {\n   |                         +          +++++++++++++++++++++\n\
    \nerror[E0599]: no method named `checked_mod` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpopg54zyv.rs:14:22\n   |\n14 |         Some(x) => x.checked_mod(p\
    \ as usize),\n   |                      ^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `checked_add`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        res |= (n & 1) << (n % 32);\n\
    \        n >>= 1;\n    }\n    res ^= p;\n    res %= p;\n    if res < 0 {\n   \
    \     res += p;\n    }\n    res >>= 1;\n    return res;\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsso58uod.rs:16:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n16 |         n >>= 1;\n   |     \
    \    ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    n %= p;\n    if n < 0 {\n\
    \        n += p;\n    }\n    n\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpl_jfnrup.rs:16:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n16 |     n %= p;\n   |     ^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `n`\n  --> /tmp/tmpl_jfnrup.rs:18:9\n   |\n12 | fn modp(n: isize, p:\
    \ isize) -> isize {\n   |         - help: consider making this binding mutable:\
    \ `mut n`\n...\n18 |         n += p;\n   |         ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!((p >= 1) && (p <= 100));\n    let mut npow = p;\n    let mut\
    \ nn = n;\n    while (nn > 1) {\n        npow = npow % p;\n        nn = nn * p\
    \ % p;\n    }\n    npow\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmprdm7ib0g.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n as isize % (p as isize)\n    } else {\n       \
    \ n as isize % (p as isize) + p as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `3`', /tmp/tmphpv1qvih.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n0 = n;\n    while n0 % p == 0 {\n        n0 /= p;\n    }\n \
    \   n0\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp3z7a7d1h.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n == 0 || p != 0);\n    n & (p - 1)\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpkcjbf9ub.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n > 0);\n    assert!(p > 0);\n    let mut n: isize = n;\n   \
    \ let mut remainder: isize = p;\n    let mut ret = 1;\n    while n > 0 {\n   \
    \     remainder, rem = divmod(n - 1, p);\n        ret = res * res + rem;\n   \
    \     n -= 1;\n    }\n    ret * remainder\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpd9vt4ly3.rs:19:18\n   |\n19 |         remainder, rem\
    \ = divmod(n - 1, p);\n   |                  ^ expected one of 8 possible tokens\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // TODO: assert p is coprime\n    let mut q = p;\n    loop {\n      \
    \  if n % q == 0 {\n            return q;\n        }\n        q *= 2;\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpg7wtdvnm.rs:19:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p - 1)*n + (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `3`', /tmp/tmp6y0i1qhb.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr8gcswqk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // we cannot use the much faster bit_xor() because that would also fail\
    \ for n < p.\n    if n < p && p % n == 0 {\n        n - (p % n)\n    } else {\n\
    \        n\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpef90yhtv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    loop {\n        if n < p { break; }\n        n -=\
    \ p;\n    }\n    n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmplpxo6djs.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = p % n;\n    if r > 0 {\n        r += n;\n    }\n    r\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpa1i8z6le.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    pow(p, n)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmphqsspfn8.rs:13:5\n\
    \   |\n13 |     pow(p, n)\n   |     ^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n <= p {\n        n\n    } else {\n        (p - 1) * (n / p)\n   \
    \ }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1000`,\n right: `2`', /tmp/tmpfhcvo45z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n < p {\n        return\
    \ modp(n - p, p);\n    }\n    if n < p {\n        return 1;\n    }\n    if n ==\
    \ p {\n        return n;\n    }\n    if n < p {\n        return modp(n - p, p);\n\
    \    }\n    let mut dp = p;\n    while n >= dp {\n        dp *= p;\n        n\
    \ -= dp;\n    }\n    n %= p;\n    dp *= p;\n    while n > 0 {\n        dp *= p;\n\
    \        n -= dp;\n    }\n    dp %= p;\n    dp\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpr8umpsmf.rs:31:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n31 |         n -= dp;\n   |     \
    \    ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign\
    \ to immutable argument `n`\n  --> /tmp/tmpr8umpsmf.rs:33:5\n   |\n12 | fn modp(n:\
    \ isize, p: isize) -> isize {\n   |         - help: consider making this binding\
    \ mutable: `mut n`\n...\n33 |     n %= p;\n   |     ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpr8umpsmf.rs:37:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n37 |         n -= dp;\n   |     \
    \    ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    modpow_base(p, n)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `modpow_base` in this scope\n  --> /tmp/tmpwhyjwwj8.rs:13:5\n\
    \   |\n13 |     modpow_base(p, n)\n   |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n == 0 || n == 1);\n    (n + p - 1) % p\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n == 0 || n == 1'', /tmp/tmp1qv0kop1.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - p % n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpb5t0sdh0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr8gcswqk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = p % n;\n    if m == 0 {\n        m += n;\n    }\n    m\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpsc0of6y_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= 0 {\n        (p - 1) % n\n    } else {\n        (n - 1) % p\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpnh_kgzon.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    use std::cmp::Ordering;\n    let mut r = n;\n    let mut nn = r as isize;\n\
    \    let mut rp = rp as isize;\n    while rp >= p {\n        if rp < p {\n   \
    \         nn = nn - 1;\n        }\n        r = r - 1;\n        if r < 0 {\n  \
    \          break;\n        }\n        rp = rp as isize;\n    }\n    let mut r\
    \ = r;\n    let mut rpp = rp as isize;\n    while rp >= p {\n        if rp < p\
    \ {\n            nn = nn + 1;\n        }\n        r = r + 1;\n        if r > p\
    \ {\n            break;\n        }\n        rp = rp as isize;\n    }\n    r\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `rp` in this scope\n  --> /tmp/tmp8hztczhp.rs:16:18\n\
    \   |\n16 |     let mut rp = rp as isize;\n   |                  ^^ help: a local\
    \ variable with a similar name exists: `p`\n\nwarning: unused import: `std::cmp::Ordering`\n\
    \  --> /tmp/tmp8hztczhp.rs:13:9\n   |\n13 |     use std::cmp::Ordering;\n   |\
    \         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by\
    \ default\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut s = p;\n    s.checked_mul(n as usize).unwrap();\n    s\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg083es9s.rs:14:19\n   |\n\
    14 |     s.checked_mul(n as usize).unwrap();\n   |                   ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |     s.checked_mul((n\
    \ as usize).try_into().unwrap()).unwrap();\n   |                   +         \
    \ +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n as isize) % (p as isize)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpego_wgdj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n <= p);\n    n - p.powi(p.bits() - n.bits())\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `powi` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpmizerdjm.rs:14:11\n   |\n14 |     n - p.powi(p.bits() -\
    \ n.bits())\n   |           ^^^^ help: there is an associated function with a\
    \ similar name: `pow`\n\nerror[E0599]: no method named `bits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpmizerdjm.rs:14:18\n   |\n14 |     n - p.powi(p.bits()\
    \ - n.bits())\n   |                  ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `bits` found for type `isize` in the current scope\n  --> /tmp/tmpmizerdjm.rs:14:29\n\
    \   |\n14 |     n - p.powi(p.bits() - n.bits())\n   |                        \
    \     ^^^^ method not found in `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut rem: isize = 0;\n    while n >= p {\n        rem += 1;\n    \
    \    n -= p;\n    }\n    rem\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp6t1cktiz.rs:16:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n16 |         n -= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p {\n        let mut a = n;\n        let mut b = p;\n        while\
    \ a % b != 0 {\n            a += b;\n            b += p;\n        }\n        b\
    \ %= p;\n        a\n    } else {\n        p\n    }\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976530
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 0;\n    }\n    if p == 0 {\n        return\
    \ 1;\n    }\n    let m = p * p % n;\n    if m < p && n < m {\n        return m;\n\
    \    }\n    if n < p && m % n == 0 {\n        return n;\n    }\n    if n < m {\n\
    \        return n;\n    }\n    return m;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmp4ejqet8e.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert_eq!(n, p % 2, \"Argument must be positive\");\n    n / 2\
    \ % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `1`: Argument must be positive', /tmp/tmpki94s3cg.rs:13:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n % p {\n        0 => n - p,\n        1 => n,\n        _ => p +\
    \ (n - p) % p,\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `192`,\n right: `2`', /tmp/tmpb2wmlvvl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 || p == 0 {\n        0\n    } else {\n        n % (p as usize)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb7eehd6x.rs:16:13\n   |\n\
    16 |         n % (p as usize)\n   |             ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpb7eehd6x.rs:16:11\n\
    \   |\n16 |         n % (p as usize)\n   |           ^ no implementation for `isize\
    \ % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n as isize;\n    let mut p = p as isize;\n    let mut result\
    \ = 1;\n    while n >= p && result > 0 {\n        result = result % p;\n     \
    \   n /= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpwww6k2l0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut nn = n;\n    let mut np = p;\n    while nn >= 10 {\n        nn\
    \ = (nn - n % 10) as isize;\n        np = (np - n % 10) as isize;\n    }\n   \
    \ (nn % p) as isize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `2`', /tmp/tmpfes5nad2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = p;\n    loop {\n        if n % result < 0 {\n      \
    \      result -= 1;\n        } else {\n            return result + p;\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `3`', /tmp/tmpf6ayhpud.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 1);\n    if n == 1 {\n        p - 1\n    } else {\n\
    \        let mut r = p % n;\n        if r == 0 {\n            r - p / n\n    \
    \    } else {\n            r\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpg5xievwy.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n <= p {\n        return\
    \ n\n    }\n    return n % p\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpu5d2lzqc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => p,\n        _ => n % p,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpfc60mrt_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = p;\n    while m > 1 && n >= pow2(m - 1) {\n        m -= 1;\n\
    \    }\n    m\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmpo0ve8c57.rs:14:25\n\
    \   |\n14 |     while m > 1 && n >= pow2(m - 1) {\n   |                      \
    \   ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let r = p % n;\n    if r == 0 {\n        return 1;\n    }\n    return\
    \ r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps_hrjno6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0 && p >= 0);\n    let mut t = n;\n    t %= p;\n \
    \   if t == 0 {\n        1\n    } else {\n        t * (p + (t & -p))\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `3`', /tmp/tmpa8x9m7m8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n % (p as u64)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2g5uow9z.rs:13:9\n   |\n\
    13 |     n % (p as u64)\n   |         ^^^^^^^^^^ expected `isize`, found `u64`\n\
    \nerror[E0277]: cannot mod `isize` by `u64`\n  --> /tmp/tmp2g5uow9z.rs:13:7\n\
    \   |\n13 |     n % (p as u64)\n   |       ^ no implementation for `isize % u64`\n\
    \   |\n   = help: the trait `Rem<u64>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n <= p { n } else { p }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `101`,\n right: `2`', /tmp/tmpc329dv20.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n ^ (n >> usize::from(p))\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: From<isize>` is not satisfied\n \
    \ --> /tmp/tmpj9v4yjao.rs:13:15\n   |\n13 |     n ^ (n >> usize::from(p))\n  \
    \ |               ^^^^^^^^^^^ the trait `From<isize>` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32\
    \ as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // use bigint to avoid numeric overflow\n    (1u64 << n).wrapping_add(p.wrapping_mul(1u64\
    \ << n))\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph6xf70b7.rs:14:45\n   |\n\
    14 |     (1u64 << n).wrapping_add(p.wrapping_mul(1u64 << n))\n   |           \
    \                                  ^^^^^^^^^ expected `isize`, found `u64`\n \
    \  |\nhelp: you can convert a `u64` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n14 |     (1u64 << n).wrapping_add(p.wrapping_mul((1u64 <<\
    \ n).try_into().unwrap()))\n   |                                             +\
    \         +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph6xf70b7.rs:14:30\n\
    \   |\n14 |     (1u64 << n).wrapping_add(p.wrapping_mul(1u64 << n))\n   |    \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     (1u64 << n).wrapping_add(p.wrapping_mul(1u64\
    \ << n).try_into().unwrap())\n   |                                           \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph6xf70b7.rs:14:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n13 |     // use bigint\
    \ to avoid numeric overflow\n14 |     (1u64 << n).wrapping_add(p.wrapping_mul(1u64\
    \ << n))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n14 |     (1u64 << n).wrapping_add(p.wrapping_mul(1u64\
    \ << n)).try_into().unwrap()\n   |                                           \
    \             ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n % p {\n        0 => 0,\n        n => n - n % p + p,\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpw9b381d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1\n    }\n    n & (n - 1) + (p - 1) & p\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1j_ddxpw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n > 0);\n    assert!(p > 0);\n    let mut result = p;\n    for\
    \ _ in 0..n {\n        result *= 2;\n    }\n    result % p\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpwfif2w2h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    p % n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp8ibg3u1w.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result: isize = 1;\n    while result <= n {\n        result *=\
    \ p;\n        p /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `p`\n  --> /tmp/tmpnxxko39o.rs:16:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                   - help:\
    \ consider making this binding mutable: `mut p`\n...\n16 |         p /= 2;\n \
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if p <= 1 { return 0 }\n    if n < 0 { return 1 }\n    if p < 2 { panic!(\"\
    p should be greater than 1\") }\n    if n <= p { return 1 }\n    if n == p { return\
    \ n }\n    let mut r = 1;\n    while n > p { r <<= 1; n -= p }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpohzdx46n.rs:19:28\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |     while n > p { r <<= 1; n\
    \ -= p }\n   |                            ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p.is_positive());\n\n    let mut ns: isize = n;\n    while ns\
    \ < p {\n        ns <<= 1;\n    }\n    ns\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `3`', /tmp/tmpvi6akf6x.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // `p` can't be zero because\n    // `n % p != 0` will fail if `p ==\
    \ 0`\n    if p == 0 {\n        p = 1\n    }\n\n    n % p\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `p`\n  --> /tmp/tmp5o5_pt0f.rs:16:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                   - help:\
    \ consider making this binding mutable: `mut p`\n...\n16 |         p = 1\n   |\
    \         ^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(p > 0);\n    let mut n = n as isize;\n    if p == 0 {\n\
    \        return 1;\n    }\n    while n > p {\n        n -= p;\n    }\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpq6o09c2m.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n % (p + p / 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `44`,\n right: `2`', /tmp/tmp0kkoqxib.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if p < 2 {\n        return 0;\n    }\n    if p > n {\n        return\
    \ p % n;\n    }\n    p %= n;\n    if p < 2 {\n        return 0;\n    }\n    p\
    \ -= 2;\n    if p < 2 {\n        return p;\n    }\n    p %= n;\n    if p < 3 {\n\
    \        return p;\n    }\n    p -= 3;\n    if p < 3 {\n        return p;\n  \
    \  }\n    p %= n;\n    if p < 5 {\n        return p;\n    }\n    p -= 5;\n   \
    \ if p < 5 {\n        return p;\n    }\n    p %= n;\n    if p < 7 {\n        return\
    \ p;\n    }\n    p -= 7;\n    if p < 7 {\n        return p;\n    }\n    p %= n;\n\
    \    if p < 9 {\n        return p;\n    }\n    p -= 9;\n    if p < 9 {\n     \
    \   return p;\n    }\n    p %= n;\n    if p < 11 {\n        return p;\n    }\n\
    \    p -= 11;\n    if p < 11 {\n        return p;\n    }\n    p %= n;\n    if\
    \ p < 13 {\n        return p;\n    }\n    p -= 13;\n    if p < 13 {\n        return\
    \ p;\n    }\n    p %= n;\n    if p < 15 {\n        return p;\n    }\n    p -=\
    \ 15;\n    if p < 15 {\n        return p;\n    }\n    p %= n;\n    if p < 17 {\n\
    \        return p;\n    }\n    p -= 17;\n    if p < 17 {\n        return p;\n\
    \    }\n    p %= n;\n    if p < 19 {\n        return p;\n    }\n    p -= 19;\n\
    \    if p < 19 {\n        return p;\n    }\n    p %= n;\n    if p < 21 {\n   \
    \     return p;\n    }\n    p -= 21;\n    if p < 21 {\n        return p;\n   \
    \ }\n    p %= n;\n    if p < 23 {\n        return p;\n    }\n    p -= 23;\n  \
    \  if p < 23 {\n        return p;\n    }\n    p %= n;\n    if p < 25 {\n     \
    \   return p;\n    }\n    p -= 25;\n    if p < 25 {\n        return p;\n    }\n\
    \    p %= n;\n    if p < 27 {\n        return p;\n    }\n    p -= 27;\n    if\
    \ p < 27 {\n        return p;\n    }\n    p %= n;\n    if p < 29 {\n        return\
    \ p;\n    }\n    p -= 29;\n    if p < 29 {\n        return p;\n    }\n    p %=\
    \ n;\n    if p \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpqsy_sja6.rs:141:1\n    |\n\
    140 |     if p \n    |     -- this `if` expression has a condition, but no block\n\
    141 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    if result % p != 0 {\n        result = result\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpsbf5mc8w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p {\n        n + (p - n) % p\n    } else {\n        (n - (n mod\
    \ p)) % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found keyword `mod`\n  --> /tmp/tmph8_jdzfn.rs:16:17\n   |\n16 |         (n\
    \ - (n mod p)) % p\n   |                 ^^^ expected one of 8 possible tokens\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut q = p;\n    let mut r = 0x1f;\n    loop {\n        let mut c\
    \ = 0;\n        while r != 0 {\n            if n % r == 0 {\n                c\
    \ += 1;\n            }\n            r = (r - n % r) / 2;\n        }\n        if\
    \ c == 2n {\n            return q;\n        }\n        q -= 1;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: invalid suffix `n` for number literal\n  --> /tmp/tmp6350z948.rs:23:17\n\
    \   |\n23 |         if c == 2n {\n   |                 ^^ invalid suffix `n`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while p > 0 {\n        if n & 1 == 1 {\n      \
    \      res += p;\n            n >>= 1;\n        }\n        p >>= 1;\n    }\n \
    \   res % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpafg37rya.rs:17:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n >>= 1;\n   | \
    \            ^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `p`\n  --> /tmp/tmpafg37rya.rs:19:9\n   |\n12 |\
    \ fn modp(n: isize, p: isize) -> isize {\n   |                   - help: consider\
    \ making this binding mutable: `mut p`\n...\n19 |         p >>= 1;\n   |     \
    \    ^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert_eq!(n, 0);\n    debug_assert_eq!(p, 0);\n    1\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpm1pkainu.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    if n == 0 {\n        1\n    } else {\n   \
    \     ((p % n) * n) / n\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpnp3vefns.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n.checked_mul(p.clone()).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `3`', /tmp/tmpm6pn37cf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p + n - 1) & !(p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1169`,\n right: `2`', /tmp/tmp4wg118xk.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    mod n\n    mod p\n    mod p\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `;` or `{`, found keyword `mod`\n  --> /tmp/tmp_yshn4aj.rs:14:5\n\
    \   |\n13 |     mod n\n   |          - expected one of `;` or `{`\n14 |     mod\
    \ p\n   |     ^^^ unexpected token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p { return n }\n    let mut nn = n;\n    for _ in 0..p + 2 {\n\
    \        if n % p == 0 {\n            nn /= p;\n        } else {\n           \
    \ nn %= p;\n        }\n    }\n    nn\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpfmffotcp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 0;\n    }\n    if n < 0 {\n        let mut\
    \ n = -n;\n        let mut p = -p;\n        let mut res = 1;\n        while n\
    \ > 0 {\n            let q = p / n;\n            res *= q;\n            n -= q;\n\
    \            p = p;\n        }\n        res %= p;\n        return res;\n    }\n\
    \    let mut res = 1;\n    while n > 0 {\n        let q = p / n;\n        res\
    \ *= q;\n        n -= q;\n    }\n    res %= p;\n    res\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp86j48dfa.rs:33:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n33 |         n -= q;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut nr = p / 2;\n    let mut d = n - nr;\n    if d > p {\n      \
    \  d = p;\n        nr /= 2;\n    }\n    d - nr\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `3`', /tmp/tmpysa3u9ml.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0, \"modulus can't be negative number\");\n    if n == 0\
    \ {\n        1\n    } else if n == 1 {\n        p\n    } else {\n        modp(n\
    \ >> 1, p)\n            * (p - 1)\n            + (n % p)\n            * (modp(n\
    \ & -n, p))\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `35`,\n right: `3`', /tmp/tmp_td4zszd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        return modp(n - 1, p) * p;\n    }\n    if p == 0\
    \ {\n        return 1;\n    }\n    let mut res = 1;\n    while n > 0 {\n     \
    \   let r = n % p;\n        n /= p;\n        res = (res * r) % p;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv2epf8mx.rs:22:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n22 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!((n >> p) == 0);\n    let mut result = n >> p;\n    while\
    \ (n > 1) {\n        n >>= 1;\n        result |= n & p;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm7glix2b.rs:15:11\n\
    \   |\n15 |     while (n > 1) {\n   |           ^     ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n15 -     while (n > 1)\
    \ {\n15 +     while n > 1 {\n   | \n\nerror[E0384]: cannot assign to immutable\
    \ argument `n`\n  --> /tmp/tmpm7glix2b.rs:16:9\n   |\n12 | fn modp(n: isize, p:\
    \ isize) -> isize {\n   |         - help: consider making this binding mutable:\
    \ `mut n`\n...\n16 |         n >>= 1;\n   |         ^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (((n % p) + p) % p)\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp3oaohc88.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return p;\n    }\n    if n == 1 {\n        return\
    \ 1;\n    }\n    if p < n {\n        let mut q: usize = n - p;\n        while\
    \ q > 0 {\n            q = q >> 1;\n        }\n        return q;\n    }\n    let\
    \ mut q = p - 1;\n    while q > 0 {\n        q = q >> 1;\n    }\n    q\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmycc2txg.rs:20:28\n   |\n\
    20 |         let mut q: usize = n - p;\n   |                    -----   ^^^^^\
    \ expected `usize`, found `isize`\n   |                    |\n   |           \
    \         expected due to this\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         let mut q:\
    \ usize = (n - p).try_into().unwrap();\n   |                            +    \
    \ +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmycc2txg.rs:24:16\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n...\n24 |         return\
    \ q;\n   |                ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n24 |         return q.try_into().unwrap();\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p\n    } else {\n        n - p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmpxyyf8oa6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp49y85mm5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    let mut q: isize = p;\n    while q > 0 {\n    \
    \    if n % q == 0 {\n            ret *= q;\n            n /= q;\n        } else\
    \ {\n            q *= q;\n        }\n    }\n    ret % p\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp45tud3kz.rs:18:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |             n /= q;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n - p\n    } else {\n        mod (n, p)\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `(`\n  --> /tmp/tmpsut765h6.rs:16:13\n\
    \   |\n16 |         mod (n, p)\n   |             ^ expected identifier\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n < p || (n % p) + (n - n % p) % p\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp09phmbq2.rs:13:14\n   |\n\
    13 |     n < p || (n % p) + (n - n % p) % p\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp09phmbq2.rs:13:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n13 |     n < p || (n\
    \ % p) + (n - n % p) % p\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n - 1) % p + 1\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp3jp7tez5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    if p % 2 == 0 {\n        result = result - 1;\n\
    \    }\n    result % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmppz7n9gp7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // Use division to avoid truncating towards zero\n    // or overflow\
    \ if n is very large.\n    (n as i64) / p as isize\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptq96_s1h.rs:15:18\n   |\n\
    15 |     (n as i64) / p as isize\n   |                  ^^^^^^^^^^ expected `i64`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptq96_s1h.rs:15:5\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \           ----- expected `isize` because of return type\n...\n15 |     (n as\
    \ i64) / p as isize\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     ((n as i64) / p as isize).try_into().unwrap()\n\
    \   |     +                       +++++++++++++++++++++\n\nerror[E0277]: cannot\
    \ divide `i64` by `isize`\n  --> /tmp/tmptq96_s1h.rs:15:16\n   |\n15 |     (n\
    \ as i64) / p as isize\n   |                ^ no implementation for `i64 / isize`\n\
    \   |\n   = help: the trait `Div<isize>` is not implemented for `i64`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n & (p - 1)) - (p & (n - 1))\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpigjq0bao.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmps86g8gg0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p {\n        if n < 0 {\n            n - p\n        } else {\n\
    \            n + p\n        }\n    } else {\n        n - p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `3`', /tmp/tmpxhgzf6g_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut a = p;\n    if a < n {\n        a = a;\n    }\n    n -= a;\n\
    \    a %= p;\n    if a < 0 {\n        a += p;\n    }\n    a\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `n` is never read\n  --> /tmp/tmphwguywqq.rs:17:5\n\
    \   |\n17 |     n -= a;\n   |     ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmphwguywqq.rs:17:5\n  \
    \ |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |     n -= a;\n   |     ^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0);\n    assert!(p == 0 || p % n == 0);\n    if n == 0 {\n\
    \        return 1;\n    }\n    if n == 1 {\n        return 0;\n    }\n    let\
    \ m = p / n;\n    let t = p - m * n;\n    if t == m {\n        return m;\n   \
    \ }\n    if t == 0 {\n        return m;\n    }\n    return m;\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p == 0 || p % n == 0'',
    /tmp/tmp94opq1ns.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match p {\n        0 => 1,\n        1 => n,\n        _ => {\n       \
    \     assert!(n > p);\n            let mut result = n;\n            while n >\
    \ p && result % p != 0 {\n                result /= p;\n            }\n      \
    \      result\n        }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n > p'', /tmp/tmpch4x38_6.rs:17:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow(p, n);\n    while npow % p != 0 {\n        npow =\
    \ pow(npow, p);\n    }\n    npow\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmp3a0myg79.rs:13:20\n\
    \   |\n13 |     let mut npow = pow(p, n);\n   |                    ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow` in this scope\n  -->\
    \ /tmp/tmp3a0myg79.rs:15:16\n   |\n15 |         npow = pow(npow, p);\n   |   \
    \             ^^^ help: a local variable with a similar name exists: `npow`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p.is_even());\n    n + ((n + 1) & (p - 1))\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp856i43tv.rs:13:15\n   |\n13 |     assert!(p.is_even());\n\
    \   |               ^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n as isize) % (p as isize) as isize\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmppz63lh2w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (p + n) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpawxqss_t.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p) as isize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp3p3pqhoi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert_eq!(n, p.bit_len());\n    n & !(p-1)\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `bit_len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpic9d5yfe.rs:13:21\n   |\n13 |     assert_eq!(n, p.bit_len());\n\
    \   |                     ^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (((n as usize) * p + 0x1f642) % (p - 0x1f642)) as isize\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpazjhau1l.rs:13:22\n   |\n\
    13 |     (((n as usize) * p + 0x1f642) % (p - 0x1f642)) as isize\n   |       \
    \               ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply\
    \ `usize` by `isize`\n  --> /tmp/tmpazjhau1l.rs:13:20\n   |\n13 |     (((n as\
    \ usize) * p + 0x1f642) % (p - 0x1f642)) as isize\n   |                    ^ no\
    \ implementation for `usize * isize`\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpazjhau1l.rs:13:37\n\
    \   |\n13 |     (((n as usize) * p + 0x1f642) % (p - 0x1f642)) as isize\n   |\
    \                                     ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot mod `usize` by `isize`\n  --> /tmp/tmpazjhau1l.rs:13:35\n\
    \   |\n13 |     (((n as usize) * p + 0x1f642) % (p - 0x1f642)) as isize\n   |\
    \                                   ^ no implementation for `usize % isize`\n\
    \   |\n   = help: the trait `Rem<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (1<<(n)) % ((1<<p)) - 1 - (n & p)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `3`', /tmp/tmp7z73bctn.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n > 0 && p > 0);\n    if n < p { n } else { p }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `101`,\n right: `2`', /tmp/tmpa6niew7c.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        std::ipow(p, n)\n    } else {\n        n / p\n  \
    \  }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `ipow` in crate `std`\n  --> /tmp/tmp1xnfu4wv.rs:14:14\n\
    \   |\n14 |         std::ipow(p, n)\n   |              ^^^^ not found in `std`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & -p | n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpiijtxijm.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(n\
    \ % p != 0);\n    debug_assert!(p <= 64);\n    debug_assert!(p >= -64);\n\n  \
    \  let mut r = n / p;\n    let mut q = 0;\n    while q * p < n {\n        q <<=\
    \ 1;\n    }\n    while r > 0 {\n        debug_assert!(p < 64);\n        debug_assert!(r\
    \ < 64);\n        debug_assert!(q >= 0);\n        debug_assert!(q < 64);\n   \
    \     debug_assert!(p <= 64);\n        debug_assert!(p > -64);\n        debug_assert!(q\
    \ * p >= n);\n        debug_assert!(r * p >= n);\n\n        let mask = (p + q)\
    \ << (64 - p);\n        let mut tmp = mask & r ^ mask;\n        r = (r - tmp)\
    \ % p;\n        q = (q - tmp) / p;\n    }\n    if r < 0 {\n        r += p;\n \
    \   }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976530
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    mod n { n % p }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!` or `::`, found `%`\n  --> /tmp/tmpj_ngpfdn.rs:13:15\n\
    \   |\n13 |     mod n { n % p }\n   |               ^ expected one of `!` or `::`\n\
    \nerror: expected item, found `}`\n  --> /tmp/tmpj_ngpfdn.rs:14:1\n   |\n14 |\
    \ }\n   | ^ expected item\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 1);\n    if p == 0 {\n        return 1;\n    }\n  \
    \  if n <= p {\n        return n;\n    }\n    debug_assert!(p > 0);\n    if n\
    \ <= (p / 2) {\n        n - (p / 2)\n    } else {\n        n + (p / 2)\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1151`,\n right: `2`', /tmp/tmpwzl08l5m.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if p < 2 {\n        return 0;\n    }\n\n    if n > p {\n        let tmp\
    \ = n;\n        n = p;\n        p = tmp;\n    }\n\n    let mut res = p % n;\n\
    \    while (res < 0) {\n        res += p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpsu8x3qx7.rs:24:11\n\
    \   |\n24 |     while (res < 0) {\n   |           ^       ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    24 -     while (res < 0) {\n24 +     while res < 0 {\n   | \n\nerror[E0384]: cannot\
    \ assign to immutable argument `n`\n  --> /tmp/tmpsu8x3qx7.rs:19:9\n   |\n12 |\
    \ fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making\
    \ this binding mutable: `mut n`\n...\n19 |         n = p;\n   |         ^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `p`\n  --> /tmp/tmpsu8x3qx7.rs:20:9\n   |\n12 | fn modp(n: isize, p:\
    \ isize) -> isize {\n   |                   - help: consider making this binding\
    \ mutable: `mut p`\n...\n20 |         p = tmp;\n   |         ^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut i = p;\n    while i > 1 {\n        i /= 2;\n    }\n    if i <=\
    \ 0 {\n        i\n    } else {\n        n % i\n    }\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpcbhtwkh4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = n;\n    let mut p2 = p;\n    while ret > p2 {\n       \
    \ ret -= p2;\n        p2 += p;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpqypk890d.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    let mut i = 1u64;\n    while i <= n {\n       \
    \ let mut rem = i % p;\n        if rem == 0 {\n            res += i;\n       \
    \ }\n        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpikew7x3n.rs:15:16\n   |\n\
    15 |     while i <= n {\n   |                ^ expected `u64`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u64` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpikew7x3n.rs:16:27\n   |\n16 |         let mut rem = i % p;\n   |   \
    \                        ^ expected `u64`, found `isize`\n\nerror[E0277]: cannot\
    \ mod `u64` by `isize`\n  --> /tmp/tmpikew7x3n.rs:16:25\n   |\n16 |         let\
    \ mut rem = i % p;\n   |                         ^ no implementation for `u64\
    \ % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented for `u64`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpikew7x3n.rs:22:5\n   |\n12 | fn modp(n: isize,\
    \ p: isize) -> isize {\n   |                                ----- expected `isize`\
    \ because of return type\n...\n22 |     res\n   |     ^^^ expected `isize`, found\
    \ `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     res.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let rem = n % p;\n    if rem == 0 {\n        return n\n    } else {\n\
    \        return n - rem\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpkgstdrzg.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut t = p % n;\n    if t < 0 {\n        t += n;\n    }\n    t\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp0svzs1xm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    while n != 0 {\n        if n % p == 0 {\n  \
    \          result *= p;\n            n /= p;\n        }\n        p /= 2;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpjhyuvbp6.rs:17:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `p`\n  --> /tmp/tmpjhyuvbp6.rs:19:9\n   |\n12 |\
    \ fn modp(n: isize, p: isize) -> isize {\n   |                   - help: consider\
    \ making this binding mutable: `mut p`\n...\n19 |         p /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n == 0 || (n & (n - 1)) == 0);\n    assert!(p != 0 && p != 1);\n\
    \n    let mut n = n as isize;\n    let mut p = p as isize;\n\n    while n != 1\
    \ {\n        n >>= 1;\n        p += 1;\n    }\n\n    n >>= 1;\n    p\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n == 0 || (n & (n - 1))
    == 0'', /tmp/tmpyhltxmqm.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976525
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpr8gcswqk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976524
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert_eq!(n, p.into());\n\n    if n < 0 {\n        n = -p;\n    }\n\n\
    \    (n - p.into()) % (p.into())\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0284]: type annotations needed: cannot satisfy `<isize as Sub<_>>::Output\
    \ == _`\n  --> /tmp/tmp6piz3w6a.rs:19:8\n   |\n19 |     (n - p.into()) % (p.into())\n\
    \   |        ^ cannot satisfy `<isize as Sub<_>>::Output == _`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0284`.\n"
  stdout: ''
  timestamp: 1659976525
