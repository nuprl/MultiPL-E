language: rs
name: HumanEval_59_largest_prime_factor
results:
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..).max_by_key(|k|\
    \ if n % k == 0 {\n        0\n    } else {\n        n\n    }).unwrap_or(n)\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976718
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1isize];\n\
    \    let mut i = 2isize;\n\n    while factors.len() < n {\n        if n % i ==\
    \ 0 {\n            factors.push(i as isize);\n            n /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n\n    factors[-1]\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt7e55sfz.rs:10:27\n   |\n\
    10 |     while factors.len() < n {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     while factors.len()\
    \ < n.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror: negative integers cannot be used to index on a `Vec<isize>`\n  --> /tmp/tmpt7e55sfz.rs:19:13\n\
    \   |\n19 |     factors[-1]\n   |             ^^ cannot use a negative integer\
    \ for indexing on `Vec<isize>`\n   |\nhelp: to access an element starting from\
    \ the end of the `Vec<isize>`, compute the index\n   |\n19 |     factors[factors.len()\
    \ -1]\n   |             +++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 { 1 } else\
    \ if n % 2 == 0 {\n        2\n    } else {\n        largest_prime_factor(n / 2)\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpiy7f3hpf.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (0..n).rev().foldl(|max_factor|\n\
    \        (max_factor < 2 || n % max_factor > 0)\n            ? max_factor\n  \
    \          : prime_factors(n - max_factor).max()\n            .clone(),\n    \
    \    1\n    )\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `-`\n\
    \  --> /tmp/tmpk5uye1m8.rs:10:31\n   |\n10 |             : prime_factors(n - max_factor).max()\n\
    \   |             -                 ^ expected one of 7 possible tokens\n   |\
    \             |\n   |             help: maybe write a path separator here: `::`\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `max_factor`\n\
    \ --> /tmp/tmpk5uye1m8.rs:9:15\n  |\n9 |             ? max_factor\n  |       \
    \       -^^^^^^^^^^ expected one of `)`, `,`, `.`, `?`, or an operator\n  |  \
    \            |\n  |              help: missing `,`\n\nerror: expected one of `.`,\
    \ `;`, `?`, `}`, or an operator, found `,`\n  --> /tmp/tmpk5uye1m8.rs:11:21\n\
    \   |\n11 |             .clone(),\n   |                     ^ expected one of\
    \ `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_factors(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factors` in this\
    \ scope\n --> /tmp/tmpt19u553w.rs:7:5\n  |\n7 |     largest_prime_factor_factors(n).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_helper(n,\
    \ |n| n%n == 0, |n| n)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_helper` in this\
    \ scope\n --> /tmp/tmp55zmqayr.rs:7:5\n  |\n7 |     largest_prime_factor_helper(n,\
    \ |n| n%n == 0, |n| n)\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    for _ in 0..3 {\n        if n % 16 == 0 && (n % 2 == 0 || n % 3 == 0) {\n\
    \            return n as isize;\n        }\n        n /= 2;\n    }\n    n += 2;\
    \ // n += 2 because we don't want to check 2\n    if n <= 1 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return n;\n    }\n   \
    \ for _ in 0..3 {\n        if n % 6 == 0 || n % 8 == 0 {\n            return n;\n\
    \        }\n        n /= 6;\n    }\n    return 1;\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvq6uybdy.rs:19:16\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n19 |    \
    \     return n;\n   |                ^ expected `isize`, found `u64`\n   |\nhelp:\
    \ you can convert a `u64` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |         return n.try_into().unwrap();\n   |                \
    \ ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 3isize;\n\
    \    while f % 2 == 0 {\n        f /= 2;\n    }\n    let mut limit: isize = (n\
    \ + 1) as isize;\n    limit = limit / 2;\n    while f % 3 == 0 && limit > 1 {\n\
    \        limit /= 3;\n        f *= 3;\n    }\n    limit\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmprgro1gcr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut factors = Vec::new();\n    let mut counter = 1;\n    loop {\n        if\
    \ n % counter == 0 {\n            factors.push(counter);\n            n /= counter;\n\
    \        } else {\n            counter *= 2;\n        }\n        if counter ==\
    \ 1 { break; }\n    }\n    factors.len()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8clvlskh.rs:19:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n19 |    \
    \ factors.len()\n   |     ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n19 |     factors.len().try_into().unwrap()\n   |        \
    \          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 1usize;\n\
    \    for i in 1..=n/2 {\n        if n % i == 0 {\n            f = i;\n       \
    \     break;\n        }\n    }\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq3mkvyfe.rs:10:17\n   |\n\
    7  |     let mut f = 1usize;\n   |                 ------ expected due to this\
    \ value\n...\n10 |             f = i;\n   |                 ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq3mkvyfe.rs:14:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n14\
    \ |     f\n   |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    14 |     f.try_into().unwrap()\n   |      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 { return 1;\
    \ }\n\n    if n % 2 == 0 {\n        n / 2\n    } else {\n        for &r in prime_factors(n)\
    \ {\n            if *r > n {\n                break;\n            }\n        }\n\
    \        (*r)\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n  -->\
    \ /tmp/tmpoad1pgvr.rs:12:19\n   |\n12 |         for &r in prime_factors(n) {\n\
    \   |                   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `r` in this scope\n  --> /tmp/tmpoad1pgvr.rs:17:11\n   |\n\
    17 |         (*r)\n   |           ^ help: a local variable with a similar name\
    \ exists: `n`\n\nwarning: unnecessary parentheses around block return value\n\
    \  --> /tmp/tmpoad1pgvr.rs:17:9\n   |\n17 |         (*r)\n   |         ^  ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n17 -         (*r)\n17 +         *r\n   | \n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = 2; // 2 is\
    \ the smallest factor\n\n    while n != 1 {\n        if n % m == 0 {\n       \
    \     n = n / m;\n        } else {\n            m = m * 2; // Try doubling the\
    \ factor\n        }\n    }\n\n    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpxe8o38h3.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n = n / m;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // We only care about\
    \ factors up to sqrt(n). Since we know the answer to the\n    // problem is less\
    \ than sqrt(n), we only need to check factors up to sqrt(n).\n    let mut d =\
    \ n - 1;\n    while d % 4 == 0 && d != 0 {\n        d /= 4;\n    }\n    if d <\
    \ 2 {\n        return 2;\n    }\n    // Now d should be less than sqrt(n), but\
    \ we check just in case for completeness.\n    for d in 2..(d/2) where d <= n\
    \ {\n        if n % d == 0 {\n            return d;\n        }\n    }\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `where`\n  --> /tmp/tmp49swodnv.rs:17:23\n\
    \   |\n17 |     for d in 2..(d/2) where d <= n {\n   |                       ^^^^^\
    \ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![true;\
    \ n + 1];\n\n    for prime in 1..=n {\n        for remainder in 2..=prime {\n\
    \            if primes[remainder] == true {\n                primes[remainder]\
    \ = false;\n                break;\n            }\n        }\n\n        if primes[prime]\
    \ == true {\n            return prime;\n        }\n    }\n\n    -1\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqvwh651u.rs:7:33\n  |\n7 |\
    \     let mut primes = vec![true; n + 1];\n  |                               \
    \  ^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n  |\n7 |     let\
    \ mut primes = vec![true; (n + 1).try_into().unwrap()];\n  |                 \
    \                +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqvwh651u.rs:11:16\n   |\n11 |  \
    \           if primes[remainder] == true {\n   |                ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpqvwh651u.rs:12:17\n\
    \   |\n12 |                 primes[remainder] = false;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpqvwh651u.rs:17:12\n\
    \   |\n17 |         if primes[prime] == true {\n   |            ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    let mut i = 1;\n    for factor in &prime_factorization(&n)[1..] {\n     \
    \   if i > factor {\n            i += 1;\n        } else {\n            return\
    \ i;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorization` in this scope\n\
    \ --> /tmp/tmp2i9z7xqz.rs:9:20\n  |\n9 |     for factor in &prime_factorization(&n)[1..]\
    \ {\n  |                    ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    let mut largest = 2;\n    for i in 2..=n {\n        if n % i == 0 {\n   \
    \         if largest <= i {\n                largest = i;\n            }\n   \
    \     }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpzyuq_10e.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n.clone() / 2\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpnc9_dn8j.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 1;\n\
    \    let mut max_factor = 1;\n    while i <= n {\n        if n % i == 0 {\n  \
    \          i += 1;\n            max_factor += 1;\n        } else if i == 2 {\n\
    \            i += 1;\n        }\n    }\n    max_factor\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976718
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(&[n]).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmpmaewv7r0.rs:7:5\n  |\n7 |     largest_prime_factors(&[n]).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1;\
    \ 2isize];\n    factors.extend_from_slice(&factors[..n % factors.len()]);\n  \
    \  factors.iter().map(|&factor| factor * factors[factors.len()]).max()\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpm3maepjc.rs:7:31\n  |\n7 |\
    \     let mut factors = vec![1; 2isize];\n  |                               ^^^^^^\
    \ expected `usize`, found `isize`\n  |\nhelp: change the type of the numeric literal\
    \ from `isize` to `usize`\n  |\n7 |     let mut factors = vec![1; 2usize];\n \
    \ |                                ~~~~~\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpm3maepjc.rs:8:46\n  |\n8 |     factors.extend_from_slice(&factors[..n\
    \ % factors.len()]);\n  |                                              ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n\
    \ --> /tmp/tmpm3maepjc.rs:8:44\n  |\n8 |     factors.extend_from_slice(&factors[..n\
    \ % factors.len()]);\n  |                                            ^ no implementation\
    \ for `isize % usize`\n  |\n  = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `RangeTo<isize>`\n\
    \ --> /tmp/tmpm3maepjc.rs:8:32\n  |\n8 |     factors.extend_from_slice(&factors[..n\
    \ % factors.len()]);\n  |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `RangeTo<isize>`\n  = help:\
    \ the following other types implement trait `SliceIndex<T>`:\n            <RangeTo<usize>\
    \ as SliceIndex<[T]>>\n            <RangeTo<usize> as SliceIndex<str>>\n  = note:\
    \ required because of the requirements on the impl of `Index<RangeTo<isize>>`\
    \ for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpm3maepjc.rs:9:5\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \                    ---"
  stdout: ''
  timestamp: 1659976713
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut largest_factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n \
    \           i += 1;\n            continue;\n        }\n\n        // n is not a\
    \ prime or a factor of n, so i is largest\n        largest_factor = i;\n     \
    \   i = 2;\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976718
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Sieve of Erastothenes\
    \ by Eratosthenes (according to Wikipedia)\n    let mut primes = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     i += 1;\n        }\n        else {\n            primes.push(i);\n      \
    \  }\n    }\n    if n < 2 {\n        1\n    }\n    else {\n        let mut highest_factor\
    \ = 0;\n        for &i in &primes {\n            if n % i == 0 {\n           \
    \     highest_factor += 1;\n                n /= i;\n            }\n        }\n\
    \        highest_factor\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2a8hnkcs.rs:26:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n26 |  \
    \               n /= i;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut prime: isize = 2;\n    while i * i <= n && i * prime <= n {\n        if\
    \ n % i == 0 {\n            i += 1;\n        }\n        else {\n            prime\
    \ = i;\n            i += 2;\n        }\n    }\n    prime\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpxgxhtelr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn is_prime(n: isize)\
    \ -> bool {\n        if n <= 1 {\n            return true;\n        }\n      \
    \  let mut i = 2;\n        let mut j = 2;\n        while i * j <= n {\n      \
    \      if n % i == 0 {\n                return false;\n            }\n       \
    \     if n % j == 0 {\n                return false;\n            }\n        \
    \    i += 1;\n            j += 1;\n        }\n        true\n    }\n\n    if n&1\
    \ == 0 {\n        return n;\n    }\n    for i in 2..(n-1)/2 {\n        if n %\
    \ i == 0 {\n            return i;\n        }\n    }\n    largest_prime_factor_factor(n,\
    \ 2)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_factor` in this\
    \ scope\n  --> /tmp/tmpg8zsuie_.rs:34:5\n   |\n34 |     largest_prime_factor_factor(n,\
    \ 2)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n    if n % 2 == 0 {\n        return 2;\n    }\n    let mut\
    \ i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ i;\n        }\n        i += 2;\n    }\n    3\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpba3tkpg8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n).filter(|i|\n\
    \        n.mod(i).is_none()\n    ).max()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `mod`\n --> /tmp/tmper6n0jiu.rs:8:11\n\
    \  |\n8 |         n.mod(i).is_none()\n  |           ^^^ expected identifier, found\
    \ keyword\n  |\nhelp: escape `mod` to use it as an identifier\n  |\n8 |      \
    \   n.r#mod(i).is_none()\n  |           ++\n\nerror[E0599]: no method named `r#mod`\
    \ found for type `isize` in the current scope\n --> /tmp/tmper6n0jiu.rs:8:11\n\
    \  |\n8 |         n.mod(i).is_none()\n  |           ^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmper6n0jiu.rs:7:5\n  |\n6 |   fn\
    \ largest_prime_factor(n: isize) -> isize {\n  |                             \
    \           ----- expected `isize` because of return type\n7 | /     (2..=n).filter(|i|\n\
    8 | |         n.mod(i).is_none()\n9 | |     ).max()\n  | |___________^ expected\
    \ `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n       \
    \      found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n)\n        .filter(|&factor|\
    \ n % factor == 0)\n        .max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphrqk38lx.rs:7:5\n  |\n6 |\
    \   fn largest_prime_factor(n: isize) -> isize {\n  |                        \
    \                ----- expected `isize` because of return type\n7 | /     (2..=n)\n\
    8 | |         .filter(|&factor| n % factor == 0)\n9 | |         .max()\n  | |______________^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering::*;\n\
    \n    fn isprime(n: usize) -> bool {\n        (1..n as isize)\n            .filter(|factor|\
    \ n % factor == 0)\n            .count() == n.checked_mul(n as usize)\n    }\n\
    \n    let mut primes = vec![1; n + 1];\n    let mut largest_prime_factor = 1;\n\
    \    for (i, prime) in primes.iter_mut().enumerate() {\n        if isprime(prime)\
    \ {\n            primes[i] = prime.checked_add(1).unwrap();\n            if primes[i]\
    \ > largest_prime_factor {\n                largest_prime_factor = primes[i];\n\
    \            }\n        }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering::*`\n --> /tmp/tmpxeb0lbn2.rs:7:9\n\
    \  |\n7 |     use std::cmp::Ordering::*;\n  |         ^^^^^^^^^^^^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxeb0lbn2.rs:15:30\n   |\n15 |     let mut primes = vec![1;\
    \ n + 1];\n   |                              ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     let mut primes = vec![1; (n + 1).try_into().unwrap()];\n\
    \   |                              +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxeb0lbn2.rs:18:20\n   |\n18 |         if isprime(prime)\
    \ {\n   |                    ^^^^^ expected `usize`, found `&mut {integer}`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |         if isprime(*prime)\
    \ {\n   |                    +\n\nerror[E0599]: no method named `checked_add`\
    \ found for mutable reference `&mut {integer}` in the current scope\n  --> /tmp/tmpxeb0lbn2.rs:19:31\n\
    \   |\n19 |             primes[i] = prime.checked_add(1).unwrap();\n   |     \
    \                          ^^^^^^^^^^^ method not found in `&mut {integer}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxeb0lbn2.rs:11:34\n   |\n11 |  \
    \           .filter(|factor| n % factor == 0)\n   |                          \
    \        ^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot mod `usize`\
    \ by `&isize`\n  --> /tmp/tmpxeb0lbn2.rs:11:32\n   |\n11 |             .filter(|factor|\
    \ n % factor == 0)\n   |                                ^ no implementation for\
    \ `usize % &isize`\n   |\n   = help: the trait `Rem<&isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use core::cmp::Ordering;\n\
    \    use core::cmp::PartialOrd;\n    use core::cmp::PartialEq;\n\n    fn gcd(x:\
    \ isize, y: isize) -> isize {\n        // This algorithm is very similar to the\
    \ one in Wikipedia but uses a\n        // different prime numbering scheme.\n\
    \        //\n        // We only need to compute the gcd of x and y up to sqrt(n)\
    \ to avoid\n        // overflows. We thus iterate until we find a factor between\
    \ n and the\n        // smallest factor greater than or equal to n.\n        let\
    \ mut i = y;\n        let mut g = x;\n        while i * g > n {\n            i\
    \ += 1;\n            g *= i;\n        }\n        g\n    }\n\n    let mut i = 2;\n\
    \    let mut prime_divisor = 1;\n    while prime_divisor < n {\n        if n %\
    \ i == 0 {\n            prime_divisor *= i;\n            i += 1;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    if n % prime_divisor\
    \ == 0 {\n        prime_divisor\n    }\n    else {\n        gcd(n, prime_divisor)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: maybe a missing crate `core`?\n --> /tmp/tmpc_ik7y2k.rs:7:9\n\
    \  |\n7 |     use core::cmp::Ordering;\n  |         ^^^^ maybe a missing crate\
    \ `core`?\n\nerror[E0433]: failed to resolve: maybe a missing crate `core`?\n\
    \ --> /tmp/tmpc_ik7y2k.rs:8:9\n  |\n8 |     use core::cmp::PartialOrd;\n  |  \
    \       ^^^^ maybe a missing crate `core`?\n\nerror[E0433]: failed to resolve:\
    \ maybe a missing crate `core`?\n --> /tmp/tmpc_ik7y2k.rs:9:9\n  |\n9 |     use\
    \ core::cmp::PartialEq;\n  |         ^^^^ maybe a missing crate `core`?\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n  --> /tmp/tmpc_ik7y2k.rs:20:23\n\
    \   |\n20 |         while i * g > n {\n   |                       ^\n   |\n  \
    \ = help: use the `|| { ... }` closure form instead\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0433, E0434.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = n as isize;\n\
    \    let mut i = 2;\n\n    while i * i <= n {\n        if n % i == 0 {\n     \
    \       i += 1;\n        }\n        else {\n            i -= 1;\n        }\n\n\
    \        if i == 0 {\n            break;\n        }\n    }\n\n    f\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976718
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n.checked_div(2).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmphjqoj9xk.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut m: u64 = 0;\n    let mut d = 1;\n\n    while n % d == 0 {\n     \
    \   n /= d;\n        m += 1;\n    }\n\n    if m > 2 {\n        m += 1;\n    }\n\
    \    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4qw_hl8.rs:19:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n19 |    \
    \ m\n   |     ^ expected `isize`, found `u64`\n   |\nhelp: you can convert a `u64`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n19 |     m.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..=n).fold(0, |a, b|\
    \ {\n        if n % a == 0 {\n            b\n        } else {\n            a\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmp7n6yvb9d.rs:8:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n).filter(|&i| n\
    \ % i == 0).max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpwqij1s4z.rs:7:5\n  |\n6 |\
    \ fn largest_prime_factor(n: isize) -> isize {\n  |                          \
    \            ----- expected `isize` because of return type\n7 |     (2..=n).filter(|&i|\
    \ n % i == 0).max()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n  |\n  = note: expected type `isize`\n             found\
    \ enum `Option<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3;\n    while\
    \ i < n / 2 {\n        if n % i == 0 {\n            return i;\n        }\n   \
    \     i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpyt6q8cqs.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1usize;\
    \ (n - 1) / 2]; // Find factors up to sqrt(n)\n    let mut factors_done = false;\n\
    \    while !factors_done {\n        factors_done = true;\n        for _ in 0..(factors.len()\
    \ - 1) {\n            if n % factors[_] == 0 {\n                factors[_] *=\
    \ 2;\n                factors_done = false;\n            }\n        }\n    }\n\
    \    factors[factors.len() - 1]\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpwvj7v307.rs:12:28\n   |\n12 |             if n % factors[_]\
    \ == 0 {\n   |                            ^ `_` not allowed here\n\nerror: in\
    \ expressions, `_` can only be used on the left-hand side of an assignment\n \
    \ --> /tmp/tmpwvj7v307.rs:13:25\n   |\n13 |                 factors[_] *= 2;\n\
    \   |                         ^ `_` not allowed here\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpwvj7v307.rs:7:36\n  |\n7 |     let mut factors = vec![1usize;\
    \ (n - 1) / 2]; // Find factors up to sqrt(n)\n  |                           \
    \         ^^^^^^^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n  |\n\
    7 |     let mut factors = vec![1usize; ((n - 1) / 2).try_into().unwrap()]; //\
    \ Find factors up to sqrt(n)\n  |                                    +       \
    \    +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwvj7v307.rs:18:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n18\
    \ |     factors[factors.len() - 1]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    for i in 2..n / 2 {\n        if n % i == 0 {\n            factor *= i;\n\
    \            n /= i;\n        }\n    }\n    if n > 1 {\n        factor *= n;\n\
    \    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzhiiok4h.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    let mut i = 2;\n    let mut factor = 1;\n    while i * i <= n {\n       \
    \ if n % i == 0 {\n            factor += 1;\n            i /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n\
    \    let mut prime = 2; // Sieve of Eratosthenes - primes are odd numbers in the\
    \ range [2, n/2]\n    for i in 2..n / 2 {\n        if n % i == 0 {\n         \
    \   for j in 2..i / 2 {\n                if i % j == 0 {\n                   \
    \ largest = i;\n                    prime += 1;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpbwvaucn0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 2;\n    let mut max_factor = n;\n\n    while max_factor % prime_factor !=\
    \ 0 {\n        max_factor /= prime_factor;\n        prime_factor *= prime_factor;\n\
    \    }\n\n    if max_factor < n {\n        max_factor\n    } else {\n        0\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmpb38eavx1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_factor(n).unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_factor` in this scope\n -->\
    \ /tmp/tmp5a8o6769.rs:7:5\n  |\n7 |     largest_factor(n).unwrap()\n  |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n    let mut i = 2;\n    while i * i < n {\n        if n %\
    \ i == 0 {\n            return i;\n        }\n        i += 1;\n    }\n    n\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpy9vug5yo.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 1 {\n   \
    \     return n / 2\n    }\n\n    for i in 3..=Int(sqrt(n)) {\n        if n % i\
    \ == 0 {\n            return i + (n / i)\n        }\n    }\n\n    return n\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Int`\
    \ in this scope\n  --> /tmp/tmpxv5t08nq.rs:11:18\n   |\n11 |     for i in 3..=Int(sqrt(n))\
    \ {\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sqrt` in this scope\n  --> /tmp/tmpxv5t08nq.rs:11:22\n   |\n\
    11 |     for i in 3..=Int(sqrt(n)) {\n   |                      ^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut max_prime_factor = 1;\n    let mut prime_factor = 1;\n    let\
    \ mut is_prime = true;\n    for _ in 1..n {\n        // Find the largest prime\
    \ factor\n        if prime_factor > max_prime {\n            // We no longer need\
    \ to check for factors larger than our max.\n            prime_factor = max_factor;\n\
    \        }\n        // Increment the max factor to check if it is prime\n    \
    \    max_factor *= 2;\n        // Check if the current factor is prime\n     \
    \   if n % prime_factor == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n        // Check if we have found a new largest prime factor\n   \
    \     if prime_factor > max_prime {\n            max_prime_factor = prime_factor;\n\
    \            max_factor = prime_factor;\n        }\n        prime_factor *= 2;\n\
    \    }\n    if prime_factor > max_prime {\n        prime_factor = max_prime;\n\
    \    }\n    if n % prime_factor == 0 {\n        is_prime = false;\n    }\n   \
    \ if is_prime {\n        prime_factor\n    } else {\n        0\n    }\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_prime` in this scope\n  --> /tmp/tmpd23texww.rs:13:27\n\
    \   |\n13 |         if prime_factor > max_prime {\n   |                      \
    \     ^^^^^^^^^ help: a local variable with a similar name exists: `is_prime`\n\
    \nerror[E0425]: cannot find value `max_prime` in this scope\n  --> /tmp/tmpd23texww.rs:25:27\n\
    \   |\n25 |         if prime_factor > max_prime {\n   |                      \
    \     ^^^^^^^^^ help: a local variable with a similar name exists: `is_prime`\n\
    \nerror[E0425]: cannot find value `max_prime` in this scope\n  --> /tmp/tmpd23texww.rs:31:23\n\
    \   |\n31 |     if prime_factor > max_prime {\n   |                       ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `is_prime`\n\nerror[E0425]:\
    \ cannot find value `max_prime` in this scope\n  --> /tmp/tmpd23texww.rs:32:24\n\
    \   |\n32 |         prime_factor = max_prime;\n   |                        ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `is_prime`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 1;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            i += 1;\n      \
    \  } else {\n            i = 1;\n        }\n    }\n    i\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let\
    \ mut i = 2;\n\n    while i < n {\n        if n % i == 0 {\n            return\
    \ i;\n        }\n\n        i += 1;\n    }\n\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp_htbutl7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = n;\n\
    \    let mut imax = 1;\n    let mut factor = 1;\n    while i <= imax {\n     \
    \   factor = i / i;\n        if factor % 2 == 0 {\n            imax += 1;\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmppydljs8_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     3\n    } else if n % 3 == 0 {\n        5\n    } else if n % 5 == 0 {\n \
    \       7\n    } else {\n        let mut n = n;\n        let mut factor = 1;\n\
    \        while n > 1 {\n            n /= 2;\n            factor *= 2;\n      \
    \  }\n        factor\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmp0p6y8aq4.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factor *= i;\n            n /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptbnown4f.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Optimize for primeness\
    \ tests\n    if n % 2 == 0 {\n        n / 2\n    } else {\n        n / 2\n   \
    \         // Optimize for odd numbers\n            .saturating_mul(2i32)\n   \
    \         // Optimize for odd numbers with high factors\n            .iter()\n\
    \            .map(|m| {\n                let mut i = m;\n                while\
    \ i * m > n {\n                    i /= 2;\n                }\n              \
    \  i;\n            })\n            .max().unwrap()\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `saturating_mul` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmpopwiinqu.rs:13:14\n   |\n13 |             .saturating_mul(2i32)\n\
    \   |              ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a concrete type\
    \ for this numeric value, like `i32`\n   |\n11 |         n / 2_i32\n   |     \
    \        ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 3isize;\n\
    \    let mut r = n / f;\n    while r != 0 {\n        if n % f == 0 {\n       \
    \     break;\n        }\n        f = 3;\n        r = (n - f) / f;\n    }\n   \
    \ f - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmp6aqt50sg.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i < n {\n        let factor = i as usize;\n        if n % factor == 0 {\n\
    \            return factor;\n        }\n        i += 1;\n    }\n    n as usize\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo1bdojsw.rs:10:16\n   |\n\
    10 |         if n % factor == 0 {\n   |                ^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpo1bdojsw.rs:10:14\n\
    \   |\n10 |         if n % factor == 0 {\n   |              ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo1bdojsw.rs:11:20\n\
    \   |\n11 |             return factor;\n   |                    ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |             return\
    \ factor.try_into().unwrap();\n   |                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo1bdojsw.rs:15:5\n   |\n6  | fn\
    \ largest_prime_factor(n: isize) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n15 |     n as usize\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |     (n as usize).try_into().unwrap()\n   |     +          +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    loop {\n        if n\
    \ % 2 == 0 {\n            n /= 2\n        } else {\n            n = ((3 * n) +\
    \ 1) / 2;\n        }\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpfvnp7ikr.rs:9:13\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \       n /= 2\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpfvnp7ikr.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n = ((3 * n) + 1) / 2;\n   |             ^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return 1;\n    }\n\n    fn is_factor(n: isize) -> bool {\n        n % n == 0\n\
    \    }\n\n    let mut i = 2;\n    let mut prime_factor = 1;\n\n    for _ in 0..n\
    \ {\n        if is_factor(i) {\n            prime_factor *= i;\n        }\n  \
    \      i += 2;\n    }\n\n    if prime_factor < n {\n        return prime_factor;\n\
    \    }\n\n    1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp28ar5bs6.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor: isize\
    \ = 1;\n    let mut max_factor_start: usize = n;\n\n    while max_factor_start\
    \ % 2 == 0 {\n        max_factor /= 2;\n    }\n\n    for i in 2..n {\n       \
    \ if n % i == 0 {\n            while (n % i == 0) {\n                n /= i;\n\
    \            }\n            if n == 1 {\n                break;\n            }\n\
    \            if max_factor < i {\n                max_factor = i;\n          \
    \      max_factor_start = n;\n            }\n        }\n    }\n\n    if max_factor_start\
    \ == 1 {\n        max_factor = 2;\n    }\n\n    max_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3rqklhme.rs:16:19\n\
    \   |\n16 |             while (n % i == 0) {\n   |                   ^       \
    \   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n16 -             while (n % i == 0) {\n16 +             while\
    \ n % i == 0 {\n   | \n\nerror[E0308]: mismatched types\n --> /tmp/tmp3rqklhme.rs:8:39\n\
    \  |\n8 |     let mut max_factor_start: usize = n;\n  |                      \
    \         -----   ^ expected `usize`, found `isize`\n  |                     \
    \          |\n  |                               expected due to this\n  |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n  |\n8 |     let mut max_factor_start: usize = n.try_into().unwrap();\n\
    \  |                                        ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3rqklhme.rs:24:36\n   |\n8  |     let mut max_factor_start:\
    \ usize = n;\n   |                               ----- expected due to this type\n\
    ...\n24 |                 max_factor_start = n;\n   |                        \
    \            ^ expected `usize`, found `isize`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976713
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 2;\n\n\
    \    while n > 1 {\n        let mut i = 3;\n        while i * i < n {\n      \
    \      i += 1;\n        }\n        if n % i == 0 {\n            res = i;\n   \
    \         n /= i;\n        } else {\n            break;\n        }\n    }\n\n\
    \    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpxwvst5s9.rs:16:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(&[n\
    \ - 1]).unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmpawsdgtuh.rs:7:5\n  |\n7 |     largest_prime_factors(&[n - 1]).unwrap()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n2 = n;\n   \
    \ while n2 == 2 {\n        n /= 2;\n        n2 += 1;\n    }\n\n    let mut n3\
    \ = n;\n    while n3 >= 3 {\n        let mut k = n3 / 2;\n        while k * k\
    \ <= n3 {\n            k += 1;\n        }\n\n        if n % k == 0 {\n       \
    \     n3 += 1;\n        } else {\n            n3 = n;\n            n -= k;\n \
    \       }\n    }\n\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp_p6cfpyn.rs:9:9\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \   n /= 2;\n  |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp_p6cfpyn.rs:24:13\n \
    \  |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |                \
    \         - help: consider making this binding mutable: `mut n`\n...\n24 |   \
    \          n -= k;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors_naive(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factors_naive` in this\
    \ scope\n --> /tmp/tmp6pvk74s4.rs:7:5\n  |\n7 |     largest_prime_factors_naive(n)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1_000_000 {\n\
    \        n as isize\n    } else {\n        let mut i = n;\n        let mut j =\
    \ 2;\n        while i * j < n {\n            i += 1;\n            j += 1;\n  \
    \      }\n        j\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmps8znvkos.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut i: usize = 0;\n    while n % 2 == 0 {\n        n /= 2;\n        i\
    \ += 1;\n    }\n    let mut largest = i;\n    let mut factor = 1;\n    while n\
    \ % largest == 0 {\n        largest += 1;\n        n /= largest;\n        factor\
    \ += 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rkty2ju.rs:15:15\n   |\n\
    15 |     while n % largest == 0 {\n   |               ^^^^^^^ expected `u64`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `u64` by `usize`\n  --> /tmp/tmp9rkty2ju.rs:15:13\n\
    \   |\n15 |     while n % largest == 0 {\n   |             ^ no implementation\
    \ for `u64 % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `u64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rkty2ju.rs:17:14\n\
    \   |\n17 |         n /= largest;\n   |              ^^^^^^^ expected `u64`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `u64` by `usize`\n  --> /tmp/tmp9rkty2ju.rs:17:11\n\
    \   |\n17 |         n /= largest;\n   |           ^^ no implementation for `u64\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `u64`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rkty2ju.rs:20:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n20\
    \ |     largest\n   |     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     largest.try_into().unwrap()\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome er"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1\n    }\n\n    let mut f = 1;\n    let mut i = 2;\n    while i <= n/2\
    \ {\n        if n % i == 0 {\n            f = i;\n            break;\n       \
    \ }\n\n        i += 1;\n    }\n\n    if f < n {\n        f\n    } else {\n   \
    \     n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpke0n211g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 1 {\n       \
    \ return 1;\n    }\n\n    let mut f = 2;\n    let mut a = 1;\n\n    while a <\
    \ n {\n        if n % f == 0 {\n            return f;\n        }\n\n        f\
    \ *= f;\n        a += 1;\n    }\n\n    f\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpp3zu60_9.rs:19:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    loop {\n        let (q,\
    \ r) = n / 2;\n        if q == r {\n            return q;\n        }\n       \
    \ let qp = q * p;\n        if qp > n {\n            n = qp;\n        } else {\n\
    \            n = qp + 1;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `p` in this scope\n  --> /tmp/tmpisfsnfip.rs:12:22\n\
    \   |\n12 |         let qp = q * p;\n   |                      ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpisfsnfip.rs:8:13\n  |\n8 |         let (q, r) = n / 2;\n  |    \
    \         ^^^^^^   ----- this expression has type `isize`\n  |             |\n\
    \  |             expected `isize`, found tuple\n  |\n  = note: expected type `isize`\n\
    \            found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // We only need to check\
    \ odd numbers, since even numbers can't be factors of n\n    for d in 2..=n/2\
    \ {\n        if n % d == 0 {\n            return d;\n        }\n    }\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpe1ej5l10.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![true;\
    \ n / 2];\n    let mut i = 2;\n    while i < n {\n        if primes[i] == true\
    \ {\n            primes[i] = false;\n            i += 1;\n        } else {\n \
    \           let mut j = i;\n            while j < n && primes[j] == true {\n \
    \               j += 1;\n            }\n            if j > i {\n             \
    \   let mut k = i;\n                while k != j && primes[k] == true {\n    \
    \                k += 1;\n                }\n                if k != i {\n   \
    \                 return k;\n                }\n            }\n        }\n   \
    \ }\n    n - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjbyhkcjm.rs:7:33\n  |\n7 |\
    \     let mut primes = vec![true; n / 2];\n  |                               \
    \  ^^^^^ expected `usize`, found `isize`\n  |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n  |\n7 |     let\
    \ mut primes = vec![true; (n / 2).try_into().unwrap()];\n  |                 \
    \                +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjbyhkcjm.rs:10:12\n   |\n10 |  \
    \       if primes[i] == true {\n   |            ^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjbyhkcjm.rs:11:13\n   |\n11 |            \
    \ primes[i] = false;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpjbyhkcjm.rs:15:28\n   |\n15 |            \
    \ while j < n && primes[j] == true {\n   |                            ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpjbyhkcjm.rs:20:33\n\
    \   |\n20 |                 while k != j && primes[k] == true {\n   |        \
    \                         ^^^^^^^^^ slice indices are of type `usize` or r"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 || n % 2 ==\
    \ 0 {\n        return n;\n    }\n\n    let mut res = 2;\n    let mut div = 3;\n\
    \n    while n % div != 0 {\n        res = div;\n        div += 2;\n    }\n\n \
    \   res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmp65ziufuk.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut s = 1;\n    while\
    \ n >= s {\n        if n % s == 0 {\n            return s;\n        }\n      \
    \  s += 1;\n    }\n    return s;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpds718n65.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m: isize = 0;\n\
    \    let mut is_composite: Vec<bool> = vec![true; n + 1];\n    for i in 1..=n\
    \ {\n        while !is_composite[i] {\n            m += i;\n            for i\
    \ in 2..=n {\n                is_composite[i] = !is_composite[i];\n          \
    \      if !is_composite[i] {\n                    break;\n                }\n\
    \            }\n        }\n    }\n    m\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_xexfac.rs:8:50\n  |\n8 |\
    \     let mut is_composite: Vec<bool> = vec![true; n + 1];\n  |              \
    \                                    ^^^^^ expected `usize`, found `isize`\n \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n  |\n8 |     let mut is_composite: Vec<bool> = vec![true;\
    \ (n + 1).try_into().unwrap()];\n  |                                         \
    \         +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpc_xexfac.rs:10:16\n   |\n10 |         while\
    \ !is_composite[i] {\n   |                ^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc_xexfac.rs:13:17\n   |\n13 |            \
    \     is_composite[i] = !is_composite[i];\n   |                 ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror[E0277]:\
    \ the type `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpc_xexfac.rs:13:36\n\
    \   |\n13 |                 is_composite[i] = !is_composite[i];\n   |        \
    \                            ^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpc_xexfac.rs:14:21\n   |\n14 |        "
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![1usize;\
    \ 2..n as usize];\n    let mut result = 1;\n\n    while primes[0] < n as isize\
    \ {\n        for &p in &mut primes {\n            if n % p == 0 {\n          \
    \      primes.remove(p);\n                result *= p;\n                break;\n\
    \            }\n        }\n    }\n\n    if result == 1 {\n        return n;\n\
    \    }\n\n    result;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpjhkqmqgx.rs:7:35\n  |\n7 |\
    \     let mut primes = vec![1usize; 2..n as usize];\n  |                     \
    \              ^^^^^^^^^^^^^ expected `usize`, found struct `std::ops::Range`\n\
    \  |\n  = note: expected type `usize`\n           found struct `std::ops::Range<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjhkqmqgx.rs:10:23\n   |\n10 |\
    \     while primes[0] < n as isize {\n   |                       ^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n10 |     while primes[0]\
    \ < (n as isize).try_into().unwrap() {\n   |                       +         \
    \ +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhkqmqgx.rs:11:13\n\
    \   |\n11 |         for &p in &mut primes {\n   |             ^^    -----------\
    \ this expression has type `Option<&mut usize>`\n   |             |\n   |    \
    \         types differ in mutability\n   |             help: you can probably\
    \ remove the explicit borrow: `p`\n   |\n   = note: expected mutable reference\
    \ `&mut usize`\n                      found reference `&_`\n\nerror[E0277]: cannot\
    \ mod `isize` by `usize`\n  --> /tmp/tmpjhkqmqgx.rs:12:18\n   |\n12 |        \
    \     if n % p == 0 {\n   |                  ^ no implementation for `isize %\
    \ usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpjhkqmqgx.rs:6:38\n  |\n6 | fn largest_prime_factor(n:\
    \ isize) -> isize {\n  |    --------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due "
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = n;\n    loop {\n        prime_factor = prime_factor / 2;\n        if prime_factor\
    \ % 2 == 0 {\n            prime_factor = prime_factor + 1;\n        }\n      \
    \  if prime_factor > 2 {\n            break;\n        }\n    }\n    prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmpzly3cciy.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return n;\n    }\n    let mut prime = n;\n    let mut max_factor = 0;\n    //\
    \ First see if n is prime\n    if n % 2 == 0 {\n        for i in 2..=n/2 {\n \
    \           if n % i == 0 {\n                prime = i;\n                break;\n\
    \            }\n        }\n    }\n    if prime > max_factor {\n        max_factor\
    \ = prime;\n    }\n    if n % prime == 0 {\n        for factor in 2..=n/prime\
    \ {\n            if n % prime == 0 {\n                if prime > factor {\n  \
    \                  max_factor = prime;\n                    break;\n         \
    \       } else {\n                    max_factor = factor;\n                }\n\
    \            }\n        }\n    }\n    if max_factor == 0 {\n        return n;\n\
    \    } else {\n        return max_factor;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpypvzqcdy.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use prime::*;\n\n   \
    \ let mut prime_factors = vec![];\n    let mut prime_factor = n;\n\n    // Test\
    \ for primes up to n\n    while prime_factor > 1 {\n        if n % prime_factor\
    \ == 0 {\n            prime_factors.push(prime_factor);\n            n /= prime_factor;\n\
    \        }\n        else {\n            prime_factor = prime_factor - 1;\n   \
    \     }\n    }\n    prime_factors.push(n);\n\n    if n != 1 {\n        prime_factors.push(n);\n\
    \    }\n\n    prime_factors\n        .iter()\n        .filter(|factor| {\n   \
    \         // filter out composites\n            factor.is_prime() || factor ==\
    \ 1\n        })\n        .max()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `prime`\n --> /tmp/tmpppiqiy2n.rs:7:9\n\
    \  |\n7 |     use prime::*;\n  |         ^^^^^ maybe a missing crate `prime`?\n\
    \nerror[E0599]: no method named `is_prime` found for reference `&&isize` in the\
    \ current scope\n  --> /tmp/tmpppiqiy2n.rs:32:20\n   |\n32 |             factor.is_prime()\
    \ || factor == 1\n   |                    ^^^^^^^^ method not found in `&&isize`\n\
    \nerror[E0277]: can't compare `&&isize` with `{integer}`\n  --> /tmp/tmpppiqiy2n.rs:32:41\n\
    \   |\n32 |             factor.is_prime() || factor == 1\n   |               \
    \                          ^^ no implementation for `&&isize == {integer}`\n \
    \  |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpppiqiy2n.rs:28:5\n\
    \   |\n6  |   fn largest_prime_factor(n: isize) -> isize {\n   |             \
    \                           ----- expected `isize` because of return type\n...\n\
    28 | /     prime_factors\n29 | |         .iter()\n30 | |         .filter(|factor|\
    \ {\n31 | |             // filter out composites\n32 | |             factor.is_prime()\
    \ || factor == 1\n33 | |         })\n34 | |         .max()\n   | |______________^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0432, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = 1;\n    let\
    \ mut max_factor = isize::MAX;\n    let mut max_factor_inc = isize::MAX;\n   \
    \ let mut cur_factor = m;\n    while n > m {\n        if n % cur_factor == 0 {\n\
    \            n /= cur_factor;\n        } else {\n            m *= cur_factor;\n\
    \        }\n        if m > max_factor {\n            max_factor = m;\n       \
    \ }\n        if m < max_factor_inc {\n            max_factor_inc = m;\n      \
    \  }\n        cur_factor *= m;\n    }\n    max_factor\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpadmhw9ii.rs:13:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n13 |  \
    \           n /= cur_factor;\n   |             ^^^^^^^^^^^^^^^ cannot assign to\
    \ immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert_eq!(n >\
    \ 1, \"n must be > 1\");\n    let mut i = 1;\n    let mut j = n;\n    let mut\
    \ m = 0;\n    while m != i {\n        let mut k = j;\n        while k * k <= i\
    \ {\n            k += 1;\n        }\n        if k == i {\n            i += 1;\n\
    \        } else {\n            m = k;\n        }\n        j -= k;\n    }\n   \
    \ i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp21z8g3op.rs:7:5\n  |\n7 |\
    \     debug_assert_eq!(n > 1, \"n must be > 1\");\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `&str`\n  |\n  = note: this error originates in the macro\
    \ `$crate::assert_eq` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    while\
    \ f * f <= n {\n        if n % f == 0 {\n            return f;\n        }\n  \
    \      f += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpy5wz8ysf.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..n).max_by(|a, b|\
    \ {\n        a.cmp(&b).unwrap() <= 0 && a.cmp(&b).unwrap() > -1\n    })\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n --> /tmp/tmp15gwbwbe.rs:8:19\n  |\n8 |         a.cmp(&b).unwrap()\
    \ <= 0 && a.cmp(&b).unwrap() > -1\n  |                   ^^^^^^ method not found\
    \ in `std::cmp::Ordering`\n\nerror[E0599]: no method named `unwrap` found for\
    \ enum `std::cmp::Ordering` in the current scope\n --> /tmp/tmp15gwbwbe.rs:8:46\n\
    \  |\n8 |         a.cmp(&b).unwrap() <= 0 && a.cmp(&b).unwrap() > -1\n  |    \
    \                                          ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp15gwbwbe.rs:8:9\n  |\n8 |     \
    \    a.cmp(&b).unwrap() <= 0 && a.cmp(&b).unwrap() > -1\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp15gwbwbe.rs:7:5\n  |\n6 |   fn largest_prime_factor(n: isize)\
    \ -> isize {\n  |                                        ----- expected `isize`\
    \ because of return type\n7 | /     (1..n).max_by(|a, b| {\n8 | |         a.cmp(&b).unwrap()\
    \ <= 0 && a.cmp(&b).unwrap() > -1\n9 | |     })\n  | |______^ expected `isize`,\
    \ found enum `Option`\n  |\n  = note: expected type `isize`\n             found\
    \ enum `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ 1\n    } else if n % 2 == 0 {\n        largest_prime_factor(n / 2)\n    } else\
    \ {\n        let max_prime = prime_divisors(n).last().unwrap();\n        let max_prime_divisor\
    \ = max_prime + 1;\n        let mut i = 2;\n        while i * i <= n {\n     \
    \       if n % i == 0 {\n                i += 1;\n            } else {\n     \
    \           i = max_prime_divisor;\n            }\n        }\n        i as usize\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_divisors` in this scope\n  -->\
    \ /tmp/tmptzqfflyp.rs:12:25\n   |\n12 |         let max_prime = prime_divisors(n).last().unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptzqfflyp.rs:22:9\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n22 |         i as usize\n   |         ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |         (i\
    \ as usize).try_into().unwrap()\n   |         +          +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f: isize = 0;\n\
    \    let mut c: isize = 1;\n    loop {\n        if n % c == 0 {\n            f\
    \ = c + 1;\n        }\n        c = c * f + 1;\n        if c >= n {\n         \
    \   break;\n        }\n    }\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp6zrvffii.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \    debug_assert!(n & 1 == 0);\n\n    let mut factor = 1;\n    let mut prime\
    \ = 1;\n    let mut i = 2;\n\n    while i < n {\n        if n % i == 0 {\n   \
    \         factor *= i;\n            prime += 1;\n        }\n        i += 2;\n\
    \    }\n\n    if factor < n / prime {\n        factor\n    } else {\n        prime\
    \ * largest_prime_factor(n / prime)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: n & 1 == 0'', /tmp/tmp1xamcey1.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976714
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::min;\n\
    \    use std::cmp::Ordering;\n\n    let mut fp = 1;\n    let mut fd = 1;\n\n \
    \   let mut n = n / fd;\n\n    while n > 1 {\n        if n % fd != 0 {\n     \
    \       n = n / fd;\n        } else {\n            n = n * fd;\n            fp\
    \ = fp * fd;\n            fd = 1;\n        }\n    }\n\n    fn largest_prime_factor(n:\
    \ isize) -> isize {\n        let mut fp = 1;\n        let mut fd = 1;\n\n    \
    \    while n > 1 {\n            let mut n = n / fd;\n            while n % fd\
    \ == 0 && n > 1 {\n                n = n / fd;\n            }\n            if\
    \ n % fd != 0 {\n                n = n / fd;\n            } else {\n         \
    \       n = n * fd;\n                fp = fp * fd;\n                fd = 1;\n\
    \            }\n        }\n\n        n / fd\n    }\n\n    if n > 2 {\n       \
    \ if n < 2 {\n            return 1;\n        }\n        if n % 2 == 0 {\n    \
    \        return n;\n        }\n        let mut p = 2;\n        while p < n {\n\
    \            if n % p == 0 {\n                n = n / p;\n                break;\n\
    \            }\n            p = p * 2;\n        }\n    }\n    largest_prime_factor(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = n;\n\
    \    for i in 2..result {\n        result = if n % i == 0 {\n            i\n \
    \       } else {\n            result\n        };\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpwgwxwrlm.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    while\
    \ f * f <= n {\n        if n % f == 0 {\n            f += 2;\n        } else if\
    \ f == 2 {\n            f = 2;\n        } else {\n            break;\n       \
    \ }\n    }\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1 {\n        largest_prime_factor_inner(n\
    \ - 1)\n    } else {\n        n\n    }\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_inner` in this\
    \ scope\n --> /tmp/tmp1wgtj144.rs:8:9\n  |\n8 |         largest_prime_factor_inner(n\
    \ - 1)\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n\
    \            i -= 1;\n        }\n    }\n    n - i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut r = 1;\n    let\
    \ mut m = n;\n\n    for _ in 0..=3 {\n        m *= 2;\n\n        if m % 2 == 0\
    \ {\n            break;\n        }\n\n        r *= m;\n    }\n\n    if m == 1\
    \ {\n        return 2;\n    }\n\n    m -= 1;\n\n    while m % 2 == 0 {\n     \
    \   r -= 1;\n        m /= 2;\n    }\n\n    if m == 1 {\n        return r;\n  \
    \  }\n\n    return r;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp4c3m9cuy.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn largest_prime_factor(n:\
    \ isize) -> isize {\n        if n < 1 {\n            return n;\n        }\n\n\
    \        let mut i = 1;\n        let mut prime_found = true;\n\n        while\
    \ prime_found && i <= n {\n            if n % i == 0 {\n                prime_found\
    \ = false;\n            } else {\n                i += 1;\n            }\n   \
    \     }\n\n        if prime_found {\n            i\n        } else {\n       \
    \     n\n        }\n    }\n\n    let largest_prime = largest_prime_factor(n);\n\
    \n    if n % largest_prime == 0 {\n        largest_prime\n    } else {\n     \
    \   n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpg5xbxjbo.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_prime = n;\n\
    \    let mut prime_factor = 1;\n    for _ in 0..((max_prime - 1) / 2) {\n    \
    \    if n % prime_factor == 0 {\n            max_prime /= prime_factor;\n    \
    \    } else {\n            prime_factor *= 2;\n        }\n    }\n    max_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpb3sm6cka.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n\n    let mut i = 2; // i is guaranteed to be odd above by the while\
    \ loop.\n    let mut prime_factor = 1;\n\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            prime_factor = i;\n            break;\n        }\n\n\
    \        i += 2;\n    }\n\n    if prime_factor > 2 {\n        prime_factor\n \
    \   } else {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpo2u4knbp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut fs = vec![n];\n\
    \    for i in 1..=n {\n        if fs[i - 1] != 1 {\n            let s = 2;\n \
    \           let mut m = i;\n            loop {\n                if fs[m - 1] !=\
    \ 1 {\n                    fs[m - 1] += 1;\n                } else {\n       \
    \             break;\n                }\n                if m * m < i {\n    \
    \                break;\n                }\n                if fs[m] == 1 {\n\
    \                    break;\n                }\n                s += 2;\n    \
    \            m *= m;\n            }\n            fs[i] = s;\n        }\n    }\n\
    \    fs.iter().max().unwrap_or(1)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n --> /tmp/tmpqw2eq1os.rs:9:12\n\
    \  |\n9 |         if fs[i - 1] != 1 {\n  |            ^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n  = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpqw2eq1os.rs:13:20\n   |\n13 |                 if fs[m - 1] != 1\
    \ {\n   |                    ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpqw2eq1os.rs:14:21\n   |\n14 |                     fs[m - 1] +=\
    \ 1;\n   |                     ^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpqw2eq1os.rs:21:20\n   |\n21 |                 if fs[m] == 1 {\n\
    \   |                    ^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpqw2eq1os.rs:27:13\n   |\n27 |             fs[i] = s;\n   |    \
    \         ^^^^^ slice indices are of type `usize` or ranges of `us"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n\n    while n % 2 == 0 {\n        max_factor *= 2;\n        n /= 2;\n  \
    \  }\n\n    for divisor in &[2..] {\n        while n % divisor == 0 {\n      \
    \      n /= divisor;\n            max_factor = cmp::max(max_factor, divisor);\n\
    \        }\n    }\n\n    if n == 1 {\n        max_factor\n    } else {\n     \
    \   max_factor\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmporlny71e.rs:17:26\n   |\n17 |             max_factor = cmp::max(max_factor,\
    \ divisor);\n   |                          ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0277]: cannot mod `isize` by `&RangeFrom<{integer}>`\n  -->\
    \ /tmp/tmporlny71e.rs:15:17\n   |\n15 |         while n % divisor == 0 {\n   |\
    \                 ^ no implementation for `isize % &RangeFrom<{integer}>`\n  \
    \ |\n   = help: the trait `Rem<&RangeFrom<{integer}>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0277]: cannot divide-assign `isize` by `&RangeFrom<{integer}>`\n\
    \  --> /tmp/tmporlny71e.rs:16:15\n   |\n16 |             n /= divisor;\n   | \
    \              ^^ no implementation for `isize /= &RangeFrom<{integer}>`\n   |\n\
    \   = help: the trait `DivAssign<&RangeFrom<{integer}>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn prime_factors_iter(n:\
    \ isize) -> Result<Vec<isize>, Vec<isize>> {\n        if n < 2 {\n           \
    \ return Err(vec![0isize]);\n        }\n        if n == 2 {\n            return\
    \ Ok(vec![2]);\n        }\n        let mut prime_factors: Vec<isize> = Vec::new();\n\
    \        let mut next_prime_factor = 2;\n        let mut factors = Vec::new();\n\
    \        while factors.len() < n {\n            if n % next_prime_factor == 0\
    \ {\n                prime_factors.push(next_prime_factor);\n                factors.push(next_prime_factor);\n\
    \            } else {\n                next_prime_factor *= prime_factors.last().unwrap()\
    \ + 1;\n            }\n        }\n        Ok(prime_factors)\n    }\n    let prime_factors\
    \ = prime_factors_iter(n)?;\n    prime_factors.iter().rev().next().unwrap_or(n)\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmpdscg78an.rs:27:46\n   |\n6  | / fn largest_prime_factor(n: isize) ->\
    \ isize {\n7  | |     fn prime_factors_iter(n: isize) -> Result<Vec<isize>, Vec<isize>>\
    \ {\n8  | |         if n < 2 {\n9  | |             return Err(vec![0isize]);\n\
    ...  |\n27 | |     let prime_factors = prime_factors_iter(n)?;\n   | |       \
    \                                       ^ cannot use the `?` operator in a function\
    \ that returns `isize`\n28 | |     prime_factors.iter().rev().next().unwrap_or(n)\n\
    29 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual<Result<Infallible, Vec<isize>>>`\
    \ is not implemented for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdscg78an.rs:28:49\n\
    \   |\n28 |     prime_factors.iter().rev().next().unwrap_or(n)\n   |         \
    \                                        ^\n   |                             \
    \                    |\n   |                                                 expected\
    \ `&isize`, found `isize`\n   |                                              \
    \   help: consider borrowing here: `&n`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdscg78an.rs:28:5\n   |\n6  | fn largest_prime_factor(n: isize) -> isize\
    \ {\n   |                                      ----- expected `isize` because\
    \ of return type\n...\n28 |     prime_factors.iter().rev().next().unwrap_or(n)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |     *prime_factors.iter().rev().next().unwrap_or(n)\n\
    \   |     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdscg78an.rs:17:31\n\
    \   |\n17 |         while factors.len() < n {\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n17 |      \
    \   while factors.len() < n.try_into().unwrap() {\n   |                  "
  stdout: ''
  timestamp: 1659976714
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n\
    \    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     result = (result * (i));\n            i /= i;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert!(n > 1);\n\
    \n    let mut i = 2;\n    let mut prime = true;\n    let mut highest = n;\n\n\
    \    while i * i <= n && prime {\n        i += 1;\n\n        if n % i == 0 {\n\
    \            prime = false;\n            i += 1;\n            highest = n;\n \
    \       }\n    }\n\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmphlyyx59h.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1 && is_prime(n)\
    \ {\n        return n;\n    }\n\n    for i in 2..=n/2 {\n        if n % i == 0\
    \ {\n            return i;\n        }\n    }\n\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpwnvemyx5.rs:7:17\n\
    \  |\n7 |     if n > 1 && is_prime(n) {\n  |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n == 0 {\n       \
    \ return 0;\n    }\n\n    fn next_factor(mut x: isize, i: usize) -> bool {\n \
    \       if x%i == 0 {\n            x = x/i;\n            return false;\n     \
    \   }\n        i += 1;\n        x*=i;\n        return true;\n    }\n    \n   \
    \ let mut x = 2u64;\n    let mut i: usize = 2;\n    loop {\n        if next_factor(x,\
    \ i) && (x>n) then break x;\n        i += 1;\n        x*=i;\n    }\n    i\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp1q_igrbn.rs:24:39\n  \
    \ |\n24 |         if next_factor(x, i) && (x>n) then break x;\n   |         --\
    \                            ^^^^ expected `{`\n   |         |\n   |         this\
    \ `if` expression has a condition, but no block\n   |\nhelp: try placing this\
    \ code inside a block\n   |\n24 |         if next_factor(x, i) && (x>n) { then\
    \ } break x;\n   |                                       +      +\n\nwarning:\
    \ unreachable expression\n  --> /tmp/tmp1q_igrbn.rs:28:5\n   |\n23 | /     loop\
    \ {\n24 | |         if next_factor(x, i) && (x>n) then break x;\n25 | |      \
    \   i += 1;\n26 | |         x*=i;\n27 | |     }\n   | |_____- any code following\
    \ this expression is unreachable\n28 |       i\n   |       ^ unreachable expression\n\
    \   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1q_igrbn.rs:28:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n28 |     i\n   |     ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n28 |     i.try_into().unwrap()\n \
    \  |      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q_igrbn.rs:12:14\n\
    \   |\n12 |         if x%i == 0 {\n   |              ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmp1q_igrbn.rs:12:13\n\
    \   |\n12 |         if x%i == 0 {\n   |             ^ no implementation for `isize\
    \ % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1q_igrbn.r"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 1; // The\
    \ largest prime factor seen so far\n    let mut m = n;\n    while m > 1 && prime_factorize(m)\
    \ == 1 {\n        m /= 2;\n        f *= 2;\n    }\n    f\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factorize` in this scope\n -->\
    \ /tmp/tmp0nf647t8.rs:9:20\n  |\n9 |     while m > 1 && prime_factorize(m) ==\
    \ 1 {\n  |                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut max_factor_count = n;\n    while max_factor_count > 1 {\n  \
    \      if n % max_factor_count == 0 {\n            max_factor_count = n / max_factor_count;\n\
    \        } else {\n            max_factor_count = 1;\n        }\n        max_factor\
    \ *= max_factor_count;\n    }\n    max_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp4tg0hhq6.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            n = n / i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkt7ob95c.rs:10:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n10 |  \
    \           n = n / i;\n   |             ^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut s = 2;\n    while\
    \ n % s != 0 {\n        s += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp6eflspah.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    factorization(n).iter().max().expect(\"\
    no prime factors found\")\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n -->\
    \ /tmp/tmpq_7jjaso.rs:7:5\n  |\n7 |     factorization(n).iter().max().expect(\"\
    no prime factors found\")\n  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_factor(n) + 1\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_factor` in this scope\n -->\
    \ /tmp/tmpl_mvspfd.rs:7:5\n  |\n7 |     largest_factor(n) + 1\n  |     ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = n;\n    let\
    \ mut f_sq = f;\n    loop {\n        f_sq = f_sq * f;\n        if f_sq == 1 {\n\
    \            break;\n        }\n        let q = div_mod_positive(n, f_sq);\n \
    \       let r = n % f_sq;\n        n = q;\n        f = r;\n    }\n    f\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `div_mod_positive` in this scope\n \
    \ --> /tmp/tmpko066vbo.rs:14:17\n   |\n14 |         let q = div_mod_positive(n,\
    \ f_sq);\n   |                 ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut a = n + 1;\n\
    \    let mut i = 3;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ a = i;\n            break;\n        }\n        i += 2;\n    }\n    a\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpu4tdkdu9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n <= 1 {\n       \
    \ return 1;\n    }\n    fn factor(i: isize) -> bool {\n        n % i == 0\n  \
    \  }\n    let mut i = 2; // The next prime to test\n    let mut max_factor = 1;\n\
    \    while i <= n {\n        if factor(i) {\n            while i <= n && factor(i)\
    \ {\n                i += 1;\n            }\n            if i == n {\n       \
    \         break;\n            }\n            max_factor = i;\n        }\n    \
    \    i += 1;\n    }\n    max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpg9hq31g6.rs:11:9\n\
    \   |\n11 |         n % i == 0\n   |         ^\n   |\n   = help: use the `|| {\
    \ ... }` closure form instead\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0434`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = std::cmp::max(self.prime_factor(n));\n    while n % largest_prime_factor !=\
    \ 0 {\n        largest_prime_factor = std::cmp::max(\n            largest_prime_factor,\n\
    \            self.prime_factor(n % largest_prime_factor),\n        );\n      \
    \  n /= largest_prime_factor;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0424]: expected value, found module `self`\n --> /tmp/tmpw6ephft2.rs:7:50\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |    --------------------\
    \ this function can't have a `self` parameter\n7 |     let mut largest_prime_factor\
    \ = std::cmp::max(self.prime_factor(n));\n  |                                \
    \                  ^^^^ `self` value is a keyword only available in methods with\
    \ a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n  -->\
    \ /tmp/tmpw6ephft2.rs:11:13\n   |\n6  | fn largest_prime_factor(n: isize) -> isize\
    \ {\n   |    -------------------- this function can't have a `self` parameter\n\
    ...\n11 |             self.prime_factor(n % largest_prime_factor),\n   |     \
    \        ^^^^ `self` value is a keyword only available in methods with a `self`\
    \ parameter\n\nerror[E0061]: this function takes 2 arguments but 1 argument was\
    \ supplied\n    --> /tmp/tmpw6ephft2.rs:7:36\n     |\n7    |     let mut largest_prime_factor\
    \ = std::cmp::max(self.prime_factor(n));\n     |                             \
    \       ^^^^^^^^^^^^^ -------------------- supplied 1 argument\n     |       \
    \                             |\n     |                                    expected\
    \ 2 arguments\n     |\nnote: function defined here\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0424.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![1,\
    \ 2];\n    while n > 1 {\n        if n % factors.last().unwrap() == 0 {\n    \
    \        break;\n        }\n        factors.push(n % factors.last().unwrap());\n\
    \        n /= factors.last().unwrap();\n    }\n    factors.pop()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpln6uuxaa.rs:15:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n15 |    \
    \ factors.pop()\n   |     ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 3 {\n        return\
    \ 1;\n    }\n    fn gcd(a: isize, b: isize) -> isize {\n        if b == 0 {\n\
    \            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\
    \n    let mut f = 1;\n    for &i in &[3..] {\n        let mut g = f;\n       \
    \ if n % i == 0 {\n            let mut j = 0;\n            for &j in &[i..] {\n\
    \                let t = i / j;\n                if t != 1 {\n               \
    \     g = gcd(g, t);\n                }\n            }\n            f = g;\n \
    \       }\n    }\n    f\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `isize` by `RangeFrom<{integer}>`\n  --> /tmp/tmpyz188w_4.rs:21:14\n\
    \   |\n21 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % RangeFrom<{integer}>`\n   |\n   = help: the trait `Rem<RangeFrom<{integer}>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0369]: cannot divide `RangeFrom<{integer}>`\
    \ by `RangeFrom<RangeFrom<{integer}>>`\n  --> /tmp/tmpyz188w_4.rs:24:27\n   |\n\
    24 |                 let t = i / j;\n   |                         - ^ - RangeFrom<RangeFrom<{integer}>>\n\
    \   |                         |\n   |                         RangeFrom<{integer}>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 2; // Start\
    \ with 2\n    let mut limit = (n as isize) as isize; // n must be odd\n\n    //\
    \ Loop while limit is greater than or equal to 2\n    while limit > 1 {\n    \
    \    if n % res == 0 {\n            limit = limit / res;\n        } else {\n \
    \           res = res + 2;\n        }\n    }\n\n    if limit > 1 {\n        limit\n\
    \    } else {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976719
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut m = n;\n    loop {\n        let mut m = m / i;\n        if m == 1 {\n  \
    \          break;\n        }\n        i += 1;\n    }\n    i\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `5`', /tmp/tmpoib19hws.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // The prime factors\
    \ found will be cached as we find them.\n    let mut largest = 1;\n\n    // The\
    \ first prime candidate is 2, which is prime\n    for p in 2..n {\n        if\
    \ n % p == 0 {\n            largest = p;\n            break;\n        }\n    }\n\
    \n    for p in 3..n {\n        if n % p == 0 {\n            largest = p;\n   \
    \         break;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp1u_irao8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Use Fermat's little\
    \ theorem to find the largest prime factor of n.\n    let mut i = 2;\n    let\
    \ mut max_factor: isize = 0;\n    let mut prime_found = false;\n\n    while i\
    \ * i <= n && !prime_found {\n        if n % i == 0 {\n            max_factor\
    \ = i;\n            prime_found = true;\n        }\n        i += 1;\n    }\n \
    \   max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpny2og1gd.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    while\
    \ n % i == 0 {\n        i += 1;\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpada3kqrx.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1 {\n        let\
    \ mut max_divisor = 1;\n        let mut factor = 1;\n\n        for divisor in\
    \ 2..n {\n            if n % divisor == 0 {\n                factor = divisor;\n\
    \            } else {\n                if factor > max_divisor {\n           \
    \         max_divisor = factor;\n                }\n                factor = 1;\n\
    \            }\n        }\n\n        max_divisor\n    } else {\n        n\n  \
    \  }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpjf7s90z7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (2..=n).step_by(|i| {\n\
    \        if n % i == 0 {\n            i += 1;\n        }\n        i % 2\n    }).rev().first().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_c5b1_t4.rs:7:21\n   |\n\
    7  |       (2..=n).step_by(|i| {\n   |  _____________________^\n8  | |       \
    \  if n % i == 0 {\n9  | |             i += 1;\n10 | |         }\n11 | |     \
    \    i % 2\n12 | |     }).rev().first().unwrap()\n   | |_____^ expected `usize`,\
    \ found closure\n   |\n   = note: expected type `usize`\n           found closure\
    \ `[closure@/tmp/tmp_c5b1_t4.rs:7:21: 12:6]`\n\nerror[E0277]: the trait bound\
    \ `RangeInclusive<isize>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp_c5b1_t4.rs:12:8\n\
    \     |\n12   |     }).rev().first().unwrap()\n     |        ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `RangeInclusive<isize>`\n     |\n     = help: the following\
    \ other types implement trait `ExactSizeIterator`:\n               RangeInclusive<i16>\n\
    \               RangeInclusive<i8>\n               RangeInclusive<u16>\n     \
    \          RangeInclusive<u8>\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `StepBy<RangeInclusive<isize>>`\nnote:\
    \ required by a bound in `rev`\n\nerror[E0599]: no method named `first` found\
    \ for struct `Rev` in the current scope\n  --> /tmp/tmp_c5b1_t4.rs:12:14\n   |\n\
    12 |     }).rev().first().unwrap()\n   |              ^^^^^ method not found in\
    \ `Rev<StepBy<RangeInclusive<isize>>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut res = 1;\n\n\
    \    for (i, factor) in (&n)*(&n).rev().iter().enumerate() {\n        if factor*factor\
    \ > res {\n            res = factor;\n        }\n    }\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `&isize` is not an iterator\n --> /tmp/tmp_xe5bmkx.rs:9:34\n\
    \  |\n9 |     for (i, factor) in (&n)*(&n).rev().iter().enumerate() {\n  |   \
    \                               ^^^ `&isize` is not an iterator\n  |\n  = note:\
    \ the following trait bounds were not satisfied:\n          `&isize: Iterator`\n\
    \          which is required by `&mut &isize: Iterator`\n          `isize: Iterator`\n\
    \          which is required by `&mut isize: Iterator`\n\nerror[E0277]: `isize`\
    \ is not an iterator\n --> /tmp/tmp_xe5bmkx.rs:9:24\n  |\n9 |     for (i, factor)\
    \ in (&n)*(&n).rev().iter().enumerate() {\n  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `isize` is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented\
    \ for `isize`\n  = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n  = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n\n    let mut max = 2;\n    let mut prime: isize = 2;\n    while\
    \ prime <= n {\n        if n % prime == 0 {\n            max = prime;\n      \
    \  }\n        prime += 1;\n    }\n\n    max\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpkgcl6set.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as isize;\n\
    \    loop {\n        let mut n2 = n * n as isize;\n        loop {\n          \
    \  n += 1;\n            if n % n2 == 0 {\n                break n2;\n        \
    \    }\n            n2 += 2;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd1zqz23x.rs:13:23\n   |\n\
    13 |                 break n2;\n   |                       ^^ expected `()`, found\
    \ `isize`\n\nwarning: unreachable expression\n  --> /tmp/tmpd1zqz23x.rs:18:5\n\
    \   |\n8  | /     loop {\n9  | |         let mut n2 = n * n as isize;\n10 | |\
    \         loop {\n11 | |             n += 1;\n...  |\n16 | |         }\n17 | |\
    \     }\n   | |_____- any code following this expression is unreachable\n18 |\
    \       n\n   |       ^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use num_bigint::{BigInt,\
    \ Sign};\n\n    if n == 1 {\n        return 1;\n    }\n\n    let mut p = 2;\n\
    \    let mut d = 2;\n    let mut i = 1;\n\n    while i < n {\n        if n % p\
    \ == 0 {\n            d = p;\n        }\n\n        if n % d == 0 {\n         \
    \   p = d;\n        }\n\n        i += 1;\n    }\n\n    if p*p > n {\n        p\n\
    \    } else {\n        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num_bigint`\n --> /tmp/tmphn6zzx4a.rs:7:9\n\
    \  |\n7 |     use num_bigint::{BigInt, Sign};\n  |         ^^^^^^^^^^ maybe a\
    \ missing crate `num_bigint`?\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n   \
    \     return 2\n    }\n    let mut m = 3;\n    while m <= n / 2 {\n        if\
    \ n % m == 0 {\n            return m;\n        }\n        m += 1;\n    }\n   \
    \ n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpthefjun9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_limit =\
    \ n as usize;\n    while prime_limit > 2 {\n        if n % prime_limit == 0 {\n\
    \            prime_limit = n;\n        } else {\n            prime_limit /= 2;\n\
    \        }\n    }\n    prime_limit\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpltn5nn3x.rs:9:16\n  |\n9 |\
    \         if n % prime_limit == 0 {\n  |                ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n --> /tmp/tmpltn5nn3x.rs:9:14\n\
    \  |\n9 |         if n % prime_limit == 0 {\n  |              ^ no implementation\
    \ for `isize % usize`\n  |\n  = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n  = help: the following other types implement trait `Rem<Rhs>`:\n\
    \            <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n      \
    \      <&'a i128 as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n          \
    \  <&'a i32 as Rem<i32>>\n            <&'a i64 as Rem<i64>>\n            <&'a\
    \ i8 as Rem<i8>>\n            <&'a isize as Rem<isize>>\n          and 54 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpltn5nn3x.rs:10:27\n   |\n7  |\
    \     let mut prime_limit = n as usize;\n   |                           ----------\
    \ expected due to this value\n...\n10 |             prime_limit = n;\n   |   \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpltn5nn3x.rs:15:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n15 |     prime_limit\n   |     ^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     prime_limit.try_into().unwrap()\n\
    \   |                ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut p = 0;\n    while i <= n {\n        if n % i == 0 {\n            p = i;\n\
    \            break;\n        }\n        i += 1;\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpkuac8zj1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    loop {\n        if n\
    \ % 2 == 0 {\n            return 2;\n        }\n\n        for factor in &[2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] {\n            if n % factor\
    \ == 0 {\n                return factor;\n            }\n        }\n\n       \
    \ n /= 2;\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe4yo0vxr.rs:14:24\n   |\n\
    14 |                 return factor;\n   |                        ^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |                 return *factor;\n   |                        +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 26;\n   \
    \ let mut j = 0;\n    let mut p = 1;\n    let mut largest_prime_factor = 1;\n\n\
    \    while i * i <= n {\n        while n % i == 0 {\n            i += 1;\n   \
    \     }\n        if i == 1 {\n            break;\n        }\n        if i % j\
    \ == 0 {\n            break;\n        }\n        j += 1;\n        p += 1;\n  \
    \      if p > largest_prime_factor {\n            largest_prime_factor = p;\n\
    \        }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp6n0x51aw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    n.checked_add((2..=n.sqrt()\
    \ as isize).find(|&x| n % x == 0).unwrap()).unwrap_or(n)\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sqrt` found for type `isize` in the current\
    \ scope\n --> /tmp/tmprmw63vhl.rs:7:26\n  |\n7 |     n.checked_add((2..=n.sqrt()\
    \ as isize).find(|&x| n % x == 0).unwrap()).unwrap_or(n)\n  |                \
    \          ^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut j = n;\n\n    while i < j {\n        let mut k = 1;\n\n        while j *\
    \ k < i {\n            k += 1;\n        }\n\n        if i == k {\n           \
    \ return i;\n        }\n\n        i = k;\n        j -= k;\n    }\n\n    i\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpwougznz5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 2;\n\
    \    loop {\n        while n % i == 0 {\n            i += 1;\n            if i\
    \ > n {\n                break;\n            }\n        }\n        if i == 2 {\n\
    \            break;\n        }\n        i += 2;\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpbrpkaep8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    factorization(n)\n  \
    \      .iter()\n        .filter_map(|i| if *i > 1 { Some(*i) } else { None })\n\
    \        .max()\n        .unwrap_or(1)\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n -->\
    \ /tmp/tmp4o22ah0y.rs:7:5\n  |\n7 |     factorization(n)\n  |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn max_factor(n: isize)\
    \ -> isize {\n        fn factor(n: isize) -> isize {\n            if n == 1 {\n\
    \                return 1;\n            }\n            let mut max_factor = 2;\n\
    \            let mut div = n / 2;\n            while div != 0 {\n            \
    \    if n % div == 0 {\n                    max_factor *= div;\n             \
    \       n /= div;\n                } else {\n                    div *= max_factor;\n\
    \                }\n            }\n            return max_factor;\n        }\n\
    \        let max_factor = factor(n);\n        if max_factor == 1 {\n         \
    \   return 1;\n        }\n        factor(n)\n    }\n    let max_factor = max_factor(n);\n\
    \    max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnkhelbsv.rs:17:21\n\
    \   |\n8  |         fn factor(n: isize) -> isize {\n   |                   - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |                   \
    \  n /= div;\n   |                     ^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 3 {\n        1\n\
    \    } else {\n        let mut i = 2;\n        let mut j = 0;\n        while i\
    \ * j < n {\n            if n % i == 0 {\n                i += 1;\n          \
    \      break;\n            } else {\n                j += 1;\n            }\n\
    \        }\n        j\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `5`', /tmp/tmpcmtc7no9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors\
    \ = Vec::new();\n    let mut is_prime = true;\n    let mut max_prime = n / 2;\n\
    \n    while is_prime {\n        let mut i = 1;\n        while i <= max_prime {\n\
    \            let mut test = (i * max_prime) % n;\n            if test != 0 {\n\
    \                break;\n            }\n            i += 1;\n        }\n\n   \
    \     if i == max_prime {\n            is_prime = false;\n            prime_factors.push(i);\n\
    \        } else {\n            max_prime += 1;\n        }\n    }\n\n    prime_factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhqc1hgg.rs:29:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n29 |    \
    \ prime_factors.iter().max().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n29 |     *prime_factors.iter().max().unwrap()\n   |     +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     factor = i;\n            i += 1;\n        }\n        i += 1;\n    }\n  \
    \  factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp6jqvd_am.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ n;\n    }\n\n    let mut largest = u64::from(2);\n\n    for prime in 1..=n {\n\
    \        if n % prime == 0 {\n            if largest < prime as u64 {\n      \
    \          largest = prime;\n            }\n        }\n    }\n\n    largest\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp4wie9vr.rs:16:27\n   |\n\
    11 |     let mut largest = u64::from(2);\n   |                       ------------\
    \ expected due to this value\n...\n16 |                 largest = prime;\n   |\
    \                           ^^^^^ expected `u64`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp4wie9vr.rs:21:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n21 |     largest\n   |     ^^^^^^^ expected\
    \ `isize`, found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n21 |     largest.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let\
    \ mut max_factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n     \
    \       i += 1;\n            continue;\n        }\n        while n % i == 0 {\n\
    \            i += 1;\n            n /= i;\n        }\n        max_factor = i;\n\
    \    }\n    if n == 1 {\n        max_factor\n    } else {\n        max_factor\
    \ + 1\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2mzbdkvg.rs:16:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n16 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_divisor\
    \ = 0;\n    let mut largest_divisor_n = 0;\n    let mut largest_divisor_n_size\
    \ = 0;\n    let mut largest_divisor_n_size_index = 0;\n    for i in 1..n {\n \
    \       let mut found = false;\n        for j in 2..i {\n            if i % j\
    \ == 0 {\n                found = true;\n                break;\n            }\n\
    \        }\n        if found {\n            if largest_divisor_n_size < j {\n\
    \                largest_divisor_n_size = j;\n                largest_divisor_n_size_index\
    \ = i;\n            }\n        }\n    }\n    if largest_divisor_n_size != 0 {\n\
    \        if largest_divisor < largest_divisor_n_size {\n            largest_divisor\
    \ = largest_divisor_n_size;\n        }\n    }\n    largest_divisor_n_size\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmphzxqwbd5.rs:20:41\n\
    \   |\n20 |             if largest_divisor_n_size < j {\n   |                \
    \                         ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmphzxqwbd5.rs:21:42\n\
    \   |\n21 |                 largest_divisor_n_size = j;\n   |                \
    \                          ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    fn is_prime(n: isize)\
    \ -> bool {\n        n > 1 && !(n % 2)\n    }\n\n    let mut highest_factor =\
    \ 1;\n    for f in 2..n {\n        if !is_prime(f) {\n            highest_factor\
    \ = f\n            break;\n        }\n    }\n\n    highest_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `break`\n  --> /tmp/tmpmudw7tkz.rs:14:31\n\
    \   |\n14 |             highest_factor = f\n   |                             \
    \  ^ help: add `;` here\n15 |             break;\n   |             ----- unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpmudw7tkz.rs:8:18\n  |\n\
    8 |         n > 1 && !(n % 2)\n  |                  ^^^^^^^^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = n;\n\
    \n    // Factor the number by squaring it.\n    // Do this until it gets small\
    \ enough that we can factor it.\n    loop {\n        result *= result % isize::max_value();\n\
    \        if result < n {\n            break;\n        }\n    }\n\n    // The number\
    \ was squared, so if it had a factor, then it was bigger than\n    // n. Otherwise,\
    \ check if it made a prime (by trying all odd numbers up to\n    // sqrt(n)).\n\
    \    if n % result == 0 {\n        result\n    } else {\n        prime_factors_up_to_root(&mut\
    \ result).unwrap()\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors_up_to_root` in this scope\n\
    \  --> /tmp/tmpc9c7z3z2.rs:24:9\n   |\n24 |         prime_factors_up_to_root(&mut\
    \ result).unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    let mut i = 2;\n    while i * i < n && n % i != 0 {\n        factor *= i;\n\
    \        i += 1;\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmptykhwizi.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n\n  \
    \  while i * i <= n {\n        i += 1;\n    }\n\n    i;\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpel011hrh.rs:6:38\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |    --------------------\
    \              ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n13 |     i;\n\
    \   |      - help: remove this semicolon\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut result = 2;\n\
    \n    while result < n {\n        result = n % result;\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpaxlfey2i.rs:10:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Avoid division by\
    \ zero\n    if n % 2 == 0 {\n        return n / 2;\n    }\n    let mut m = n;\n\
    \    let mut p = 2;\n    while p * p <= m {\n        if m % p == 0 {\n       \
    \     m /= p;\n        } else {\n            p *= 2;\n        }\n    }\n    p\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpzaupy_l4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 1;\n    let mut max_prime = 2;\n\n    for f in 2..=n {\n        if n % f ==\
    \ 0 {\n            let p = f*max_factor;\n            if p > max_prime {\n   \
    \             max_prime = p;\n                max_factor = 1;\n            } else\
    \ {\n                max_factor = p;\n            }\n        }\n    }\n    max_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmp8gg6kz1u.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = isize::max_value();\n    for i in 2..=n/2 {\n        if n % i == 0 {\n   \
    \         if largest_prime_factor > i {\n                largest_prime_factor\
    \ = i;\n            }\n        }\n    }\n    largest_prime_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpwxb3hmun.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n   \
    \ let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n          \
    \  i += 1;\n        } else {\n            i += 2;\n        }\n    }\n    i\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpft1jnxb4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut max_factor = n as isize;\n\n    while n > 1 {\n        if n % 2 ==\
    \ 0 {\n            n /= 2;\n        } else {\n            n /= 2;\n          \
    \  max_factor = std::cmp::max(max_factor, n as isize);\n        }\n    }\n\n \
    \   max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpe0ywow63.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n / 2;\n\
    \    let mut i = 1;\n    while i * i <= n {\n        i = i + 1;\n        n = n\
    \ / i;\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmp54714dv6.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = Vec::new();\n\
    \    factors.push(2);\n    while n >= 2 {\n        let factor: isize = n % factors.last().unwrap();\n\
    \        factors.push(factor);\n        n = n / factor;\n    }\n    factors.reverse();\n\
    \    factors.last().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa54bbwal.rs:15:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n15 |    \
    \ factors.last().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |  \
    \   *factors.last().unwrap()\n   |     +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factor_iter(n)\n\
    \        .next()\n        .expect(\"cannot find largest_prime_factor\")\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_iter` in this\
    \ scope\n --> /tmp/tmppx1a9dq6.rs:7:5\n  |\n7 |     largest_prime_factor_iter(n)\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug!(\"largest_prime_factor\"\
    );\n    let mut factor = 1;\n    while n % factor == 0 {\n        factor += 1;\n\
    \    }\n    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n --> /tmp/tmp1uhjyw3s.rs:7:5\n\
    \  |\n7 |     debug!(\"largest_prime_factor\");\n  |     ^^^^^\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match n {\n        1\
    \ => 1,\n        2 => 2,\n        _ => {\n            let m = &*n % isize::max_value();\n\
    \            if *m > m {\n                m\n            } else {\n          \
    \      largest_prime_factor(&(n - m))\n            }\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp4fuk9a8q.rs:11:22\n\
    \   |\n11 |             let m = &*n % isize::max_value();\n   |              \
    \        ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4fuk9a8q.rs:15:38\n\
    \   |\n15 |                 largest_prime_factor(&(n - m))\n   |             \
    \                         ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider removing the borrow\n   |\n15 -                 largest_prime_factor(&(n\
    \ - m))\n15 +                 largest_prime_factor((n - m))\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match n % 2 {\n     \
    \   0 => 3,\n        1 => 5,\n        _ => n,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpx6lzi48c.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors(n)[0]\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factors` in this scope\n\
    \ --> /tmp/tmpwpmtihge.rs:7:5\n  |\n7 |     largest_prime_factors(n)[0]\n  | \
    \    ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    while\
    \ n >= p {\n        let next = n%p;\n        if next != 0 {\n            break;\n\
    \        }\n        p += 1;\n    }\n    p\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpc6g2w_fe.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f: usize = 2;\
    \ // starting at 2 since the largest prime factor is 2\n    while f * f <= n {\n\
    \        if n % f == 0 {\n            return f;\n        }\n        f += 1;\n\
    \    }\n    return f;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkaaifu76.rs:8:20\n  |\n8 |\
    \     while f * f <= n {\n  |                    ^ expected `usize`, found `isize`\n\
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n  |\n8 |     while f * f <= n.try_into().unwrap() {\n  |\
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpkaaifu76.rs:9:16\n  |\n9 |         if n % f == 0 {\n  |        \
    \        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize`\
    \ by `usize`\n --> /tmp/tmpkaaifu76.rs:9:14\n  |\n9 |         if n % f == 0 {\n\
    \  |              ^ no implementation for `isize % usize`\n  |\n  = help: the\
    \ trait `Rem<usize>` is not implemented for `isize`\n  = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n            <&'a f32 as Rem<f32>>\n     \
    \       <&'a f64 as Rem<f64>>\n            <&'a i128 as Rem<i128>>\n         \
    \   <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n            <&'a\
    \ i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n            <&'a isize as\
    \ Rem<isize>>\n          and 54 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkaaifu76.rs:10:20\n   |\n10 |             return f;\n   |          \
    \          ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n10 |     \
    \        return f.try_into().unwrap();\n   |                     ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    (1..n).filter(|&n| is_prime(n)).max()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpz7phvo3z.rs:7:24\n\
    \  |\n7 |     (1..n).filter(|&n| is_prime(n)).max()\n  |                     \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz7phvo3z.rs:7:5\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \                    ----- expected `isize` because of return type\n7 |     (1..n).filter(|&n|\
    \ is_prime(n)).max()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n  |\n  = note: expected type `isize`\n             found\
    \ enum `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut p = 1i32;\n \
    \   let mut i = 3i32;\n    while i <= n {\n        if n % i == 0 {\n         \
    \   p += 1;\n        }\n        i += 2i32;\n    }\n    p\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_syrg6us.rs:9:16\n  |\n9 |\
    \     while i <= n {\n  |                ^ expected `i32`, found `isize`\n  |\n\
    help: you can convert an `isize` to an `i32` and panic if the converted value\
    \ doesn't fit\n  |\n9 |     while i <= n.try_into().unwrap() {\n  |          \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_syrg6us.rs:10:16\n\
    \   |\n10 |         if n % i == 0 {\n   |                ^ expected `isize`, found\
    \ `i32`\n\nerror[E0277]: cannot mod `isize` by `i32`\n  --> /tmp/tmp_syrg6us.rs:10:14\n\
    \   |\n10 |         if n % i == 0 {\n   |              ^ no implementation for\
    \ `isize % i32`\n   |\n   = help: the trait `Rem<i32>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_syrg6us.rs:15:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n15\
    \ |     p\n   |     ^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |     p.try_into().unwrap()\n   |      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976714
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 0;\n    }\n\n    let mut i = 1;\n\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            return i;\n        }\n\n        i += 1;\n    }\n\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmp4mgdkkq3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 1usize;\n\
    \    loop {\n        if n % f == 0 {\n            return f;\n        }\n     \
    \   f += 2usize;\n        if f > 1usize {\n            return 1usize;\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8uf87u5d.rs:9:16\n  |\n9 |\
    \         if n % f == 0 {\n  |                ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot mod `isize` by `usize`\n --> /tmp/tmp8uf87u5d.rs:9:14\n\
    \  |\n9 |         if n % f == 0 {\n  |              ^ no implementation for `isize\
    \ % usize`\n  |\n  = help: the trait `Rem<usize>` is not implemented for `isize`\n\
    \  = help: the following other types implement trait `Rem<Rhs>`:\n           \
    \ <&'a f32 as Rem<f32>>\n            <&'a f64 as Rem<f64>>\n            <&'a i128\
    \ as Rem<i128>>\n            <&'a i16 as Rem<i16>>\n            <&'a i32 as Rem<i32>>\n\
    \            <&'a i64 as Rem<i64>>\n            <&'a i8 as Rem<i8>>\n        \
    \    <&'a isize as Rem<isize>>\n          and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8uf87u5d.rs:10:20\n   |\n10 |             return f;\n \
    \  |                    ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n10 |             return f.try_into().unwrap();\n   |                  \
    \   ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i < n {\n        if n % i == 0 {\n            return i;\n        }\n   \
    \     i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpe46j5j17.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n as usize;\n\
    \    let mut p = 2 as usize;\n    while p < n {\n        if n % p == 0 {\n   \
    \         m = n / p;\n            p += 1;\n        }\n        p += 1;\n    }\n\
    \    m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxzzqdak5.rs:9:15\n  |\n9 |\
    \     while p < n {\n  |               ^ expected `usize`, found `isize`\n  |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n  |\n9 |     while p < n.try_into().unwrap() {\n  |           \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxzzqdak5.rs:10:16\n\
    \   |\n10 |         if n % p == 0 {\n   |                ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpxzzqdak5.rs:10:14\n\
    \   |\n10 |         if n % p == 0 {\n   |              ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxzzqdak5.rs:11:21\n\
    \   |\n11 |             m = n / p;\n   |                     ^ expected `isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxzzqdak5.rs:11:17\n\
    \   |\n7  |     let mut m = n as usize;\n   |                 ---------- expected\
    \ due to this value\n...\n11 |             m = n / p;\n   |                 ^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n\
    \  --> /tmp/tmpxzzqdak5.rs:11:19\n   |\n11 |             m = n / p;\n   |    \
    \               ^ no implementation for `isize / usize`\n   |\n   = help: the\
    \ trait `Div<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut f = 1isize;\n\
    \    let mut max_f = 2isize;\n    while f * f <= n {\n        if n % f == 0 {\n\
    \            f = f * 2;\n        } else {\n            f += 1;\n        }\n  \
    \      if f > max_f {\n            max_f = f;\n        }\n    }\n    max_f\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmp8x4ttnhn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![2;];\
    \ // Primes <= n are already known to be non-prime factors\n    let mut factors\
    \ = Vec::new();\n    // Check prime factors up to the square root of the number.\n\
    \    for i in 2..=n.sqrt() {\n        if n / i != i {\n            continue;\n\
    \        }\n        for p in primes.iter().rev() {\n            // Test for factor\
    \ of i\n            if n % p == 0 {\n                factors.push(i);\n      \
    \          break;\n            }\n        }\n    }\n    factors.sort_unstable();\n\
    \    factors.first().unwrap_or(n)\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected end of macro invocation\n --> /tmp/tmp_8059b9o.rs:7:29\n\
    \  |\n7 |     let mut primes = vec![2;]; // Primes <= n are already known to be\
    \ non-prime factors\n  |                             ^ missing tokens in macro\
    \ arguments\n\nerror[E0599]: no method named `sqrt` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp_8059b9o.rs:10:20\n   |\n10 |     for i in\
    \ 2..=n.sqrt() {\n   |                    ^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_8059b9o.rs:23:31\n   |\n23 |  \
    \   factors.first().unwrap_or(n)\n   |                               ^\n   | \
    \                              |\n   |                               expected\
    \ `&isize`, found `isize`\n   |                               help: consider borrowing\
    \ here: `&n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_8059b9o.rs:23:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n23\
    \ |     factors.first().unwrap_or(n)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |     *factors.first().unwrap_or(n)\n   |     +\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ factors.push(i);\n        }\n        i += 1;\n    }\n    factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2w0ubj9j.rs:15:5\n   |\n\
    6  | fn largest_prime_factor(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n15 |    \
    \ factors.iter().max().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    15 |     *factors.iter().max().unwrap()\n   |     +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            return i;\n        }\n  \
    \      i += 1;\n    }\n    return n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpyzwecjqe.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut ns: Vec<_> =\
    \ vec![n as usize];\n    loop {\n        ns.push(n);\n        n = smallest_prime_factor(n);\n\
    \        if ns.remove(&n).is_some() {\n            break;\n        }\n    }\n\
    \    ns.reverse();\n    ns.pop()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `smallest_prime_factor` in this scope\n\
    \  --> /tmp/tmpu4riav2a.rs:10:13\n   |\n10 |         n = smallest_prime_factor(n);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpu4riav2a.rs:9:17\n  |\n9 |         ns.push(n);\n\
    \  |                 ^ expected `usize`, found `isize`\n  |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n  |\n\
    9 |         ns.push(n.try_into().unwrap());\n  |                  ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu4riav2a.rs:11:22\n   |\n11 |\
    \         if ns.remove(&n).is_some() {\n   |                      ^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0599]: no method named `is_some` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmpu4riav2a.rs:11:26\n   |\n11\
    \ |         if ns.remove(&n).is_some() {\n   |                          ^^^^^^^\
    \ method not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu4riav2a.rs:16:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n16\
    \ |     ns.pop()\n   |     ^^^^^^^^ expected `isize`, found enum `Option`\n  \
    \ |\n   = note: expected type `isize`\n              found enum `Option<usize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert_eq!(n >\
    \ 0, \"n must be greater than 0\");\n    let mut primes = vec![2..n];\n    primes.remove(&1);\n\
    \n    for prime in primes.iter() {\n        let mut max_multiple: isize = 0;\n\
    \        let mut prime_factor = 1;\n        while prime > 1 {\n            if\
    \ prime % 2 == 0 {\n                prime_factor *= 2;\n            }\n      \
    \      prime_factor = prime / 2;\n            prime = prime % primes.len();\n\
    \        }\n        max_multiple = max_multiple < prime_factor ? max_multiple\
    \ : prime_factor;\n    }\n    max_multiple\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `max_multiple`\n\
    \  --> /tmp/tmpa3k744bo.rs:21:54\n   |\n21 |         max_multiple = max_multiple\
    \ < prime_factor ? max_multiple : prime_factor;\n   |                        \
    \                              ^^^^^^^^^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0425]: cannot find value `max_multiple` in this scope\n\
    \  --> /tmp/tmpa3k744bo.rs:23:5\n   |\n23 |     max_multiple\n   |     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/tmpa3k744bo.rs:7:5\n\
    \  |\n7 |     debug_assert_eq!(n > 0, \"n must be greater than 0\");\n  |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `&str`\n\
    \  |\n  = note: this error originates in the macro `$crate::assert_eq` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpa3k744bo.rs:9:19\n  |\n9 |     primes.remove(&1);\n  | \
    \                  ^^ expected `usize`, found `&{integer}`\n  |\nhelp: consider\
    \ removing the borrow\n  |\n9 -     primes.remove(&1);\n9 +     primes.remove(1);\n\
    \  | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3k744bo.rs:14:23\n   |\n\
    14 |         while prime > 1 {\n   |                       ^\n   |           \
    \            |\n   |                       expected reference, found integer\n\
    \   |                       help: consider borrowing here: `&1`\n   |\n   = note:\
    \ expected reference `&_`\n                   found type `{integer}`\n\nerror[E0369]:\
    \ binary operation `>` cannot be applied to type `&std::ops::Range<isize>`\n \
    \ --> /tmp/tmpa3k744bo.rs:14:21\n   |\n14 |         while prime > 1 {\n   |  \
    \             ----- ^ - &_\n   |               |\n   |               &std::ops::Range<isize>\n\
    \nerror[E0369]: cannot mod `&std::ops::Range<isize>` by `{integer}`\n  --> /tmp/tmpa3k744bo.rs:15:22\n\
    \   |\n15 |             if prime % 2 == 0 {\n   |                ----- ^ - {integer}\n\
    \   |                |\n   |                &std::ops::Range<isize>\n\nerror[E0369]:\
    \ cannot divide `&std::ops::Range<isize>` by `{integer}`\n  --> /tmp/tmpa3k74"
  stdout: ''
  timestamp: 1659976715
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as isize;\n\
    \    let mut max_factor = 1;\n    let mut i = 2;\n    while i < n {\n        let\
    \ mut j = i;\n        while j < n && n % j == 0 {\n            j = j + 1;\n  \
    \      }\n        if j > max_factor {\n            max_factor = j;\n        }\n\
    \        i = j;\n    }\n    max_factor\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976720
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return\
    \ 1;\n    }\n\n    // n & 1 => n must be prime\n    if n == 1 {\n        return\
    \ n;\n    }\n\n    let mut i = 2;\n\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            return i;\n        }\n        i += 1;\n    }\n\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpp9lv_mpc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let\
    \ mut m2 = 1;\n    while m2 <= m {\n        let mut m3 = m;\n        while m3\
    \ % m2 == 0 {\n            m3 /= m2;\n        }\n        if m3 != 1 {\n      \
    \      m2 += m3;\n        } else {\n            break;\n        }\n    }\n   \
    \ m\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976720
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut a = primes::get();\n\
    \    a.checked_add(n).unwrap();\n    while a.is_prime(1) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    a.checked_add(2).unwrap();\n    while a.is_prime(2) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    a.checked_add(3).unwrap();\n    while a.is_prime(3) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(4) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    a.checked_add(5).unwrap();\n    while a.is_prime(5) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(6) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(7) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(8) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(9)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(10) {\n \
    \       a.checked_add(1).unwrap();\n    }\n    while a.is_prime(11) {\n      \
    \  a.checked_add(1).unwrap();\n    }\n    while a.is_prime(12) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(13) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(14) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(15) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(16)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(17) {\n \
    \       a.checked_add(1).unwrap();\n    }\n    while a.is_prime(18) {\n      \
    \  a.checked_add(1).unwrap();\n    }\n    while a.is_prime(19) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(20) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(21) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(22) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(23)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(24) {\n \
    \       a.checked_add(1).unwrap();\n    }\n    while a.is_prime(25) {\n      \
    \  a.checked_add(1).\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa7xn_rt4.rs:95:3\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n84 |     while a.is_prime(25)\
    \ {\n   |                          - this delimiter might not be properly closed...\n\
    85 |         a.checked_add(1).\n86 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n95 | }\n   |   ^\n\nerror: unexpected token: `}`\n\
    \  --> /tmp/tmpa7xn_rt4.rs:86:1\n   |\n86 | }\n   | ^\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `primes`\n --> /tmp/tmpa7xn_rt4.rs:7:17\n\
    \  |\n7 |     let mut a = primes::get();\n  |                 ^^^^^^ use of undeclared\
    \ crate or module `primes`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpa7xn_rt4.rs:6:38\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |    --------------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i: isize = 1;\n\
    \    let mut m: isize = 1;\n    for _ in 0..n {\n        if n % i == 0 {\n   \
    \         i = i * m / i;\n            m = 1;\n        } else {\n            m\
    \ = m * m / i;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpc6tn42e8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    use std::cmp::Ordering::{GT,\
    \ Less};\n\n    // n is odd\n    if n % 2 == 1 {\n        return 1;\n    }\n\n\
    \    // n is prime\n    if n == 1 {\n        return n;\n    }\n\n    // 2 is the\
    \ smallest even integer\n    if n == 2 || n % 2 == 0 {\n        return 2;\n  \
    \  }\n\n    let mut m = n::max_value();\n\n    while m % 2 == 0 {\n        m /=\
    \ 2;\n    }\n\n    while m % 3 == 0 {\n        m /= 3;\n    }\n\n    while m %\
    \ 5 == 0 {\n        m /= 5;\n    }\n\n    while m % 7 == 0 {\n        m /= 7;\n\
    \    }\n\n    while m % 11 == 0 {\n        m /= 11;\n    }\n\n    while m % 13\
    \ == 0 {\n        m /= 13;\n    }\n\n    while m % 17 == 0 {\n        m /= 17;\n\
    \    }\n\n    while m % 19 == 0 {\n        m /= 19;\n    }\n\n    while m % 23\
    \ == 0 {\n        m /= 23;\n    }\n\n    while m % 29 == 0 {\n        m /= 29;\n\
    \    }\n\n    while m % 31 == 0 {\n        m /= 31;\n    }\n\n    while m % 37\
    \ == 0 {\n        m /= 37;\n    }\n\n    while m % 41 == 0 {\n        m /= 41;\n\
    \    }\n\n    while m % 43 == 0 {\n        m /= 43;\n    }\n\n    while m % 47\
    \ == 0 {\n        m /= 47;\n    }\n\n    while m % 53 == 0 {\n        m /= 53;\n\
    \    }\n\n    while m % 59 == 0 {\n        m /= 59;\n    }\n\n    while m % 61\
    \ == 0 {\n        m /= 61;\n    }\n\n    while m % 67 == 0 {\n        m /= 67;\n\
    \    }\n\n    while m % 71 == 0 {\n        m /= 71;\n    }\n\n    while m % 73\
    \ == 0 {\n        m /= 73;\n    }\n\n    while m % 79 == 0 {\n        m /= 79;\n\
    \    }\n\n    while m % 83 == 0 {\n        m /= 83;\n    }\n\n    while m % 89\
    \ == 0 {\n        m /= 89;\n    }\n\n    while m % 97 == 0 {\n        m /= 97;\n\
    \    }\n\n    while m % 101 == 0 {\n        m /= 101;\n    }\n\n    while m %\
    \ 103 == 0 {\n        m /= 103;\n    }\n\n    while m % 107 == 0 {\n        m\
    \ /= 107;\n    }\n\n    while m % 109 == 0 {\n        m /= 109;\n    }\n\n   \
    \ while m % 113 == 0 {\n        m /= 113;\n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppwlbc0mi.rs:154:3\n\
    \    |\n6   | fn largest_prime_factor(n: isize) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n142 |     while m\
    \ % 113 == 0 {\n    |                        - this delimiter might not be properly\
    \ closed...\n...\n145 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n154 | }\n    |   ^\n\nerror[E0432]: unresolved import `std::cmp::Ordering::GT`\n\
    \ --> /tmp/tmppwlbc0mi.rs:7:30\n  |\n7 |     use std::cmp::Ordering::{GT, Less};\n\
    \  |                              ^^ no `GT` in `cmp::Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `n`\n  --> /tmp/tmppwlbc0mi.rs:24:17\n\
    \   |\n24 |     let mut m = n::max_value();\n   |                 ^ use of undeclared\
    \ crate or module `n`\n\nwarning: unused import: `Less`\n --> /tmp/tmppwlbc0mi.rs:7:34\n\
    \  |\n7 |     use std::cmp::Ordering::{GT, Less};\n  |                       \
    \           ^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmppwlbc0mi.rs:6:38\n  |\n6 | fn largest_prime_factor(n:\
    \ isize) -> isize {\n  |    --------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor:\
    \ Vec<_> = (0..n).filter(|&x| *x == 0).collect();\n    let mut prime_factors =\
    \ vec![0; n];\n\n    for &d in &mut prime_factors {\n        if *d >= 2 {\n  \
    \          for &r in &mut prime_factor {\n                if r > d {\n       \
    \             *d = r;\n                    break;\n                }\n       \
    \     }\n        }\n    }\n\n    let mut largest_factor = 1;\n    for &d in &prime_factors\
    \ {\n        largest_factor *= d;\n    }\n\n    if largest_factor > n {\n    \
    \    largest_factor\n    } else {\n        n\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpoq2ul2lk.rs:7:55\n\
    \  |\n7 |     let mut prime_factor: Vec<_> = (0..n).filter(|&x| *x == 0).collect();\n\
    \  |                                                       ^^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpoq2ul2lk.rs:8:37\n  |\n8 |     let mut prime_factors\
    \ = vec![0; n];\n  |                                     ^ expected `usize`, found\
    \ `isize`\n  |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n  |\n8 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n\
    \  |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoq2ul2lk.rs:10:9\n   |\n10 |     for &d in &mut\
    \ prime_factors {\n   |         ^^    ------------------ this expression has type\
    \ `Option<&mut {integer}>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `d`\n   |\n \
    \  = note: expected mutable reference `&mut {integer}`\n                     \
    \ found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoq2ul2lk.rs:12:17\n\
    \   |\n12 |             for &r in &mut prime_factor {\n   |                 ^^\
    \    ----------------- this expression has type `Option<&mut isize>`\n   |   \
    \              |\n   |                 types differ in mutability\n   |      \
    \           help: you can probably remove the explicit borrow: `r`\n   |\n   =\
    \ note: expected mutable reference `&mut isize`\n                      found reference\
    \ `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    largest_prime_factors_iter(n).next()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factors_iter` in this\
    \ scope\n --> /tmp/tmpx61wrn04.rs:7:5\n  |\n7 |     largest_prime_factors_iter(n).next()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 1;\n\
    \    while n % factor == 0 {\n        factor += 1;\n    }\n    factor\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmprqbwyho0.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3;\n    let\
    \ mut lf = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            if\
    \ i != n {\n                i += 1;\n                lf = 0;\n            } else\
    \ {\n                i += 1;\n            }\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp4xidre0c.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 2;\n    let mut prime_factors_found = 0;\n\n    while prime_factors_found\
    \ < n / prime_factor {\n        if n % prime_factor == 0 {\n            n /= prime_factor;\n\
    \            prime_factors_found += 1;\n        } else {\n            prime_factor\
    \ += 1;\n        }\n    }\n\n    prime_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpryvm8cc3.rs:12:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n12 |  \
    \           n /= prime_factor;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut is_prime: Vec<_>\
    \ = Vec::new();\n    for i in 2..n {\n        if is_prime.iter().any(|&x| x ==\
    \ true) {\n            return i;\n        }\n        for divisor in 0..i {\n \
    \           if n % divisor == 0 {\n                is_prime.push(divisor);\n \
    \               break;\n            }\n        }\n    }\n    0\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `bool`\n --> /tmp/tmpfowvycaw.rs:9:39\n\
    \  |\n9 |         if is_prime.iter().any(|&x| x == true) {\n  |              \
    \                         ^^ no implementation for `isize == bool`\n  |\n  = help:\
    \ the trait `PartialEq<bool>` is not implemented for `isize`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            f32\n           \
    \ f64\n            i128\n            i16\n            i32\n            i64\n \
    \           i8\n            isize\n          and 6 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = vec![0;\
    \ 3];\n    let mut p = 1usize;\n    let mut i = 2;\n    while i <= n {\n     \
    \   while n % p == 0 {\n            primes[0] += 1;\n            n /= p;\n   \
    \     }\n        primes[i] += 1;\n        p *= i;\n        i += 1;\n    }\n  \
    \  primes[2] // the last one\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph42neetp.rs:11:19\n   |\n\
    11 |         while n % p == 0 {\n   |                   ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmph42neetp.rs:11:17\n\
    \   |\n11 |         while n % p == 0 {\n   |                 ^ no implementation\
    \ for `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph42neetp.rs:13:18\n\
    \   |\n13 |             n /= p;\n   |                  ^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmph42neetp.rs:13:15\n\
    \   |\n13 |             n /= p;\n   |               ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmph42neetp.rs:15:9\n   |\n15 |         primes[i] += 1;\n   |    \
    \     ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut primes = prime_factors(n);\n\
    \    primes.reverse();\n    primes.filter(|x| x < n).max()\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmp1ax77sdz.rs:7:22\n  |\n7 |     let mut primes = prime_factors(n);\n\
    \  |                      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest = n;\n\
    \    let mut counter = 1;\n    loop {\n        largest /= counter;\n        if\
    \ largest % 2 == 1 {\n            return largest;\n        }\n        counter\
    \ += 1;\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpd9a64ya_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2isize;\n\
    \    let mut max: isize = 1;\n    while i <= n {\n        if n % i == 0 {\n  \
    \          max = i;\n        }\n        i += 2isize;\n    }\n    max\n}\n\nfn\
    \ main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpmm5g6hlv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    loop\
    \ {\n        if n % i == 0 {\n            i += 1;\n            n /= i;\n     \
    \   } else {\n            break;\n        }\n    }\n    i\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpcb7ocnn6.rs:11:13\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n11 |  \
    \           n /= i;\n   |             ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Prime factors of n\
    \ are (n - 1) // 2 - 1 or (n - 1) // 2 + 1\n    let mut prime_factors = vec![n];\n\
    \    prime_factors.push(n - 1);\n    prime_factors.push(n - 1);\n    while prime_factors.len()\
    \ < n.clone() / 2 {\n        for &p in &prime_factors {\n            if n % p\
    \ == 0 {\n                break;\n            }\n        }\n        prime_factors.push(2\
    \ * p);\n    }\n    prime_factors[0]\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `p` in this scope\n  --> /tmp/tmp31ud3hvk.rs:17:32\n\
    \   |\n17 |         prime_factors.push(2 * p);\n   |                         \
    \       ^ help: a local variable with a similar name exists: `n`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp31ud3hvk.rs:11:33\n   |\n11 |     while prime_factors.len()\
    \ < n.clone() / 2 {\n   |                                 ^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     while prime_factors.len()\
    \ < (n.clone() / 2).try_into().unwrap() {\n   |                              \
    \   +             +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n\n    if n % 2 == 0 {\n        largest_prime_factor = n.checked_mul(2).unwrap();\n\
    \        largest_prime_factor = largest_prime_factor.checked_add(1).unwrap();\n\
    \    }\n\n    let mut counter = 1;\n    while counter <= n {\n        largest_prime_factor\
    \ = n.checked_mul(largest_prime_factor).unwrap();\n        counter = counter.checked_add(1).unwrap();\n\
    \    }\n\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `437893890380859375`,\n right: `5`', /tmp/tmpwbd2v9pk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut max_factor =\
    \ 0;\n    let mut next_factor = 1;\n    for prime in &primes {\n        if n >\
    \ prime {\n            n /= prime;\n            max_factor = next_factor;\n  \
    \          next_factor = 1;\n        } else {\n            n /= prime;\n     \
    \       next_factor *= prime;\n        }\n    }\n    max_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `primes` in this scope\n --> /tmp/tmp6oo5odio.rs:9:19\n\
    \  |\n9 |     for prime in &primes {\n  |                   ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            return i;\n        }\n      \
    \  i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpe4yqo7p0.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as isize;\n\
    \    if n % 2 == 1 {\n        return 2;\n    }\n    n /= 2;\n    loop {\n    \
    \    if n == 1 {\n            return n;\n        }\n        if n % 2 == 1 {\n\
    \            return 2;\n        }\n        n /= 2;\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpeyd2tqlj.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 1;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n \
    \           return i;\n        }\n    }\n    return i;\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmp635slqqz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    // Optimize for small\
    \ numbers that won't need a prime.\n    if n < 3 {\n        return n;\n    }\n\
    \n    let mut n = n;\n    let mut i = 1;\n\n    // Scan for prime factors.\n \
    \   while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n\n    // Return only the largest\
    \ prime factor.\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976720
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor\
    \ = 1;\n    let mut primes = prime_factors(n);\n\n    while primes.len() > 0 {\n\
    \        let mut found = false;\n        let mut factor = 1;\n        for prime\
    \ in primes {\n            if n == prime {\n                found = true;\n  \
    \              factor = 1;\n                continue;\n            }\n       \
    \     factor *= prime;\n        }\n        if !found {\n            largest_factor\
    \ *= factor;\n        }\n        primes.clear();\n    }\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpzrovl3ez.rs:8:22\n  |\n8 |     let mut primes = prime_factors(n);\n\
    \  |                      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2; // start\
    \ at 2 since 2 will never be a prime number\n    let mut max_factor_found = 0;\n\
    \n    // continue increasing i by one until we hit our maximum factor\n    while\
    \ i <= n {\n        // check if i is a prime by checking if it divides evenly\n\
    \        let mut is_prime = true;\n\n        // check if i is divisible by any\
    \ prime less than i\n        while i % 2 == 0 {\n            i += 1;\n       \
    \     i += 2;\n            is_prime = false;\n        }\n\n        // check if\
    \ i is divisible by any prime greater than i\n        while i % 3 == 0 {\n   \
    \         i += 1;\n            i += 2;\n            is_prime = false;\n      \
    \  }\n\n        // check if i is divisible by any prime greater than i\n     \
    \   while i % 5 == 0 {\n            i += 1;\n            i += 2;\n           \
    \ is_prime = false;\n        }\n\n        // check if i is divisible by any prime\
    \ greater than i\n        while i % 7 == 0 {\n            i += 1;\n          \
    \  i += 2;\n            is_prime = false;\n        }\n\n        // check if i\
    \ is divisible by any prime greater than i\n        while i % 11 == 0 {\n    \
    \        i += 1;\n            i += 2;\n            is_prime = false;\n       \
    \ }\n\n        // check if i is divisible by any prime greater than i\n      \
    \  while i % 13 == 0 {\n            i += 1;\n            i += 2;\n           \
    \ is_prime = false;\n        }\n\n        // check if i is divisible by any prime\
    \ greater than i\n        while i % 17 == 0 {\n            i += 1;\n         \
    \   i += 2;\n            is_prime = false;\n        }\n\n        // check if i\
    \ is divisible by any prime greater than i\n        while i % 19 == 0 {\n    \
    \        i += 1;\n            i += 2;\n            is_prime = false;\n       \
    \ }\n\n        // check if i is divisible by any prime greater than i\n      \
    \  while i % 23 == 0 {\n            i += 1;\n            i += 2;\n           \
    \ is_prime = false;\n        }\n\n        // check if i is divisible by any prime\
    \ greater than i\n        while i % 29 == 0 {\n            i += 1;\n         \
    \   i += 2;\n            is_prime = false;\n        }\n\n        // check if i\
    \ is divisible by any prime greater than i\n        while i % 31 == 0 {\n    \
    \        i += 1;\n            i += 2;\n            is_prime = false;\n       \
    \ }\n\n        // check if i is divisible by any prime greater than i\n      \
    \  while i % 37 == 0 {\n            i += 1;\n            i += 2;\n           \
    \ is_prime = false;\n        }\n\n        // check if i is divisible by any prime\
    \ greater than i\n        while i % 41 == 0 {\n            i += 1;\n         \
    \   i += 2;\n            is_prime = false;\n        }\n\n        // check if i\
    \ is divisible by any prime greater than i\n        while i % 43 == 0 {\n    \
    \        i += 1;\n            i += 2;\n            is_prime = false;\n       \
    \ }\n\n        // check if \n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqdtxt0q2.rs:123:3\n\
    \    |\n6   | fn largest_prime_factor(n: isize) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n11  |     while i\
    \ <= n {\n    |                  - this delimiter might not be properly closed...\n\
    ...\n114 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n123 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpqdtxt0q2.rs:6:38\n\
    \  |\n6 | fn largest_prime_factor(n: isize) -> isize {\n  |    --------------------\
    \              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut n = n as u64;\n\
    \    let mut factors: Vec<isize> = vec![];\n    let mut max = 1;\n    let mut\
    \ i = 1;\n    while i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            max = i;\n        }\n        i += 1;\n    }\n    for i in 1..factors.len()\
    \ {\n        if factors[i] > max {\n            max = factors[i];\n        }\n\
    \    }\n    max\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_hlfnt4.rs:13:26\n   |\n\
    13 |             factors.push(i);\n   |                          ^ expected `isize`,\
    \ found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n13 |             factors.push(i.try_into().unwrap());\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu_hlfnt4.rs:19:25\n   |\n19 |         if factors[i] > max\
    \ {\n   |                         ^^^ expected `isize`, found `u64`\n   |\nhelp:\
    \ you can convert a `u64` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |         if factors[i] > max.try_into().unwrap() {\n   |    \
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu_hlfnt4.rs:20:19\n   |\n9  |     let mut max = 1;\n   |      \
    \             - expected due to this value\n...\n20 |             max = factors[i];\n\
    \   |                   ^^^^^^^^^^ expected `u64`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu_hlfnt4.rs:23:5\n   |\n6  | fn largest_prime_factor(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n23 |     max\n   |     ^^^ expected `isize`,\
    \ found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     max.try_into().unwrap()\n  \
    \ |        ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    debug_assert_ne!(n as\
    \ usize, \"cannot take the absolute value of a usize\");\n    let mut factors\
    \ = vec![n as isize];\n    factors.insert(factors.len(), 1);\n    loop {\n   \
    \     let mut i = factors.len() - 1;\n        let mut found = false;\n       \
    \ while i >= 0 {\n            if factors[i] % n == 0 {\n                factors.pop();\n\
    \                found = true;\n                break;\n            }\n      \
    \      i -= 1;\n        }\n        if found {\n            break;\n        }\n\
    \        factors.insert(0, n);\n    }\n    factors.len()\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpz9wl9lz9.rs:7:5\n  |\n7 |\
    \     debug_assert_ne!(n as usize, \"cannot take the absolute value of a usize\"\
    );\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&str`\n  |\n  = note: this error originates in the\
    \ macro `$crate::assert_ne` (in Nightly builds, run with -Z macro-backtrace for\
    \ more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9wl9lz9.rs:26:5\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n26\
    \ |     factors.len()\n   |     ^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |     factors.len().try_into().unwrap()\n   |  \
    \                ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    loop {\n        let mut\
    \ primes = Vec::new();\n        for d in divisors(n) {\n            if d > 1 {\n\
    \                primes.push(d % n);\n            }\n        }\n        if primes.len()\
    \ == 1 {\n            return primes[0];\n        }\n        n = primes[0];\n \
    \   }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `divisors` in this scope\n --> /tmp/tmpp_4yga3m.rs:9:18\n\
    \  |\n9 |         for d in divisors(n) {\n  |                  ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    match factorization(n)\
    \ {\n        Some(factors) => factors.len() as isize,\n        None => 1,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n -->\
    \ /tmp/tmpkcu0g_fk.rs:7:11\n  |\n7 |     match factorization(n) {\n  |       \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n\
    \            i -= 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976720
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    if n > 1 {\n        let\
    \ mut n = n;\n        let mut d = 0;\n        while n % d == 0 {\n           \
    \ d += 1;\n            n /= d;\n        }\n        d\n    } else {\n        1\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpzh8cbq8b.rs:10:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976715
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factor\
    \ = 1;\n    let mut current_factor = 2;\n\n    while current_factor < n {\n  \
    \      prime_factor = current_factor;\n        if n % current_factor == 0 {\n\
    \            while n % current_factor != 0 {\n                n /= current_factor;\n\
    \                current_factor *= 2;\n            }\n            break;\n   \
    \     }\n        current_factor *= 2;\n    }\n    prime_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdd7qxhn5.rs:14:17\n\
    \   |\n6  | fn largest_prime_factor(n: isize) -> isize {\n   |               \
    \          - help: consider making this binding mutable: `mut n`\n...\n14 |  \
    \               n /= current_factor;\n   |                 ^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976715
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
    /// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3 * n;\n\
    \    while i * i <= n {\n        i += 1;\n    }\n    i\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `45`,\n right: `5`', /tmp/tmpu8gtt6e6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976715
