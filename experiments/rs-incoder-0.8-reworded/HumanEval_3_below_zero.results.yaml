language: rs
name: HumanEval_3_below_zero
results:
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |mut\
    \ current, operation| {\n        current + (operation as isize)\n    });\n   \
    \ balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp9mhai7ld.rs:10:19\n\
    \   |\n10 |         current + (operation as isize)\n   |                   ^---------^^^^^^^^^^\n\
    \   |                   ||\n   |                   |help: dereference the expression:\
    \ `*operation`\n   |                   cannot cast `&isize` as `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0i32;\n    \n    for mut op in\
    \ operations {\n        balance += op;\n        if balance < 0 {\n           \
    \ return false;\n        }\n    }\n    \n    balance < 0\n}\n\nfn main() {\n \
    \   let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqx_47kpd.rs:12:20\n   |\n\
    12 |         balance += op;\n   |                    ^^ expected `i32`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `i32`\n  --> /tmp/tmpqx_47kpd.rs:12:17\n\
    \   |\n12 |         balance += op;\n   |                 ^^ no implementation\
    \ for `i32 += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822544
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|&x| x < 0) || operations.iter().any(|&x|\
    \ x == 0) {\n        return true;\n    }\n    else {\n        return false;\n\
    \    }\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzy37epub.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut running_sum = 0;\n    for operation in &operations\
    \ {\n        running_sum += *operation;\n        if running_sum < 0 {\n      \
    \      return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for operation in operations\
    \ {\n        sum += operation;\n    }\n    sum <= 0\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp78gu27aq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        if op > 0 {\n            balance += op;\n        }\n    }\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq88qnra2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().fold(0, |acc, x| acc + x) <\
    \ 0 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n  \
    \  let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph4pg9bz_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance: isize = 0;\n    for i in 0..operations.len()\
    \ {\n        balance += operations[i];\n        if balance < 0 {\n           \
    \ return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|&x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzudtc1m4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |b, b| b && b < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `b` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp3g_2l3c7.rs:9:39\n  |\n9 |     operations.iter().fold(false,\
    \ |b, b| b && b < 0)\n  |                                       ^ used as parameter\
    \ more than once\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3g_2l3c7.rs:9:42\n\
    \  |\n9 |     operations.iter().fold(false, |b, b| b && b < 0)\n  |          \
    \                                ^ expected `bool`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp3g_2l3c7.rs:9:51\n  |\n9 |     operations.iter().fold(false,\
    \ |b, b| b && b < 0)\n  |                                                   ^\n\
    \  |                                                   |\n  |                \
    \                                   expected `&isize`, found integer\n  |    \
    \                                               help: consider borrowing here:\
    \ `&0`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0415.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = vec![0; 10];\n\n    for (i, item)\
    \ in operations.into_iter().enumerate() {\n        balance[i] = item;\n    }\n\
    \n    balance.iter().all(|&x| x <= 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjdggjw1i.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance: isize = 0;\n    for operation in\
    \ operations {\n        balance += operation;\n    }\n    balance < 0\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_hx860n2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|operation| operation < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3cytvfr7.rs:9:51\n  |\n9 |\
    \     operations.iter().all(|operation| operation < 0)\n  |                  \
    \                                 ^\n  |                                     \
    \              |\n  |                                                   expected\
    \ `&isize`, found integer\n  |                                               \
    \    help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold1(|acc, i| acc && i < *acc)(true)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `fold1` found for struct `std::slice::Iter`\
    \ in the current scope\n --> /tmp/tmppijj3mma.rs:9:23\n  |\n9 |     operations.iter().fold1(|acc,\
    \ i| acc && i < *acc)(true)\n  |                       ^^^^^ method not found\
    \ in `std::slice::Iter<'_, isize>`\n\nerror[E0614]: type `bool` cannot be dereferenced\n\
    \ --> /tmp/tmppijj3mma.rs:9:49\n  |\n9 |     operations.iter().fold1(|acc, i|\
    \ acc && i < *acc)(true)\n  |                                                \
    \ ^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |mut\
    \ balance, operation| {\n        match operation {\n            Deposit(amount)\
    \ => balance + amount,\n            Withdraw(amount) => balance - amount,\n  \
    \      }\n    });\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Deposit` in this\
    \ scope\n  --> /tmp/tmp_l9un27k.rs:11:13\n   |\n11 |             Deposit(amount)\
    \ => balance + amount,\n   |             ^^^^^^^ not found in this scope\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `Withdraw` in this scope\n  --> /tmp/tmp_l9un27k.rs:12:13\n\
    \   |\n12 |             Withdraw(amount) => balance - amount,\n   |          \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0531`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut min_balance = std::i32::MAX;\n    for operation\
    \ in operations {\n        min_balance = std::cmp::min(min_balance, operation);\n\
    \    }\n    min_balance == std::i32::MAX\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0jxtz66j.rs:11:50\n   |\n\
    11 |         min_balance = std::cmp::min(min_balance, operation);\n   |      \
    \                                            ^^^^^^^^^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n11 |         min_balance = std::cmp::min(min_balance,\
    \ operation.try_into().unwrap());\n   |                                      \
    \                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |mut\
    \ sum, i| sum + i);\n    balance <= 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp50td5lat.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3m_mll1d.rs:9:35\n  |\n9 |\
    \     operations.iter().any(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |mut b, i| {\n    \
    \    if b {\n            if i > 0 {\n                return true;\n          \
    \  }\n        }\n        false\n    })\n}\n\nfn main() {\n    let candidate =\
    \ below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitpu2rs2.rs:11:20\n   |\n\
    11 |             if i > 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance_changed = false;\n    for op in operations.iter()\
    \ {\n        let amount = if op >= 0 {\n            op.abs()\n        } else {\n\
    \            -op.abs()\n        };\n        if amount < 0 {\n            balance_changed\
    \ = true;\n            break;\n        }\n    }\n    balance_changed\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptm0p9omy.rs:11:31\n   |\n\
    11 |         let amount = if op >= 0 {\n   |                               ^\n\
    \   |                               |\n   |                               expected\
    \ `&isize`, found integer\n   |                               help: consider borrowing\
    \ here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // TODO: implement this\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpchj2cnn4.rs:8:42\n  |\n8 |\
    \ fn below_zero(operations: Vec<isize>) -> bool {\n  |    ----------         \
    \                   ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // Find the minimum value in the operation vector\n\
    \    let mut min_operation = operations[0] as isize;\n    for op in 1..operations.len()\
    \ {\n        if min_operation > operations[op] {\n            min_operation =\
    \ operations[op];\n        }\n    }\n\n    // Check whether the minimum is negative\n\
    \    min_operation < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmplj2eddd0.rs:10:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance_down = true;\n    let mut balance_up\
    \ = true;\n    for operation in operations {\n        if balance_down == false\
    \ {\n            if operation == -3 {\n                balance_down = true;\n\
    \            } else {\n                balance_up = false;\n            }\n  \
    \      }\n        if balance_up == false {\n            if operation == 3 {\n\
    \                balance_up = true;\n            } else {\n                balance_down\
    \ = false;\n            }\n        }\n    }\n    balance_down && balance_up\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdughfg2d.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |mut\
    \ acc, i| {\n        acc += i;\n        acc\n    });\n    (balance > 0).unwrap()\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmp6wvst25u.rs:13:19\n   |\n13 |     (balance > 0).unwrap()\n\
    \   |                   ^^^^^^ method not found in `bool`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut max = operations.iter().max().unwrap();\n\
    \    for i in 0..operations.len() {\n        sum += operations[i];\n        if\
    \ sum < 0 {\n            sum += max;\n        }\n        if sum < 0 {\n      \
    \      max = operations[i];\n        }\n    }\n    sum < 0\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ovujdpk.rs:17:19\n   |\n\
    10 |     let mut max = operations.iter().max().unwrap();\n   |               \
    \    -------------------------------- expected due to this value\n...\n17 |  \
    \           max = operations[i];\n   |                   ^^^^^^^^^^^^^\n   | \
    \                  |\n   |                   expected `&isize`, found `isize`\n\
    \   |                   help: consider borrowing here: `&operations[i]`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().cloned().sum();\n\
    \    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp8tw1h0ql.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().cloned().sum();\n  |        \
    \ ^^^^^^^^^^^ consider giving `balance` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().map(|op| if op < 0 { true } else\
    \ { false }).all(|b| b)\n}\n\nfn main() {\n    let candidate = below_zero;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg0l3a_6l.rs:9:40\n  |\n9 |\
    \     operations.iter().map(|op| if op < 0 { true } else { false }).all(|b| b)\n\
    \  |                                        ^\n  |                           \
    \             |\n  |                                        expected `&isize`,\
    \ found integer\n  |                                        help: consider borrowing\
    \ here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut acc = 0i32;\n    for a in operations {\n\
    \        acc += a;\n        if acc < 0 {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3uswymse.rs:11:16\n   |\n\
    11 |         acc += a;\n   |                ^ expected `i32`, found `isize`\n\n\
    error[E0277]: cannot add-assign `isize` to `i32`\n  --> /tmp/tmp3uswymse.rs:11:13\n\
    \   |\n11 |         acc += a;\n   |             ^^ no implementation for `i32\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |acc, operation| {\n\
    \        if acc {\n            *acc && operation < 0\n        } else {\n     \
    \       *acc || operation > 0\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmp_7l0x86m.rs:11:13\n\
    \   |\n11 |             *acc && operation < 0\n   |             ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_7l0x86m.rs:11:33\n   |\n11 |             *acc\
    \ && operation < 0\n   |                                 ^\n   |             \
    \                    |\n   |                                 expected `&isize`,\
    \ found integer\n   |                                 help: consider borrowing\
    \ here: `&0`\n\nerror[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmp_7l0x86m.rs:13:13\n\
    \   |\n13 |             *acc || operation > 0\n   |             ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_7l0x86m.rs:13:33\n   |\n13 |             *acc\
    \ || operation > 0\n   |                                 ^\n   |             \
    \                    |\n   |                                 expected `&isize`,\
    \ found integer\n   |                                 help: consider borrowing\
    \ here: `&0`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(\n        0,\n        |previous,\
    \ current| previous + current as isize < 0,\n    )\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpmszs616z.rs:11:57\n   |\n11 |           |previous,\
    \ current| previous + current as isize < 0,\n   |  _________________________________________________________^_-\n\
    \   | |                                                         |\n   | |    \
    \                                                     not interpreted as comparison\n\
    12 | |     )\n   | |_____- interpreted as generic arguments\n   |\nhelp: try comparing\
    \ the cast value\n   |\n11 |         |previous, current| previous + (current as\
    \ isize) < 0,\n   |                                        +                +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmszs616z.rs:10:9\n   |\n10 | \
    \        0,\n   |         ^ expected `bool`, found integer\n\nerror[E0369]: cannot\
    \ add `isize` to `bool`\n  --> /tmp/tmpmszs616z.rs:11:38\n   |\n11 |         |previous,\
    \ current| previous + current as isize < 0,\n   |                            \
    \ -------- ^ ---------------- isize\n   |                             |\n   |\
    \                             bool\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpmszs616z.rs:11:40\n   |\n11 |         |previous, current|\
    \ previous + current as isize < 0,\n   |                                     \
    \   -------^^^^^^^^^\n   |                                        |\n   |    \
    \                                    cannot cast `&isize` as `isize`\n   |   \
    \                                     help: dereference the expression: `*current`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    match\
    \ balance {\n        x if x < 0 => true,\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp1w46l4bp.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |b, x| b || x == 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n --> /tmp/tmp7q97cwc7.rs:9:49\n\
    \  |\n9 |     operations.iter().fold(false, |b, x| b || x == 0)\n  |         \
    \                                        ^^ no implementation for `&isize == {integer}`\n\
    \  |\n  = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \       f32\n            f64\n            i128\n            i16\n            i32\n\
    \            i64\n            i8\n            isize\n          and 6 others\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut total = 0;\n    for op in operations.iter()\
    \ {\n        if total > 0 {\n            total -= *op;\n        } else {\n   \
    \         total += *op;\n        }\n    }\n    total < 0\n}\n\nfn main() {\n \
    \   let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvsn79b6z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().cloned().take(1).sum::<isize>();\n\
    \    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkfacq3iv.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().sum::<isize>() <= 0 {\n    \
    \    true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmwnofp19.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance_initial = 0;\n    loop {\n      \
    \  balance_initial += operations.last().unwrap();\n        balance_initial -=\
    \ operations.first().unwrap();\n        if balance_initial < 0 {\n           \
    \ return true;\n        }\n        if balance_initial > 0 {\n            break;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpurg_91f2.rs:11:46

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n\n  \
    \  balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpcx9mqddx.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for (op, val) in operations.iter().cloned().enumerate()\
    \ {\n        sum += val;\n    }\n\n    sum < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_uqz7lx5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = 0;\n\n    for operation\
    \ in &operations {\n        match operation {\n            -2 => current_balance,\n\
    \            2 => current_balance -= operation,\n            0 => current_balance,\n\
    \            _ => current_balance += operation,\n        }\n    }\n\n    current_balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpu1gynrz8.rs:14:18\n\
    \   |\n12 | /         match operation {\n13 | |             -2 => current_balance,\n\
    \   | |                   --------------- this is found to be of type `isize`\n\
    14 | |             2 => current_balance -= operation,\n   | |                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `()`\n15 | |         \
    \    0 => current_balance,\n16 | |             _ => current_balance += operation,\n\
    17 | |         }\n   | |_________- `match` arms have incompatible types\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_nglq3ag.rs:9:35\n  |\n9 |\
    \     operations.iter().all(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().reduce(0);\n\
    \    match balance {\n        0 => true,\n        _ => false,\n    }\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(&isize, &isize)>` closure, found `{integer}`\n\
    \    --> /tmp/tmpdx_unm1x.rs:9:48\n     |\n9    |     let mut balance = operations.iter().reduce(0);\n\
    \     |                                         ------ ^ expected an `FnMut<(&isize,\
    \ &isize)>` closure, found `{integer}`\n     |                               \
    \          |\n     |                                         required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `FnMut<(&isize, &isize)>`\
    \ is not implemented for `{integer}`\nnote: required by a bound in `reduce`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdx_unm1x.rs:11:9\n   |\n10 |   \
    \  match balance {\n   |           ------- this expression has type `Option<&isize>`\n\
    11 |         0 => true,\n   |         ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<&isize>`\n              found type `{integer}`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|&x| x <= 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphxsfo8xw.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0 as usize;\n\n    for op in operations\
    \ {\n        if op > 0 {\n            balance += op;\n        } else {\n     \
    \       balance -= op;\n        }\n    }\n\n    balance < 0\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9lnj8c15.rs:13:24\n   |\n\
    13 |             balance += op;\n   |                        ^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmp9lnj8c15.rs:13:21\n\
    \   |\n13 |             balance += op;\n   |                     ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9lnj8c15.rs:15:24\n\
    \   |\n15 |             balance -= op;\n   |                        ^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract-assign `isize` from\
    \ `usize`\n  --> /tmp/tmp9lnj8c15.rs:15:21\n   |\n15 |             balance -=\
    \ op;\n   |                     ^^ no implementation for `usize -= isize`\n  \
    \ |\n   = help: the trait `SubAssign<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut deposits = operations.iter().filter(|&i|\
    \ i != 0);\n    let mut withdrawals = operations.iter().filter(|&i| i < 0);\n\
    \    loop {\n        if deposits.len() > 0 && withdrawals.len() > 0 {\n      \
    \      deposits.pop();\n            withdrawals.pop();\n        } else {\n   \
    \         break;\n        }\n    }\n    let deposits = deposits.len();\n    let\
    \ withdrawals = withdrawals.len();\n    if deposits == 0 && withdrawals == 0 {\n\
    \        true\n    } else if deposits == 0 {\n        false\n    } else if withdrawals\
    \ == 0 {\n        true\n    } else {\n        let deposit = deposits.iter().sum();\n\
    \        let withdrawal = withdrawals.iter().sum();\n        deposit < 0\n   \
    \ }\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n --> /tmp/tmp220t29hn.rs:9:56\n\
    \  |\n9 |     let mut deposits = operations.iter().filter(|&i| i != 0);\n  | \
    \                                                       ^^ no implementation for\
    \ `&isize == {integer}`\n  |\n  = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&isize`\n  = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n            f32\n            f64\n            i128\n    \
    \        i16\n            i32\n            i64\n            i8\n            isize\n\
    \          and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp220t29hn.rs:10:61\n\
    \   |\n10 |     let mut withdrawals = operations.iter().filter(|&i| i < 0);\n\
    \   |                                                             ^\n   |    \
    \                                                         |\n   |            \
    \                                                 expected `&isize`, found integer\n\
    \   |                                                             help: consider\
    \ borrowing here: `&0`\n\nerror[E0599]: no method named `len` found for struct\
    \ `Filter` in the current scope\n  --> /tmp/tmp220t29hn.rs:12:21\n   |\n12 | \
    \        if deposits.len() > 0 && withdrawals.len() > 0 {\n   |              \
    \       ^^^ method not found in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmp220t29hn.rs:9:49:\
    \ 9:60]>`\n\nerror[E0599]: no method named `len` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp220t29hn.rs:12:46\n   |\n12 |         if deposits.len()\
    \ > 0 && withdrawals.len() > 0 {\n   |                                       \
    \       ^^^ method not found in `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmp220t29hn.rs:10:52:\
    \ 10:62]>`\n\nerror[E0599]: no method named `pop` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmp220t29hn.rs:13:22\n   |\n13 |             deposits.pop();\n\
    \   |                      ^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp220t29hn.rs:9:49: 9:60]>`\n\nerror[E0599]: no method\
    \ named `pop` found for struct `Filter` in the current sc"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in &operations {\n\
    \        if op == -1 {\n            balance = 0 - balance;\n        } else {\n\
    \            balance += op;\n        }\n    }\n    balance < 0\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_ac8liwi.rs:11:15\n\
    \   |\n11 |         if op == -1 {\n   |               ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut res = true;\n    let mut balance = 0 as isize;\n\
    \    for num in operations.iter() {\n        if balance <= 0 {\n            res\
    \ = false;\n            break;\n        }\n        balance -= num as isize;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpl0ay5o9o.rs:16:20\n\
    \   |\n16 |         balance -= num as isize;\n   |                    ---^^^^^^^^^\n\
    \   |                    |\n   |                    cannot cast `&isize` as `isize`\n\
    \   |                    help: dereference the expression: `*num`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.is_empty() {\n        false\n    }\
    \ else {\n        operations.iter().map(|op| op).collect::<Vec<_>>().iter().any(|x|\
    \ x < 0)\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaa9phi0s.rs:12:79\n   |\n\
    12 |         operations.iter().map(|op| op).collect::<Vec<_>>().iter().any(|x|\
    \ x < 0)\n   |                                                               \
    \                ^ expected `&&isize`, found integer\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.len();\n    operations.iter().for_each(|operation|\
    \ {\n        balance -= operation;\n    });\n    balance < 0\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2cy5ij0c.rs:11:20\n   |\n\
    11 |         balance -= operation;\n   |                    ^^^^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract-assign `&isize` from\
    \ `usize`\n  --> /tmp/tmp2cy5ij0c.rs:11:17\n   |\n11 |         balance -= operation;\n\
    \   |                 ^^ no implementation for `usize -= &isize`\n   |\n   = help:\
    \ the trait `SubAssign<&isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `SubAssign<Rhs>`:\n             <f32 as\
    \ SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold((0, 0),\
    \ |(amount, operation), i| {\n        match operation {\n            1 => (amount\
    \ + 1, 0),\n            2 => (amount + 1, 1),\n            3 => (amount + 1, 2),\n\
    \            4 => (amount, 3),\n            5 => (amount, 4),\n            _ =>\
    \ (amount, 0),\n        }\n    });\n    !(balance.1 >= 0)\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx56kl8sw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&n| n < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy9vu8os1.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3m_mll1d.rs:9:35\n  |\n9 |\
    \     operations.iter().any(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |b, x|\
    \ b + x);\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8zvw7wwn.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().position(|&x| x < 0).is_some()\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpukjeebgd.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum::<isize>()\
    \ as isize;\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3ramldnb.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    !operations.iter().any(|&x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpobrkml4u.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6x_mz6ux.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().filter(|&x| x > 0).count() ==\
    \ 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw6bmgbtl.rs:9:42\n  |\n9 |\
    \     if operations.iter().filter(|&x| x > 0).count() == 0 {\n  |            \
    \                              ^\n  |                                        \
    \  |\n  |                                          expected `&isize`, found integer\n\
    \  |                                          help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n\n    for (i, e) in operations.iter().enumerate()\
    \ {\n        balance += e;\n\n        if balance < 0 {\n            balance =\
    \ 0;\n            i += 1;\n        }\n    }\n\n    balance < 0\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `i` is assigned to, but never used\n  --> /tmp/tmp_zbgmxiy.rs:11:10\n\
    \   |\n11 |     for (i, e) in operations.iter().enumerate() {\n   |          ^\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_i` instead\n\nwarning: value assigned to `i` is never read\n  --> /tmp/tmp_zbgmxiy.rs:16:13\n\
    \   |\n16 |             i += 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmp_zbgmxiy.rs:16:13\n\
    \   |\n11 |     for (i, e) in operations.iter().enumerate() {\n   |          -\n\
    \   |          |\n   |          first assignment to `i`\n   |          help: consider\
    \ making this binding mutable: `mut i`\n...\n16 |             i += 1;\n   |  \
    \           ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance: isize = 0;\n    let mut withdrawal_operations:\
    \ Vec<isize> = vec![0; 1];\n\n    for operation in operations {\n        withdrawal_operations.0\
    \ = (withdrawal_operations.0 as isize) - operation;\n        balance -= withdrawal_operations.0;\n\
    \        if balance < 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp1ad1fq59.rs:13:31\n\
    \   |\n13 |         withdrawal_operations.0 = (withdrawal_operations.0 as isize)\
    \ - operation;\n   |                               ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `Vec<isize>`\n  --> /tmp/tmp1ad1fq59.rs:13:58\n   |\n13\
    \ |         withdrawal_operations.0 = (withdrawal_operations.0 as isize) - operation;\n\
    \   |                                                          ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `Vec<isize>`\n  --> /tmp/tmp1ad1fq59.rs:14:42\n\
    \   |\n14 |         balance -= withdrawal_operations.0;\n   |                \
    \                          ^ unknown field\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = Vec::new();\n    for operation\
    \ in operations {\n        current_balance.push(operation as isize);\n    }\n\n\
    \    match current_balance.iter().rev() {\n        None => true,\n        Some(rev)\
    \ => rev\n            .iter()\n            .enumerate()\n            .filter(|&(_,\
    \ amount)| amount < 0)\n            .count() == 0,\n    }\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpznv1k5kg.rs:15:9\n   |\n\
    14 |     match current_balance.iter().rev() {\n   |           ----------------------------\
    \ this expression has type `Rev<std::slice::Iter<'_, isize>>`\n15 |         None\
    \ => true,\n   |         ^^^^ expected struct `Rev`, found enum `Option`\n   |\n\
    \   = note: expected struct `Rev<std::slice::Iter<'_, isize>>`\n             \
    \   found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpznv1k5kg.rs:16:9\n\
    \   |\n14 |     match current_balance.iter().rev() {\n   |           ----------------------------\
    \ this expression has type `Rev<std::slice::Iter<'_, isize>>`\n15 |         None\
    \ => true,\n16 |         Some(rev) => rev\n   |         ^^^^^^^^^ expected struct\
    \ `Rev`, found enum `Option`\n   |\n   = note: expected struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n                found enum `Option<_>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(false,\
    \ |acc, value| acc && value <= 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9u6bokz0.rs:11:51\n   |\n\
    11 |         .fold(false, |acc, value| acc && value <= 0)\n   |              \
    \                                     ^\n   |                                \
    \                   |\n   |                                                  \
    \ expected `&isize`, found integer\n   |                                     \
    \              help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |a, b| a || b < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpaz4uxsvl.rs:9:51\n  |\n9 |\
    \     operations.iter().fold(false, |a, b| a || b < 0)\n  |                  \
    \                                 ^\n  |                                     \
    \              |\n  |                                                   expected\
    \ `&isize`, found integer\n  |                                               \
    \    help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |acc, i| acc || (*i\
    \ <  0))\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqh07n_r4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|x| x < 0) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzr8aijrm.rs:9:38\n  |\n9 |\
    \     if operations.iter().any(|x| x < 0) {\n  |                             \
    \         ^\n  |                                      |\n  |                 \
    \                     expected `&isize`, found integer\n  |                  \
    \                    help: consider borrowing here: `&0`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() <= 0 {\n        return false;\n\
    \    }\n\n    let mut last_op = -std::isize::MAX;\n    for i in 0..operations.len()\
    \ {\n        last_op = operations[i] > last_op ? operations[i] : last_op;\n  \
    \  }\n\n    for j in 0..operations.len() {\n        if operations[j] <= last_op\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `operations`\n\
    \  --> /tmp/tmp6gdy0otw.rs:15:45\n   |\n15 |         last_op = operations[i] >\
    \ last_op ? operations[i] : last_op;\n   |                                   \
    \          ^^^^^^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|&x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzudtc1m4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |acc,\
    \ _| acc - &operations[0]);\n    if balance < 0 {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyvo88g0t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut acc: Vec<isize> = vec![0; operations.len()];\n\
    \    for (i, &op) in operations.iter().enumerate() {\n        acc.push(op);\n\
    \        if acc[i] < 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp084566n7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() == 0 {\n        false\n    }\
    \ else {\n        operations[0] + operations[1] <= 0\n    }\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb41z02s8.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut running_total: isize = 0;\n    for op in\
    \ operations {\n        running_total += op;\n        if running_total < 0 {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut counter = 0;\n    for i in 0..(operations.len()\
    \ - 1) {\n        if operations[i + 1] < 0 {\n            counter += 1;\n    \
    \    } else {\n            counter += 0;\n        }\n    }\n    counter == operations.len()\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp6vpyc2m2.rs:10:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut min_value = std::isize::MIN;\n    for element\
    \ in &operations {\n        min_value = std::cmp::min(min_value, element);\n \
    \   }\n    min_value < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmgriusim.rs:11:46\n   |\n\
    11 |         min_value = std::cmp::min(min_value, element);\n   |            \
    \                                  ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n11 |         min_value =\
    \ std::cmp::min(min_value, *element);\n   |                                  \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|&x| x < 0) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6geizboo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    while i < operations.len() {\n\
    \        if operations[i] > 0 {\n            i += 1;\n        } else {\n     \
    \       return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi2vnlcsz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut total_balance = operations.iter().reduce(|a,\
    \ b| a + b);\n    total_balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpg4xrbayw.rs:9:61\n  |\n9 |\
    \     let mut total_balance = operations.iter().reduce(|a, b| a + b);\n  |   \
    \                                                          ^^^^^\n  |        \
    \                                                     |\n  |                 \
    \                                            expected `&isize`, found `isize`\n\
    \  |                                                             help: consider\
    \ borrowing here: `&(a + b)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg4xrbayw.rs:10:21\n\
    \   |\n10 |     total_balance < 0\n   |                     ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<&isize>`\n           \
    \   found type `{integer}`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n\n    for op in &operations\
    \ {\n        match op {\n            1 => balance -= 1,\n            -1 => balance\
    \ += 1,\n            _ => panic!(\"Invalid operation\")\n        }\n    }\n\n\
    \    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid operation'', /tmp/tmp9j_d17f7.rs:15:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter()\n        .zip(operations.iter().cloned())\n\
    \        .any(|(deposit, withdraw)| withdraw < 0 || deposit < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsu5h7i23.rs:11:62\n   |\n\
    11 |         .any(|(deposit, withdraw)| withdraw < 0 || deposit < 0)\n   |   \
    \                                                           ^\n   |          \
    \                                                    |\n   |                 \
    \                                             expected `&isize`, found integer\n\
    \   |                                                              help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for op in &operations {\n        if op < 0 {\n  \
    \          return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgngcwa3n.rs:10:17\n   |\n\
    10 |         if op < 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut result = true;\n    let mut pos = 0;\n  \
    \  while pos < operations.len() {\n        let mut cur_val = operations[pos];\n\
    \        cur_val -= 1;\n        if cur_val < 0 {\n            result = false;\n\
    \            break;\n        }\n        pos = pos + 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj8l82dyn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(true,\
    \ |b, op| !(b && op > 0))\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwnu30vn_.rs:11:41\n   |\n\
    11 |         .fold(true, |b, op| !(b && op > 0))\n   |                       \
    \                  ^\n   |                                         |\n   |   \
    \                                      expected `&isize`, found integer\n   |\
    \                                         help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0i32;\n    for num in operations\
    \ {\n        balance += num;\n    }\n    balance < 0\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4d2knv5r.rs:11:20\n   |\n\
    11 |         balance += num;\n   |                    ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `i32`\n  --> /tmp/tmp4d2knv5r.rs:11:17\n\
    \   |\n11 |         balance += num;\n   |                 ^^ no implementation\
    \ for `i32 += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut first_zero = false;\n    let mut prev_sum\
    \ = 0;\n    for _ in 0..(operations.len() - 1) {\n        if prev_sum == 0 {\n\
    \            first_zero = true;\n        }\n        prev_sum += operations[_];\n\
    \        if prev_sum < 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmprd0r84l2.rs:15:32\n   |\n15 |         prev_sum +=\
    \ operations[_];\n   |                                ^ `_` not allowed here\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0_usize;\n    for v in operations {\n\
    \        sum += v;\n    }\n    return sum < 0;\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa66_k9jj.rs:11:16\n   |\n\
    11 |         sum += v;\n   |                ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpa66_k9jj.rs:11:13\n\
    \   |\n11 |         sum += v;\n   |             ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.last() as isize;\n \
    \   loop {\n        if balance < 0 {\n            return true;\n        }\n  \
    \      balance -= operations.last().unwrap();\n        if balance < 0 {\n    \
    \        return false;\n        }\n        operations.pop();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0605]: non-primitive cast: `Option<&isize>` as `isize`\n --> /tmp/tmp6e1v6g7g.rs:9:23\n\
    \  |\n9 |     let mut balance = operations.last() as isize;\n  |             \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0605`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations {\n\
    \        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822544
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = &mut 0;\n    for _ in 0..(operations.len()\
    \ - 1) {\n        let mut operation = operations.last().unwrap();\n        balance\
    \ += operation;\n        if balance < 0 {\n            return true;\n        }\n\
    \        balance -= operation;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp71t2kk_8.rs:12:9\n   |\n12 |         balance\
    \ += operation;\n   |         -------^^^^^^^^^^^^^\n   |         |\n   |     \
    \    cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on\
    \ `{integer}`, you can dereference `balance`\n   |\n12 |         *balance += operation;\n\
    \   |         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp71t2kk_8.rs:13:22\n\
    \   |\n13 |         if balance < 0 {\n   |                      ^\n   |      \
    \                |\n   |                      expected `&mut isize`, found integer\n\
    \   |                      help: consider mutably borrowing here: `&mut 0`\n\n\
    error[E0368]: binary assignment operation `-=` cannot be applied to type `&mut\
    \ isize`\n  --> /tmp/tmp71t2kk_8.rs:16:9\n   |\n16 |         balance -= operation;\n\
    \   |         -------^^^^^^^^^^^^^\n   |         |\n   |         cannot use `-=`\
    \ on type `&mut isize`\n   |\nhelp: `-=` can be used on `isize`, you can dereference\
    \ `balance`\n   |\n16 |         *balance -= operation;\n   |         +\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |a, e| {\n        debug_assert!(-e\
    \ < 0);\n        a + 1 < 0\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `bool`\n  --> /tmp/tmpzv8crrfl.rs:11:11\n\
    \   |\n11 |         a + 1 < 0\n   |         - ^ - {integer}\n   |         |\n\
    \   |         bool\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0usize;\n    let mut sum_of_deposits\
    \ = operations.iter().sum();\n    let mut sum_of_withdrawals = operations.iter().sum();\n\
    \    for operation in operations {\n        sum_of_deposits -= operation;\n  \
    \      sum_of_withdrawals += operation;\n        balance += operation;\n     \
    \   if balance < 0 {\n            return true;\n        }\n    }\n    if sum_of_withdrawals\
    \ < 0 {\n        return false;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfs7bzx2a.rs:15:20\n   |\n\
    15 |         balance += operation;\n   |                    ^^^^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n\
    \  --> /tmp/tmpfs7bzx2a.rs:15:17\n   |\n15 |         balance += operation;\n \
    \  |                 ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().zip(operations.iter().rev()).all(|(a,\
    \ b)| a < b)\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp34hasxlh.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = vec![0];\n    let mut running_balance\
    \ = balance.clone();\n    for operation in operations {\n        running_balance\
    \ = running_balance.checked_sub(operation);\n        if running_balance.abs()\
    \ < 0 {\n            return true;\n        }\n        balance = running_balance.clone();\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_sub` found for struct `Vec<{integer}>`\
    \ in the current scope\n  --> /tmp/tmpat5weljx.rs:12:43\n   |\n12 |         running_balance\
    \ = running_balance.checked_sub(operation);\n   |                            \
    \               ^^^^^^^^^^^ method not found in `Vec<{integer}>`\n\nerror[E0599]:\
    \ no method named `abs` found for struct `Vec<{integer}>` in the current scope\n\
    \  --> /tmp/tmpat5weljx.rs:13:28\n   |\n13 |         if running_balance.abs()\
    \ < 0 {\n   |                            ^^^ method not found in `Vec<{integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // Your code here\n    false\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9kqfum_h.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_nglq3ag.rs:9:35\n  |\n9 |\
    \     operations.iter().all(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut last_operation = operations[0];\n\n    for\
    \ operation in operations {\n        if last_operation < operation {\n       \
    \     return false;\n        }\n        last_operation = operation;\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpc5ib0xn2.rs:9:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n\n    for operation in operations\
    \ {\n        if operation > 0 {\n            balance += operation;\n        }\n\
    \n        if balance < 0 {\n            return true;\n        }\n\n        balance\
    \ -= operation;\n    }\n\n    balance < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnkc4siv2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() < 1 {\n        false\n    }\n\
    \    else if operations[0] < 0 {\n        true\n    }\n    else {\n        below_zero(operations.iter().skip(1).take_while(|&i|\
    \ i < 0).collect())\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4mw407gd.rs:16:66\n   |\n\
    16 |         below_zero(operations.iter().skip(1).take_while(|&i| i < 0).collect())\n\
    \   |                                                                  ^\n   |\
    \                                                                  |\n   |   \
    \                                                               expected `&isize`,\
    \ found integer\n   |                                                        \
    \          help: consider borrowing here: `&0`\n\nerror[E0277]: a value of type\
    \ `Vec<isize>` cannot be built from an iterator over elements of type `&isize`\n\
    \    --> /tmp/tmp4mw407gd.rs:16:20\n     |\n16   |         below_zero(operations.iter().skip(1).take_while(|&i|\
    \ i < 0).collect())\n     |         ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |         |\n     |         required by a bound introduced by this call\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |acc, _| acc && acc\
    \ < 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp8md_143b.rs:9:56\n  |\n9 |\
    \     operations.iter().fold(true, |acc, _| acc && acc < 0)\n  |             \
    \                                           ^ expected `bool`, found integer\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(false,\
    \ |prev, operation| {\n            if *operation < 0 {\n                prev\n\
    \            } else {\n                false\n            }\n        })\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0hof0gjv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n\n  \
    \  while balance < 0 {\n        balance = balance.saturating_add(-operations.iter().sum());\n\
    \    }\n\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpq8tvy48f.rs:12:19\n\
    \   |\n9  |     let mut balance = operations.iter().sum();\n   |         -----------\
    \ consider giving `balance` a type\n...\n12 |         balance = balance.saturating_add(-operations.iter().sum());\n\
    \   |                   ^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |b, b| b && (*b < 0))\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `b` is bound more than once in this parameter\
    \ list\n --> /tmp/tmpn6f2qfwt.rs:9:38\n  |\n9 |     operations.iter().fold(true,\
    \ |b, b| b && (*b < 0))\n  |                                      ^ used as parameter\
    \ more than once\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn6f2qfwt.rs:9:41\n\
    \  |\n9 |     operations.iter().fold(true, |b, b| b && (*b < 0))\n  |        \
    \                                 ^ expected `bool`, found `&isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0415.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = vec![0; operations.len()];\n\n\
    \    for (index, element) in operations.iter().enumerate() {\n        balance[index]\
    \ += element;\n        if balance[index] <= 0 {\n            return true;\n  \
    \      }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7yxyd14d.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for operation in operations {\n        if *operation\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmphqnlplpw.rs:10:12\n\
    \   |\n10 |         if *operation < 0 {\n   |            ^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut positive_balance = true;\n    for op in operations\
    \ {\n        if op > 0 {\n            positive_balance = false;\n        }\n \
    \   }\n    positive_balance\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplveoosbg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&operation| operation < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6ajtqvfv.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut total_balance = 0;\n    for operation in\
    \ &operations {\n        let balance = match operation {\n            -x => total_balance\
    \ - x,\n            +x => total_balance + x,\n            _ => panic!(\"Unexpected\
    \ operation\")\n        };\n        total_balance += balance;\n        if total_balance\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `x`\n  --> /tmp/tmplt4d7agf.rs:12:14\n \
    \  |\n12 |             -x => total_balance - x,\n   |              ^ expected\
    \ pattern\n\nwarning: unreachable statement\n  --> /tmp/tmplt4d7agf.rs:16:9\n\
    \   |\n11 |           let balance = match operation {\n   |  _______________________-\n\
    12 | |             -x => total_balance - x,\n13 | |             +x => total_balance\
    \ + x,\n14 | |             _ => panic!(\"Unexpected operation\")\n15 | |     \
    \    };\n   | |_________- any code following this expression is unreachable\n\
    16 |           total_balance += balance;\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ unreachable statement\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror[E0277]: cannot add-assign `()` to `i32`\n  --> /tmp/tmplt4d7agf.rs:16:23\n\
    \   |\n16 |         total_balance += balance;\n   |                       ^^ no\
    \ implementation for `i32 += ()`\n   |\n   = help: the trait `AddAssign<()>` is\
    \ not implemented for `i32`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance: isize = 0;\n    for (i, el) in operations.iter().enumerate()\
    \ {\n        balance += el;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    balance == 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphz310_t7.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = Vec::new();\n    operations.iter().for_each(|o|\
    \ {\n        balance.push(o);\n        balance.pop();\n    });\n    balance.len()\
    \ == 0 || balance.len() <= 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm_v0uo3a.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.last();\n    for op\
    \ in operations.iter_mut() {\n        *op += 1;\n        if balance < 0 {\n  \
    \          return true;\n        }\n        *op -= 1;\n        balance -= 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl739o5wm.rs:12:22\n   |\n\
    12 |         if balance < 0 {\n   |                      ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<&isize>`\n           \
    \   found type `{integer}`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `Option<&isize>`\n  --> /tmp/tmpl739o5wm.rs:16:9\n   |\n\
    16 |         balance -= 1;\n   |         -------^^^^^\n   |         |\n   |  \
    \       cannot use `-=` on type `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = Zero::zero();\n    for val in operations\
    \ {\n        if val >= 0 {\n            balance += val;\n        }\n    }\n  \
    \  balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Zero`\n --> /tmp/tmpu0si9hm4.rs:9:23\n\
    \  |\n9 |     let mut balance = Zero::zero();\n  |                       ^^^^\
    \ use of undeclared type `Zero`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = Vec::new();\n    for mut op in\
    \ operations {\n        balance.push(op);\n    }\n    balance.iter().all(|x| x\
    \ < 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqp2k41cu.rs:13:32\n   |\n\
    13 |     balance.iter().all(|x| x < 0)\n   |                                ^\n\
    \   |                                |\n   |                                expected\
    \ `&isize`, found integer\n   |                                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .map(|op| {\n\
    \            if op < 0 {\n                false\n            } else {\n      \
    \          true\n            }\n        })\n        .all(|b| b)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3nrqncn.rs:12:21\n   |\n\
    12 |             if op < 0 {\n   |                     ^\n   |               \
    \      |\n   |                     expected `&isize`, found integer\n   |    \
    \                 help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|o| o < 0)\n    {\n    \
    \    return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj5pes1ys.rs:9:38\n  |\n9 |\
    \     if operations.iter().any(|o| o < 0)\n  |                               \
    \       ^\n  |                                      |\n  |                   \
    \                   expected `&isize`, found integer\n  |                    \
    \                  help: consider borrowing here: `&0`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().cloned().fold(false, |a, b| {\n\
    \        if b < 0 {\n            a.clone()\n        } else {\n            b.clone()\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmncdicfp.rs:13:13\n   |\n\
    13 |             b.clone()\n   |             ^^^^^^^^^ expected `bool`, found\
    \ `isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for operation in operations.iter() {\n        let\
    \ mut balance = operation.0;\n        balance += operation.1;\n        if balance\
    \ < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmp98apswsd.rs:10:37\n\
    \   |\n10 |         let mut balance = operation.0;\n   |                     \
    \                ^\n\nerror[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmp98apswsd.rs:11:30\n\
    \   |\n11 |         balance += operation.1;\n   |                            \
    \  ^\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().next().unwrap();\n\
    \    for element in &operations {\n        balance += element;\n        if balance\
    \ < 0 {\n            return true;\n        }\n    }\n    balance < 0\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmp20atj751.rs:11:9\n   |\n11 |         balance += element;\n\
    \   |         -------^^^^^^^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference\
    \ `balance`\n   |\n11 |         *balance += element;\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp20atj751.rs:12:22\n   |\n12 |         if balance\
    \ < 0 {\n   |                      ^\n   |                      |\n   |      \
    \                expected `&isize`, found integer\n   |                      help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp20atj751.rs:16:15\n\
    \   |\n16 |     balance < 0\n   |               ^\n   |               |\n   |\
    \               expected `&isize`, found integer\n   |               help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for op in operations.iter()\
    \ {\n        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for (operation, amount)\
    \ in operations.iter().rev().zip(&[100..]) {\n        balance += amount;\n   \
    \     if balance < 0 {\n            return true;\n        }\n    }\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `&RangeFrom<{integer}>` to `{integer}`\n\
    \  --> /tmp/tmp9p97dd47.rs:11:17\n   |\n11 |         balance += amount;\n   |\
    \                 ^^ no implementation for `{integer} += &RangeFrom<{integer}>`\n\
    \   |\n   = help: the trait `AddAssign<&RangeFrom<{integer}>>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    debug_assert!(operations.len() == operations.iter().count(|&a|\
    \ a == -0));\n\n    let mut balance = operations.iter().fold(0, |balance, operation|\
    \ balance + operation);\n\n    while balance < 0 {\n        balance -= operations.iter().fold(0,\
    \ |balance, operation| balance + operation);\n    }\n\n    balance < 0\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp49jd0qbm.rs:9:57\n    |\n9   |     debug_assert!(operations.len()\
    \ == operations.iter().count(|&a| a == -0));\n    |                          \
    \                               ^^^^^ ------------ supplied 1 argument\n    |\
    \                                                         |\n    |           \
    \                                              expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    let mut check = false;\n\
    \    for op in operations.iter() {\n        if balance > 0 {\n            balance\
    \ = balance - op;\n        } else {\n            check = true;\n        }\n  \
    \  }\n\n    return check;\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4j7vi6al.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|x| x < 0) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzr8aijrm.rs:9:38\n  |\n9 |\
    \     if operations.iter().any(|x| x < 0) {\n  |                             \
    \         ^\n  |                                      |\n  |                 \
    \                     expected `&isize`, found integer\n  |                  \
    \                    help: consider borrowing here: `&0`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |mut\
    \ x, &y| x + y);\n\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp32l2p5em.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.first();\n\n    for\
    \ i in 1..operations.len() {\n        if balance < 0 {\n            return true;\n\
    \        }\n\n        balance = operations[i - 1];\n    }\n\n    false\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6km1wb6t.rs:12:22\n   |\n\
    12 |         if balance < 0 {\n   |                      ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<&isize>`\n           \
    \   found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6km1wb6t.rs:16:19\n\
    \   |\n9  |     let mut balance = operations.first();\n   |                  \
    \     ------------------ expected due to this value\n...\n16 |         balance\
    \ = operations[i - 1];\n   |                   ^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n \
    \             found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_nglq3ag.rs:9:35\n  |\n9 |\
    \     operations.iter().all(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    match operations.len() {\n        0 => true,\n  \
    \      _ => operations.iter().map(|&x| x < 0).all(|b| b),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgcgfo340.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in 0..operations.len()\
    \ {\n        let op = operations[i];\n        if op == 0 {\n            continue;\n\
    \        }\n        let val = -op;\n        if val > 0 {\n            sum += val;\n\
    \        }\n    }\n\n    if sum < 0 {\n        return true;\n    }\n\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmputr25hk0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().cloned().take_while(|&x| x < 0).count()\
    \ <= 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvv1dxpys.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&val| val < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5nqr3nn9.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |b, b| b && b < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `b` is bound more than once in this parameter\
    \ list\n --> /tmp/tmp3g_2l3c7.rs:9:39\n  |\n9 |     operations.iter().fold(false,\
    \ |b, b| b && b < 0)\n  |                                       ^ used as parameter\
    \ more than once\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3g_2l3c7.rs:9:42\n\
    \  |\n9 |     operations.iter().fold(false, |b, b| b && b < 0)\n  |          \
    \                                ^ expected `bool`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp3g_2l3c7.rs:9:51\n  |\n9 |     operations.iter().fold(false,\
    \ |b, b| b && b < 0)\n  |                                                   ^\n\
    \  |                                                   |\n  |                \
    \                                   expected `&isize`, found integer\n  |    \
    \                                               help: consider borrowing here:\
    \ `&0`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0415.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // The function can be optimized as we do not need\
    \ to traverse the whole vector to achieve this.\n    let mut balance = operations.iter().fold((0,\
    \ 0), |(balance, next), &i| {\n        let mut new_balance = (*balance).checked_sub(next);\n\
    \        if new_balance < 0 {\n            new_balance = 0;\n        }\n     \
    \   (balance, new_balance)\n    });\n\n    // If balance is 0, then we would return\
    \ true, else false.\n    balance.0 == 0.0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpdcslzdo_.rs:11:31\n\
    \   |\n11 |         let mut new_balance = (*balance).checked_sub(next);\n   |\
    \                               ^^^^^^^^^^\n\nerror[E0277]: can't compare `{integer}`\
    \ with `{float}`\n  --> /tmp/tmpdcslzdo_.rs:19:15\n   |\n19 |     balance.0 ==\
    \ 0.0\n   |               ^^ no implementation for `{integer} == {float}`\n  \
    \ |\n   = help: the trait `PartialEq<{float}>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdcslzdo_.rs:19:18\n\
    \   |\n19 |     balance.0 == 0.0\n   |                  ^^^ expected integer,\
    \ found floating-point number\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter()\n        .map(|x| *x)\n       \
    \ .filter(|x| *x <= 0)\n        .count() == operations.len()\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb6r_erf7.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|op| op < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4d7hrm_8.rs:9:37\n  |\n9 |\
    \     operations.iter().all(|op| op < 0)\n  |                                \
    \     ^\n  |                                     |\n  |                      \
    \               expected `&isize`, found integer\n  |                        \
    \             help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() < 1 {\n        return false;\n\
    \    }\n\n    let mut balance = operations[0];\n    for i in 1..operations.len()\
    \ {\n        if operations[i] - balance < 0 {\n            return true;\n    \
    \    }\n        balance = operations[i];\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_iw3m66j.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance_sum = Vec::new();\n    let mut balance_min\
    \ = Vec::new();\n    for operation in operations {\n        if let Some(balance)\
    \ = operation {\n            balance_sum.push(balance);\n            if balance\
    \ < 0 {\n                balance_min.push(-balance);\n            }\n        }\n\
    \    }\n    let mut sum_minus_min = balance_sum.iter().cloned().enumerate().find(|(_,\
    \ balance)| balance < 0).unwrap();\n    // Since we know that all operations are\
    \ positive, we just need to check if balance_min has changed\n    // in the same\
    \ way. If balance_min changed from positive to negative, we know that balance_sum\
    \ must\n    // change. Otherwise balance_sum must stay the same and there cannot\
    \ be any deposits or withdrawals\n    // on the account.\n    let mut min_change\
    \ = Vec::new();\n    for balance in balance_min {\n        if balance < 0 {\n\
    \            min_change.push(-balance);\n        }\n    }\n    if min_change.iter().any(|balance|\
    \ balance != 0) {\n        // The balance_sum change has to be non-zero\n    \
    \    balance_sum.iter().any(|balance| balance != 0)\n    } else {\n        //\
    \ The balance_sum change must stay zero\n        sum_minus_min != (min_change[0]\
    \ as usize)\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8uw3e4bg.rs:12:16\n   |\n\
    12 |         if let Some(balance) = operation {\n   |                ^^^^^^^^^^^^^\
    \   --------- this expression has type `isize`\n   |                |\n   |  \
    \              expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<_>`\n\nerror[E0277]: can't compare\
    \ `&_` with `{integer}`\n  --> /tmp/tmp8uw3e4bg.rs:30:48\n   |\n30 |     if min_change.iter().any(|balance|\
    \ balance != 0) {\n   |                                                ^^ no implementation\
    \ for `&_ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |b, x| b && x < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1jlqba53.rs:9:51\n  |\n9 |\
    \     operations.iter().fold(false, |b, x| b && x < 0)\n  |                  \
    \                                 ^\n  |                                     \
    \              |\n  |                                                   expected\
    \ `&isize`, found integer\n  |                                               \
    \    help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |acc, &i| {\n     \
    \   if *acc {\n            return true;\n        }\n\n        if *acc < 0 {\n\
    \            return false;\n        }\n\n        false\n    })\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmpkcd174t3.rs:10:12\n\
    \   |\n10 |         if *acc {\n   |            ^^^^\n\nerror[E0614]: type `bool`\
    \ cannot be dereferenced\n  --> /tmp/tmpkcd174t3.rs:14:12\n   |\n14 |        \
    \ if *acc < 0 {\n   |            ^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |b, x| {\n        b\
    \ && (b < 0)\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4qjs5oj.rs:10:19\n   |\n\
    10 |         b && (b < 0)\n   |                   ^ expected `bool`, found integer\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = vec![0];\n    for op in operations\
    \ {\n        balance += op;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmpbkydsbqk.rs:11:9\n   |\n11 |         balance\
    \ += op;\n   |         -------^^^^^^\n   |         |\n   |         cannot use\
    \ `+=` on type `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkydsbqk.rs:12:22\n\
    \   |\n12 |         if balance < 0 {\n   |                      ^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<{integer}>`\n  \
    \              found type `{integer}`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |acc, x| acc && x <\
    \ 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp33oevt82.rs:9:54\n  |\n9 |\
    \     operations.iter().fold(true, |acc, x| acc && x < 0)\n  |               \
    \                                       ^\n  |                               \
    \                       |\n  |                                               \
    \       expected `&isize`, found integer\n  |                                \
    \                      help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |acc,\
    \ x| {\n        if x < 0 {\n            acc + x\n        } else {\n          \
    \  acc\n        }\n    });\n    balance < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo91jyia4.rs:10:16\n   |\n\
    10 |         if x < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0isize;\n    for (i, o) in operations.iter().enumerate()\
    \ {\n        balance += o;\n        if balance < 0isize {\n            return\
    \ true;\n        }\n    }\n    balance > 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance: isize = 0;\n    for (index, operation)\
    \ in operations.iter().enumerate() {\n        match operation {\n            Deposit(amount)\
    \ => {\n                balance += amount;\n            }\n            Withdraw(amount)\
    \ => {\n                balance -= amount;\n            }\n            _ => panic!(\"\
    Invalid operation\"),\n        }\n    }\n    balance < 0\n}\n\nfn main() {\n \
    \   let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0531]: cannot find tuple struct or tuple variant `Deposit` in this\
    \ scope\n  --> /tmp/tmpljjgt92d.rs:12:13\n   |\n12 |             Deposit(amount)\
    \ => {\n   |             ^^^^^^^ not found in this scope\n\nerror[E0531]: cannot\
    \ find tuple struct or tuple variant `Withdraw` in this scope\n  --> /tmp/tmpljjgt92d.rs:15:13\n\
    \   |\n15 |             Withdraw(amount) => {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0531`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3m_mll1d.rs:9:35\n  |\n9 |\
    \     operations.iter().any(|x| x < 0)\n  |                                  \
    \ ^\n  |                                   |\n  |                            \
    \       expected `&isize`, found integer\n  |                                \
    \   help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for op in operations {\n        if op < 0 {\n   \
    \         return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_daa4upo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    balance <= 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpf7q9zlev.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = ZERO_BALANCE;\n    for\
    \ (i, &e) in operations.iter().enumerate() {\n        if e < 0 {\n           \
    \ return true;\n        }\n        current_balance += e;\n        if current_balance\
    \ < ZERO_BALANCE {\n            return true;\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ZERO_BALANCE` in this scope\n --> /tmp/tmpb6xt0i0i.rs:9:31\n\
    \  |\n9 |     let mut current_balance = ZERO_BALANCE;\n  |                   \
    \            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ZERO_BALANCE` in this scope\n  --> /tmp/tmpb6xt0i0i.rs:15:30\n   |\n\
    15 |         if current_balance < ZERO_BALANCE {\n   |                       \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    // You don't need to modify the input vec or return\
    \ anything.\n    let mut balance = 0;\n    for x in operations {\n        balance\
    \ += x;\n        if balance < 0 {\n            return true;\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976704
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut acc = 0;\n    for op in operations {\n  \
    \      acc += op;\n        if acc < 0 {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822544
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for v in operations {\n\
    \        balance += v;\n        if balance < 0 {\n            return true;\n \
    \       }\n        balance -= v;\n    }\n    balance <= 0\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn_48hqng.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(false,\
    \ (|a, b| a || b >= 0))\n}\n\nfn main() {\n    let candidate = below_zero;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpntlj9ldl.rs:11:22\n\
    \   |\n11 |         .fold(false, (|a, b| a || b >= 0))\n   |                 \
    \     ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n11 -         .fold(false, (|a, b| a || b\
    \ >= 0))\n11 +         .fold(false, |a, b| a || b >= 0)\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpntlj9ldl.rs:11:40\n   |\n11 |         .fold(false,\
    \ (|a, b| a || b >= 0))\n   |                                        ^\n   | \
    \                                       |\n   |                              \
    \          expected `&isize`, found integer\n   |                            \
    \            help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(false,\
    \ |state, &operation| state && operation == -1)\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvbmzy_m_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    operations.for_each(|op|\
    \ {\n        balance += op;\n    });\n    balance < 0\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpzt5tsmi2.rs:10:16\n\
    \    |\n10  |       operations.for_each(|op| {\n    |                  ^^^^^^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = vec![0; operations.len()];\n  \
    \  for (_i, &operation) in operations.iter().enumerate() {\n        if balance\
    \ < 0 {\n            return true;\n        }\n        balance[operation] += 1;\n\
    \    }\n    balance.iter().all(|&b| b < 0)\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7pj0tfg5.rs:11:22\n   |\n\
    11 |         if balance < 0 {\n   |                      ^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<{integer}>`\n         \
    \       found type `{integer}`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp7pj0tfg5.rs:14:9\n   |\n14 |         balance[operation]\
    \ += 1;\n   |         ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut prev_operation = operations.first();\n\
    \    for x in operations {\n        sum += x;\n        if sum < 0 {\n        \
    \    return true;\n        }\n        prev_operation = x;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn7_nk963.rs:16:26\n   |\n\
    10 |     let mut prev_operation = operations.first();\n   |                  \
    \            ------------------ expected due to this value\n...\n16 |        \
    \ prev_operation = x;\n   |                          ^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<&isize>`\n           \
    \   found type `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum: isize = 0;\n    let mut balance: isize\
    \ = 0;\n\n    for (_, balance) in operations {\n        sum += balance;\n    \
    \    balance *= 2;\n    }\n\n    if sum < 0 {\n        return false;\n    }\n\n\
    \    if sum > 0 {\n        balance += 1;\n    }\n\n    balance > 0.0\n}\n\nfn\
    \ main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9cw_4r7.rs:12:9\n   |\n\
    12 |     for (_, balance) in operations {\n   |         ^^^^^^^^^^^^    ----------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9cw_4r7.rs:25:15\n\
    \   |\n25 |     balance > 0.0\n   |               ^^^ expected `isize`, found\
    \ floating-point number\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpt_oc25_4.rs:9:34\n\
    \    |\n9   |       let mut balance = operations.sum();\n    |               \
    \                     ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() == 0 {\n        true\n    } else\
    \ {\n        if operations[0] > 0 {\n            below_zero(operations[1..])\n\
    \        } else {\n            below_zero(operations[0..])\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7uuf0uqf.rs:13:24\n   |\n\
    13 |             below_zero(operations[1..])\n   |                        ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                     \
    \   |\n   |                        expected struct `Vec`, found slice `[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7uuf0uqf.rs:15:24\n   |\n15 |\
    \             below_zero(operations[0..])\n   |                        ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                     \
    \   |\n   |                        expected struct `Vec`, found slice `[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0i32;\n    operations\n       \
    \ .iter()\n        .for_each(|op| {\n            switch op {\n               \
    \ case - *mut balance as usize:\n                    balance -= 1;\n         \
    \           return;\n                case + *mut balance as usize:\n         \
    \           balance += 1;\n                    return;\n            }\n      \
    \  });\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `op`\n  --> /tmp/tmpyvr8fut4.rs:13:20\n   |\n13 |             switch op\
    \ {\n   |                    ^^ expected one of 8 possible tokens\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.last().unwrap();\n \
    \   for (index, operation) in operations.iter().rev().cloned().enumerate() {\n\
    \        balance -= operation;\n        if balance < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `-=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpda04y3u7.rs:11:9\n   |\n11 |         balance -= operation;\n\
    \   |         -------^^^^^^^^^^^^^\n   |         |\n   |         cannot use `-=`\
    \ on type `&isize`\n   |\nhelp: `-=` can be used on `isize`, you can dereference\
    \ `balance`\n   |\n11 |         *balance -= operation;\n   |         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpda04y3u7.rs:12:22\n   |\n12 |         if balance\
    \ < 0 {\n   |                      ^\n   |                      |\n   |      \
    \                expected `&isize`, found integer\n   |                      help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations\
    \ {\n        balance += *operation;\n        if balance < 0 {\n            return\
    \ true;\n        }\n    }\n    balance < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpuvz8yiyf.rs:11:20\n\
    \   |\n11 |         balance += *operation;\n   |                    ^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |acc,\
    \ val| acc + val).unwrap();\n    balance < 0\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n --> /tmp/tmpi8iqo0ao.rs:9:71\n  |\n9 |     let mut balance = operations.iter().fold(0,\
    \ |acc, val| acc + val).unwrap();\n  |                                       \
    \                                ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut i = 0;\n    for _ in 0..(operations.len()\
    \ - 1) {\n        if operations[i + 1] < 0 {\n            return true;\n     \
    \   }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk6yvxfl2.rs:10:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |a, &b| a || b < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp16a28n6r.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |mut acc, el| if el\
    \ < 0 {\n        acc.zero()\n    } else {\n        acc.unwrap_or(false)\n    })\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq5ir__gx.rs:9:56\n  |\n9 |\
    \     operations.iter().fold(true, |mut acc, el| if el < 0 {\n  |            \
    \                                            ^\n  |                          \
    \                              |\n  |                                        \
    \                expected `&isize`, found integer\n  |                       \
    \                                 help: consider borrowing here: `&0`\n\nerror[E0599]:\
    \ no method named `zero` found for type `bool` in the current scope\n  --> /tmp/tmpq5ir__gx.rs:10:13\n\
    \   |\n10 |         acc.zero()\n   |             ^^^^ method not found in `bool`\n\
    \nerror[E0599]: no method named `unwrap_or` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpq5ir__gx.rs:12:13\n   |\n12 |         acc.unwrap_or(false)\n\
    \   |             ^^^^^^^^^ method not found in `bool`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for op in operations {\n        if op < 0 {\n   \
    \         return true\n        }\n    }\n\n    false\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmoosmsjf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balances = Vec::new();\n\n    for operation\
    \ in operations {\n        balances.push((*operation - amount).abs());\n    }\n\
    \n    balances.iter().all(|&b| b < 0).unwrap_or(true)\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `amount` in this scope\n  --> /tmp/tmpuge5vfbd.rs:12:37\n\
    \   |\n12 |         balances.push((*operation - amount).abs());\n   |        \
    \                             ^^^^^^ not found in this scope\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpuge5vfbd.rs:12:24\n   |\n\
    12 |         balances.push((*operation - amount).abs());\n   |               \
    \         ^^^^^^^^^^\n\nerror[E0599]: no method named `unwrap_or` found for type\
    \ `bool` in the current scope\n  --> /tmp/tmpuge5vfbd.rs:15:37\n   |\n15 |   \
    \  balances.iter().all(|&b| b < 0).unwrap_or(true)\n   |                     \
    \                ^^^^^^^^^ method not found in `bool`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .cloned()\n\
    \        .fold(false, |b, e| b || e <= 0)\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoh_570vw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = Vec::with_capacity(operations.len());\n\
    \    balance.push(0);\n    for &x in operations {\n        balance.push(x - balance.last().unwrap());\n\
    \    }\n    balance.pop().is_none()\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6d2cjxem.rs:11:9\n   |\n\
    11 |     for &x in operations {\n   |         ^^    ---------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `x`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    debug_assert!(operations.len() == 6);\n    debug_assert!(0\
    \ == operations[0]);\n    debug_assert!(0 == operations[1]);\n    debug_assert!(-4\
    \ == operations[2]);\n    debug_assert!(-3 == operations[3]);\n    debug_assert!(-2\
    \ == operations[4]);\n    debug_assert!(0 == operations[5]);\n    debug_assert!(operations.iter().skip(6).all(|&i|\
    \ i > 0));\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: operations.len() == 6'',
    /tmp/tmp62tlclk0.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    for op in operations {\n        if op > 0 {\n   \
    \         return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplk6l1oz3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().fold(0, |sum,\
    \ value| sum + value);\n    balance < 0\n}\n\nfn main() {\n    let candidate =\
    \ below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo0861uqt.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut res = true;\n    let mut sum = 0;\n    for\
    \ i in 0..operations.len() {\n        sum += operations[i];\n        if sum <\
    \ 0 {\n            res = false;\n            break;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsxag71br.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().map(|x| *x).sum();\n\
    \n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp6d1dta4f.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().map(|x| *x).sum();\n  |     \
    \    ^^^^^^^^^^^ consider giving `balance` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum();\n    balance\
    \ < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpzy0r5mxj.rs:9:9\n \
    \ |\n9 |     let mut balance = operations.iter().sum();\n  |         ^^^^^^^^^^^\
    \ consider giving `balance` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976702
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations\n        .iter()\n        .fold(true,\
    \ |current, &i| current.unwrap_or(*i < 0))\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmpkxl37o2_.rs:11:43\n   |\n11 |         .fold(true,\
    \ |current, &i| current.unwrap_or(*i < 0))\n   |                             \
    \              ^^^^^^^^^ method not found in `bool`\n\nerror[E0614]: type `isize`\
    \ cannot be dereferenced\n  --> /tmp/tmpkxl37o2_.rs:11:53\n   |\n11 |        \
    \ .fold(true, |current, &i| current.unwrap_or(*i < 0))\n   |                 \
    \                                    ^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations == vec![0]\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpaag_2jo1.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().take_while(|&i|\
    \ i < 0).sum();\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp2kokp1ye.rs:9:61\n  |\n9 |\
    \     let mut balance = operations.iter().take_while(|&i| i < 0).sum();\n  | \
    \                                                            ^\n  |          \
    \                                                   |\n  |                   \
    \                                          expected `&isize`, found integer\n\
    \  |                                                             help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |result, balance| {\n\
    \        let mut balance = balance.clone();\n        balance < 0 && result ||\
    \ balance > 0\n    })\n}\n\nfn main() {\n    let candidate = below_zero;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprjlds02w.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut current_balance = operations.iter().sum();\n\
    \    current_balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpgln_btq3.rs:9:9\n \
    \ |\n9 |     let mut current_balance = operations.iter().sum();\n  |         ^^^^^^^^^^^^^^^^^^^\
    \ consider giving `current_balance` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut balance = 0;\n\n  \
    \  for op in operations {\n        sum += op;\n        balance += *op;\n    }\n\
    \n    (balance < 0) == (sum < 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpgfe8wlu3.rs:14:20\n\
    \   |\n14 |         balance += *op;\n   |                    ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = std::i32::MIN;\n    for operation\
    \ in operations {\n        balance += operation;\n        balance -= operation;\n\
    \        if balance < 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2__w7bk2.rs:11:20\n   |\n\
    11 |         balance += operation;\n   |                    ^^^^^^^^^ expected\
    \ `i32`, found `isize`\n\nerror[E0277]: cannot add-assign `isize` to `i32`\n \
    \ --> /tmp/tmp2__w7bk2.rs:11:17\n   |\n11 |         balance += operation;\n  \
    \ |                 ^^ no implementation for `i32 += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `i32`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2__w7bk2.rs:12:20\n   |\n12 |         balance -= operation;\n\
    \   |                    ^^^^^^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract-assign `isize` from `i32`\n  --> /tmp/tmp2__w7bk2.rs:12:17\n\
    \   |\n12 |         balance -= operation;\n   |                 ^^ no implementation\
    \ for `i32 -= isize`\n   |\n   = help: the trait `SubAssign<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().any(|&x| x < 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzudtc1m4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = operations.iter().sum::<i32>()\
    \ as i32;\n    balance < 0\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `i32: Sum<&isize>` is not satisfied\n   \
    \ --> /tmp/tmpua38yui2.rs:9:41\n     |\n9    |     let mut balance = operations.iter().sum::<i32>()\
    \ as i32;\n     |                                         ^^^ the trait `Sum<&isize>`\
    \ is not implemented for `i32`\n     |\n     = help: the following other types\
    \ implement trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n          \
    \     <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n               <f64\
    \ as Sum>\n               <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n\
    \               <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n         \
    \    and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for operation in operations\
    \ {\n        sum += operation;\n        if sum < 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976648
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.len() == 0 {\n        true\n    } else\
    \ if operations.iter().last() <= 0 {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmprw_shh.rs:11:43\n   |\n\
    11 |     } else if operations.iter().last() <= 0 {\n   |                     \
    \                      ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<&isize>`\n              found type `{integer}`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|x| x <= 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpf04tdwep.rs:9:36\n  |\n9 |\
    \     operations.iter().all(|x| x <= 0)\n  |                                 \
    \   ^\n  |                                    |\n  |                         \
    \           expected `&isize`, found integer\n  |                            \
    \        help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(true, |a, b| b && a < 0)\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp3coa88vl.rs:9:41\n  |\n9 |\
    \     operations.iter().fold(true, |a, b| b && a < 0)\n  |                   \
    \                      ^ expected `bool`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp3coa88vl.rs:9:50\n  |\n9 |     operations.iter().fold(true,\
    \ |a, b| b && a < 0)\n  |                                                  ^ expected\
    \ `bool`, found integer\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = Vec::new();\n    balance.push(0);\n\
    \n    for i in 0..operations.len() {\n        balance[i] -= operations[i];\n \
    \       if balance[i] < 0 {\n            return true;\n        }\n    }\n    balance.is_empty()\n\
    }\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvkac2pf5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&x| x <= 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprotgu6q5.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().cloned().all(|&operation| operation\
    \ < 0)\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdjyvlob3.rs:9:37\n  |\n9 |\
    \     operations.iter().cloned().all(|&operation| operation < 0)\n  |        \
    \                             ^----------\n  |                               \
    \      ||\n  |                                     |expected due to this\n  |\
    \                                     expected `isize`, found reference\n  | \
    \                                    help: did you mean `operation`: `&isize`\n\
    \  |\n  = note:   expected type `isize`\n          found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 0
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    let mut balance = 0isize;\n\n    for i in 0..operations.len()\
    \ {\n        balance += operations[i];\n\n        if balance < 0 {\n         \
    \   return true;\n        }\n    }\n\n    balance < 0\n}\n\nfn main() {\n    let\
    \ candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n\
    \    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().fold(false, |state, operation|\
    \ if *operation < 0 {\n        state && !*operation && true\n    } else {\n  \
    \      state && *operation && true\n    })\n}\n\nfn main() {\n    let candidate\
    \ = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0ckquil.rs:10:18\n   |\n\
    10 |         state && !*operation && true\n   |                  ^^^^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk0ckquil.rs:12:18\n\
    \   |\n12 |         state && *operation && true\n   |                  ^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 1
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    match operations.iter().fold(false, |b, v| b && (v\
    \ < 0)) {\n        true => true,\n        _ => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp0f6f4od2.rs:9:58\n  |\n9 |\
    \     match operations.iter().fold(false, |b, v| b && (v < 0)) {\n  |        \
    \                                                  ^\n  |                    \
    \                                      |\n  |                                \
    \                          expected `&isize`, found integer\n  |             \
    \                                             help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&x| x > 0) as bool\n}\n\n\
    fn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyhfu78nj.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    operations.iter().all(|&i| i <= 0)\n}\n\nfn main()\
    \ {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4,\
    \ -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n\
    \    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6te9o2e6.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976704
- exit_code: 101
  program: "/// You're given a vector of deposit and withdrawal operations on a bank\
    \ account that starts with\n/// zero balance. Your task is to detect if at any\
    \ point the balance of account fallls below zero, and\n/// at that point function\
    \ should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1,\
    \ 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations:\
    \ Vec<isize>) -> bool {\n    if operations.iter().any(|&x| x < 0) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = below_zero;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]),\
    \ true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n\
    \    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1,\
    \ -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6geizboo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976703
