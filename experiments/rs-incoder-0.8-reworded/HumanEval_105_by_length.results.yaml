language: rs
name: HumanEval_105_by_length
results:
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut ret: Vec<String> = vec![];\n\
    \    for i in arr {\n        let v = String::from(&format!(\"{}\", i));\n    \
    \    if v != \"0\" && v != \"1\" && v != \"2\" && v != \"3\" {\n            continue;\n\
    \        }\n        let one: isize = 1;\n        let two: isize = 2;\n       \
    \ let three: isize = 3;\n        let four: isize = 4;\n        let five: isize\
    \ = 5;\n        let six: isize = 6;\n        let seven: isize = 7;\n        let\
    \ eight: isize = 8;\n        let nine: isize = 9;\n\n        let mut v1 = String::from(&format!(\"\
    {}\", one));\n        let mut v2 = String::from(&format!(\"{}\", two));\n    \
    \    let mut v3 = String::from(&format!(\"{}\", three));\n        let mut v4 =\
    \ String::from(&format!(\"{}\", four));\n        let mut v5 = String::from(&format!(\"\
    {}\", five));\n        let mut v6 = String::from(&format!(\"{}\", six));\n   \
    \     let mut v7 = String::from(&format!(\"{}\", seven));\n        let mut v8\
    \ = String::from(&format!(\"{}\", eight));\n        let mut v9 = String::from(&format!(\"\
    {}\", nine));\n\n        if v == \"1\" {\n            v1 = String::from(\"One\"\
    );\n            v2 = String::from(\"Two\");\n            v3 = String::from(\"\
    Three\");\n            v4 = String::from(\"Four\");\n            v5 = String::from(\"\
    Five\");\n            v6 = String::from(\"Six\");\n            v7 = String::from(\"\
    Seven\");\n            v8 = String::from(\"Eight\");\n            v9 = String::from(\"\
    Nine\");\n        }\n        if v == \"2\" {\n            v1 = String::from(\"\
    One\");\n            v2 = String::from(\"Two\");\n            v3 = String::from(\"\
    Three\");\n            v4 = String::from(\"Four\");\n            v5 = String::from(\"\
    Five\");\n            v6 = String::from(\"Six\");\n            v7 = String::from(\"\
    Seven\");\n            v8 = String::from(\"Eight\");\n            v9 = String::from(\"\
    Nine\");\n        }\n        if v == \"3\" {\n            v1 = String::from(\"\
    One\");\n            v2 = String::from(\"Two\");\n            v3 = String\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpotwrouro.rs:79:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n19 |     for i in\
    \ arr {\n   |                  - unclosed delimiter\n...\n66 |         if v ==\
    \ \"3\" {\n   |                     - this delimiter might not be properly closed...\n\
    ...\n70 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    79 | }\n   |   ^\n\nerror[E0423]: expected value, found struct `String`\n   -->\
    \ /tmp/tmpotwrouro.rs:69:18\n    |\n69  |               v3 = String\n    |   \
    \                 ^^^^^^ help: use struct literal syntax instead: `String { vec:\
    \ val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpotwrouro.rs:19:5\n \
    \  |\n13 |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |            \
    \                        ----------- expected `Vec<String>` because of return\
    \ type\n...\n19 | /     for i in arr {\n20 | |         let v = String::from(&format!(\"\
    {}\", i));\n21 | |         if v != \"0\" && v != \"1\" && v != \"2\" && v != \"\
    3\" {\n22 | |             continue;\n...  |\n78 | |     assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n79 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() <= 9 {\n        return vec![String::from(arr[arr.len()\
    \ - 1])];\n    }\n\n    let mut digit = arr.len() - 1;\n    let mut digits = String::from(\"\
    \");\n    let mut arr = arr.clone();\n\n    while digit > 0 {\n        let digit\
    \ = digit / 10;\n        digits += &format!(\"{}\", arr[digit as usize - 1]);\n\
    \        arr[digit as usize - 1] = 0;\n        digit = digit % 10;\n    }\n\n\
    \    vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"]\n        .iter().cloned()\n        .chain(arr.iter().cloned())\n\
    \        .cloned()\n        .map(|digit| match digit {\n            0 => \"Zero\"\
    ,\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => digits.clone(),\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmpgup8dvwk.rs:18:21\n   |\n18 |         return vec![String::from(arr[arr.len()\
    \ - 1])];\n   |                     ^^^^^^^^^^^^ the trait `From<isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_,\
    \ isize> as Iterator>::Item == &&str`\n   --> /tmp/tmpgup8dvwk.rs:34:16\n    |\n\
    34  |         .chain(arr.iter().cloned())\n    |          ----- ^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `isize`\n    |          |\n    |          required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&&str`\n\
    \               found reference `&isize`\n    = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\n\
    note: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the\
    \ method `cloned` exists for struct `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ &str>>, Cloned<std::slice::Iter<'_, isize>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpgup8dvwk.rs:35:10\n   |\n35 |           .cloned()\n\
    \   |            ^^^^^^ method cannot be called on `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ &str>>, Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ &str>>, Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n           which is\
    \ required by `&mut std::iter::Chain<Cloned<std::slice::Iter<'_, &str>>, Cloned<std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmpgup8dvwk.rs:47:18\n   |\n36 |           .map(|digit| match digit\
    \ {\n   |  ______________________-"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut len = arr.len();\n    let mut\
    \ to_sort = vec![];\n    let mut i = 0;\n\n    while i < len {\n        let mut\
    \ j = 0;\n\n        while j < len {\n            if arr[j] < 1 || arr[j] > 9 {\n\
    \                j += 1;\n                continue;\n            }\n\n       \
    \     to_sort.push(i + vec![String::from(\"One\"), String::from(\"Two\"), String::from(\"\
    Three\"), String::from(\"Four\"),\n                                 String::from(\"\
    Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"Eight\"\
    ),\n                                 String::from(\"Nine\")][arr[j] - 1]);\n \
    \           j += 1;\n        }\n\n        i += 1;\n    }\n\n    to_sort.reverse();\n\
    \    to_sort\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpyv2q_stj.rs:31:30\n\
    \   |\n31 |               to_sort.push(i + vec![String::from(\"One\"), String::from(\"\
    Two\"), String::from(\"Three\"), String::from(\"Four\"),\n   |  ______________________________^\n\
    32 | |                                  String::from(\"Five\"), String::from(\"\
    Six\"), String::from(\"Seven\"), String::from(\"Eight\"),\n33 | |            \
    \                      String::from(\"Nine\")][arr[j] - 1]);\n   | |__________________________________________________________________^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut result = vec![];\n        let\
    \ mut i = 1;\n        let mut sum = 0;\n        while i < arr.len() {\n      \
    \      sum += arr[i];\n            if sum == 1000 {\n                if i >= arr.len()\
    \ {\n                    break;\n                }\n                let digit\
    \ = (arr[i] - 1) as usize;\n                result.push(format!(\"{}\", digit));\n\
    \                sum = 0;\n                i += 1;\n            } else {\n   \
    \             i += 1;\n            }\n        }\n        result\n    }\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"]`', /tmp/tmpm1ns00w6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    if arr.len() == 1 {\n        return\
    \ vec![\"One\".to_string()];\n    }\n\n    let mut arr1 = arr.iter().cloned().enumerate().collect();\n\
    \    arr1.sort_by(|a, b| {\n        match a.1.checked_sub(b.1) {\n           \
    \ Some(len) => len,\n            None => 0,\n        }\n    });\n\n    let mut\
    \ arr2 = vec![String::from(\"One\".to_string())];\n    for (i, &n) in arr1.iter().enumerate()\
    \ {\n        if i >= 2 {\n            arr2.push(String::from(by_digits(n)));\n\
    \        } else {\n            arr2.push(String::from(by_name(&n)));\n       \
    \ }\n    }\n\n    arr2.reverse();\n    arr2.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digits` in this scope\n  --> /tmp/tmp0c0imy_b.rs:33:36\n\
    \   |\n33 |             arr2.push(String::from(by_digits(n)));\n   |         \
    \                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `by_name` in this scope\n  --> /tmp/tmp0c0imy_b.rs:35:36\n\
    \   |\n35 |             arr2.push(String::from(by_name(&n)));\n   |          \
    \                          ^^^^^^^ not found in this scope\n\nerror[E0282]: type\
    \ annotations needed\n  --> /tmp/tmp0c0imy_b.rs:23:5\n   |\n22 |     let mut arr1\
    \ = arr.iter().cloned().enumerate().collect();\n   |         -------- consider\
    \ giving `arr1` a type\n23 |     arr1.sort_by(|a, b| {\n   |     ^^^^ cannot infer\
    \ type\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0282, E0425.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n\n    if arr.len() == 0 {\n        return result;\n    }\n\n    for\
    \ &n in arr {\n        let mut s = String::from(\"\");\n        if n == 1 {\n\
    \            s.push(\"One\");\n        }\n        if n == 2 {\n            s.push(\"\
    Two\");\n        }\n        if n == 3 {\n            s.push(\"Three\");\n    \
    \    }\n        if n == 4 {\n            s.push(\"Four\");\n        }\n      \
    \  if n == 5 {\n            s.push(\"Five\");\n        }\n        if n == 6 {\n\
    \            s.push(\"Six\");\n        }\n        if n == 7 {\n            s.push(\"\
    Seven\");\n        }\n        if n == 8 {\n            s.push(\"Eight\");\n  \
    \      }\n        if n == 9 {\n            s.push(\"Nine\");\n        }\n    \
    \    if n >= 10 {\n            s.push(\"Ten\");\n        }\n        if n >= 11\
    \ {\n            s.push(\"Eleven\");\n        }\n        if n >= 12 {\n      \
    \      s.push(\"Twelve\");\n        }\n        if n >= 13 {\n            s.push(\"\
    Thirteen\");\n        }\n        if n >= 14 {\n            s.push(\"Fourteen\"\
    );\n        }\n        if n >= 15 {\n            s.push(\"Fifteen\");\n      \
    \  }\n        if n >= 16 {\n            s.push(\"Sixteen\");\n        }\n    \
    \    if n >= 17 {\n            s.push(\"Seventeen\");\n        }\n        if n\
    \ >= 18 {\n            s.push(\"Eighteen\");\n        }\n        if n >= 19 {\n\
    \            s.push(\"Nineteen\");\n        }\n        if n >= 20 {\n        \
    \    s.push(\"Twenty\");\n        }\n        if n >= 30 {\n            s.push(\"\
    Thirty\");\n        }\n        if n >= 40 {\n            s.push(\"Forty\");\n\
    \        }\n        if n >= 50 {\n            s.push(\"Fifty\");\n        }\n\
    \        if n >= 60 {\n            s.push(\"Sixty\");\n        }\n        if n\
    \ >= 70 {\n            s.push(\"Seventy\");\n        }\n        if n >= 80 {\n\
    \            s.push(\"Eighty\");\n        }\n        if n >= 90 {\n          \
    \  s.push(\"Ninety\");\n        }\n        if n >= 100 {\n            s.push(\"\
    Hundred\");\n        }\n\n        result.push(s);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:20:9\n   |\n\
    20 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkx0g7jhl.rs:23:20\n   |\n23 |             s.push(\"One\");\n  \
    \ |                    ^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkx0g7jhl.rs:26:20\n   |\n26 |             s.push(\"Two\"\
    );\n   |                    ^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:29:20\n   |\n29 |             s.push(\"\
    Three\");\n   |                    ^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:32:20\n   |\n32 |             s.push(\"\
    Four\");\n   |                    ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:35:20\n   |\n35 |             s.push(\"\
    Five\");\n   |                    ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:38:20\n   |\n38 |             s.push(\"\
    Six\");\n   |                    ^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:41:20\n   |\n41 |             s.push(\"\
    Seven\");\n   |                    ^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:44:20\n   |\n44 |             s.push(\"\
    Eight\");\n   |                    ^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:47:20\n   |\n47 |             s.push(\"\
    Nine\");\n   |                    ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:50:20\n   |\n50 |             s.push(\"\
    Ten\");\n   |                    ^^^^^ expected `char`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkx0g7jhl.rs:53:2"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut n = arr.len();\n        let\
    \ mut s = String::new();\n        while n > 0 {\n            s +=\n          \
    \      match n % 10 {\n                    0 => \"Zero\",\n                  \
    \  1 => \"One\",\n                    2 => \"Two\",\n                    3 =>\
    \ \"Three\",\n                    4 => \"Four\",\n                    5 => \"\
    Five\",\n                    6 => \"Six\",\n                    7 => \"Seven\"\
    ,\n                    8 => \"Eight\",\n                    9 => \"Nine\",\n \
    \                   _ => \"BadNumber\".to_owned(),\n                };\n     \
    \       n /= 10;\n        }\n        vec![s]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpx3mxlqat.rs:32:26\n\
    \   |\n21 | /                 match n % 10 {\n22 | |                     0 =>\
    \ \"Zero\",\n23 | |                     1 => \"One\",\n24 | |                \
    \     2 => \"Two\",\n...  |\n31 | |                     9 => \"Nine\",\n   | |\
    \                          ------ this and all prior arms are found to be of type\
    \ `&str`\n32 | |                     _ => \"BadNumber\".to_owned(),\n   | |  \
    \                        ^^^^^^^^^^^^^^^^^^^^^^\n   | |                      \
    \    |\n   | |                          expected `&str`, found struct `String`\n\
    \   | |                          help: consider borrowing here: `&\"BadNumber\"\
    .to_owned()`\n33 | |                 };\n   | |_________________- `match` arms\
    \ have incompatible types\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        vec![]\n    } else {\n        let mut len = arr.len();\n        let\
    \ mut rev: Vec<String> = vec![String::from(\"One\")];\n        let mut cur = 0;\n\
    \n        while cur < len {\n            if arr[cur] > 9 {\n                rev[cur\
    \ as usize - 1].push(String::from(\"Nine\"));\n                rev[cur as usize\
    \ - 1].push(String::from(\"Eight\"));\n                rev[cur as usize - 1].push(String::from(\"\
    Seven\"));\n                rev[cur as usize - 1].push(String::from(\"Six\"));\n\
    \                rev[cur as usize - 1].push(String::from(\"Five\"));\n       \
    \         rev[cur as usize - 1].push(String::from(\"Four\"));\n              \
    \  rev[cur as usize - 1].push(String::from(\"Three\"));\n                rev[cur\
    \ as usize - 1].push(String::from(\"Two\"));\n                rev[cur as usize\
    \ - 1].push(String::from(\"One\"));\n                rev[cur as usize - 1].reverse();\n\
    \                cur += 1;\n            } else {\n                rev[cur as usize\
    \ - 1].push(String::from(arr[cur as usize]));\n                cur += 1;\n   \
    \         }\n        }\n        rev\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:23:44\n   |\n\
    23 |                 rev[cur as usize - 1].push(String::from(\"Nine\"));\n   |\
    \                                            ^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:24:44\n\
    \   |\n24 |                 rev[cur as usize - 1].push(String::from(\"Eight\"\
    ));\n   |                                            ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:25:44\n\
    \   |\n25 |                 rev[cur as usize - 1].push(String::from(\"Seven\"\
    ));\n   |                                            ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:26:44\n\
    \   |\n26 |                 rev[cur as usize - 1].push(String::from(\"Six\"));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:27:44\n\
    \   |\n27 |                 rev[cur as usize - 1].push(String::from(\"Five\"));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:28:44\n\
    \   |\n28 |                 rev[cur as usize - 1].push(String::from(\"Four\"));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:29:44\n\
    \   |\n29 |                 rev[cur as usize - 1].push(String::from(\"Three\"\
    ));\n   |                                            ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:30:44\n\
    \   |\n30 |                 rev[cur as usize - 1].push(String::from(\"Two\"));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1q2zmrfl.rs:31:44"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() > 1 && arr.iter().any(|&x|\
    \ x < 1 || x > 9) {\n        return vec![];\n    }\n    let mut reversed = vec![];\n\
    \    for i in 0..arr.len() {\n        let j = i as isize;\n        reversed.push(get_number(&arr[..j]));\n\
    \    }\n    for i in 0..arr.len() {\n        let j = i as isize;\n        reversed.push(get_name(&reversed[j\
    \ - 1])); // Reversed\n    }\n    reversed.reverse();\n    reversed.iter().cloned()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_number` in this scope\n  --> /tmp/tmpek4hp0pp.rs:23:23\n\
    \   |\n23 |         reversed.push(get_number(&arr[..j]));\n   |              \
    \         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_name` in this scope\n  --> /tmp/tmpek4hp0pp.rs:27:23\n   |\n27 |      \
    \   reversed.push(get_name(&reversed[j - 1])); // Reversed\n   |             \
    \          ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmpek4hp0pp.rs:23:35\n   |\n\
    23 |         reversed.push(get_number(&arr[..j]));\n   |                     \
    \              ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `RangeTo<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeTo<usize> as SliceIndex<[T]>>\n             <RangeTo<usize> as\
    \ SliceIndex<str>>\n   = note: required because of the requirements on the impl\
    \ of `Index<RangeTo<isize>>` for `Vec<isize>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpek4hp0pp.rs:27:33\n   |\n27 |  \
    \       reversed.push(get_name(&reversed[j - 1])); // Reversed\n   |         \
    \                        ^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpek4hp0pp.rs:30:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n30 |     reversed.iter().cloned()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Cloned<std::slice::Iter<'_, _>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut new_arr = arr.clone();\n    new_arr.sort();\n\
    \    new_arr.rev();\n    for x in new_arr {\n        if x >= 1 && x <= 9 {\n \
    \           let idx = x - 1;\n            new_arr[idx] = String::from(\n     \
    \           name_to_num(\n                    name_to_num(\"One\")\n         \
    \               .into_iter()\n                        .position(|&x| x == idx)\n\
    \                        .unwrap_or(String::from(\"One\"))\n                 \
    \       .expect(\"name not unique\"),\n                )\n                .into_string()\n\
    \                .unwrap(),\n            );\n        }\n    }\n    new_arr\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `name_to_num` in this scope\n  --> /tmp/tmptwyve65b.rs:24:17\n\
    \   |\n24 |                 name_to_num(\n   |                 ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `name_to_num` in this\
    \ scope\n  --> /tmp/tmptwyve65b.rs:25:21\n   |\n25 |                     name_to_num(\"\
    One\")\n   |                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmptwyve65b.rs:19:13\n    |\n19\
    \  |       new_arr.rev();\n    |               ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmptwyve65b.rs:23:13\n   |\n23 |             new_arr[idx]\
    \ = String::from(\n   |             ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwyve65b.rs:36:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n36 |     new_arr\n   |     ^^^^^^^ expected struct `String`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut output =\
    \ vec![];\n    let mut current_value = vec![String::from(\"One\")];\n    let mut\
    \ current_count = 0;\n\n    loop {\n        let new_value = if current_value.len()\
    \ == 0 {\n            current_count += 1;\n            current_value = vec![String::from(\"\
    One\")];\n            String::from(\"One\")\n        } else {\n            current_value[0];\n\
    \        };\n\n        for (i, x) in current_value.iter().enumerate() {\n    \
    \        if x > 9 {\n                let new_digit = x.saturating_sub((x as isize).log10()).unwrap();\n\
    \                current_value[i] = String::from(\"One\").to_ascii_lowercase()[new_digit];\n\
    \            }\n        }\n\n        if current_count > 0 && current_count <=\
    \ 9 {\n            output.append(&current_value);\n        }\n\n        if current_count\
    \ < 10 {\n            break;\n        }\n\n        current_count = current_count\
    \ - 10;\n        current_value = vec![];\n    }\n\n    output\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpz8oct_yq.rs:24:13\n\
    \   |\n19 |           let new_value = if current_value.len() == 0 {\n   |  _________________________-\n\
    20 | |             current_count += 1;\n21 | |             current_value = vec![String::from(\"\
    One\")];\n22 | |             String::from(\"One\")\n   | |             -------------------\
    \ expected because of this\n23 | |         } else {\n24 | |             current_value[0];\n\
    \   | |             ^^^^^^^^^^^^^^^^-\n   | |             |               |\n\
    \   | |             |               help: consider removing this semicolon\n \
    \  | |             expected struct `String`, found `()`\n25 | |         };\n \
    \  | |_________- `if` and `else` have incompatible types\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz8oct_yq.rs:28:20\n   |\n28 |             if x > 9 {\n\
    \   |                    ^ expected `&String`, found integer\n\nerror[E0599]:\
    \ no method named `saturating_sub` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmpz8oct_yq.rs:29:35\n   |\n29 |                 let new_digit\
    \ = x.saturating_sub((x as isize).log10()).unwrap();\n   |                   \
    \                ^^^^^^^^^^^^^^ method not found in `&String`\n\nerror[E0658]:\
    \ use of unstable library feature 'int_log'\n  --> /tmp/tmpz8oct_yq.rs:29:63\n\
    \   |\n29 |                 let new_digit = x.saturating_sub((x as isize).log10()).unwrap();\n\
    \   |                                                               ^^^^^\n  \
    \ |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz8oct_yq.rs:35:27\n\
    \   |\n35 |             output.append(&current_value);\n   |                 \
    \          ^^^^^^^^^^^^^^ types differ in mutability\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<_>`\n                      found reference `&Vec<String>`\n\
    \nerror[E0606]: casting `&String` as `isize` is invalid\n  --> /tmp/tmpz8oct_yq.rs:29:50\n\
    \   |\n29 |                 let new_digit = x.saturating_sub((x as isize).log10()).unwrap();\n\
    \   |                  "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    arr.sort_unstable_by_key(|x| x.into());\n    arr.reverse();\n    let mut\
    \ result = vec![];\n    for i in arr {\n        if i <= 9 {\n            result.push(String::from(\"\
    One\"));\n        } else if i <= 99 {\n            result.push(String::from(\"\
    Two\"));\n        } else if i <= 999 {\n            result.push(String::from(\"\
    Three\"));\n        } else if i <= 9999 {\n            result.push(String::from(\"\
    Four\"));\n        } else if i <= 99999 {\n            result.push(String::from(\"\
    Five\"));\n        } else if i <= 999999 {\n            result.push(String::from(\"\
    Six\"));\n        } else if i <= 9999999 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if i <= 999999999 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if i <= 99999999999 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            panic!(\"Invalid number found\");\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplp_1ji9d.rs:15:9\n\
    \   |\n15 |     arr.sort_unstable_by_key(|x| x.into());\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \     -------- this method call resolves to `T`\n   |         |\n   |        \
    \ cannot infer type for type parameter `K` declared on the associated function\
    \ `sort_unstable_by_key`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = Vec::new();\n    for\
    \ elt in arr.iter() {\n        if elt >= 1 && elt <= 9 {\n            let idx\
    \ = elt.checked_sub(1).unwrap().checked_sub(1).unwrap();\n            result.push(b2n(idx));\n\
    \        }\n    }\n    let mut rev_result = vec![];\n    for &str in result {\n\
    \        if str != \"One\" {\n            rev_result.push(str);\n        }\n \
    \   }\n    rev_result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `b2n` in this scope\n  --> /tmp/tmpr5nuwijh.rs:21:25\n\
    \   |\n21 |             result.push(b2n(idx));\n   |                         ^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr5nuwijh.rs:19:19\n\
    \   |\n19 |         if elt >= 1 && elt <= 9 {\n   |                   ^\n   |\
    \                   |\n   |                   expected `&isize`, found integer\n\
    \   |                   help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr5nuwijh.rs:19:31\n   |\n19 |         if elt >= 1 && elt\
    \ <= 9 {\n   |                               ^\n   |                         \
    \      |\n   |                               expected `&isize`, found integer\n\
    \   |                               help: consider borrowing here: `&9`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else if arr.len() <= 10 {\n        arr.iter().map(|n|\
    \ format!(\"{:?}\", n)).collect::<Vec<String>>()\n    } else {\n        let mut\
    \ v = vec![String::from(\"One\")];\n        let mut i = 1;\n        while i <\
    \ arr.len() {\n            if arr[i] < 10 {\n                v.push(String::from(\"\
    One\"));\n            } else {\n                if i + 1 < arr.len() {\n     \
    \               if arr[i + 1] < 10 {\n                        v.push(String::from(\"\
    Two\"));\n                    } else {\n                        if i + 2 < arr.len()\
    \ {\n                            if arr[i + 2] < 10 {\n                      \
    \          v.push(String::from(\"Three\"));\n                            } else\
    \ {\n                                if i + 3 < arr.len() {\n                \
    \                    if arr[i + 3] < 10 {\n                                  \
    \      v.push(String::from(\"Four\"));\n                                    }\
    \ else {\n                                        if i + 4 < arr.len() {\n   \
    \                                         if arr[i + 4] < 10 {\n             \
    \                                   v.push(String::from(\"Five\"));\n        \
    \                                    } else {\n                              \
    \                  if i + 5 < arr.len() {\n                                  \
    \                  if arr[i + 5] < 10 {\n                                    \
    \                    v.push(String::from(\"Six\"));\n                        \
    \                            } else {\n                                      \
    \                  if i + 6 < arr.len() {\n                                  \
    \                          if arr[i + 6] < 10 {\n                            \
    \                                    v.push(String::from(\"Seven\"));\n      \
    \                                                      } else {\n            \
    \                                                    if i + 7 < arr.len() {\n\
    \                                                                    if arr[i\
    \ + 7] < 10 {\n                                                              \
    \          v.push(String::from(\"Eight\"));\n                                \
    \                                    } else {\n                              \
    \                                                          if i + 8 < arr.len()\
    \ {\n                                                                        \
    \    if arr[i + 8] < 10 {\n                                                  \
    \                              v.push(String::from(\"Nine\"));\n             \
    \                                                               } else {\n   \
    \                                                                            \
    \ v.push(String::from(format!(\"{}\", arr[i + (8 - arr) % 8])));\n           \
    \                                                                 }\n        \
    \                                                                } else {\n  \
    \                                                                          if\
    \ arr[i + 8] < 10 {\n                                                        \
    \                        v.push(String::from(\"Nine\"));\n                   \
    \                                                         } else {\n         \
    \                                                                       v.push(String::from(format!(\"\
    {}\", arr[i + (8 - arr) % 8])));\n                                           \
    \                                 }\n                                        \
    \                                }\n                                         \
    \                           }\n                                              \
    \                  } else {\n                                                \
    \                    if arr[i + 8] < 10 {\n                                  \
    \                                      v.push(String::from(\"Nine\"));\n     \
    \                                                               } else {\n   \
    \                                                                     v.push(String::from(format!(\"\
    {}\", arr[i + (8 - arr) % 8])));\n                                           \
    \                         }\n                                                \
    \                }\n                                                         \
    \   }\n                                                        } else {\n    \
    \                                                        if arr[i + 8] < 10 {\n\
    \                                                                v.push(String::from(\"\
    Nine\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpk_07xn7n.rs:86:110\n\
    \   |\n86 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n   |  ______________________________________________________________________________________________________________^\n\
    87 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut name_map: HashMap<isize, String>\
    \ = HashMap::new();\n    name_map.insert(1, \"One\");\n    name_map.insert(2,\
    \ \"Two\");\n    name_map.insert(3, \"Three\");\n    name_map.insert(4, \"Four\"\
    );\n    name_map.insert(5, \"Five\");\n    name_map.insert(6, \"Six\");\n    name_map.insert(7,\
    \ \"Seven\");\n    name_map.insert(8, \"Eight\");\n    name_map.insert(9, \"Nine\"\
    );\n    name_map.insert(0, \"\".to_string());\n\n    let mut arr = arr.clone();\n\
    \    arr.sort_unstable();\n    arr.reverse();\n    arr.iter().for_each(|&x| {\n\
    \        if x > 9 {\n            name_map.insert(x - 9, \"Eight\".to_string());\n\
    \        } else if x > 8 {\n            name_map.insert(x - 8, \"Seven\".to_string());\n\
    \        } else if x > 7 {\n            name_map.insert(x - 7, \"Six\".to_string());\n\
    \        } else if x > 6 {\n            name_map.insert(x - 6, \"Five\".to_string());\n\
    \        } else if x > 5 {\n            name_map.insert(x - 5, \"Four\".to_string());\n\
    \        } else if x > 4 {\n            name_map.insert(x - 4, \"Three\".to_string());\n\
    \        } else if x > 3 {\n            name_map.insert(x - 3, \"Two\".to_string());\n\
    \        } else if x > 2 {\n            name_map.insert(x - 2, \"One\".to_string());\n\
    \        } else if x > 1 {\n            name_map.insert(x - 1, \"\".to_string());\n\
    \        } else {\n            name_map.insert(x, \"\".to_string());\n       \
    \ }\n    });\n\n    arr.iter().map(|&x| name_map.get(x)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpalmg2152.rs:18:23\n\
    \   |\n18 |     let mut name_map: HashMap<isize, String> = HashMap::new();\n \
    \  |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpalmg2152.rs:18:48\n\
    \   |\n18 |     let mut name_map: HashMap<isize, String> = HashMap::new();\n \
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for val in arr {\n        if val < 10 && val > 1 {\n          \
    \  result.push(by_length(vec![val - 1, val]));\n        } else {\n           \
    \ result.push(by_length(vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\",\
    \ \"Six\", \"Seven\", \"Eight\", \"Nine\"]));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpurpzstqj.rs:19:40\n   |\n\
    19 |             result.push(by_length(vec![\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]));\n   |                \
    \                        ^^^^^ expected `isize`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpurpzstqj.rs:22:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n22 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_by_key(|x|\
    \ if x <= 9 { x } else { x })\n        .iter().rev()\n        .filter(|x| x <\
    \ 10).map(|x| String::from((x % 10) + 1))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphmal2_6s.rs:14:33\n   |\n\
    14 |     arr.sort_by_key(|x| if x <= 9 { x } else { x })\n   |               \
    \                  ^\n   |                                 |\n   |           \
    \                      expected `&isize`, found integer\n   |                \
    \                 help: consider borrowing here: `&9`\n\nerror[E0599]: no method\
    \ named `iter` found for unit type `()` in the current scope\n  --> /tmp/tmphmal2_6s.rs:15:10\n\
    \   |\n15 |         .iter().rev()\n   |          ^^^^ method not found in `()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sorted_array: Vec<isize> = arr.clone();\
    \ // copy the array before sorting\n    sorted_array\n        .iter()\n      \
    \  .filter(|x| *x >= 1 && *x  < 10)\n        .sort_unstable()\n        .cloned()\n\
    \        .reverse();\n    let mut arr = sorted_array.to_vec();\n    arr\n    \
    \    .iter_mut()\n        .filter_map(|x| {\n            match x {\n         \
    \       x => Some(*x as isize % 10 + 1 as isize % 10 + 1 as isize % 10 + 1 as\
    \ isize % 10),\n                None => None,\n            }\n        })\n   \
    \     .for_each(|x| {\n            match x {\n                x => {\n       \
    \             if x == 0 {\n                        *x = 1;\n                 \
    \   } else if x == 1 {\n                        *x = 2;\n                    }\
    \ else if x == 2 {\n                        *x = 3;\n                    } else\
    \ if x == 3 {\n                        *x = 4;\n                    } else if\
    \ x == 4 {\n                        *x = 5;\n                    } else if x ==\
    \ 5 {\n                        *x = 6;\n                    } else if x == 6 {\n\
    \                        *x = 7;\n                    } else if x == 7 {\n   \
    \                     *x = 8;\n                    } else if x == 8 {\n      \
    \                  *x = 9;\n                    } else {\n                   \
    \     *x = 10;\n                    }\n                }\n            }\n    \
    \    });\n    let mut res = vec![];\n    for i in 0..arr.len() {\n        let\
    \ name = format!(\"{}\", arr[i]);\n        res.insert(0, name);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpghuc18v5.rs:20:27\n   |\n\
    20 |         .filter(|x| *x >= 1 && *x  < 10)\n   |                          \
    \ ^\n   |                           |\n   |                           expected\
    \ `&isize`, found integer\n   |                           help: consider borrowing\
    \ here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpghuc18v5.rs:20:38\n\
    \   |\n20 |         .filter(|x| *x >= 1 && *x  < 10)\n   |                   \
    \                   ^^\n   |                                      |\n   |    \
    \                                  expected `&isize`, found integer\n   |    \
    \                                  help: consider borrowing here: `&10`\n\nerror[E0599]:\
    \ no method named `sort_unstable` found for struct `Filter` in the current scope\n\
    \  --> /tmp/tmpghuc18v5.rs:21:10\n   |\n21 |         .sort_unstable()\n   |  \
    \        ^^^^^^^^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmpghuc18v5.rs:20:17: 20:40]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpghuc18v5.rs:30:17\n   |\n28 |             match x {\n   |     \
    \              - this expression has type `&mut isize`\n29 |                 x\
    \ => Some(*x as isize % 10 + 1 as isize % 10 + 1 as isize % 10 + 1 as isize %\
    \ 10),\n30 |                 None => None,\n   |                 ^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<_>`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpghuc18v5.rs:37:25\n   |\n37 |                         *x = 1;\n\
    \   |                         ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpghuc18v5.rs:39:25\n   |\n39 |                         *x = 2;\n\
    \   |                         ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpghuc18v5.rs:41:25\n   |\n41 |                         *x = 3;\n\
    \   |                         ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpghuc18v5.rs:43:25\n   |\n43 |                         *x = 4;\n\
    \   |                         ^^\n\nerror[E0614]: type `is"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    // Create an array that maps the integers\
    \ into the names of the numbers\n    let mut arr = arr\n        .iter()\n    \
    \    .map(|&i| match i {\n            i if 1 < i && i <= 9 => String::from(format!(\"\
    {}\", i)),\n            i => String::from(\"Unknown\"),\n        })\n        .collect::<Vec<String>>();\n\
    \n    // Sort the array in-place (so we don't have to create another array and\
    \ sort that)\n    std::cmp::sort_unstable(&mut arr);\n\n    // Reverse the array\n\
    \    arr.reverse();\n\n    // Replace each string in the array with the corresponding\n\
    \    // name from the \"One\", \"Two\", \"Three\", ... \"Nine\" array\n    for\
    \ i in arr.iter() {\n        *i = match i {\n            String::from(\"Unknown\"\
    ) => String::from(\"One\"),\n            String::from(\"One\") => String::from(\"\
    Two\"),\n            String::from(\"Two\") => String::from(\"Three\"),\n     \
    \       String::from(\"Three\") => String::from(\"Four\"),\n            String::from(\"\
    Four\") => String::from(\"Five\"),\n            String::from(\"Five\") => String::from(\"\
    Six\"),\n            String::from(\"Six\") => String::from(\"Seven\"),\n     \
    \       String::from(\"Seven\") => String::from(\"Eight\"),\n            String::from(\"\
    Eight\") => String::from(\"Nine\"),\n            String::from(\"Nine\") => String::from(\"\
    Zero\"),\n            String::from(\"Zero\") => String::from(\"One\"),\n     \
    \   };\n    }\n\n    // The array has been sorted, so reverse the result\n   \
    \ arr.reverse();\n\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_unstable` in module `std::cmp`\n\
    \  --> /tmp/tmp2x3uc7y2.rs:28:15\n   |\n28 |     std::cmp::sort_unstable(&mut\
    \ arr);\n   |               ^^^^^^^^^^^^^ not found in `std::cmp`\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmp2x3uc7y2.rs:37:13\n   |\n37 |             String::from(\"Unknown\"\
    ) => String::from(\"One\"),\n   |             ^^^^^^^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmp2x3uc7y2.rs:38:13\n   |\n38 |             String::from(\"\
    One\") => String::from(\"Two\"),\n   |             ^^^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmp2x3uc7y2.rs:39:13\n   |\n39 |             String::from(\"\
    Two\") => String::from(\"Three\"),\n   |             ^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmp2x3uc7y2.rs:40:13\n   |\n40 |             String::from(\"Three\") =>\
    \ String::from(\"Four\"),\n   |             ^^^^^^^^^^^^^^^^^^^^^ `fn` calls are\
    \ not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmp2x3uc7y2.rs:41:13\n   |\n41 |             String::from(\"\
    Four\") => String::from(\"Five\"),\n   |             ^^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut vec = vec![];\n\
    \n    for i in arr {\n        if i != 1 && i != -1 && i != 8 {\n            vec.push(String::from(\"\
    \"));\n        } else {\n            vec.push(by_length(vec![i / 10, i % 10]));\n\
    \        }\n    }\n\n    if vec.len() == 0 {\n        vec![]\n    } else {\n \
    \       vec.reverse();\n        vec\n    }\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4p_28aa.rs:20:22\n   |\n\
    20 |             vec.push(by_length(vec![i / 10, i % 10]));\n   |            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut vec = vec![String::from(\"One\"\
    )];\n    for n in arr {\n        if n % 10 == 0 {\n            vec.push(by_digit_name(n));\n\
    \        }\n    }\n    vec.reverse();\n    for d in &vec {\n        if d == \"\
    One\" || d == \"Two\" || d == \"Three\" || d == \"Four\" ||\n            d ==\
    \ \"Five\" || d == \"Six\" || d == \"Seven\" || d == \"Eight\" || d == \"Nine\"\
    \ {\n            continue;\n        }\n        vec.push(String::from(d));\n  \
    \  }\n    vec\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit_name` in this scope\n  -->\
    \ /tmp/tmpc9cb8r0k.rs:20:22\n   |\n20 |             vec.push(by_digit_name(n));\n\
    \   |                      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut i = 0;\n\n    let mut str =\
    \ String::new();\n    while i < arr.len() {\n        if arr[i] > 0 {\n       \
    \     str.push_str(&NAMES[arr[i] - 1]);\n        } else {\n            if let\
    \ Some(j) = (&arr[i..]).find(|&x| x > 0 && x <= 9) {\n                str.push_str(&NAMES[j\
    \ as usize - 1]);\n            }\n        }\n\n        i += 1;\n    }\n\n    str.into_owned()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `NAMES` in this scope\n  --> /tmp/tmp6cnwqxr4.rs:23:27\n\
    \   |\n23 |             str.push_str(&NAMES[arr[i] - 1]);\n   |              \
    \             ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `NAMES` in this scope\n  --> /tmp/tmp6cnwqxr4.rs:26:31\n   |\n26 |         \
    \        str.push_str(&NAMES[j as usize - 1]);\n   |                         \
    \      ^^^^^ not found in this scope\n\nerror[E0599]: no method named `find` found\
    \ for reference `&[isize]` in the current scope\n  --> /tmp/tmp6cnwqxr4.rs:25:42\n\
    \   |\n25 |             if let Some(j) = (&arr[i..]).find(|&x| x > 0 && x <= 9)\
    \ {\n   |                                          ^^^^ method not found in `&[isize]`\n\
    \nerror[E0599]: no method named `into_owned` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6cnwqxr4.rs:33:9\n   |\n33 |     str.into_owned()\n\
    \   |         ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        _ => arr.iter()\n            .enumerate()\n   \
    \         .filter(|(idx, _)| idx <= 9)\n            .map(|(idx, num)| format!(\"\
    {}{}\", num, idx % 10))\n            .collect::<Vec<_>>()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9suwjmm.rs:18:39\n   |\n\
    18 |             .filter(|(idx, _)| idx <= 9)\n   |                          \
    \             ^\n   |                                       |\n   |          \
    \                             expected `&usize`, found integer\n   |         \
    \                              help: consider borrowing here: `&9`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    use std::cmp::Ordering;\n\
    \n    let mut by_length: Vec<String> = vec![];\n\n    if arr.len() > 0 {\n   \
    \     let mut reversed_arr = arr.rev();\n\n        for n in reversed_arr {\n \
    \           by_length.push(by_lengths[n % 10].clone());\n        }\n\n       \
    \ let mut reversed_by_length = by_length.rev();\n        reversed_by_length.sort_by(|a,\
    \ b| Ordering::<isize>().cmp(&a, &b));\n        reversed_by_length.iter().for_each(|&x|\
    \ by_length.push(x.clone()));\n    }\n\n    by_length\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `by_lengths` in this scope\n  --> /tmp/tmpprarz6gt.rs:22:28\n\
    \   |\n22 |             by_length.push(by_lengths[n % 10].clone());\n   |    \
    \                        ^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `by_length`\n\nerror[E0423]: expected function, tuple struct or tuple\
    \ variant, found enum `Ordering`\n  --> /tmp/tmpprarz6gt.rs:26:43\n   |\n26 |\
    \         reversed_by_length.sort_by(|a, b| Ordering::<isize>().cmp(&a, &b));\n\
    \   |                                           ^^^^^^^^^^^^^^^^^\n   |\n   =\
    \ help: the enum has no tuple variants to construct\n   = help: you might have\
    \ meant to construct one of the enum's non-tuple variants\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmpprarz6gt.rs:19:36\n    |\n19  |         \
    \  let mut reversed_arr = arr.rev();\n    |                                  \
    \    ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<String>`\
    \ is not an iterator\n   --> /tmp/tmpprarz6gt.rs:25:48\n    |\n25  |         \
    \  let mut reversed_by_length = by_length.rev();\n    |                      \
    \                            ^^^ `Vec<String>` is not an iterator\n    |\n   \
    \ = note: the following trait bounds were not satisfied:\n            `Vec<String>:\
    \ Iterator`\n            which is required by `&mut Vec<String>: Iterator`\n \
    \           `[String]: Iterator`\n            which is required by `&mut [String]:\
    \ Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0423, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976649
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    arr.sort_by_key(|&i| i as isize);\n\n    for i in arr.iter() {\n\
    \        if i > 9 {\n            result.push(by_digit_name(i as usize));\n   \
    \     } else {\n            result.push(by_digit_name(i));\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit_name` in this scope\n  -->\
    \ /tmp/tmpmam72fs2.rs:19:25\n   |\n19 |             result.push(by_digit_name(i\
    \ as usize));\n   |                         ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `by_digit_name` in this scope\n  --> /tmp/tmpmam72fs2.rs:21:25\n\
    \   |\n21 |             result.push(by_digit_name(i));\n   |                 \
    \        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmam72fs2.rs:18:16\n   |\n18 |         if i > 9 {\n   |        \
    \        ^\n   |                |\n   |                expected `&isize`, found\
    \ integer\n   |                help: consider borrowing here: `&9`\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpmam72fs2.rs:19:39\n  \
    \ |\n19 |             result.push(by_digit_name(i as usize));\n   |          \
    \                             -^^^^^^^^^\n   |                               \
    \        |\n   |                                       cannot cast `&isize` as\
    \ `usize`\n   |                                       help: dereference the expression:\
    \ `*i`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut strings = vec![];\n    let mut\
    \ digits = String::new();\n    let mut min_value = 1;\n    let mut max_value =\
    \ 9;\n    let mut strings_len = arr.len();\n    while strings_len > 1 {\n    \
    \    min_value = min_value as isize + (arr.len() - strings_len) as isize;\n  \
    \      max_value = max_value as isize + (strings_len - 1) as isize;\n        strings_len\
    \ -= 1;\n    }\n    let mut first = true;\n    for value in arr.iter().rev() {\n\
    \        if value == min_value || value == max_value {\n            if first {\n\
    \                strings.push(String::from(\"One\"));\n                first =\
    \ false;\n            } else {\n                strings.push(String::from(\"Nine\"\
    ));\n                strings.push(String::from(\"One\"));\n            }\n   \
    \     } else {\n            digits.push((value as isize as char).to_string());\n\
    \        }\n    }\n    strings.push(digits);\n    strings\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpueydjdkb.rs:29:18\n\
    \   |\n29 |         if value == min_value || value == max_value {\n   |      \
    \            ^^ no implementation for `&isize == isize`\n   |\n   = help: the\
    \ trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmpueydjdkb.rs:29:40\n   |\n\
    29 |         if value == min_value || value == max_value {\n   |             \
    \                           ^^ no implementation for `&isize == isize`\n   |\n\
    \   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpueydjdkb.rs:38:25\n\
    \   |\n38 |             digits.push((value as isize as char).to_string());\n \
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n\
    \  --> /tmp/tmpueydjdkb.rs:38:26\n   |\n38 |             digits.push((value as\
    \ isize as char).to_string());\n   |                          -----^^^^^^^^^\n\
    \   |                          |\n   |                          cannot cast `&isize`\
    \ as `isize`\n   |                          help: dereference the expression:\
    \ `*value`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  -->\
    \ /tmp/tmpueydjdkb.rs:38:25\n   |\n38 |             digits.push((value as isize\
    \ as char).to_string());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpueydjdkb.rs:38:25\n   |\n38 |             digits.push((value as isize\
    \ as"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else if arr.len() == 1 {\n        vec![String::from(\"\
    One\")]\n    } else {\n        let mut r = vec![];\n        for i in arr.iter().rev()\
    \ {\n            if i < 1 || i > 9 {\n                continue;\n            }\n\
    \            if i == 1 {\n                r.push(String::from(\"One\"));\n   \
    \         } else if i == 2 {\n                r.push(String::from(\"Two\"));\n\
    \            } else if i == 3 {\n                r.push(String::from(\"Three\"\
    ));\n            } else if i == 4 {\n                r.push(String::from(\"Four\"\
    ));\n            } else if i == 5 {\n                r.push(String::from(\"Five\"\
    ));\n            } else if i == 6 {\n                r.push(String::from(\"Six\"\
    ));\n            } else if i == 7 {\n                r.push(String::from(\"Seven\"\
    ));\n            } else if i == 8 {\n                r.push(String::from(\"Eight\"\
    ));\n            } else if i == 9 {\n                r.push(String::from(\"Nine\"\
    ));\n            } else {\n                continue;\n            }\n        }\n\
    \        r\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwugmek4x.rs:21:20\n   |\n\
    21 |             if i < 1 || i > 9 {\n   |                    ^\n   |        \
    \            |\n   |                    expected `&isize`, found integer\n   |\
    \                    help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwugmek4x.rs:21:29\n   |\n21 |             if i < 1 || i\
    \ > 9 {\n   |                             ^\n   |                            \
    \ |\n   |                             expected `&isize`, found integer\n   | \
    \                            help: consider borrowing here: `&9`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmpwugmek4x.rs:24:18\n \
    \  |\n24 |             if i == 1 {\n   |                  ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpwugmek4x.rs:26:25\n   |\n26 |             }\
    \ else if i == 2 {\n   |                         ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmpwugmek4x.rs:28:25\n   |\n28 |             } else if i == 3 {\n\
    \   |                         ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut nums: Vec<String> = vec![];\n\
    \n        let mut low = 0;\n        let mut high = arr.len() - 1;\n        let\
    \ mut mid = 0;\n\n        while low <= high {\n            mid = (low + high)\
    \ / 2;\n            let low = arr[mid];\n            let high = arr[mid];\n\n\
    \            if low <= 9 && high > 9 {\n                nums.push(String::from(&arr[mid]\
    \ as char));\n            } else {\n                nums.push(String::from(&arr[mid]\
    \ as char).rev());\n            }\n        }\n\n        nums\n    }\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpx57u9inw.rs:31:59\n\
    \    |\n31  |                   nums.push(String::from(&arr[mid] as char).rev());\n\
    \    |                                                             ^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0606]: casting\
    \ `&isize` as `char` is invalid\n  --> /tmp/tmpx57u9inw.rs:29:40\n   |\n29 | \
    \                nums.push(String::from(&arr[mid] as char));\n   |           \
    \                             ---------^^^^^^^^\n   |                        \
    \                |\n   |                                        cannot cast `&isize`\
    \ as `char`\n   |                                        help: dereference the\
    \ expression: `*&arr[mid]`\n\nerror[E0606]: casting `&isize` as `char` is invalid\n\
    \  --> /tmp/tmpx57u9inw.rs:31:40\n   |\n31 |                 nums.push(String::from(&arr[mid]\
    \ as char).rev());\n   |                                        ---------^^^^^^^^\n\
    \   |                                        |\n   |                         \
    \               cannot cast `&isize` as `char`\n   |                         \
    \               help: dereference the expression: `*&arr[mid]`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0606.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().filter(|&x|\
    \ x > 0 && x <= 9).cloned().collect::<Vec<_>>();\n    let mut reversed = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut counter = 0;\n    for x in reversed {\n     \
    \   reversed[counter] = &arr[counter];\n        counter += 1;\n        i += 1;\n\
    \    }\n    let mut arr2 = arr.into_iter().cloned().collect::<Vec<_>>();\n   \
    \ arr2.swap(arr.len(), 0);\n    for x in arr2 {\n        arr2[counter] = &arr[i];\n\
    \        i += 1;\n        counter += 1;\n    }\n    arr2.iter().map(|x| String::from(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Filter<std::vec::IntoIter<isize>,\
    \ [closure@/tmp/tmpqm60hlrl.rs:17:42: 17:62]> as Iterator>::Item == &_`\n    -->\
    \ /tmp/tmpqm60hlrl.rs:17:64\n     |\n17   |     let mut arr = arr.into_iter().filter(|&x|\
    \ x > 0 && x <= 9).cloned().collect::<Vec<_>>();\n     |                     \
    \                                           ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Filter<std::vec::IntoIter<isize>, [closure@/tmp/tmpqm60hlrl.rs:17:42:\
    \ 17:62]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpqm60hlrl.rs:17:73\n\
    \   |\n17 |        let mut arr = arr.into_iter().filter(|&x| x > 0 && x <= 9).cloned().collect::<Vec<_>>();\n\
    \   |                                                                        \
    \    ^^^^^^^ method cannot be called on `Cloned<Filter<std::vec::IntoIter<isize>,\
    \ [closure@/tmp/tmpqm60hlrl.rs:17:42: 17:62]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Filter<std::vec::IntoIter<isize>,\
    \ [closure@/tmp/tmpqm60hlrl.rs:17:42: 17:62]> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Filter<std::vec::IntoIter<isize>, [closure@/tmp/tmpqm60hlrl.rs:17:42:\
    \ 17:62]>>: Iterator`\n           `Cloned<Filter<std::vec::IntoIter<isize>, [closure@/tmp/tmpqm60hlrl.rs:17:42:\
    \ 17:62]>>: Iterator`\n           which is required by `&mut Cloned<Filter<std::vec::IntoIter<isize>,\
    \ [closure@/tmp/tmpqm60hlrl.rs:17:42: 17:62]>>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.into_iter().map(|x|\
    \ if x == -2 {} else { if x < 10 { String::from(\"One\") } else { String::from(\"\
    Two\") } }).collect::<Vec<String>>();\n    arr.sort_by(|a, b| a.len() < b.len());\n\
    \    let mut i = arr.iter().position(|x| x >= 10 && x < 20);\n    while i >= 0\
    \ {\n        arr[i] += arr.remove(i).unwrap();\n        i += 1;\n    }\n    arr\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp4bwxp2_u.rs:14:64\n\
    \   |\n14 | ... if x == -2 {} else { if x < 10 { String::from(\"One\") } else\
    \ { String::from(\"Two\") } }).collect::<Vec<String>>();\n   |               \
    \ --        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `()`, found struct `String`\n   |                |\n   |                expected\
    \ because of this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4bwxp2_u.rs:15:24\n\
    \   |\n15 |     arr.sort_by(|a, b| a.len() < b.len());\n   |                 \
    \       ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4bwxp2_u.rs:16:46\n   |\n16 |  \
    \   let mut i = arr.iter().position(|x| x >= 10 && x < 20);\n   |            \
    \                                  ^^ expected `&String`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4bwxp2_u.rs:16:56\n   |\n16 |     let mut i\
    \ = arr.iter().position(|x| x >= 10 && x < 20);\n   |                        \
    \                                ^^ expected `&String`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4bwxp2_u.rs:17:16\n   |\n17 |     while i >=\
    \ 0 {\n   |                ^ expected enum `Option`, found integer\n   |\n   =\
    \ note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n17 |     while i >= Some(0)\
    \ {\n   |                +++++ +\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `Option<usize>`\n  --> /tmp/tmp4bwxp2_u.rs:18:9\n   |\n18 |     \
    \    arr[i] += arr.remove(i).unwrap();\n   |         ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4bwxp2_u.rs:18:30\n   |\n18 |         arr[i] += arr.remove(i).unwrap();\n\
    \   |                              ^ expected `usize`, found enum `Option`\n \
    \  |\n   = note: exp"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut min = std::u16::MAX as u16;\n\
    \    let mut max = std::u16::MIN as u16;\n\n    for i in arr {\n        match\
    \ i {\n            i if i >= min && i <= max => {\n                min = i;\n\
    \            }\n            i if i <= min && i >= max => {\n                max\
    \ = i;\n            }\n            _ => {}\n        }\n    }\n\n    arr.iter().map(|i|\
    \ {\n        let mut x = i;\n        if x > min && x < max {\n            std::u16::try_from(x).unwrap().to_string()\n\
    \        } else {\n            String::from(\"Other\")\n        }\n    }).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `try_from` in module `std::u16`\n  -->\
    \ /tmp/tmpvmh4ce5n.rs:36:23\n   |\n36 |             std::u16::try_from(x).unwrap().to_string()\n\
    \   |                       ^^^^^^^^ not found in `std::u16`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvmh4ce5n.rs:23:23\n   |\n23 |             i\
    \ if i >= min && i <= max => {\n   |                       ^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |             i if i >= min.try_into().unwrap()\
    \ && i <= max => {\n   |                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvmh4ce5n.rs:23:35\n   |\n23 |             i\
    \ if i >= min && i <= max => {\n   |                                   ^^^ expected\
    \ `isize`, found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |             i if i >= min\
    \ && i <= max.try_into().unwrap() => {\n   |                                 \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmh4ce5n.rs:24:23\n\
    \   |\n18 |     let mut min = std::u16::MAX as u16;\n   |                   --------------------\
    \ expected due to this value\n...\n24 |                 min = i;\n   |       \
    \                ^ expected `u16`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvmh4ce5n.rs:26:23\n   |\n26 |             i if i <= min && i >=\
    \ max => {\n   |                       ^^^ expected `isize`, found `u16`\n   |\n\
    help: you can convert a `u16` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |             i if i <= min.try_into().unwrap() && i >= max =>\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvmh4ce5n.rs:26:35\n   |\n26 |             i if i <= min\
    \ && i >= max => {\n   |                                   ^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n26 |             i if i <= min && i >=\
    \ max.tr"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().take(9);\n\
    \    let mut names: Vec<String> = vec![String::from(\"One\"),String::from(\"Two\"\
    ),String::from(\"Three\"),String::from(\"Four\"),String::from(\"Five\"),String::from(\"\
    Six\"),String::from(\"Seven\"),String::from(\"Eight\"),String::from(\"Nine\")];\n\
    \    for (i, &d) in arr.iter().enumerate() {\n        let name = match d {\n \
    \           1 => String::from(\"One\"),\n            2 => String::from(\"Two\"\
    ),\n            3 => String::from(\"Three\"),\n            4 => String::from(\"\
    Four\"),\n            5 => String::from(\"Five\"),\n            6 => String::from(\"\
    Six\"),\n            7 => String::from(\"Seven\"),\n            8 => String::from(\"\
    Eight\"),\n            9 => String::from(\"Nine\"),\n            _ => panic!(\"\
    Invalid number {} - should be between 1 and 9 inclusive\", d),\n        };\n \
    \       arr.swap(i, names);\n        names.push(name);\n    }\n    arr.iter().map(|d|\
    \ d.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmp4xlld2in.rs:19:24\n   |\n19 |     for (i,\
    \ &d) in arr.iter().enumerate() {\n   |                        ^^^^ private field,\
    \ not a method\n\nerror[E0599]: no method named `swap` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmp4xlld2in.rs:32:13\n   |\n32 |         arr.swap(i,\
    \ names);\n   |             ^^^^ method not found in `std::iter::Take<std::vec::IntoIter<isize>>`\n\
    \nerror[E0599]: no method named `iter` found for struct `std::iter::Take` in the\
    \ current scope\n  --> /tmp/tmp4xlld2in.rs:35:9\n   |\n35 |     arr.iter().map(|d|\
    \ d.to_string()).collect()\n   |         ^^^^ private field, not a method\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() == 1 {\n        return vec![\"\
    One\"];\n    }\n    let mut arr = arr.to_owned();\n    let mut result = vec![\"\
    One\"];\n    let mut count = 1;\n    while let Some(i) = arr.iter().position(|x|\
    \ x >= 1 && x <= 9) {\n        result.push(String::from(\"One\"));\n        if\
    \ count == 0 {\n            result.push(String::from(\"Two\"));\n        }\n \
    \       if count == 1 {\n            result.push(String::from(\"Three\"));\n \
    \       }\n        if count == 2 {\n            result.push(String::from(\"Four\"\
    ));\n        }\n        if count == 3 {\n            result.push(String::from(\"\
    Five\"));\n        }\n        if count == 4 {\n            result.push(String::from(\"\
    Six\"));\n        }\n        if count == 5 {\n            result.push(String::from(\"\
    Seven\"));\n        }\n        if count == 6 {\n            result.push(String::from(\"\
    Eight\"));\n        }\n        if count == 7 {\n            result.push(String::from(\"\
    Nine\"));\n        }\n        count += 1;\n        if i == arr.len() - 1 {\n \
    \           break;\n        }\n        arr.swap(i, arr.len() - i - 1);\n    }\n\
    \    if count == 9 {\n        result.push(String::from(\"Nine\"));\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpov6nkkgo.rs:18:21\n   |\n\
    18 |         return vec![\"One\"];\n   |                     ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                     |\n   |\
    \                     expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpov6nkkgo.rs:23:54\n   |\n23 |     while let\
    \ Some(i) = arr.iter().position(|x| x >= 1 && x <= 9) {\n   |                \
    \                                      ^\n   |                               \
    \                       |\n   |                                              \
    \        expected `&isize`, found integer\n   |                              \
    \                        help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpov6nkkgo.rs:23:64\n   |\n23 |     while let\
    \ Some(i) = arr.iter().position(|x| x >= 1 && x <= 9) {\n   |                \
    \                                                ^\n   |                     \
    \                                           |\n   |                          \
    \                                      expected `&isize`, found integer\n   |\
    \                                                                help: consider\
    \ borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov6nkkgo.rs:24:21\n\
    \   |\n24 |         result.push(String::from(\"One\"));\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^\n   |                     |\n   |                  \
    \   expected `&str`, found struct `String`\n   |                     help: consider\
    \ borrowing here: `&String::from(\"One\")`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpov6nkkgo.rs:26:25\n   |\n26 |             result.push(String::from(\"\
    Two\"));\n   |                         ^^^^^^^^^^^^^^^^^^^\n   |             \
    \            |\n   |                         expected `&str`, found struct `String`\n\
    \   |                         help: consider borrowing here: `&String::from(\"\
    Two\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov6nkkgo.rs:29:25\n \
    \  |\n29 |             result.push(String::from(\"Three\"));\n   |           \
    \              ^^^^^"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut counter = HashMap::new();\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        counter.insert(i, 0);\n\
    \        i += 1;\n    }\n\n    let mut result = Vec::new();\n\n    for elem in\
    \ arr {\n        if elem == 1 {\n            result.push(String::from(\"One\"\
    ));\n        } else if elem == 2 {\n            result.push(String::from(\"Two\"\
    ));\n        } else if elem == 3 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if elem == 4 {\n            result.push(String::from(\"Four\"\
    ));\n        } else if elem == 5 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if elem == 6 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if elem == 7 {\n            result.push(String::from(\"Seven\"\
    ));\n        } else if elem == 8 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if elem == 9 {\n            result.push(String::from(\"Nine\"\
    ));\n        } else {\n            continue;\n        }\n\n        let mut tmp\
    \ = 0;\n        let mut counter = counter.clone();\n        let mut i = 0;\n \
    \       while i < result.len() {\n            let mut c = counter.clone();\n \
    \           while i < result.len() {\n                if tmp < c[i].1 {\n    \
    \                tmp += 1;\n                } else {\n                    i +=\
    \ 1;\n                    break;\n                }\n            }\n         \
    \   i += 1;\n        }\n        if counter.iter().any(|&(_, val)| val > 0) {\n\
    \            continue;\n        }\n\n        let mut i = 0;\n        while i <\
    \ result.len() {\n            let mut c = counter.clone();\n            while\
    \ i < result.len() {\n                if c[i] >= result.len() {\n            \
    \        break;\n                }\n                if c[i] - 1 < i {\n      \
    \              c[i] -= 1;\n                    break;\n                }\n   \
    \             i += 1;\n            }\n        }\n\n        for entry in counter.iter()\
    \ {\n            if entry.1 < entry.0 {\n                result.insert(entry.0\
    \ - 1, String::from(\n                    &result[entry.0 - 1].to_string()\n \
    \               ));\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk_1yd8vf.rs:18:23\n   |\n18 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut counter =\
    \ 1isize;\n    let mut result: Vec<String> = vec![];\n    for i in arr {\n   \
    \     if i <= 9 {\n            result.push(format!(\"{}\", i));\n            counter\
    \ += i;\n        } else if i > 0isize && counter != 1isize {\n            result.push((counter\
    \ - 1) as String);\n            counter = i;\n        }\n    }\n    if counter\
    \ > 0isize {\n        result.push(format!(\"{}\", counter));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0605]: non-primitive cast: `isize` as `String`\n  --> /tmp/tmpgsd2uqi6.rs:21:25\n\
    \   |\n21 |             result.push((counter - 1) as String);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to\
    \ convert between primitive types or to coerce to a specific trait object\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0605`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut copy = arr.clone();\n    copy.sort_unstable();\n\
    \    copy.iter_mut().rev().for_each(|&x| {\n        match x {\n            0 =>\
    \ {},\n            1 => {},\n            2 => {},\n            3 => {},\n    \
    \        4 => {},\n            5 => {},\n            6 => {},\n            7 =>\
    \ {},\n            8 => {},\n            9 => {},\n            _ => {}\n     \
    \   }\n    });\n    let mut res = Vec::new();\n    let mut digits = vec![String::from(\"\
    One\"), String::from(\"Two\"), String::from(\"Three\"), String::from(\"Four\"\
    ), String::from(\"Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"\
    Eight\"), String::from(\"Nine\")];\n    for digit in copy.iter() {\n        if\
    \ digit < 10 {\n            res.push_back(digits[digit as usize]);\n        }\
    \ else {\n            res.push_back(stringify!(digit % 10));\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphcicsbjo.rs:19:37\n   |\n\
    19 |     copy.iter_mut().rev().for_each(|&x| {\n   |                         \
    \            ^--\n   |                                     ||\n   |          \
    \                           |expected due to this\n   |                      \
    \               types differ in mutability\n   |                             \
    \        help: did you mean `x`: `&&mut isize`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphcicsbjo.rs:37:20\n   |\n37 |         if digit\
    \ < 10 {\n   |                    ^^\n   |                    |\n   |        \
    \            expected `&isize`, found integer\n   |                    help: consider\
    \ borrowing here: `&10`\n\nerror[E0599]: no method named `push_back` found for\
    \ struct `Vec<_>` in the current scope\n  --> /tmp/tmphcicsbjo.rs:38:17\n   |\n\
    38 |             res.push_back(digits[digit as usize]);\n   |                \
    \ ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmphcicsbjo.rs:40:17\n\
    \   |\n40 |             res.push_back(stringify!(digit % 10));\n   |         \
    \        ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0606]: casting `&isize`\
    \ as `usize` is invalid\n  --> /tmp/tmphcicsbjo.rs:38:34\n   |\n38 |         \
    \    res.push_back(digits[digit as usize]);\n   |                            \
    \      -----^^^^^^^^^\n   |                                  |\n   |         \
    \                         cannot cast `&isize` as `usize`\n   |              \
    \                    help: dereference the expression: `*digit`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    arr.sort();\n    arr.iter().rev().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_w47j47m.rs:18:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    18 |     arr.iter().rev().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut n = arr.len();\n    let mut reversed = false;\n    while n > 0 {\n\
    \        if n % 10 == 0 {\n            arr.swap(0, n - 1);\n            reversed\
    \ = true;\n        }\n        n /= 10;\n    }\n    let mut result = vec![];\n\
    \    if reversed {\n        for &d in arr {\n            result.push(by_digit(d).cloned());\n\
    \        }\n    } else {\n        for &d in arr {\n            result.push(by_digit(d).cloned());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp3xj2ky69.rs:30:25\n\
    \   |\n30 |             result.push(by_digit(d).cloned());\n   |             \
    \            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_digit` in this scope\n  --> /tmp/tmp3xj2ky69.rs:34:25\n   |\n34 |      \
    \       result.push(by_digit(d).cloned());\n   |                         ^^^^^^^^\
    \ not found in this scope\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp3xj2ky69.rs:17:35\n     |\n17   |\
    \     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n     |    \
    \                               ^^^^^^ expected reference, found `isize`\n   \
    \  |\n     = note: expected reference `&_`\n                     found type `isize`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp3xj2ky69.rs:17:44\n   |\n17 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result: Vec<String> = vec![];\n\
    \    let mut digit_iter = arr.iter().filter_map(|i| if i < 10 {\n        Some(format!(\"\
    {}\", i))\n    } else if i < 100 {\n        Some(format!(\"{}{}\", i / 10, i %\
    \ 10))\n    } else {\n        None\n    });\n\n    for d in digit_iter {\n   \
    \     let mut digits = vec![String::from(\"One\")];\n        while d > 9 {\n \
    \           digits = vec![\"One\"].into_iter().chain(digits.iter()).collect();\n\
    \            d /= 10;\n        }\n        result.append(digits.iter().cloned());\n\
    \    }\n\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg0xzyl0a.rs:19:59\n   |\n\
    19 |     let mut digit_iter = arr.iter().filter_map(|i| if i < 10 {\n   |    \
    \                                                       ^^\n   |             \
    \                                              |\n   |                       \
    \                                    expected `&isize`, found integer\n   |  \
    \                                                         help: consider borrowing\
    \ here: `&10`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg0xzyl0a.rs:21:19\n\
    \   |\n21 |     } else if i < 100 {\n   |                   ^^^\n   |        \
    \           |\n   |                   expected `&isize`, found integer\n   | \
    \                  help: consider borrowing here: `&100`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg0xzyl0a.rs:29:19\n   |\n29 |         while d > 9 {\n \
    \  |                   ^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ integer\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_, String>\
    \ as IntoIterator>::Item == &str`\n   --> /tmp/tmpg0xzyl0a.rs:30:46\n    |\n30\
    \  |             digits = vec![\"One\"].into_iter().chain(digits.iter()).collect();\n\
    \    |                                              ^^^^^ expected `str`, found\
    \ struct `String`\n    |\n    = note: expected reference `&str`\n            \
    \   found reference `&String`\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0599]: the method `collect` exists for struct `std::iter::Chain<std::vec::IntoIter<&str>,\
    \ std::slice::Iter<'_, String>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpg0xzyl0a.rs:30:67\n   |\n30 |               digits = vec![\"One\"].into_iter().chain(digits.iter()).collect();\n\
    \   |                                                                     ^^^^^^^\
    \ method cannot be called on `std::iter::Chain<std::vec::IntoIter<&str>, std::slice::Iter<'_,\
    \ String>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<std::slice::"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut sorted_arr: Vec<isize> = arr.clone();\n\
    \    sorted_arr.sort_unstable();\n\n    let mut numbers = sorted_arr.clone();\n\
    \    let mut to_return = sorted_arr.clone();\n\n    for number in numbers {\n\
    \        if number <= 9 { to_return.remove(0); }\n        else {\n           \
    \ let index = match number {\n                1 => 0,\n                2 => 1,\n\
    \                3 => 2,\n                4 => 3,\n                5 => 4,\n \
    \               6 => 5,\n                7 => 6,\n                8 => 7,\n  \
    \              9 => 8,\n                _ => continue,\n            };\n\n   \
    \         to_return[index] = strings::One.into();\n        }\n    }\n\n    to_return\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `strings`\n\
    \  --> /tmp/tmp6acd7h7i.rs:40:32\n   |\n40 |             to_return[index] = strings::One.into();\n\
    \   |                                ^^^^^^^ use of undeclared crate or module\
    \ `strings`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6acd7h7i.rs:44:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n44 |     to_return\n   |     ^^^^^^^^^ expected struct `String`, found `isize`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut vec = Vec::new();\n    let mut\
    \ reversed = arr\n        .iter()\n        .cloned()\n        .filter(|&x| x >\
    \ 0 && x < 10)\n        .cloned()\n        .rev();\n    let mut digit = String::from(\"\
    One\");\n\n    while !reversed.is_empty() {\n        if reversed.len() == 1 {\n\
    \            break;\n        }\n\n        let index = &reversed[0];\n        let\
    \ mut next = digit;\n\n        let (low, high) = reversed.split_at_mut(2);\n\n\
    \        if index < 10 {\n            *next = String::from(&format!(\"{}\", index));\n\
    \            reversed.pop();\n            vec.push(next);\n        }\n\n     \
    \   *next = String::from(&format!(\"{}\", high[0]));\n        digit = &low[0];\n\
    \        reversed.pop();\n\n        if index < 10 {\n            vec.push(next);\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, isize> as\
    \ Iterator>::Item == &&_`\n  --> /tmp/tmp3ihrnr0b.rs:23:10\n   |\n23 |       \
    \  .cloned()\n   |          ^^^^^^ expected reference, found `isize`\n   |\n \
    \  = note: expected reference `&&_`\n              found reference `&isize`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n   = note: 1 redundant requirement hidden\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17:\
    \ 22:37]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmp3ihrnr0b.rs:23:10\n\
    \   |\n22 |         .filter(|&x| x > 0 && x < 10)\n   |                 --------------------\
    \ found signature of `for<'r> fn(&'r isize) -> _`\n23 |         .cloned()\n  \
    \ |          ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17: 22:37]>`\n\nerror[E0599]: the method\
    \ `rev` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmp3ihrnr0b.rs:22:17: 22:37]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp3ihrnr0b.rs:24:10\n   |\n24 |            .rev();\n\
    \   |             ^^^ method cannot be called on `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17: 22:37]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17:\
    \ 22:37]> as Iterator>::Item = &_`\n           which is required by `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17: 22:37]>>: Iterator`\n         \
    \  `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp3ihrnr0b.rs:22:17:\
    \ 22:37]>>: Iterator`\n           which is required by `&mut Cloned<Filter<Cloned<std::slice::"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 1;\n    result.push(String::from(\"One\"));\n    while i < 10 {\n      \
    \  if arr[0] < i {\n            result.push(String::from(\"One\"));\n        }\
    \ else {\n            result.push(String::from(format!(\"Two\", i)));\n      \
    \  }\n        i += 1;\n    }\n    result.push(String::from(\"Ten\"));\n    for\
    \ elt in arr {\n        if elt < 10 {\n            i += elt as isize - 1;\n  \
    \      } else {\n            i += 9 - elt as isize - 1;\n        }\n        result.push(String::from(format!(\"\
    Ten\", i)));\n    }\n    if arr.len() == 10 {\n        result.push(String::from(\"\
    Ten\"));\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmp9_s0fjet.rs:24:53\n   |\n24 |\
    \             result.push(String::from(format!(\"Two\", i)));\n   |          \
    \                                    -----  ^ argument never used\n   |      \
    \                                        |\n   |                             \
    \                 formatting specifier missing\n\nerror: argument never used\n\
    \  --> /tmp/tmp9_s0fjet.rs:35:49\n   |\n35 |         result.push(String::from(format!(\"\
    Ten\", i)));\n   |                                          -----  ^ argument\
    \ never used\n   |                                          |\n   |          \
    \                                formatting specifier missing\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut to_sort = arr;\n    to_sort.sort();\n\
    \n    to_sort.reverse();\n\n    to_sort.iter().map(|x| {\n        if x > 9 {\n\
    \            String::from(format!(\"{}\", x))\n        } else {\n            String::from(format!(\"\
    {}\", by_digit(x)?))\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp00w2mbs3.rs:27:40\n\
    \   |\n27 |             String::from(format!(\"{}\", by_digit(x)?))\n   |    \
    \                                    ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp00w2mbs3.rs:24:16\n   |\n24 |         if x >\
    \ 9 {\n   |                ^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&9`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n    if arr.len() == 1 {\n        vec![String::from(\"\
    One\")]\n    }\n    let mut n = arr.len();\n    let mut rev: Vec<isize> = vec![];\n\
    \    while n > 0 {\n        let m = n / 10;\n        let rem = n % 10;\n     \
    \   n -= m;\n        rev.push(rem);\n    }\n    rev.sort_unstable();\n    let\
    \ mut str: Vec<String> = vec![];\n    for (i, digit) in rev.iter().enumerate()\
    \ {\n        let name = stringify::int::from_str(digit).unwrap();\n        str.push(name.into());\n\
    \    }\n    str.into_iter().map(|s| s.to_string()).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `stringify`\n\
    \  --> /tmp/tmpo4fmh4nv.rs:31:20\n   |\n31 |         let name = stringify::int::from_str(digit).unwrap();\n\
    \   |                    ^^^^^^^^^ use of undeclared crate or module `stringify`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo4fmh4nv.rs:18:9\n   |\n17 | /\
    \     if arr.len() == 1 {\n18 | |         vec![String::from(\"One\")]\n   | |\
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `Vec`\n19 | |\
    \     }\n   | |_____- expected this to be `()`\n   |\n   = note: expected unit\
    \ type `()`\n                 found struct `Vec<String>`\n   = note: this error\
    \ originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\nhelp: consider using a semicolon here\n   |\n19 |     };\n \
    \  |      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4fmh4nv.rs:26:18\n\
    \   |\n26 |         rev.push(rem);\n   |                  ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |         rev.push(rem.try_into().unwrap());\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut len = arr.len();\n\
    \    if len > 0 && arr[len - 1] < 10 { len -= 1 }\n    let mut ret = vec![String::from(\"\
    One\")];\n    for i in 0..len - 1 {\n        if i == len - 2 || i % 2 == 0 {\n\
    \            let val = arr[len - 1 - i];\n            let idx = len - 1 - i;\n\
    \            let next = arr[idx];\n            ret.push(by_length(&[val, next]));\n\
    \        } else {\n            let val = arr[i];\n            ret.push(by_length(&[val]));\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfgvv_0j.rs:22:32\n   |\n\
    22 |             ret.push(by_length(&[val, next]));\n   |                    \
    \            ^^^^^^^^^^^^ expected struct `Vec`, found `&[isize; 2]`\n   |\n \
    \  = note: expected struct `Vec<isize>`\n           found reference `&[isize;\
    \ 2]`\nhelp: try using a conversion method\n   |\n22 |             ret.push(by_length((&[val,\
    \ next]).to_vec()));\n   |                                +            ++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptfgvv_0j.rs:22:22\n   |\n22 |\
    \             ret.push(by_length(&[val, next]));\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptfgvv_0j.rs:25:32\n   |\n25 |             ret.push(by_length(&[val]));\n\
    \   |                                ^^^^^^ expected struct `Vec`, found `&[isize;\
    \ 1]`\n   |\n   = note: expected struct `Vec<isize>`\n           found reference\
    \ `&[isize; 1]`\nhelp: try using a conversion method\n   |\n25 |             ret.push(by_length((&[val]).to_vec()));\n\
    \   |                                +      ++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptfgvv_0j.rs:25:22\n   |\n25 |             ret.push(by_length(&[val]));\n\
    \   |                      ^^^^^^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ans = Vec::with_capacity(arr.len());\n\
    \    let mut low = arr[0];\n    let mut high = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        if i <= 9 {\n            ans.push(String::from(format!(\"{}\", i)));\n\
    \        } else {\n            ans.push(String::from(format!(\"{}\", high)));\n\
    \            low = i;\n            high = i;\n        }\n    }\n    ans.push(String::from(format!(\"\
    {}\", low)));\n    ans\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpod0df9c0.rs:21:17\n   |\n\
    21 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpod0df9c0.rs:25:19\n\
    \   |\n18 |     let mut low = arr[0];\n   |                   ------ expected\
    \ due to this value\n...\n25 |             low = i;\n   |                   ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |             low = *i;\n   |                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpod0df9c0.rs:26:20\n   |\n19 |     let mut high = arr[0];\n\
    \   |                    ------ expected due to this value\n...\n26 |        \
    \     high = i;\n   |                    ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |             high =\
    \ *i;\n   |                    +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr_rev = arr.iter().cloned().rev();\n\
    \    let mut digits = String::new();\n    for i in arr_rev {\n        digits.push_str(&vec![\n\
    \            i % 10, i % 100,\n            i / 10, i / 100,\n        ]);\n   \
    \ }\n    digits.into_owned()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqrfp9d7w.rs:20:25\n   |\n\
    20 |           digits.push_str(&vec![\n   |  _________________________^\n21 |\
    \ |             i % 10, i % 100,\n22 | |             i / 10, i / 100,\n23 | |\
    \         ]);\n   | |_________^ expected `str`, found struct `Vec`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&Vec<isize>`\n\
    \nerror[E0599]: no method named `into_owned` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpqrfp9d7w.rs:25:12\n   |\n25 |     digits.into_owned()\n\
    \   |            ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut i = 0;\n    let mut result = vec![];\n\
    \    while i < arr.len() {\n        let value = arr[i];\n        let mut name\
    \ = String::from(\"One\");\n        if value == 9 {\n            name = \"Nine\"\
    ;\n        } else {\n            name = \"One\";\n        }\n        let mut j\
    \ = 1;\n        while j < 10 {\n            if value == j {\n                name\
    \ += String::from(\"Two\");\n            } else {\n                name += String::from(\"\
    Zero\");\n            }\n            j +=1;\n        }\n        result.push(name);\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdcqir3gp.rs:23:20\n   |\n\
    21 |         let mut name = String::from(\"One\");\n   |                     \
    \   ------------------- expected due to this value\n22 |         if value == 9\
    \ {\n23 |             name = \"Nine\";\n   |                    ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                    |\n \
    \  |                    expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdcqir3gp.rs:25:20\n   |\n21 |         let mut\
    \ name = String::from(\"One\");\n   |                        -------------------\
    \ expected due to this value\n...\n25 |             name = \"One\";\n   |    \
    \                ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdcqir3gp.rs:30:25\n\
    \   |\n30 |                 name += String::from(\"Two\");\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^\n   |                         |\n   |       \
    \                  expected `&str`, found struct `String`\n   |              \
    \           help: consider borrowing here: `&String::from(\"Two\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdcqir3gp.rs:32:25\n   |\n32 |              \
    \   name += String::from(\"Zero\");\n   |                         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&String::from(\"Zero\")`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rev: Vec<usize> = vec![1usize;\
    \ 10];\n\n    for i in arr.iter().rev() {\n        rev[i] = i;\n    }\n\n    rev.sort_unstable_by_key(|x|\
    \ x).into_iter().map(|x| {\n        let mut s: String;\n        match x {\n  \
    \          0 => s = \"Zero\".to_string(),\n            1 => \"One\".to_string(),\n\
    \            2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n\
    \            4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => {\n                let mut s = String::new();\n            \
    \    s.push_str(&names[x.to_usize()]);\n                s\n            }\n   \
    \     }\n    })\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpzfsppxgx.rs:39:29\n\
    \   |\n39 |                 s.push_str(&names[x.to_usize()]);\n   |          \
    \                   ^^^^^ not found in this scope\n\nerror[E0277]: the type `[usize]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmpzfsppxgx.rs:21:9\n   |\n21 |  \
    \       rev[i] = i;\n   |         ^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<usize>`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpzfsppxgx.rs:24:37\n\
    \   |\n24 |     rev.sort_unstable_by_key(|x| x).into_iter().map(|x| {\n   |  \
    \                                   ^^^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `(): IntoIterator`\n           `&(): Iterator`\n\
    \           which is required by `&(): IntoIterator`\n           `&mut (): Iterator`\n\
    \           which is required by `&mut (): IntoIterator`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpzfsppxgx.rs:28:18\n   |\n26 | /\
    \         match x {\n27 | |             0 => s = \"Zero\".to_string(),\n   | |\
    \                  ---------------------- this is found to be of type `()`\n28\
    \ | |             1 => \"One\".to_string(),\n   | |                  ^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n29 | |             2 => \"Two\".to_string(),\n\
    ...  |\n41 | |             }\n42 | |         }\n   | |_________- `match` arms\
    \ have incompatible types\n\nerror[E0599]: no method named `to_usize` found for\
    \ type `{integer}` in the current scope\n  --> /tmp/tmpzfsppxgx.rs:39:37\n   |\n\
    39 |                 s.push_str(&names[x.to_usize()]);\n   |                 \
    \                    ^^^^^^^^ method not found in `{integer}`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425, E05"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rev = arr.rev();\n    for (idx,\
    \ _) in rev.iter().enumerate() {\n        match idx {\n            0 | 1 | 2 |\
    \ 3 | 4 | 5 | 6 | 7 | 8 | 9 => rev.swap(idx, 9),\n            _ => (),\n     \
    \   }\n    }\n\n    rev.into_iter().map(|x| {\n        if x < 10 { \"One\".to_string()\
    \ } else if x < 20 { \"Two\".to_string() } else if x < 30 { \"Three\".to_string()\
    \ } else if x < 40 { \"Four\".to_string() } else if x < 50 { \"Five\".to_string()\
    \ } else if x < 60 { \"Six\".to_string() } else if x < 70 { \"Seven\".to_string()\
    \ } else if x < 80 { \"Eight\".to_string() } else if x < 90 { \"Nine\".to_string()\
    \ } else {\n            x\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp0jysffei.rs:18:23\n\
    \    |\n18  |       let mut rev = arr.rev();\n    |                         ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror[E0277]: can't\
    \ compare `String` with `{integer}`\n  --> /tmp/tmp0jysffei.rs:27:14\n   |\n27\
    \ | ...   if x < 10 { \"One\".to_string() } else if x < 20 { \"Two\".to_string()\
    \ } else if x < 30 { \"Three\".to_string() } else if x < 40 { \"Four\"...\n  \
    \ |            ^ no implementation for `String < {integer}` and `String > {integer}`\n\
    \   |\n   = help: the trait `PartialOrd<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          String\n             str\n\nerror[E0277]: can't compare `String` with\
    \ `{integer}`\n  --> /tmp/tmp0jysffei.rs:27:51\n   |\n27 | ...   if x < 10 { \"\
    One\".to_string() } else if x < 20 { \"Two\".to_string() } else if x < 30 { \"\
    Three\".to_string() } else if x < 40 { \"Four\"...\n   |                     \
    \                            ^ no implementation for `String < {integer}` and\
    \ `String > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             String\n             str\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmp0jysffei.rs:27:88\n \
    \  |\n27 | ...{ \"Two\".to_string() } else if x < 30 { \"Three\".to_string() }\
    \ else if x < 40 { \"Four\".to_string() } else if x < 50 { \"Five\".to_string()...\n\
    \   |                                    ^ no implementation for `String < {integer}`\
    \ and `String > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             String\n             str\n\ner"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    // Create a slice of numbers from 1\
    \ to 9 from arr and get the slice\n    let first_numbers = &arr[0..6];\n\n   \
    \ // Reverse the slice\n    let first_numbers_reverse = first_numbers.rev();\n\
    \n    // Get the digits from slice\n    let mut digits = first_numbers_reverse.collect::<Vec<usize>>();\n\
    \n    // For each digit in numbers, replace the number with its name from One,\
    \ Two,\n    // Three, Four, Five, Six, Seven, Eight, Nine\n    for i in first_numbers_reverse\
    \ {\n        digits[digits.iter().position(|&x| x == i).unwrap()] =\n        \
    \    String::from(&names::BYLENGTH[i % 10]);\n    }\n\n    // Rebuild the array\
    \ by adding the digits back to the first array and convert the result to Vec\n\
    \    arr[0..6].iter().cloned().chain(digits).collect().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `names`\n\
    \  --> /tmp/tmp_4_28bgz.rs:31:27\n   |\n31 |             String::from(&names::BYLENGTH[i\
    \ % 10]);\n   |                           ^^^^^ use of undeclared crate or module\
    \ `names`\n\nerror[E0599]: `&[isize]` is not an iterator\n  --> /tmp/tmp_4_28bgz.rs:22:47\n\
    \   |\n22 |     let first_numbers_reverse = first_numbers.rev();\n   |       \
    \                                        ^^^ `&[isize]` is not an iterator; try\
    \ calling `.iter()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&[isize]: Iterator`\n           which is required by `&mut &[isize]:\
    \ Iterator`\n           `[isize]: Iterator`\n           which is required by `&mut\
    \ [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr\n        .iter()\n\
    \        .windows(4)\n        .flat_map(|w| w.iter().map(|&i| i))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmplfn85xdn.rs:16:10\n   |\n16 |         .windows(4)\n\
    \   |          ^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() <= 0\
    \ {\n        return vec![];\n    }\n    let mut vec = Vec::new();\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        vec.push(&mut arr[i..].iter().map(|&n|\
    \ match n {\n            1 => \"One\",\n            2 => \"Two\",\n          \
    \  3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n \
    \           6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => \"Not a number\",\n        }).collect());\n\
    \        i += 1;\n    }\n    vec.reverse();\n    for x in vec.iter() {\n     \
    \   x.iter_mut().for_each(|&s| s.push_str(&\"0\".to_string()));\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&&mut B`\n  --> /tmp/tmpgheb693c.rs:31:12\n\
    \   |\n17 |     let mut vec = Vec::new();\n   |         ------- consider giving\
    \ `vec` the explicit type `&&mut B`, where the type parameter `B` is specified\n\
    ...\n31 |         }).collect());\n   |            ^^^^^^^ cannot infer type for\
    \ type parameter `B` declared on the associated function `collect`\n   |\n   =\
    \ note: type must be known at this point\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_unstable_by(|a,\
    \ b| b.cmp(a));\n    let mut result = Vec::new();\n    for i in arr {\n      \
    \  result.push(if i <= 9 { \"One\" } else { \"Nine\" });\n        result.push(String::from((i\
    \ % 10).to_string()));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgudo68f3.rs:18:21\n   |\n\
    18 |         result.push(String::from((i % 10).to_string()));\n   |          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                     |\n \
    \  |                     expected `&str`, found struct `String`\n   |        \
    \             help: consider borrowing here: `&String::from((i % 10).to_string())`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgudo68f3.rs:20:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n20 |\
    \     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n \
    \  = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut num: isize = 0;\n    let mut i:\
    \ isize = 0;\n    let mut first_digit = false;\n    let mut first_char: char;\n\
    \    let mut first_str: String;\n    let mut number: Vec<String> = Vec::new();\n\
    \    let mut digits: Vec<isize> = vec![1; 10];\n    while i < arr.len() {\n  \
    \      first_digit = false;\n        first_char = '\\0';\n        if arr[i] >\
    \ 9 {\n            i += 1;\n            first_digit = true;\n        } else {\n\
    \            first_char = &arr[i];\n        }\n        if num > 9 {\n        \
    \    number[num - 1].push_str(first_char.to_string());\n        } else {\n   \
    \         number[num].push_str(first_char.to_string());\n        }\n        if\
    \ first_digit {\n            digits.insert(0, 0);\n            i += 1;\n     \
    \   } else {\n            digits[num] += 1;\n        }\n        num += 1;\n  \
    \  }\n    for d in &digits {\n        if d == 0 {\n            number[d - 1].push_str(String::from(\"\
    Zero\"));\n        } else {\n            number[d - 1].push_str(String::from(\"\
    One\"));\n        }\n    }\n    let mut result = vec![String::from(\"Zero\");\
    \ 10];\n    for i in 0..10 {\n        let length = number[i].len();\n        if\
    \ length == 0 {\n            continue;\n        }\n        if length == 1 {\n\
    \            result.push(number[i]);\n            continue;\n        }\n     \
    \   if i == 0 && num % 2 == 0 {\n            continue;\n        }\n        let\
    \ first_num = if num % 2 == 0 {\n            number[i - 1].to_owned()\n      \
    \  } else {\n            number[i - 1]\n        };\n        if first_num.to_owned()\
    \ < first_char {\n            if length > 1 && (first_num.to_owned() - first_char).abs()\
    \ > 0 {\n                result.push(number[i]);\n            } else {\n     \
    \           result.push(String::from(\"One\"));\n            }\n        } else\
    \ {\n            result.push(number[i]);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkc7mk420.rs:24:15\n   |\n\
    24 |     while i < arr.len() {\n   |               ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |     while i < arr.len().try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkc7mk420.rs:27:12\n  \
    \ |\n27 |         if arr[i] > 9 {\n   |            ^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpkc7mk420.rs:31:27\n   |\n31 |            \
    \ first_char = &arr[i];\n   |                           ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkc7mk420.rs:31:26\n\
    \   |\n20 |     let mut first_char: char;\n   |                         ---- expected\
    \ due to this type\n...\n31 |             first_char = &arr[i];\n   |        \
    \                  ^^^^^^^ expected `char`, found reference\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\nhelp: consider removing\
    \ the borrow\n   |\n31 -             first_char = &arr[i];\n31 +             first_char\
    \ = arr[i];\n   | \n\nerror[E0277]: the type `[String]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpkc7mk420.rs:34:13\n   |\n34 |             number[num - 1].push_str(first_char.to_string());\n\
    \   |             ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[S"
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr_rev = arr\n        .iter()\n\
    \        .cloned()\n        .enumerate()\n        .map(|(_, i)| i as isize)\n\
    \        .collect::<Vec<_>>();\n    arr_rev.sort_unstable();\n    arr_rev.reverse();\n\
    \    arr_rev\n        .iter()\n        .map(|&x| String::from(format!(\"{}\",\
    \ x)))\n        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpdmw1py3_.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut vec: Vec<String>\
    \ = vec![];\n    let mut i = 0;\n    let mut length = 0;\n    while i < arr.len()\
    \ {\n        vec.push(String::from(by_length(arr.subvec(i).cloned()).pop()));\n\
    \        let length = vec.last().unwrap().len();\n        if length == 1 {\n \
    \           i += 1;\n        } else {\n            i += 2;\n        }\n    }\n\
    \    vec\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subvec` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpfjfo21il.rs:18:45\n   |\n18 |         vec.push(String::from(by_length(arr.subvec(i).cloned()).pop()));\n\
    \   |                                             ^^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0277]: the trait bound `String: From<Option<String>>` is not satisfied\n\
    \  --> /tmp/tmpfjfo21il.rs:18:31\n   |\n18 |         vec.push(String::from(by_length(arr.subvec(i).cloned()).pop()));\n\
    \   |                  ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the\
    \ trait `From<Option<String>>` is not implemented for `String`\n   |         \
    \         |\n   |                  required by a bound introduced by this call\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut min_value = 1;\n    let mut\
    \ max_value = 9;\n    let mut index = 0;\n    let mut names = vec![];\n    while\
    \ index < arr.len() {\n        let current_value = arr[index];\n        if current_value\
    \ < min_value || current_value > max_value {\n            break;\n        }\n\n\
    \        let current_name = string_from_value(current_value);\n        if current_value\
    \ == min_value {\n            index = index + 1\n        } else if current_value\
    \ == max_value {\n            index = index + 1\n        } else {\n          \
    \  let current_name = string_from_value(current_value);\n            let index\
    \ = index + 1\n            // move all values after this one\n            for\
    \ j in (index..arr.len()) {\n                let value = arr[j];\n           \
    \     if value == current_value {\n                    let current_name = string_from_value(value);\n\
    \                    break;\n                }\n            }\n\n            names.push(current_name);\n\
    \        }\n\n        min_value = min_value + 1;\n        max_value = max_value\
    \ - 1;\n    }\n    names\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp0swug8r5.rs:35:34\n\
    \   |\n35 |             let index = index + 1\n   |                          \
    \        ^ help: add `;` here\n36 |             // move all values after this\
    \ one\n37 |             for j in (index..arr.len()) {\n   |             --- unexpected\
    \ token\n\nerror[E0425]: cannot find function `string_from_value` in this scope\n\
    \  --> /tmp/tmp0swug8r5.rs:28:28\n   |\n28 |         let current_name = string_from_value(current_value);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `string_from_value` in this scope\n  --> /tmp/tmp0swug8r5.rs:34:32\n\
    \   |\n34 |             let current_name = string_from_value(current_value);\n\
    \   |                                ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `string_from_value` in this scope\n  -->\
    \ /tmp/tmp0swug8r5.rs:40:40\n   |\n40 |                     let current_name =\
    \ string_from_value(value);\n   |                                        ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nwarning: unnecessary parentheses around `for` iterator\
    \ expression\n  --> /tmp/tmp0swug8r5.rs:37:22\n   |\n37 |             for j in\
    \ (index..arr.len()) {\n   |                      ^                ^\n   |\n \
    \  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n37 -             for j in (index..arr.len()) {\n37 +             for j\
    \ in index..arr.len() {\n   | \n\nerror: aborting due to 4 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n\n    let\
    \ mut min_val = 1;\n    let mut max_val = 9 - 1;\n\n    let mut min_string: String\
    \ = \"\";\n    let mut max_string: String = \"\";\n\n    let mut digit_val = 0;\n\
    \    let mut digit_string: String = \"\";\n\n    // Get min and max val\n    for\
    \ item in arr.iter() {\n        let val = *item;\n        if val < min_val {\n\
    \            min_val = val;\n            min_string = String::from(to_str(val));\n\
    \        } else if val > max_val {\n            max_val = val;\n            max_string\
    \ = String::from(to_str(val));\n        }\n    }\n\n    // Loop through the vector,\
    \ get every number between min and max\n    for i in min_val..=max_val {\n   \
    \     if i != 0 {\n            let mut val = i;\n            let mut string =\
    \ \"\";\n\n            // Get digit and string val\n            while val > 0\
    \ {\n                digit_val = val % 10;\n                string += to_str(digit_val);\n\
    \                val /= 10;\n            }\n\n            // Get string and update\
    \ min and max\n            if string != \"\" {\n                if min_string.len()\
    \ > string.len() {\n                    min_string = string;\n               \
    \ } else if min_string != string {\n                    min_string = string;\n\
    \                }\n                if max_string.len() > string.len() {\n   \
    \                 max_string = string;\n                } else if max_string !=\
    \ string {\n                    max_string = string;\n                }\n    \
    \        }\n        }\n    }\n\n    for i in min_val..=max_val {\n        // Get\
    \ digit and string val\n        let mut val = i;\n        let mut string = \"\"\
    ;\n\n        while val > 0 {\n            digit_val = val % 10;\n            string\
    \ += to_str(digit_val);\n            val /= 10;\n        }\n\n        // Get string\
    \ and update min and max\n        if string != \"\" {\n            if min_string.len()\
    \ > string.len() {\n                min_string = string;\n            } else if\
    \ min_string != string {\n                min_string = string;\n            }\n\
    \            if max_string.len() > string.len() {\n                max_string\
    \ = string;\n            } else if max_string != string {\n                max_string\
    \ = string;\n            }\n        }\n    }\n\n    // Replace numbers between\
    \ min and max with their name from 0 to 9\n    for item in arr.iter() {\n    \
    \    let val = *item;\n        if val < min_val {\n            *item = min_string.clone();\n\
    \        } else if val > max_val {\n            *item = max_string.clone();\n\
    \        } else {\n            let mut digit_val = 0;\n            let mut digit_string:\
    \ String = \"\";\n\n            // Get digit and string val\n            while\
    \ val > 0 {\n                digit_val = val % 10;\n                digit_string\
    \ += \n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpi24e_sx4.rs:120:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n97  |     for\
    \ item in arr.iter() {\n    |                            - unclosed delimiter\n\
    ...\n103 |         } else {\n    |                - unclosed delimiter\n...\n\
    108 |             while val > 0 {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n111 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n120 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpi24e_sx4.rs:111:1\n    |\n111 | }\n  \
    \  | ^ expected expression\n\nerror[E0425]: cannot find function `to_str` in this\
    \ scope\n  --> /tmp/tmpi24e_sx4.rs:34:39\n   |\n34 |             min_string =\
    \ String::from(to_str(val));\n   |                                       ^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `to_str` in this\
    \ scope\n  --> /tmp/tmpi24e_sx4.rs:37:39\n   |\n37 |             max_string =\
    \ String::from(to_str(val));\n   |                                       ^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `to_str` in this\
    \ scope\n  --> /tmp/tmpi24e_sx4.rs:50:27\n   |\n50 |                 string +=\
    \ to_str(digit_val);\n   |                           ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `to_str` in this scope\n  --> /tmp/tmpi24e_sx4.rs:77:23\n\
    \   |\n77 |             string += to_str(digit_val);\n   |                   \
    \    ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi24e_sx4.rs:23:34\n\
    \   |\n23 |     let mut min_string: String = \"\";\n   |                     \
    \    ------   ^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                       |        |\n   |                         |        expected\
    \ struct `String`, found `&str`\n   |                         expected due to\
    \ this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi24e_sx4.rs:24:34\n  \
    \ |\n24 |     let mut max_string: String = \"\";"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut v = arr.to_vec();\n    let mut\
    \ reversed = v.clone();\n    \n    // Reverse the order\n    reversed.reverse();\n\
    \n    // Reverse the number\n    for &num in reversed {\n        // Find a number\
    \ between 1 and 9\n        let rev_num: isize = num % 10;\n        let tens =\
    \ num / 10;\n        // Convert \"1\" -> \"One\"\n        let one = String::from(\"\
    One\");\n        // Convert \"10\" -> \"Ten\"\n        let ten = String::from(\"\
    Ten\");\n        // Convert \"11\" -> \"Twelve\"\n        let twelve = String::from(\"\
    Twelve\");\n        // Convert \"12\" -> \"Twelve\"\n        let twenty = String::from(\"\
    Twenty\");\n        // Convert \"13\" -> \"Thirteen\"\n        let thirteen =\
    \ String::from(\"Thirteen\");\n        // Convert \"14\" -> \"Fourteen\"\n   \
    \     let fourteen = String::from(\"Fourteen\");\n        // Convert \"15\" ->\
    \ \"Fifteen\"\n        let fifteen = String::from(\"Fifteen\");\n        // Convert\
    \ \"16\" -> \"Sixteen\"\n        let sixteen = String::from(\"Sixteen\");\n  \
    \      // Convert \"17\" -> \"Seventeen\"\n        let seventeen = String::from(\"\
    Seventeen\");\n        // Convert \"18\" -> \"Eighteen\"\n        let eighteen\
    \ = String::from(\"Eighteen\");\n        // Convert \"19\" -> \"Nineteen\"\n \
    \       let nineteen = String::from(\"Nineteen\");\n        // Convert \"1\" ->\
    \ \"One\"\n        let one = String::from(\"One\");\n        // Convert \"10\"\
    \ -> \"Ten\"\n        let ten = String::from(\"Ten\");\n        // Convert \"\
    11\" -> \"Twelve\"\n        let twelve = String::from(\"Twelve\");\n        //\
    \ Convert \"12\" -> \"Twelve\"\n        let twenty = String::from(\"Twenty\");\n\
    \        // Convert \"13\" -> \"Thirteen\"\n        let thirteen = String::from(\"\
    Thirteen\");\n        // Convert \"14\" -> \"Fourteen\"\n        let fourteen\
    \ = String::from(\"Fourteen\");\n        // Convert \"15\" -> \"Fifteen\"\n  \
    \      let fifteen = String::from(\"Fifteen\");\n        // Convert \"16\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7dzznr00.rs:74:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n24 |     for &num\
    \ in reversed {\n   |                          - this delimiter might not be properly\
    \ closed...\n...\n65 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n74 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7dzznr00.rs:24:9\n\
    \   |\n24 |     for &num in reversed {\n   |         ^^^^    -------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7dzznr00.rs:13:34\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------             \
    \        ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut num_strs = vec![];\n      \
    \  let mut num_strs_iter = arr.iter();\n        let mut num_strs_iter = num_strs_iter.cloned().filter(|x|\
    \ x >= 1 && x <= 9);\n        match num_strs_iter.next() {\n            None =>\
    \ vec![],\n            Some(first_num) => {\n                num_strs.push(String::from(\"\
    One\"));\n                num_strs.push(String::from(\"Two\"));\n            \
    \    num_strs.push(String::from(\"Three\"));\n                num_strs.push(String::from(\"\
    Four\"));\n                num_strs.push(String::from(\"Five\"));\n          \
    \      num_strs.push(String::from(\"Six\"));\n                num_strs.push(String::from(\"\
    Seven\"));\n                num_strs.push(String::from(\"Eight\"));\n        \
    \        num_strs.push(String::from(\"Nine\"));\n                num_strs.push(String::from(first_num));\n\
    \            }\n        }\n        match num_strs_iter.next() {\n            None\
    \ => vec![],\n            Some(second_num) => {\n                num_strs.push(String::from(\"\
    One\"));\n                num_strs.push(String::from(\"Two\"));\n            \
    \    num_strs.push(String::from(\"Three\"));\n                num_strs.push(String::from(\"\
    Four\"));\n                num_strs.push(String::from(\"Five\"));\n          \
    \      num_strs.push(String::from(\"Six\"));\n                num_strs.push(String::from(\"\
    Seven\"));\n                num_strs.push(String::from(\"Eight\"));\n        \
    \        num_strs.push(String::from(\"Nine\"));\n                num_strs.push(String::from(second_num));\n\
    \            }\n        }\n        num_strs\n    }\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjw12s2yt.rs:19:72\n   |\n\
    19 |         let mut num_strs_iter = num_strs_iter.cloned().filter(|x| x >= 1\
    \ && x <= 9);\n   |                                                          \
    \              ^\n   |                                                       \
    \                 |\n   |                                                    \
    \                    expected `&isize`, found integer\n   |                  \
    \                                                      help: consider borrowing\
    \ here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjw12s2yt.rs:19:82\n\
    \   |\n19 |         let mut num_strs_iter = num_strs_iter.cloned().filter(|x|\
    \ x >= 1 && x <= 9);\n   |                                                   \
    \                               ^\n   |                                      \
    \                                            |\n   |                         \
    \                                                         expected `&isize`, found\
    \ integer\n   |                                                              \
    \                    help: consider borrowing here: `&9`\n\nerror[E0277]: the\
    \ trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmpjw12s2yt.rs:32:31\n\
    \   |\n32 |                 num_strs.push(String::from(first_num));\n   |    \
    \                           ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpjw12s2yt.rs:32:17\n\
    \   |\n20 | /         match num_strs_iter.next() {\n21 | |             None =>\
    \ vec![],\n   | |                     ------ this is found to be of type `Vec<_>`\n\
    22 | |             Some(first_num) => {\n23 | |                 num_strs.push(String::from(\"\
    One\"));\n...  |\n32 | |          "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut counter =\
    \ HashMap::new();\n    for &i in arr {\n        counter.insert(i, String::from(\"\
    \".to_owned()));\n    }\n    let mut reversed = Vec::with_capacity(arr.len());\n\
    \    for i in arr {\n        if let Some(key) = counter.remove(&i) {\n       \
    \     reversed.push(*key);\n        }\n    }\n    reversed.dedup();\n    for i\
    \ in arr {\n        if let Some(key) = counter.remove(&i) {\n            reversed.push(*key);\n\
    \        }\n    }\n    reversed\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpa40zd5p5.rs:14:23\n   |\n14 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa40zd5p5.rs:15:9\n   |\n15 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut new_arr = arr\n        .iter()\n\
    \        .filter(|&i| i <= 9)\n        .cloned()\n        .collect::<Vec<_>>();\n\
    \    new_arr.reverse();\n    new_arr\n        .iter_mut()\n        .map(|i| {\n\
    \            match i {\n                0 => \"Zero\",\n                1 => \"\
    One\",\n                2 => \"Two\",\n                3 => \"Three\",\n     \
    \           4 => \"Four\",\n                5 => \"Five\",\n                6\
    \ => \"Six\",\n                7 => \"Seven\",\n                8 => \"Eight\"\
    ,\n                9 => \"Nine\",\n                _ => unreachable!(\"Should\
    \ not reach here\"),\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpadaca4lp.rs:19:27\n   |\n\
    19 |         .filter(|&i| i <= 9)\n   |                           ^\n   |    \
    \                       |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&9`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpadaca4lp.rs:40:10\n     |\n40\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.iter()\n    \
    \    .filter(|&num| num > 0 && num < 10)\n        .collect::<Vec<String>>()\n\
    \        .reverse()\n        .cloned()\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8a1o41l.rs:15:30\n   |\n\
    15 |         .filter(|&num| num > 0 && num < 10)\n   |                       \
    \       ^\n   |                              |\n   |                         \
    \     expected `&isize`, found integer\n   |                              help:\
    \ consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8a1o41l.rs:15:41\n\
    \   |\n15 |         .filter(|&num| num > 0 && num < 10)\n   |                \
    \                         ^^\n   |                                         |\n\
    \   |                                         expected `&isize`, found integer\n\
    \   |                                         help: consider borrowing here: `&10`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpf8a1o41l.rs:16:10\n     |\n\
    16   |         .collect::<Vec<String>>()\n     |          ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&isize>`\n    \
    \ |\n     = help: the trait `FromIterator<&isize>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpf8a1o41l.rs:18:10\n\
    \   |\n18 |         .cloned()\n   |          ^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut result = vec![];\n        for\
    \ value in arr {\n            if value >= 1 && value <= 9 {\n                result.push(format!(\"\
    {}\", value));\n            } else {\n                continue;\n            }\n\
    \        }\n        result.reverse();\n        result\n    }\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp_zgve51w.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for x in\
    \ arr {\n        match x {\n            1 => result.push(String::from(\"One\"\
    )),\n            2 => result.push(String::from(\"Two\")),\n            3 => result.push(String::from(\"\
    Three\")),\n            4 => result.push(String::from(\"Four\")),\n          \
    \  5 => result.push(String::from(\"Five\")),\n            6 => result.push(String::from(\"\
    Six\")),\n            7 => result.push(String::from(\"Seven\")),\n           \
    \ 8 => result.push(String::from(\"Eight\")),\n            9 => result.push(String::from(\"\
    Nine\")),\n            _ => (),\n        }\n    }\n    result.sort_by_key(|x|\
    \ x.len());\n    result.reverse();\n    for x in result {\n        match x {\n\
    \            String::from(\"One\") => x,\n            String::from(\"Two\") =>\
    \ x,\n            String::from(\"Three\") => x,\n            String::from(\"Four\"\
    ) => x,\n            String::from(\"Five\") => x,\n            String::from(\"\
    Six\") => x,\n            String::from(\"Seven\") => x,\n            String::from(\"\
    Eight\") => x,\n            String::from(\"Nine\") => x,\n            _ => unreachable!(),\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpkkf2licq.rs:36:13\n   |\n36 |       \
    \      String::from(\"One\") => x,\n   |             ^^^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]: expected\
    \ tuple struct or tuple variant, found associated function `String::from`\n  -->\
    \ /tmp/tmpkkf2licq.rs:37:13\n   |\n37 |             String::from(\"Two\") => x,\n\
    \   |             ^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpkkf2licq.rs:38:13\n   |\n38 |             String::from(\"\
    Three\") => x,\n   |             ^^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpkkf2licq.rs:39:13\n   |\n39 |             String::from(\"\
    Four\") => x,\n   |             ^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpkkf2licq.rs:40:13\n   |\n40 |             String::from(\"\
    Five\") => x,\n   |             ^^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpkkf2licq.rs:41:13\n   |\n41 |             String::from(\"\
    Six\") => x,\n   |             ^^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut cur = 0;\n    while cur < arr.len() {\n        if arr[cur]\
    \ > 9 {\n            result.push(by_length(arr[cur..cur + 9]).rev().cloned());\n\
    \            cur += 9;\n        } else {\n            result.push(by_length(arr[cur..cur\
    \ + 1]));\n            cur += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuqkfxi9z.rs:18:35\n   |\n\
    18 |             result.push(by_length(arr[cur..cur + 9]).rev().cloned());\n \
    \  |                                   ^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                                   |\n   |        \
    \                           expected struct `Vec`, found slice `[isize]`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmpuqkfxi9z.rs:18:54\n\
    \    |\n18  |               result.push(by_length(arr[cur..cur + 9]).rev().cloned());\n\
    \    |                                                        ^^^ `Vec<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuqkfxi9z.rs:21:35\n\
    \   |\n21 |             result.push(by_length(arr[cur..cur + 1]));\n   |     \
    \                              ^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                                   |\n   |        \
    \                           expected struct `Vec`, found slice `[isize]`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuqkfxi9z.rs:25:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n25 |\
    \     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut vec = vec![];\n    let mut i =\
    \ 0;\n    while i < arr.len() {\n        if i < arr.len() - 1 && arr[i] > arr[i\
    \ + 1] {\n            i += 1;\n            continue;\n        }\n        let mut\
    \ s = String::from(\"Nine\");\n        if arr[i] <= 9 {\n            s = String::from(\"\
    One\");\n        }\n        if arr[i] <= 99 {\n            s = String::from(\"\
    Two\");\n        }\n        if arr[i] <= 999 {\n            s = String::from(\"\
    Three\");\n        }\n        if arr[i] <= 9999 {\n            s = String::from(\"\
    Four\");\n        }\n        if arr[i] <= 99999 {\n            s = String::from(\"\
    Five\");\n        }\n        if arr[i] <= 999999 {\n            s = String::from(\"\
    Six\");\n        }\n        if arr[i] <= 9999999 {\n            s = String::from(\"\
    Seven\");\n        }\n        if arr[i] <= 999999999 {\n            s = String::from(\"\
    Eight\");\n        }\n        if arr[i] <= 99999999999 {\n            s = String::from(\"\
    Nine\");\n        }\n        vec.push(s);\n        i += 1;\n    }\n    vec\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Nine\", \"Nine\", \"Nine\", \"Nine\", \"Nine\", \"Nine\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmp_i0bwywb.rs:60:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result: Vec<String> = vec![];\n\
    \n    for i in arr.iter().rev() {\n        if i >= 1 && i <= 9 {\n           \
    \ result += vec![String::from(format!(\"{}\", i).as_str())];\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcnzol1b.rs:21:17\n   |\n\
    21 |         if i >= 1 && i <= 9 {\n   |                 ^\n   |             \
    \    |\n   |                 expected `&isize`, found integer\n   |          \
    \       help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwcnzol1b.rs:21:27\n   |\n21 |         if i >= 1 && i <= 9 {\n \
    \  |                           ^\n   |                           |\n   |     \
    \                      expected `&isize`, found integer\n   |                \
    \           help: consider borrowing here: `&9`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<String>`\n  --> /tmp/tmpwcnzol1b.rs:22:13\n\
    \   |\n22 |             result += vec![String::from(format!(\"{}\", i).as_str())];\n\
    \   |             ------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  \
    \ |             |\n   |             cannot use `+=` on type `Vec<String>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut digits = String::from(\"One\"\
    );\n    for digit in arr.iter().rev() {\n        if digit < 10 {\n           \
    \ digits = digits[..digit.clone()] + \"0\".to_string();\n        } else {\n  \
    \          digits = digits[..digit.clone()] + \"A\".to_string();\n        }\n\
    \    }\n    vec![digits]\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ycdhihg.rs:19:20\n   |\n\
    19 |         if digit < 10 {\n   |                    ^^\n   |               \
    \     |\n   |                    expected `&isize`, found integer\n   |      \
    \              help: consider borrowing here: `&10`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `RangeTo<isize>`\n  --> /tmp/tmp6ycdhihg.rs:20:22\n\
    \   |\n20 |             digits = digits[..digit.clone()] + \"0\".to_string();\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeTo<isize>`\n   |\n   = help: the trait `Index<RangeTo<isize>>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmp6ycdhihg.rs:22:22\n   |\n22 |             digits = digits[..digit.clone()]\
    \ + \"A\".to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `RangeTo<isize>`\n   |\n   = help: the trait `Index<RangeTo<isize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res = vec![];\n\
    \n    for num in arr {\n        if num <= 9 && num >= 1 {\n            res.push(by_length_helper(num));\n\
    \        } else {\n            continue;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length_helper` in this scope\n \
    \ --> /tmp/tmp6ltc2p5c.rs:18:22\n   |\n18 |             res.push(by_length_helper(num));\n\
    \   |                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut arr = arr.into_iter();\n   \
    \ let mut num_to_name = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\",\
    \ \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut cur = 0;\n    let mut\
    \ cur_rev = 0;\n    let mut cur_len = arr.len();\n    let mut cur_digit = 0;\n\
    \    let mut last_digit = -1;\n    loop {\n        let next = cur_len.saturating_sub(1);\n\
    \        if cur_digit < next {\n            cur_len = next;\n            cur_digit\
    \ = 0;\n        } else {\n            cur_digit = next;\n        }\n        if\
    \ cur_digit < 10 {\n            if arr[cur_rev].is_some() {\n                last_digit\
    \ = cur_digit;\n                cur_rev += 1;\n            } else {\n        \
    \        cur_rev += 1;\n            }\n        } else {\n            if cur_digit\
    \ - last_digit > 5 {\n                let num_to_name_iter = num_to_name.iter().take(10);\n\
    \                let mut cur_num_to_name = num_to_name_iter.next();\n        \
    \        while cur_num_to_name != num_to_name_iter.next() {\n                \
    \    cur_num_to_name = num_to_name_iter.next();\n                }\n         \
    \       let mut cur_rev_to_name = cur_rev.saturating_sub(10);\n              \
    \  while cur_rev_to_name != 0 {\n                    cur_rev_to_name = cur_rev_to_name.saturating_sub(10);\n\
    \                }\n                if cur_rev < 10 {\n                    let\
    \ mut cur_num_to_name_iter = num_to_name_iter.take(10);\n                    let\
    \ mut cur_cur_rev_to_name = cur_rev.saturating_sub(10);\n                    let\
    \ mut cur_cur_digit = cur_digit;\n                    while cur_cur_digit < 10\
    \ {\n                        if cur_num_to_name == cur_num_to_name_iter.next()\
    \ {\n                            if cur_rev_to_name == 0 {\n                 \
    \               cur_rev_to_name = cur_cur_rev_to_name;\n                     \
    \           cur_cur_digit = 0;\n                            }\n              \
    \              cur_rev_to_name = cur_rev_to_name.saturating_sub(10);\n       \
    \                     cur_cur_digit += 1;\n                        } else {\n\
    \                            cur_rev_to_name = cur_rev_to_name.saturating_sub(10);\n\
    \                            cur_cur_digit += 1;\n                        }\n\
    \                    }\n                    if cur_cur_digit < 10 {\n        \
    \                if cur_rev_to_name == 0 {\n                            cur_rev_to_name\
    \ = cur_cur_rev_to_name;\n                            cur_cur_digit = 0;\n   \
    \                     }\n                        cur_rev_to_name = cur_rev_to_name.saturating_sub(10);\n\
    \                        cur_cur_digit += 1;\n                    }\n        \
    \        }\n                cur_len\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptrefsy4z.rs:87:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n25 |     loop {\n\
    \   |          - unclosed delimiter\n...\n40 |         } else {\n   |        \
    \        - unclosed delimiter\n41 |             if cur_digit - last_digit > 5\
    \ {\n   |                                           - this delimiter might not\
    \ be properly closed...\n...\n78 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n87 | }\n   |   ^\n\nerror[E0608]: cannot index into\
    \ a value of type `std::vec::IntoIter<isize>`\n  --> /tmp/tmptrefsy4z.rs:34:16\n\
    \   |\n34 |             if arr[cur_rev].is_some() {\n   |                ^^^^^^^^^^^^\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptrefsy4z.rs:24:26\n\
    \   |\n24 |     let mut last_digit = -1;\n   |                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0689]: can't\
    \ call method `saturating_sub` on ambiguous numeric type `{integer}`\n  --> /tmp/tmptrefsy4z.rs:47:51\n\
    \   |\n47 |                 let mut cur_rev_to_name = cur_rev.saturating_sub(10);\n\
    \   |                                                   ^^^^^^^^^^^^^^\n   |\n\
    help: you must specify a type for this binding, like `i32`\n   |\n21 |     let\
    \ mut cur_rev: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't\
    \ call method `saturating_sub` on ambiguous numeric type `{integer}`\n  --> /tmp/tmptrefsy4z.rs:53:59\n\
    \   |\n53 |                     let mut cur_cur_rev_to_name = cur_rev.saturating_sub(10);\n\
    \   |                                                           ^^^^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `i32`\n   |\n21 |\
    \     let mut cur_rev: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mis"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut len = arr.len();\n\
    \    let mut nums = vec![];\n    let mut i = 0;\n    while len > 0 {\n       \
    \ match nums.last() {\n            Some(last) => match (arr[len - i..len], last)\
    \ {\n                (i, _) => panic!(\"length mismatch (len: {}, i: {}): {}\"\
    , len, i, arr),\n                (i, _) => nums.push(i + &last[0]),\n        \
    \        (_, _) => panic!(\"length mismatch (len: {}, i: {}): {}\", len, i, arr),\n\
    \            },\n            None => nums.push(0),\n        }\n        i += 1;\n\
    \        len -= 1;\n    }\n    nums\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpdp_dbask.rs:20:18\n   |\n20 |              \
    \   (i, _) => panic!(\"length mismatch (len: {}, i: {}): {}\", len, i, arr),\n\
    \   |                  ^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `[isize]`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpdp_dbask.rs:21:18\n   |\n\
    21 |                 (i, _) => nums.push(i + &last[0]),\n   |                \
    \  ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `[isize]`\n   = note: all local variables must have a\
    \ statically known size\n   = help: unsized locals are gated as an unstable feature\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n   --> /tmp/tmpdp_dbask.rs:20:79\n    |\n20  |                 (i, _)\
    \ => panic!(\"length mismatch (len: {}, i: {}): {}\", len, i, arr),\n    |   \
    \                                                                            ^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `[isize]`\nnote: required by a bound in `ArgumentV1::<'a>::new_display`\n\
    \    = note: this error originates in the macro `$crate::const_format_args` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ `[isize]` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpdp_dbask.rs:20:79\n\
    \   |\n20 |                 (i, _) => panic!(\"length mismatch (len: {}, i: {}):\
    \ {}\", len, i, arr),\n   |                                                  \
    \                             ^ `[isize]` cannot be formatted with the default\
    \ formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented\
    \ for `[isize]`\n   = note: in format strings you may be able to use `{:?}` (or\
    \ {:#?} for pretty-print) instead\n   = note:"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut sorted_arr = arr.iter().sorted();\n\
    \    sorted_arr.rev();\n    let mut output = vec![];\n    for i in &sorted_arr\
    \ {\n        let mut one_to_nine = vec![\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n        let i = i as usize;\n\
    \        let name = one_to_nine[i % 10];\n        output.append(name);\n    }\n\
    \    output\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpfn9wpvcl.rs:18:37\n   |\n18 |     let mut\
    \ sorted_arr = arr.iter().sorted();\n   |                                    \
    \ ^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfn9wpvcl.rs:25:23\n   |\n25 |         output.append(name);\n\
    \   |                       ^^^^ types differ in mutability\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                      found reference\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = Vec::new();\n    let\
    \ mut index = 0;\n    let mut prev = None;\n    while index < arr.len() {\n  \
    \      let cur_str = String::from_str(&arr[index]);\n        if cur_str.is_empty()\
    \ {\n            return vec![];\n        }\n        if prev.is_none() || cur_str\
    \ > prev {\n            result.push(by_length(vec![cur_str, cur_str.to_string().rev().unwrap()]));\n\
    \        } else {\n            result.push(by_length(vec![cur_str.clone(), cur_str]));\n\
    \        }\n        prev = cur_str;\n        index += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp1erjx3k6.rs:21:31\n   |\n\
    21 |         let cur_str = String::from_str(&arr[index]);\n   |              \
    \                 ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1erjx3k6.rs:33:5\n   |\n13 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    }\n    else {\n        let mut arr2 = arr.clone();\n\
    \        arr2.sort_by_key(|x| x as usize);\n        arr2.reverse();\n\n      \
    \  let mut result = vec![];\n        for val in arr2 {\n            let num =\
    \ val % 10;\n            result.push(match num {\n                1 => \"One\"\
    .to_string(),\n                2 => \"Two\".to_string(),\n                3 =>\
    \ \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n       \
    \         5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => panic!(\"Invalid\
    \ digit for sort: {}\", num),\n            });\n            val /= 10;\n     \
    \   }\n        result\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpqdhg31fu.rs:19:30\n\
    \   |\n19 |         arr2.sort_by_key(|x| x as usize);\n   |                  \
    \            -^^^^^^^^^\n   |                              |\n   |           \
    \                   cannot cast `&isize` as `usize`\n   |                    \
    \          help: dereference the expression: `*x`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for val\
    \ in arr {\n        if val >= 1 && val <= 9 {\n            result.push(format!(\"\
    {}\", val as String));\n        } else {\n            return vec![];\n       \
    \ }\n    }\n    let mut reverse = result.rev();\n    let mut replace = String::from(\"\
    One\");\n    for val in reverse {\n        replace.push_str(replace);\n    }\n\
    \    replace.push_str(replace);\n    result.reverse();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmp0hydn4sk.rs:25:30\n\
    \    |\n25  |       let mut reverse = result.rev();\n    |                   \
    \             ^^^ `Vec<String>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n    \
    \        which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hydn4sk.rs:28:26\n   |\n28 |         replace.push_str(replace);\n\
    \   |                          ^^^^^^^\n   |                          |\n   |\
    \                          expected `&str`, found struct `String`\n   |      \
    \                    help: consider borrowing here: `&replace`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hydn4sk.rs:30:22\n   |\n30 |     replace.push_str(replace);\n\
    \   |                      ^^^^^^^\n   |                      |\n   |        \
    \              expected `&str`, found struct `String`\n   |                  \
    \    help: consider borrowing here: `&replace`\n\nerror[E0605]: non-primitive\
    \ cast: `isize` as `String`\n  --> /tmp/tmp0hydn4sk.rs:20:39\n   |\n20 |     \
    \        result.push(format!(\"{}\", val as String));\n   |                  \
    \                     ^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0605.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut res = vec![];\n        let\
    \ mut len = arr.len();\n        while len > 0 {\n            if len >= 10 {\n\
    \                res.push(by_length_helper(arr.iter().filter(|&x| x != 1).collect()));\n\
    \                len -= 10;\n            } else {\n                res.push(by_length_helper(arr.iter().filter(|&x|\
    \ x == 1).collect()));\n                len -= 1;\n            }\n        }\n\
    \        res.reverse();\n        res.iter().map(|x| {\n            match x {\n\
    \                x @ &1 => String::from(\"One\"),\n                x @ &2 => String::from(\"\
    Two\"),\n                x @ &3 => String::from(\"Three\"),\n                x\
    \ @ &4 => String::from(\"Four\"),\n                x @ &5 => String::from(\"Five\"\
    ),\n                x @ &6 => String::from(\"Six\"),\n                x @ &7 =>\
    \ String::from(\"Seven\"),\n                x @ &8 => String::from(\"Eight\"),\n\
    \                x @ &9 => String::from(\"Nine\"),\n                _ => panic!(\"\
    Unexpected number in vector!\"),\n            }\n        }).collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length_helper` in this scope\n \
    \ --> /tmp/tmpcw99mu4z.rs:21:26\n   |\n21 |                 res.push(by_length_helper(arr.iter().filter(|&x|\
    \ x != 1).collect()));\n   |                          ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `by_length_helper` in this\
    \ scope\n  --> /tmp/tmpcw99mu4z.rs:24:26\n   |\n24 |                 res.push(by_length_helper(arr.iter().filter(|&x|\
    \ x == 1).collect()));\n   |                          ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  -->\
    \ /tmp/tmpcw99mu4z.rs:21:68\n   |\n21 |                 res.push(by_length_helper(arr.iter().filter(|&x|\
    \ x != 1).collect()));\n   |                                                 \
    \                   ^^ no implementation for `&isize == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpcw99mu4z.rs:24:68\n\
    \   |\n24 |                 res.push(by_length_helper(arr.iter().filter(|&x| x\
    \ == 1).collect()));\n   |                                                   \
    \                 ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_owned();\n\
    \    let len = arr.len();\n    if len > 0 && !(len % 3) {\n        let mut reversed\
    \ = vec![];\n        for i in 0..len {\n            reversed.push(arr[i].to_string());\n\
    \        }\n        reversed.reverse();\n        for i in 0..(len / 3) {\n   \
    \         arr[i] = reversed[i as usize].parse::<isize>().unwrap();\n        }\n\
    \    }\n    arr.to_vec()\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1nhu2fz.rs:16:19\n   |\n\
    16 |     if len > 0 && !(len % 3) {\n   |                   ^^^^^^^^^^ expected\
    \ `bool`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph1nhu2fz.rs:26:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n26 |     arr.to_vec()\n   |     ^^^^^^^^^^^^ expected struct `String`, found\
    \ `isize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ret: Vec<String> = vec![];\n \
    \   for i in arr {\n        if i < 1 || i > 9 {\n            continue;\n     \
    \   }\n        ret.push(String::from(names_reversed[i]));\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names_reversed` in this scope\n  --> /tmp/tmpdg743wsa.rs:22:31\n\
    \   |\n22 |         ret.push(String::from(names_reversed[i]));\n   |         \
    \                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut output = Vec::new();\n\n   \
    \ for &n in arr {\n        let mut i = 0;\n        let mut j = n - 1;\n\n    \
    \    while i <= j {\n            let tmp = if i < j {\n                &arr[i]\n\
    \            } else {\n                &arr[j]\n            };\n\n           \
    \ if i > 9 {\n                i += 10;\n                j -= 10;\n           \
    \ } else {\n                i += 1;\n                j -= 1;\n            }\n\
    \            output.push(String::from(tmp));\n        }\n    }\n\n    output\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7fo09zfx.rs:20:9\n   |\n\
    20 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `String: From<&isize>` is not satisfied\n  --> /tmp/tmp7fo09zfx.rs:38:25\n \
    \  |\n38 |             output.push(String::from(tmp));\n   |                 \
    \        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.into_iter().map(|n|\
    \ n - 1).collect();\n    arr.sort();\n    arr.iter().map(|n| match n {\n     \
    \   0 => \"Zero\",\n        1 => \"One\",\n        2 => \"Two\",\n        3 =>\
    \ \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"\
    Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\"\
    ,\n        _ => String::from(format!(\"{}\", n)),\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp8rw08qd1.rs:15:5\n\
    \   |\n14 |     let mut arr = arr.into_iter().map(|n| n - 1).collect();\n   |\
    \         ------- consider giving `arr` a type\n15 |     arr.sort();\n   |   \
    \  ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\n\
    error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp8rw08qd1.rs:27:14\n\
    \   |\n16 |       arr.iter().map(|n| match n {\n   |  ________________________-\n\
    17 | |         0 => \"Zero\",\n18 | |         1 => \"One\",\n19 | |         2\
    \ => \"Two\",\n...  |\n26 | |         9 => \"Nine\",\n   | |              ------\
    \ this and all prior arms are found to be of type `&str`\n27 | |         _ =>\
    \ String::from(format!(\"{}\", n)),\n   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   | |              |\n   | |              expected `&str`, found struct `String`\n\
    \   | |              help: consider borrowing here: `&String::from(format!(\"\
    {}\", n))`\n28 | |     }).collect()\n   | |_____- `match` arms have incompatible\
    \ types\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut arr = arr.clone();\n    let mut\
    \ reversed = arr;\n    reversed.rev();\n    let mut map: HashMap<isize, String>\
    \ = HashMap::new();\n    let mut i = 0;\n    let mut last_digit = 0;\n    let\
    \ mut last_digit_index = 0;\n    while i < arr.len() {\n        let digit = arr[i]\
    \ % 10;\n        let digit_index = (digit + i) as isize;\n        last_digit =\
    \ digit;\n        last_digit_index = digit_index;\n        map.insert(last_digit_index,\
    \ String::from(\"One\"));\n        map.insert(digit_index, String::from(\"Two\"\
    ));\n        map.insert(digit_index - 1, String::from(\"Three\"));\n        map.insert(digit_index\
    \ + 2, String::from(\"Four\"));\n        map.insert(digit_index - 3, String::from(\"\
    Five\"));\n        map.insert(digit_index + 4, String::from(\"Six\"));\n     \
    \   map.insert(digit_index - 5, String::from(\"Seven\"));\n        map.insert(digit_index\
    \ + 6, String::from(\"Eight\"));\n        map.insert(digit_index - 7, String::from(\"\
    Nine\"));\n        i += 1;\n    }\n    let mut reversed_with_numbers = vec![];\n\
    \    for &str in map.values() {\n        reversed_with_numbers.push(str);\n  \
    \  }\n    reversed_with_numbers.push(reversed.to_vec());\n    let mut reversed_with_numbers_vec\
    \ = reversed_with_numbers;\n    reversed_with_numbers_vec.reverse();\n    reversed_with_numbers_vec.push(vec![]);\n\
    \    return reversed_with_numbers_vec;\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpmxj6gtce.rs:20:18\n\
    \   |\n20 |     let mut map: HashMap<isize, String> = HashMap::new();\n   |  \
    \                ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpmxj6gtce.rs:20:43\n\
    \   |\n20 |     let mut map: HashMap<isize, String> = HashMap::new();\n   |  \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpmxj6gtce.rs:19:14\n\
    \    |\n19  |       reversed.rev();\n    |                ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmxj6gtce.rs:26:36\n\
    \   |\n26 |         let digit_index = (digit + i) as isize;\n   |            \
    \                        ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ add `usize` to `isize`\n  --> /tmp/tmpmxj6gtce.rs:26:34\n   |\n26 |        \
    \ let digit_index = (digit + i) as isize;\n   |                              \
    \    ^ no implementation for `isize + usize`\n   |\n   = help: the trait `Add<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmxj6gtce.rs:48:12\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \    "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.clone();\n\
    \    arr.sort_by_key(|n| {\n        match n % 10 {\n            1 => Some(\"One\"\
    ),\n            2 => Some(\"Two\"),\n            3 => Some(\"Three\"),\n     \
    \       4 => Some(\"Four\"),\n            5 => Some(\"Five\"),\n            6\
    \ => Some(\"Six\"),\n            7 => Some(\"Seven\"),\n            8 => Some(\"\
    Eight\"),\n            9 => Some(\"Nine\"),\n            _ => None,\n        }\n\
    \            .map(|n| n.to_string())\n            .unwrap_or(n)\n    });\n   \
    \ arr.reverse();\n    arr.iter().map(|&x| String::from(x)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfuw4zads.rs:29:24\n   |\n\
    29 |             .unwrap_or(n)\n   |                        ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `&isize`\n\nerror[E0277]:\
    \ the trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmpfuw4zads.rs:32:25\n\
    \   |\n32 |     arr.iter().map(|&x| String::from(x)).collect()\n   |         \
    \                ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() == 1 {\n        return vec![\"\
    One\".to_string()];\n    }\n    let mut result = vec![];\n    let mut reversed\
    \ = arr.rev();\n    let mut counter = 0;\n    while !reversed.is_empty() {\n \
    \       let len = reversed.len();\n        for &index in 0..len {\n          \
    \  if index == 0 {\n                continue;\n            }\n            let\
    \ digit = reversed[index];\n            if digit > 9 {\n                break;\n\
    \            }\n            let index = counter + digit as isize;\n          \
    \  if index > 9 {\n                break;\n            }\n            let string\
    \ = String::from(&vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"][index - 1]);\n            counter = index;\n\
    \            result.push(string);\n        }\n        reversed.pop();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpir8u_vi4.rs:21:28\n\
    \    |\n21  |       let mut reversed = arr.rev();\n    |                     \
    \         ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpir8u_vi4.rs:25:13\n   |\n25 |         for &index\
    \ in 0..len {\n   |             ^^^^^^    ------ this expression has type `Option<{integer}>`\n\
    \   |             |\n   |             expected integer, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `index`\n   |\n\
    \   = note:   expected type `{integer}`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `[&str]` cannot be indexed by `isize`\n  --> /tmp/tmpir8u_vi4.rs:37:40\n\
    \   |\n37 |             let string = String::from(&vec![\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][index - 1]);\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<&str>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    let mut\
    \ current = String::from(\"One\");\n    let mut first_time = true;\n\n    for\
    \ num in arr.iter() {\n        let mut new_num = num;\n        if num < 10 {\n\
    \            new_num = \"0\".to_string()\n                .into_iter()\n     \
    \           .cloned()\n                .chain(vec![num.clone()])\n           \
    \     .collect();\n        } else {\n            new_num = \"One\".to_string().into_iter().cloned().chain(vec![num.clone()\
    \ - 10]).collect();\n        }\n        if first_time {\n            current =\
    \ String::from(new_num);\n            first_time = false;\n        } else {\n\
    \            current = format!(\"{}{}\", current, String::from(new_num));\n  \
    \      }\n    }\n\n    result.push(current);\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgzm99ww2.rs:24:18\n   |\n\
    24 |         if num < 10 {\n   |                  ^^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&10`\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpgzm99ww2.rs:26:18\n    |\n26  |                   .into_iter()\n   \
    \ |                    ^^^^^^^^^\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `String: IntoIterator`\n            `&String: Iterator`\n            which\
    \ is required by `&String: IntoIterator`\n            `&mut String: Iterator`\n\
    \            which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror[E0599]: the method `into_iter` exists for struct `String`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpgzm99ww2.rs:31:41\n\
    \    |\n31  |               new_num = \"One\".to_string().into_iter().cloned().chain(vec![num.clone()\
    \ - 10]).collect();\n    |                                           ^^^^^^^^^\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `String: IntoIterator`\n\
    \            `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n         "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr2 = vec![];\n\
    \    let mut arr3 = vec![];\n    let mut i = 0;\n    let mut num = 9;\n    while\
    \ num >= 1 {\n        while arr2.len() < i {\n            arr2.push(String::from(\"\
    0\"));\n        }\n        while arr3.len() < i {\n            arr3.push(String::from(\"\
    0\"));\n        }\n        arr2.push(String::from(&arr[num % 10]));\n        arr3.push(String::from(&arr[num\
    \ / 10]));\n        num /= 10;\n        i += 1;\n    }\n    if arr2.len() > 0\
    \ {\n        arr2.reverse();\n    }\n    if arr3.len() > 0 {\n        arr3.reverse();\n\
    \    }\n    for i in 0..(arr2.len() - 1) {\n        let mut j = 0;\n        if\
    \ arr2[i].is_empty() {\n            arr2[i] = arr3[j];\n            arr3[j] =\
    \ \"0\".to_string();\n            i += 1;\n        }\n    }\n    arr2\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpatkhxsq8.rs:25:19\n   |\n25 |         arr2.push(String::from(&arr[num\
    \ % 10]));\n   |                   ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0277]: the trait bound `String: From<&isize>`\
    \ is not satisfied\n  --> /tmp/tmpatkhxsq8.rs:26:19\n   |\n26 |         arr3.push(String::from(&arr[num\
    \ / 10]));\n   |                   ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut result = vec![];\n        let\
    \ mut digits = arr\n            .iter()\n            .cloned()\n            .enumerate()\n\
    \            .map(|(i, el)| el)\n            .collect::<Vec<_>>();\n        while\
    \ digits.pop().is_some() {\n            let mut i = 0;\n            while i <\
    \ digits.len() && digits[i].is_some() {\n                i += 1;\n           \
    \ }\n            result.push(by_index(&digits.drain(0..i)));\n        }\n    \
    \    result.extend(\n            by_index(&digits\n                .into_iter()\n\
    \                .enumerate()\n                .map(|(i, el)| if i < arr.len()\
    \ {\n                    el\n                } else {\n                    None\n\
    \                })\n                .collect::<Vec<_>>(),\n            ),\n \
    \       );\n        result\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_index` in this scope\n  --> /tmp/tmpjmfb4n9j.rs:29:25\n\
    \   |\n29 |             result.push(by_index(&digits.drain(0..i)));\n   |    \
    \                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `by_index` in this scope\n  --> /tmp/tmpjmfb4n9j.rs:32:13\n  \
    \ |\n32 |             by_index(&digits\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `is_some` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpjmfb4n9j.rs:26:49\n   |\n26 |          \
    \   while i < digits.len() && digits[i].is_some() {\n   |                    \
    \                             ^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmpjmfb4n9j.rs:38:21\n \
    \  |\n35 |                   .map(|(i, el)| if i < arr.len() {\n   |  ________________________________-\n\
    36 | |                     el\n   | |                     -- expected because\
    \ of this\n37 | |                 } else {\n38 | |                     None\n\
    \   | |                     ^^^^ expected `isize`, found enum `Option`\n39 | |\
    \                 })\n   | |_________________- `if` and `else` have incompatible\
    \ types\n   |\n   = note: expected type `isize`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() > 0\
    \ {\n        let mut str = String::new();\n        let mut reversed = vec![];\n\
    \        for el in arr {\n            if el >= 1 && el <= 9 {\n              \
    \  str = str\n                    .replace_range(el, el + 1, \"One\")\n      \
    \              .replace_range(el - 1, el, \"Zero\");\n            } else {\n \
    \               str = str\n                    .replace_range(el, el + 1, \"Two\"\
    )\n                    .replace_range(el - 1, el, \"One\");\n            }\n \
    \           reversed.push(str);\n        }\n        reversed.rev();\n        for\
    \ el in reversed.iter() {\n            str = str\n                .replace_range(el\
    \ - 1, el, \"One\")\n                .replace_range(el, el + 1, \"Two\");\n  \
    \      }\n        return vec![str];\n    }\n    return vec![];\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \    --> /tmp/tmporw0wj9o.rs:20:22\n     |\n20   |                     .replace_range(el,\
    \ el + 1, \"One\")\n     |                      ^^^^^^^^^^^^^ --  ------  -----\
    \ supplied 3 arguments\n     |                      |\n     |                \
    \      expected 2 arguments\n     |\nnote: associated function defined here\n\n\
    error[E0599]: no method named `replace_range` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmporw0wj9o.rs:21:22\n   |\n21 |                 \
    \    .replace_range(el - 1, el, \"Zero\");\n   |                      ^^^^^^^^^^^^^\
    \ method not found in `()`\n\nerror[E0061]: this function takes 2 arguments but\
    \ 3 arguments were supplied\n    --> /tmp/tmporw0wj9o.rs:24:22\n     |\n24   |\
    \                     .replace_range(el, el + 1, \"Two\")\n     |            \
    \          ^^^^^^^^^^^^^ --  ------  ----- supplied 3 arguments\n     |      \
    \                |\n     |                      expected 2 arguments\n     |\n\
    note: associated function defined here\n\nerror[E0599]: no method named `replace_range`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmporw0wj9o.rs:25:22\n\
    \   |\n25 |                     .replace_range(el - 1, el, \"One\");\n   |   \
    \                   ^^^^^^^^^^^^^ method not found in `()`\n\nerror[E0599]: `Vec<String>`\
    \ is not an iterator\n   --> /tmp/tmporw0wj9o.rs:29:18\n    |\n29  |         \
    \  reversed.rev();\n    |                    ^^^ `Vec<String>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `&String`\n  --> /tmp/tmporw0wj9o.rs:32:35\n   |\n32 |                 .replace_range(el\
    \ - 1, el, \"One\")\n   |                                -- ^ - {integer}\n  \
    \ |                                |\n   |                                &String\n\
    \nerror[E0061]: this function takes 2 arguments "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result: Vec<String>\
    \ = vec![];\n    let mut len: isize = 0;\n    for elem in arr.iter() {\n     \
    \   if elem >= 1 && elem <= 9 {\n            len += 1;\n        } else {\n   \
    \         len = 0;\n        }\n        if len == 1 {\n            result.push(String::from(\"\
    One\"));\n        } else if len == 2 {\n            result.push(String::from(\"\
    Two\"));\n        } else if len == 3 {\n            result.push(String::from(\"\
    Three\"));\n        } else if len == 4 {\n            result.push(String::from(\"\
    Four\"));\n        } else if len == 5 {\n            result.push(String::from(\"\
    Five\"));\n        } else if len == 6 {\n            result.push(String::from(\"\
    Six\"));\n        } else if len == 7 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if len == 8 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if len == 9 {\n            result.push(String::from(\"\
    Nine\"));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwuhumhzb.rs:17:20\n   |\n\
    17 |         if elem >= 1 && elem <= 9 {\n   |                    ^\n   |    \
    \                |\n   |                    expected `&isize`, found integer\n\
    \   |                    help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwuhumhzb.rs:17:33\n   |\n17 |         if elem\
    \ >= 1 && elem <= 9 {\n   |                                 ^\n   |          \
    \                       |\n   |                                 expected `&isize`,\
    \ found integer\n   |                                 help: consider borrowing\
    \ here: `&9`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.into_iter();\n\
    \    let mut len = arr.len();\n    if len == 0 {\n        return vec![];\n   \
    \ }\n    if len <= 9 {\n        arr.rev().sort_unstable();\n    }\n    loop {\n\
    \        let mut tmp = arr.clone();\n        let mut count = 0;\n        while\
    \ count < len {\n            let x = &tmp[count];\n            if x >= 1 && x\
    \ <= 9 {\n                let name = &NAMES[x];\n                arr.swap(count,\
    \ count + 1);\n                count += 1;\n                *tmp = name;\n   \
    \         } else {\n                break;\n            }\n        }\n       \
    \ if count == len {\n            break;\n        }\n        len -= count;\n  \
    \  }\n    arr.into_iter().map(String::from).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `NAMES` in this scope\n  --> /tmp/tmpfuu63vub.rs:28:29\n\
    \   |\n28 |                 let name = &NAMES[x];\n   |                      \
    \       ^^^^^ not found in this scope\n\nerror[E0599]: no method named `sort_unstable`\
    \ found for struct `Rev` in the current scope\n  --> /tmp/tmpfuu63vub.rs:20:19\n\
    \   |\n20 |         arr.rev().sort_unstable();\n   |                   ^^^^^^^^^^^^^\
    \ method not found in `Rev<std::vec::IntoIter<isize>>`\n\nerror[E0608]: cannot\
    \ index into a value of type `std::vec::IntoIter<isize>`\n  --> /tmp/tmpfuu63vub.rs:26:22\n\
    \   |\n26 |             let x = &tmp[count];\n   |                      ^^^^^^^^^^\n\
    \nerror[E0599]: no method named `swap` found for struct `std::vec::IntoIter` in\
    \ the current scope\n  --> /tmp/tmpfuu63vub.rs:29:21\n   |\n29 |             \
    \    arr.swap(count, count + 1);\n   |                     ^^^^ method not found\
    \ in `std::vec::IntoIter<isize>`\n\nerror[E0614]: type `std::vec::IntoIter<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpfuu63vub.rs:31:17\n   |\n31 |        \
    \         *tmp = name;\n   |                 ^^^^\n\nerror[E0277]: the trait bound\
    \ `String: From<isize>` is not satisfied\n  --> /tmp/tmpfuu63vub.rs:41:5\n   |\n\
    41 |     arr.into_iter().map(String::from).collect()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `From<isize>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the trait bound\
    \ `String: From<isize>` is not satisfied\n  --> /tmp/tmpfuu63vub.rs:41:25\n  \
    \ |\n41 |     arr.into_iter().map(String::from).collect()\n   |              \
    \           ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \       "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else if arr.len() == 1 {\n        vec![String::from(\"\
    One\")]\n    } else {\n        let mut nums = arr.clone();\n        nums.sort();\n\
    \        nums.reverse();\n        nums.iter_mut().for_each(|x| {\n           \
    \ match x {\n                isize::from(x) => *x = String::from(\"One\"),\n \
    \               x => unreachable!(),\n            }\n        })\n    }\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `isize::from`\n  --> /tmp/tmp_wvy5mlq.rs:24:17\n   |\n24 |        \
    \         isize::from(x) => *x = String::from(\"One\"),\n   |                \
    \ ^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n   |\n   = help: for\
    \ more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_wvy5mlq.rs:22:9\n   |\n13 | \
    \  fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                      \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    22 | /         nums.iter_mut().for_each(|x| {\n23 | |             match x {\n\
    24 | |                 isize::from(x) => *x = String::from(\"One\"),\n25 | | \
    \                x => unreachable!(),\n26 | |             }\n27 | |         })\n\
    \   | |__________^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0164, E0308.\n\
    For more information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr\n\
    \        .into_iter()\n        .enumerate()\n        .filter(|(i, elem)| elem\
    \ > 1 && elem < 10)\n        .map(|(i, elem)| {\n            format!(\n      \
    \          \"{:#0#}\",\n                (i + 1) * (elem + 1)\n            )\n\
    \        })\n        .collect::<Vec<String>>();\n    let mut reversed_arr = vec![];\n\
    \    for i in 0 .. arr.len() - 1 {\n        let reversed_arr.append(&arr[i]);\n\
    \    }\n    let mut map = String::from(\"One\");\n    for i in 0 .. reversed_arr.len()\
    \ - 1 {\n        map = map.to_string().into();\n        if reversed_arr[i] !=\
    \ \"\" {\n            map = \"Two\".to_string().into();\n        }\n        if\
    \ reversed_arr[i + 1] != \"\" {\n            map = \"Three\".to_string().into();\n\
    \        }\n        if reversed_arr[i + 2] != \"\" {\n            map = \"Four\"\
    .to_string().into();\n        }\n        if reversed_arr[i + 3] != \"\" {\n  \
    \          map = \"Five\".to_string().into();\n        }\n        if reversed_arr[i\
    \ + 4] != \"\" {\n            map = \"Six\".to_string().into();\n        }\n \
    \       if reversed_arr[i + 5] != \"\" {\n            map = \"Seven\".to_string().into();\n\
    \        }\n        if reversed_arr[i + 6] != \"\" {\n            map = \"Eight\"\
    .to_string().into();\n        }\n        if reversed_arr[i + 7] != \"\" {\n  \
    \          map = \"Nine\".to_string().into();\n        }\n        if reversed_arr[i\
    \ + 8] != \"\" {\n            map = \"Ten\".to_string().into();\n        }\n \
    \       if reversed_arr[i + 9] != \"\" {\n            map = \"Eleven\".to_string().into();\n\
    \        }\n        if reversed_arr[i + 10] != \"\" {\n            map = \"Twelve\"\
    .to_string().into();\n        }\n        if reversed_arr[i + 11] != \"\" {\n \
    \           map = \"Thirteen\".to_string().into();\n        }\n        if reversed_arr[i\
    \ + 12] != \"\" {\n            map = \"Fourteen\".to_string().into();\n      \
    \  }\n        if reversed_arr[i + 13] != \"\" {\n            map = \"Fifteen\"\
    .to_string().into();\n        }\n        if reversed_arr[i + 14] != \"\" {\n \
    \           map = \"Sixteen\".to_string().into();\n        }\n        if reversed_arr[i\
    \ + 15] != \"\" {\n            map = \"Seventeen\".to_string().into();\n     \
    \   }\n        if reversed_arr[i + 16] != \"\" {\n            map = \"Eighteen\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp3bghosn9.rs:90:110\n\
    \   |\n90 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n   |  ______________________________________________________________________________________________________________^\n\
    91 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else if arr.len() <= 9 {\n        vec![String::from(\"\
    One\"), String::from(\"Two\"), String::from(\"Three\"), String::from(\"Four\"\
    ), String::from(\"Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"\
    Eight\"), String::from(\"Nine\")]\n    } else {\n        let mut ret: Vec<String>\
    \ = vec![];\n        for digit in arr {\n            let index = digit as i32;\n\
    \            if index < 10 { // index from 1 to 9\n                let name =\
    \ String::from(\"One\");\n                if index == 1 {\n                  \
    \  name = \"Two\";\n                } else if index == 2 {\n                 \
    \   name = \"Three\";\n                } else if index == 3 {\n              \
    \      name = \"Four\";\n                } else if index == 4 {\n            \
    \        name = \"Five\";\n                } else if index == 5 {\n          \
    \          name = \"Six\";\n                } else if index == 6 {\n         \
    \           name = \"Seven\";\n                } else if index == 7 {\n      \
    \              name = \"Eight\";\n                } else if index == 8 {\n   \
    \                 name = \"Nine\";\n                }\n                ret.push((name).to_owned());\n\
    \            } else {\n                let name = String::from(\"Ten\");\n   \
    \             if index == 10 {\n                    name = \"Eleven\";\n     \
    \           } else if index == 11 {\n                    name = \"Twelve\";\n\
    \                } else if index == 12 {\n                    name = \"Thirteen\"\
    ;\n                } else if index == 13 {\n                    name = \"Fourteen\"\
    ;\n                } else if index == 14 {\n                    name = \"Fifteen\"\
    ;\n                } else if index == 15 {\n                    name = \"Sixteen\"\
    ;\n                } else if index == 16 {\n                    name = \"Seventeen\"\
    ;\n                } else if index == 17 {\n                    name = \"Eighteen\"\
    ;\n                } else if index == 18 {\n                    name = \"Nineteen\"\
    ;\n                }\n                ret.push((name).to_owned());\n         \
    \   }\n        }\n        ret.iter().rev().map(|s| s.to_string()).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd7x3w023.rs:25:28\n   |\n\
    23 |                 let name = String::from(\"One\");\n   |                 \
    \           ------------------- expected due to this value\n24 |             \
    \    if index == 1 {\n25 |                     name = \"Two\";\n   |         \
    \                   ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7x3w023.rs:27:28\n\
    \   |\n23 |                 let name = String::from(\"One\");\n   |          \
    \                  ------------------- expected due to this value\n...\n27 | \
    \                    name = \"Three\";\n   |                            ^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7x3w023.rs:29:28\n\
    \   |\n23 |                 let name = String::from(\"One\");\n   |          \
    \                  ------------------- expected due to this value\n...\n29 | \
    \                    name = \"Four\";\n   |                            ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7x3w023.rs:31:28\n\
    \   |\n23 |                 let name = String::from(\"One\");\n   |          \
    \                  ------------------- expected due to this value\n...\n31 | \
    \                    name = \"Five\";\n   |                            ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd7x3w023.rs:33:28\n\
    \   |\n23 |                 let name = String::from(\"One\");\n   |          \
    \                  ------------------- expected due to this value\n...\n33 | \
    \                    name = \"Six\";\n   |"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result = vec![];\n    for i\
    \ in arr.iter() {\n        if i == 0 {\n            result.push(String::from(\"\
    One\"));\n        } else if i == 1 {\n            result.push(String::from(\"\
    Two\"));\n        } else if i == 2 {\n            result.push(String::from(\"\
    Three\"));\n        } else if i == 3 {\n            result.push(String::from(\"\
    Four\"));\n        } else if i == 4 {\n            result.push(String::from(\"\
    Five\"));\n        } else if i == 5 {\n            result.push(String::from(\"\
    Six\"));\n        } else if i == 6 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if i == 7 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if i == 8 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(&arr[i - 1].to_string()));\n\
    \        }\n    }\n    result.into_iter().rev().collect::<Vec<String>>()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4w5vjttj.rs:20:14\n\
    \   |\n20 |         if i == 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp4w5vjttj.rs:22:21\n   |\n22 |         } else if i == 1 {\n   |\
    \                     ^^ no implementation for `&isize == {integer}`\n   |\n \
    \  = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  -->\
    \ /tmp/tmp4w5vjttj.rs:24:21\n   |\n24 |         } else if i == 2 {\n   |     \
    \                ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4w5vjttj.rs:26:21\n\
    \   |\n26 |         } else if i == 3 {\n   |                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't co"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut to_sort:\
    \ Vec<String> = Vec::new();\n    let mut min_val: isize = 1;\n    let mut max_val:\
    \ isize = 9;\n    let mut curr_val: isize = 0;\n    let mut temp_arr: Vec<String>\
    \ = Vec::new();\n    to_sort.push(String::from(\"One\"));\n    to_sort.push(String::from(\"\
    Two\"));\n    to_sort.push(String::from(\"Three\"));\n    to_sort.push(String::from(\"\
    Four\"));\n    to_sort.push(String::from(\"Five\"));\n    to_sort.push(String::from(\"\
    Six\"));\n    to_sort.push(String::from(\"Seven\"));\n    to_sort.push(String::from(\"\
    Eight\"));\n    to_sort.push(String::from(\"Nine\"));\n    to_sort.push(String::from(\"\
    Ten\"));\n    to_sort.push(String::from(\"Eleven\"));\n    to_sort.push(String::from(\"\
    Twelve\"));\n\n    to_sort.sort_unstable_by_key(|x|\n        // Reverse sorting\n\
    \        if x > max_val || x < min_val {\n            curr_val = 0;\n        }\n\
    \        curr_val = curr_val * 10 + x;\n        max_val *= 10;\n        min_val\
    \ *= 10;\n        curr_val as isize\n    );\n\n    for v in &mut to_sort {\n \
    \       temp_arr.push(v);\n    }\n\n    for i in temp_arr.iter_mut().rev() {\n\
    \        *i = String::from(&to_sort[i]);\n    }\n\n    to_sort\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, `else`, or an operator, found\
    \ `curr_val`\n  --> /tmp/tmposj95ypd.rs:37:9\n   |\n36 |         }\n   |     \
    \     -\n   |          |\n   |          expected one of `)`, `,`, `.`, `?`, `else`,\
    \ or an operator\n   |          help: missing `,`\n37 |         curr_val = curr_val\
    \ * 10 + x;\n   |         ^^^^^^^^ unexpected token\n\nerror: expected one of\
    \ `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `;`\n  --> /tmp/tmposj95ypd.rs:37:37\n\
    \   |\n37 |         curr_val = curr_val * 10 + x;\n   |                      \
    \               ^\n   |                                     |\n   |          \
    \                           expected one of 8 possible tokens\n   |          \
    \                           help: missing `,`\n\nerror: expected one of `)`, `,`,\
    \ `.`, `?`, or an operator, found `;`\n  --> /tmp/tmposj95ypd.rs:38:22\n   |\n\
    38 |         max_val *= 10;\n   |                      ^\n   |               \
    \       |\n   |                      expected one of `)`, `,`, `.`, `?`, or an\
    \ operator\n   |                      help: missing `,`\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found `;`\n  --> /tmp/tmposj95ypd.rs:39:22\n\
    \   |\n39 |         min_val *= 10;\n   |                      ^\n   |        \
    \              |\n   |                      expected one of `)`, `,`, `.`, `?`,\
    \ or an operator\n   |                      help: missing `,`\n\nerror[E0425]:\
    \ cannot find value `x` in this scope\n  --> /tmp/tmposj95ypd.rs:37:36\n   |\n\
    37 |         curr_val = curr_val * 10 + x;\n   |                             \
    \       ^ not found in this scope\n\nerror[E0061]: this function takes 1 argument\
    \ but 5 arguments were supplied\n    --> /tmp/tmposj95ypd.rs:32:13\n     |\n32\
    \   |       to_sort.sort_unstable_by_key(|x|\n     |  _____________^^^^^^^^^^^^^^^^^^^^_-\n\
    \     | |             |\n     | |             expected 1 argument\n33   | |  \
    \       // Reverse sorting\n34   | |         if x > max_val || x < min_val {\n\
    35   | |             curr_val = 0;\n36   | |         }\n     | |_________-\n37\
    \   |           curr_val = curr_val * 10 + x;\n     |     "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.iter().filter_map(|x|\
    \ x >= 1 && x <= 9 || x == 0).collect::<Vec<_>>().rev().collect::<Vec<_>>().iter().map(|x|\
    \ {\n        match x {\n            1 => String::from(\"One\"),\n            2\
    \ => String::from(\"Two\"),\n            3 => String::from(\"Three\"),\n     \
    \       4 => String::from(\"Four\"),\n            5 => String::from(\"Five\"),\n\
    \            6 => String::from(\"Six\"),\n            7 => String::from(\"Seven\"\
    ),\n            8 => String::from(\"Eight\"),\n            9 => String::from(\"\
    Nine\"),\n            _ => String::from(\"Unknown\"),\n        }\n    }).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpctm4r3am.rs:14:36\n   |\n\
    14 |     arr.iter().filter_map(|x| x >= 1 && x <= 9 || x == 0).collect::<Vec<_>>().rev().collect::<Vec<_>>().iter().map(|x|\
    \ {\n   |                                    ^\n   |                         \
    \           |\n   |                                    expected `&isize`, found\
    \ integer\n   |                                    help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctm4r3am.rs:14:46\n  \
    \ |\n14 |     arr.iter().filter_map(|x| x >= 1 && x <= 9 || x == 0).collect::<Vec<_>>().rev().collect::<Vec<_>>().iter().map(|x|\
    \ {\n   |                                              ^\n   |               \
    \                               |\n   |                                      \
    \        expected `&isize`, found integer\n   |                              \
    \                help: consider borrowing here: `&9`\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpctm4r3am.rs:14:53\n   |\n14 |     arr.iter().filter_map(|x|\
    \ x >= 1 && x <= 9 || x == 0).collect::<Vec<_>>().rev().collect::<Vec<_>>().iter().map(|x|\
    \ {\n   |                                                     ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpctm4r3am.rs:14:31\n   |\n14 |     arr.iter().filter_map(|x| x >= 1 &&\
    \ x <= 9 || x == 0).collect::<Vec<_>>().rev().collect::<Vec<_>>().iter().map(|x|\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n\
    14 |     arr.iter().filter_map(|x| Some(x >= 1 && x <= 9 || x == 0)).collect::<Vec<_>>().rev().colle"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut len = arr.len();\n\
    \    if len == 0 {\n        return vec![];\n    }\n\n    let mut num_arr = arr.clone();\n\
    \    by_length_helper(num_arr);\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length_helper` in this scope\n \
    \ --> /tmp/tmpnz4on7mm.rs:20:5\n   |\n20 |     by_length_helper(num_arr);\n  \
    \ |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnz4on7mm.rs:21:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n21 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_unstable_by_key(|x|\
    \ {\n        let mut y = x;\n        let len = x.len();\n        for &n in &mut\
    \ y[..len] {\n            if n > 9 {\n                y -= 10;\n             \
    \   *n += 1;\n            }\n        }\n        y\n    });\n    arr.iter().map(|x|\
    \ if x < 10 { \"One\" } else { \"Two\" }).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpxjtr46xa.rs:16:21\n   |\n16 |         let len =\
    \ x.len();\n   |                     ^^^ method not found in `&isize`\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpxjtr46xa.rs:17:24\n\
    \   |\n17 |         for &n in &mut y[..len] {\n   |                        ^^^^^^^^\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `&isize`\n\
    \  --> /tmp/tmpxjtr46xa.rs:19:17\n   |\n19 |                 y -= 10;\n   |  \
    \               -^^^^^^\n   |                 |\n   |                 cannot use\
    \ `-=` on type `&isize`\n   |\nhelp: `-=` can be used on `isize`, you can dereference\
    \ `y`\n   |\n19 |                 *y -= 10;\n   |                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxjtr46xa.rs:25:31\n   |\n25 |     arr.iter().map(|x|\
    \ if x < 10 { \"One\" } else { \"Two\" }).collect::<Vec<_>>()\n   |          \
    \                     ^^\n   |                               |\n   |         \
    \                      expected `&isize`, found integer\n   |                \
    \               help: consider borrowing here: `&10`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxjtr46xa.rs:25:5\n   |\n13 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n25 |     arr.iter().map(|x| if x\
    \ < 10 { \"One\" } else { \"Two\" }).collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368, E0599, E0608.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut len = arr.len() as usize;\n\
    \    let mut res: Vec<String> = vec![];\n\n    // Find the longest run of numbers\
    \ and remember it for later.\n    let mut cur_longest = 0;\n    let mut longest\
    \ = 0;\n    for num in arr.iter() {\n        if num == -1 {\n            if longest\
    \ > 1 {\n                cur_longest = longest;\n            }\n        } else\
    \ {\n            longest = cur_longest;\n            cur_longest = 0;\n      \
    \  }\n        res.push(format!(\"{}\", num));\n    }\n\n    // Reverse the run\
    \ of numbers and then rebuild the string from the numbers.\n    res.reverse();\n\
    \    for num in res {\n        let mut digit = num.parse::<usize>().unwrap();\n\
    \        if digit < 10 && digit >= 1 {\n            res.insert(res.len() - 1,\
    \ format!(\"{}\", digit));\n        }\n    }\n\n    res\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpvr69goh7.rs:25:16\n\
    \   |\n25 |         if num == -1 {\n   |                ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    debug_assert!(arr.is_sorted());\n\
    \    let mut reverse = arr;\n    reverse.rev();\n    reverse.sort_unstable_by(|a,\
    \ b| a < b);\n    reverse.iter().enumerate().map(|(i, x)| if x <= 9 { \"One\"\
    ..\"Nine\"[x - 1] } else { \"_\" }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmp7_5xnidb.rs:14:23\n   |\n14 |     debug_assert!(arr.is_sorted());\n\
    \   |                       ^^^^^^^^^\n   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   -->\
    \ /tmp/tmp7_5xnidb.rs:16:13\n    |\n16  |       reverse.rev();\n    |        \
    \       ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7_5xnidb.rs:17:37\n   |\n17 |     reverse.sort_unstable_by(|a,\
    \ b| a < b);\n   |                                     ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_5xnidb.rs:18:53\n\
    \   |\n18 |     reverse.iter().enumerate().map(|(i, x)| if x <= 9 { \"One\"..\"\
    Nine\"[x - 1] } else { \"_\" }).collect()\n   |                              \
    \                       ^\n   |                                              \
    \       |\n   |                                                     expected `&isize`,\
    \ found integer\n   |                                                     help:\
    \ consider borrowing here: `&9`\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp7_5xnidb.rs:18:64\n   |\n18 |     reverse.iter().enumerate().map(|(i,\
    \ x)| if x <= 9 { \"One\"..\"Nine\"[x - 1] } else { \"_\" }).collect()\n   | \
    \                                                               ^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `str`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmp7_5xnidb.rs:18:87\n   |\n18 |   "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut digits =\
    \ arr.clone();\n    digits.sort_by(|a, b| {\n        if b < 1 {\n            std::cmp::Ordering::Less\n\
    \        } else {\n            std::cmp::Ordering::Greater\n        }\n    });\n\
    \    let mut strings: Vec<String> = Vec::new();\n    let mut i = 0;\n    for digit\
    \ in digits {\n        if digit < 10 {\n            strings.push(String::from(\"\
    One\"));\n        } else if digit < 100 {\n            strings.push(String::from(\"\
    Two\"));\n        } else if digit < 1000 {\n            strings.push(String::from(\"\
    Three\"));\n        } else if digit < 10000 {\n            strings.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            strings.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            strings.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            strings.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            strings.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            strings.push(String::from(\"\
    Nine\"));\n        } else {\n            continue;\n        }\n        strings[i]\
    \ = strings[i].clone();\n        i += 1;\n    }\n    strings\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9c_4jx2.rs:16:16\n   |\n\
    16 |         if b < 1 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&1`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ret = vec![String::from(\"One\"\
    )];\n    for i in 0..arr.len() {\n        if i % 10 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 100 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 1000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 10000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 100000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 1000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 10000000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 10000000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 100000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 1000000000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 10000000000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 100000000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 1000000000000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 10000000000000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 100000000000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 1000000000000000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 10000000000000000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 100000000000000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 1000000000000000000 == 0 {\n            ret.push(String::from(\"\
    Ten\"));\n        }\n        if i % 10000000000000000000 == 0 {\n            ret.push(String::from(\"\
    Nine\"));\n        }\n        if i % 100000000000000000000 == 0 {\n          \
    \  ret.push(String::from(\"One\"));\n        }\n        if i % 1000000000000000000000\
    \ == 0 {\n            ret.push(String::from(\"Ten\"));\n        }\n        if\
    \ i % 10000000000000000000000 == 0 {\n            ret.push(String::from(\"Nine\"\
    ));\n        }\n        if i % 100000000000000000000000 == 0 {\n            ret.push(String::from(\"\
    One\"));\n        }\n        if i % 1000000000000000000000000 == 0 {\n       \
    \     ret.push(\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpoq5oh_4s.rs:102:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n18  |     for\
    \ i in 0..arr.len() {\n    |                           - unclosed delimiter\n\
    ...\n91  |         if i % 1000000000000000000000000 == 0 {\n    |            \
    \                                   - this delimiter might not be properly closed...\n\
    92  |             ret.push(\n93  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n102 | }\n    |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpoq5oh_4s.rs:92:21\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                         \
    \     - closing delimiter possibly meant for this\n...\n92 |             ret.push(\n\
    \   |                     ^ unclosed delimiter\n93 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0061]: this function takes 1 argument but 0 arguments were\
    \ supplied\n    --> /tmp/tmpoq5oh_4s.rs:92:17\n     |\n92   |             ret.push(\n\
    \     |                 ^^^^- supplied 0 arguments\n     |                 |\n\
    \     |                 expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpoq5oh_4s.rs:18:5\n\
    \    |\n13  |   fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |        \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n18  | /     for i in 0..arr.len() {\n19  | |         if i % 10 ==\
    \ 0 {\n20  | |             ret.push(String::from(\"Ten\"));\n21  | |         }\n\
    ...   |\n101 | |     assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n102 | | }\n    |\
    \ |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<String>`\n\
    \            found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut vec = Vec::new();\n    let mut\
    \ counter = 1;\n    while counter <= 9 {\n        let len = arr.iter().filter(|&x|\
    \ x > counter).count();\n        if len == 0 {\n            break;\n        }\n\
    \        vec.push(String::from(format!(\"{}\", counter)));\n        counter =\
    \ counter + len;\n    }\n    let len = arr.iter().filter(|&x| x > counter).count();\n\
    \    counter = counter + len;\n    vec.push((String::from(\"0\")));\n    vec.push((String::from(\"\
    One\")));\n    vec.push((String::from(\"Two\")));\n    vec.push((String::from(\"\
    Three\")));\n    vec.push((String::from(\"Four\")));\n    vec.push((String::from(\"\
    Five\")));\n    vec.push((String::from(\"Six\")));\n    vec.push((String::from(\"\
    Seven\")));\n    vec.push((String::from(\"Eight\")));\n    vec.push((String::from(\"\
    Nine\")));\n    vec\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmphgnwkpqt.rs:29:14\n\
    \   |\n29 |     vec.push((String::from(\"0\")));\n   |              ^        \
    \         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n29 -     vec.push((String::from(\"0\")));\n29 +   \
    \  vec.push(String::from(\"0\"));\n   | \n\nwarning: unnecessary parentheses around\
    \ method argument\n  --> /tmp/tmphgnwkpqt.rs:30:14\n   |\n30 |     vec.push((String::from(\"\
    One\")));\n   |              ^                   ^\n   |\nhelp: remove these parentheses\n\
    \   |\n30 -     vec.push((String::from(\"One\")));\n30 +     vec.push(String::from(\"\
    One\"));\n   | \n\nwarning: unnecessary parentheses around method argument\n \
    \ --> /tmp/tmphgnwkpqt.rs:31:14\n   |\n31 |     vec.push((String::from(\"Two\"\
    )));\n   |              ^                   ^\n   |\nhelp: remove these parentheses\n\
    \   |\n31 -     vec.push((String::from(\"Two\")));\n31 +     vec.push(String::from(\"\
    Two\"));\n   | \n\nwarning: unnecessary parentheses around method argument\n \
    \ --> /tmp/tmphgnwkpqt.rs:32:14\n   |\n32 |     vec.push((String::from(\"Three\"\
    )));\n   |              ^                     ^\n   |\nhelp: remove these parentheses\n\
    \   |\n32 -     vec.push((String::from(\"Three\")));\n32 +     vec.push(String::from(\"\
    Three\"));\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmphgnwkpqt.rs:33:14\n   |\n33 |     vec.push((String::from(\"Four\"\
    )));\n   |              ^                    ^\n   |\nhelp: remove these parentheses\n\
    \   |\n33 -     vec.push((String::from(\"Four\")));\n33 +     vec.push(String::from(\"\
    Four\"));\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmphgnwkpqt.rs:34:14\n   |\n34 |     vec.push((String::from(\"Five\"\
    )));\n   |              ^                    ^\n   |\nhelp: remove these parentheses\n\
    \   |\n34 -     vec.push((String::from(\"Five\")));\n34 +     vec.push(String::from(\"\
    Five\"));\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmphgnwkpqt.rs:35:14\n   |\n35 |     vec.push((String::from(\"Six\"\
    )));\n   |              ^      "
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr {\n        if 1 < i && i <= 9 {\n            result.push(String::from(\"\
    One\") + &format!(\"{:02}\", i));\n        } else if 10 < i {\n            result.push(String::from(\"\
    Two\") + &format!(\"{:02}\", i));\n        } else if 11 < i {\n            result.push(String::from(\"\
    Three\") + &format!(\"{:02}\", i));\n        } else if 12 < i {\n            result.push(String::from(\"\
    Four\") + &format!(\"{:02}\", i));\n        } else if 13 < i {\n            result.push(String::from(\"\
    Five\") + &format!(\"{:02}\", i));\n        } else if 14 < i {\n            result.push(String::from(\"\
    Six\") + &format!(\"{:02}\", i));\n        } else if 15 < i {\n            result.push(String::from(\"\
    Seven\") + &format!(\"{:02}\", i));\n        } else if 16 < i {\n            result.push(String::from(\"\
    Eight\") + &format!(\"{:02}\", i));\n        } else if 17 < i {\n            result.push(String::from(\"\
    Nine\") + &format!(\"{:02}\", i));\n        } else if 18 < i {\n            result.push(String::from(\"\
    Ten\") + &format!(\"{:02}\", i));\n        } else {\n            result.push(String::from(\"\
    Unknown\") + &format!(\"{:02}\", i));\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One02\", \"Unknown01\", \"Unknown01\", \"One04\", \"One05\", \"One08\",\
    \ \"One02\", \"One03\"]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\"\
    , \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpcpr4cw4k.rs:45:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut digits = String::from(\"\"\
    );\n        let mut is_reversed = false;\n        let mut j = 0;\n        for\
    \ i in arr.iter() {\n            if i > (9 - i).max() {\n                is_reversed\
    \ = true;\n                break;\n            }\n            digits += String::from(&i)\
    \ + &*j as String;\n            j += 1\n        }\n        vec![digits[..digits.len()\
    \ - 1].chars().rev().collect::<Vec<u8>>()].iter().fold(String::new(), |mut digits,\
    \ c| {\n            digits.push_str(&c[..]);\n            digits\n        })\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp84d_eu6j.rs:21:28\n    |\n21  |             if i > (9 - i).max()\
    \ {\n    |                            ^^^- supplied 0 arguments\n    |       \
    \                     |\n    |                            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp84d_eu6j.rs:21:20\n   |\n21 |             if i > (9 - i).max()\
    \ {\n   |                    ^^^^^^^^^^^^^\n   |                    |\n   |  \
    \                  expected `&isize`, found `isize`\n   |                    help:\
    \ consider borrowing here: `&(9 - i).max()`\n\nerror[E0277]: the trait bound `String:\
    \ From<&&isize>` is not satisfied\n  --> /tmp/tmp84d_eu6j.rs:25:23\n   |\n25 |\
    \             digits += String::from(&i) + &*j as String;\n   |              \
    \         ^^^^^^^^^^^^ the trait `From<&&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmp84d_eu6j.rs:25:43\n\
    \   |\n25 |             digits += String::from(&i) + &*j as String;\n   |    \
    \                                       ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp84d_eu6j.rs:25:23\n   |\n25 |             digits += String::from(&i)\
    \ + &*j as String;\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&str`, found\
    \ struct `String`\n   |                       help: consider borrowing here: `&(String::from(&i)\
    \ + &*j as String)`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp84d_eu6j.rs:28:55\n\
    \     |\n28   |         vec![digits[..digits.len() - 1].chars().rev().collect::<Vec<u8>>()].iter().fold(Stri"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut nums = arr.clone();\n\
    \    nums.sort_unstable();\n    let mut result = Vec::with_capacity(nums.len());\n\
    \    for i in nums.into_iter().rev() {\n        let j = nums.iter().position(|&x|\
    \ x == i).unwrap() + 1;\n        result.push(&\"One\".to_string()[j] as String);\n\
    \        result.push(&\"Two\".to_string()[j] as String);\n        result.push(&\"\
    Three\".to_string()[j] as String);\n        result.push(&\"Four\".to_string()[j]\
    \ as String);\n        result.push(&\"Five\".to_string()[j] as String);\n    \
    \    result.push(&\"Six\".to_string()[j] as String);\n        result.push(&\"\
    Seven\".to_string()[j] as String);\n        result.push(&\"Eight\".to_string()[j]\
    \ as String);\n        result.push(&\"Nine\".to_string()[j] as String);\n    \
    \    result.push(&\"Ten\".to_string()[j] as String);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8afi8tmq.rs:19:22\n\
    \   |\n19 |         result.push(&\"One\".to_string()[j] as String);\n   |    \
    \                  ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8afi8tmq.rs:20:22\n   |\n20 |         result.push(&\"Two\".to_string()[j]\
    \ as String);\n   |                      ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8afi8tmq.rs:21:22\n   |\n21 |         result.push(&\"Three\".to_string()[j]\
    \ as String);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeT"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut v = Vec::new();\n\
    \    for num in arr.iter() {\n        if num <= 9 {\n            v.push(String::from(\"\
    One\") + &num.to_string());\n        } else if num >= 10 {\n            v.push(String::from(\"\
    Two\") + &num.to_string());\n        } else if num >= 11 {\n            v.push(String::from(\"\
    Three\") + &num.to_string());\n        } else if num >= 12 {\n            v.push(String::from(\"\
    Four\") + &num.to_string());\n        } else if num >= 13 {\n            v.push(String::from(\"\
    Five\") + &num.to_string());\n        } else if num >= 14 {\n            v.push(String::from(\"\
    Six\") + &num.to_string());\n        } else if num >= 15 {\n            v.push(String::from(\"\
    Seven\") + &num.to_string());\n        } else if num >= 16 {\n            v.push(String::from(\"\
    Eight\") + &num.to_string());\n        } else if num >= 17 {\n            v.push(String::from(\"\
    Nine\") + &num.to_string());\n        } else {\n            continue;\n      \
    \  }\n    }\n    v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmwjq9ocv.rs:16:19\n   |\n\
    16 |         if num <= 9 {\n   |                   ^\n   |                   |\n\
    \   |                   expected `&isize`, found integer\n   |               \
    \    help: consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmwjq9ocv.rs:18:26\n   |\n18 |         } else if num >= 10 {\n  \
    \ |                          ^^\n   |                          |\n   |       \
    \                   expected `&isize`, found integer\n   |                   \
    \       help: consider borrowing here: `&10`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmwjq9ocv.rs:20:26\n   |\n20 |         } else if num >= 11 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: `&11`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmwjq9ocv.rs:22:26\n   |\n22 |         } else if num >= 12 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: `&12`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmwjq9ocv.rs:24:26\n   |\n24 |         } else if num >= 13 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: `&13`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmwjq9ocv.rs:26:26\n   |\n26 |         } else if num >= 14 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: `&14`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmwjq9ocv.rs:28:26\n   |\n28 |         } else if num >= 15 {\n \
    \  |                          ^^\n   |                          |\n   |      \
    \                    expected `&isize`, found integer\n   |                  \
    \        help: consider borrowing here: "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    // create a map of values that will\
    \ be ordered when sorted\n    let mut map = HashMap::new();\n    for &n in arr\
    \ {\n        match map.entry(n) {\n            hash_map::Entry::Occupied(mut o)\
    \ => {\n                o.set_val(n);\n            }\n            hash_map::Entry::Vacant(o)\
    \ => o.insert(n),\n        }\n    }\n\n    let mut arr = arr.iter().cloned().collect();\n\
    \    arr.sort_unstable_by_key(|&n| map.get(n).unwrap());\n    arr.reverse();\n\
    \n    arr.iter().map(|&n| {\n        match map.get(n) {\n            Some(i) =>\
    \ String::from(\"One\") + i as String,\n            None => String::from(\"Nine\"\
    ) + n as String,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmplxnsj1kd.rs:22:13\n   |\n22 |             hash_map::Entry::Occupied(mut\
    \ o) => {\n   |             ^^^^^^^^ use of undeclared crate or module `hash_map`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `hash_map`\n\
    \  --> /tmp/tmplxnsj1kd.rs:25:13\n   |\n25 |             hash_map::Entry::Vacant(o)\
    \ => o.insert(n),\n   |             ^^^^^^^^ use of undeclared crate or module\
    \ `hash_map`\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n\
    \  --> /tmp/tmplxnsj1kd.rs:19:19\n   |\n19 |     let mut map = HashMap::new();\n\
    \   |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplxnsj1kd.rs:20:9\n   |\n20 |     for &n in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplxnsj1kd.rs:35:46\n   |\n35 |             Some(i) => String::from(\"\
    One\") + i as String,\n   |                                              ^^^^^^^^^^^\n\
    \   |                                              |\n   |                   \
    \                           expected `&str`, found struct `String`\n   |     \
    \                                         help: consider borrowing here: `&(i\
    \ as String)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplxnsj1kd.rs:36:44\n\
    \   |\n36 |             None => String::from(\"Nine\") + n as String,\n   |  \
    \                                          ^^^^^^^^^^^\n   |                 \
    \                           |\n   |                                          \
    \  expected `&str`, found struct `String`\n   |                              \
    \              help: consider borrowing here: `&(n as String)`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    let mut j = 0;\n\n    while j < arr.len() {\n\
    \        let mut cur = vec![];\n\n        while i + 1 < arr.len() && j + 1 < arr.len()\
    \ {\n            if arr[j] < arr[i+1] {\n                cur.push(String::from(\"\
    One\"));\n                i += 1;\n            } else {\n                cur.push(String::from(\"\
    Nine\"));\n                i += 1;\n            }\n        }\n\n        if i <\
    \ arr.len() {\n            cur.push(String::from(\"Nine\"));\n        }\n\n  \
    \      result.push(cur);\n        i += 1;\n        j += 1\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpib3fj16n.rs:39:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    39 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut ans = Vec::with_capacity(arr.len());\n\
    \    let mut digits = arr.iter().map(|i| {\n        match i {\n            0 =>\
    \ \"One\",\n            1 => \"Two\",\n            2 => \"Three\",\n         \
    \   3 => \"Four\",\n            4 => \"Five\",\n            5 => \"Six\",\n  \
    \          6 => \"Seven\",\n            7 => \"Eight\",\n            8 => \"Nine\"\
    ,\n            _ => panic!(\"Unexpected value {:?} of int!\", i),\n        }\n\
    \    });\n\n    let mut carry = 0;\n    while !digits.next().is_some() {\n   \
    \     // reverse digits in the vector\n        digits.reverse();\n\n        //\
    \ update carry\n        carry = 0;\n\n        for &digit in digits {\n       \
    \     let result = digit + carry;\n\n            if result > 9 {\n           \
    \     ans.push(String::from(\"Nine\"));\n                carry = 1;\n        \
    \    } else if result > 0 {\n                ans.push(String::from(\"One\"));\n\
    \                carry = 1;\n            } else {\n                ans.push(String::from(\"\
    Zero\"));\n            }\n        }\n    }\n\n    // reverse final digits\n  \
    \  ans.reverse();\n    ans\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp5unur3hm.rs:37:16\n   |\n37 |         digits.reverse();\n\
    \   |                ^^^^^^^ method not found in `Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp5unur3hm.rs:19:37: 32:6]>`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp5unur3hm.rs:42:14\n\
    \   |\n42 |         for &digit in digits {\n   |              ^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0369]: cannot\
    \ add `{integer}` to `str`\n  --> /tmp/tmp5unur3hm.rs:43:32\n   |\n43 |      \
    \       let result = digit + carry;\n   |                          ----- ^ -----\
    \ {integer}\n   |                          |\n   |                          str\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut ret: Vec<String> = vec![];\n\
    \        let mut nums = arr.iter().cloned();\n\n        let mut reversed = false;\n\
    \n        while let Some(first) = nums.next() {\n            let last = nums.last().unwrap();\n\
    \            if last < first {\n                nums = nums.rev();\n         \
    \       ret.append(&mut nums);\n                reversed = true;\n           \
    \ }\n\n            ret.push((String::from(str::from_digit(first, 10).unwrap())))\n\
    \        }\n\n        if !reversed {\n            nums = nums.rev();\n       \
    \     ret.append(&mut nums);\n        }\n        ret\n    }\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpdbbnnhxv.rs:30:22\n\
    \   |\n30 |             ret.push((String::from(str::from_digit(first, 10).unwrap())))\n\
    \   |                      ^                                                 ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n30 -             ret.push((String::from(str::from_digit(first, 10).unwrap())))\n\
    30 +             ret.push(String::from(str::from_digit(first, 10).unwrap()))\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbbnnhxv.rs:25:24\n  \
    \ |\n18 |         let mut nums = arr.iter().cloned();\n   |                  \
    \      ------------------- expected due to this value\n...\n25 |             \
    \    nums = nums.rev();\n   |                        ^^^^^^^^^^ expected struct\
    \ `Cloned`, found struct `Rev`\n   |\n   = note: expected struct `Cloned<std::slice::Iter<'_,\
    \ _>>`\n              found struct `Rev<Cloned<std::slice::Iter<'_, _>>>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdbbnnhxv.rs:26:28\n   |\n26 |  \
    \               ret.append(&mut nums);\n   |                            ^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<String>`\n              found mutable reference `&mut Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no function or associated item named `from_digit`\
    \ found for type `str` in the current scope\n  --> /tmp/tmpdbbnnhxv.rs:30:41\n\
    \   |\n30 |             ret.push((String::from(str::from_digit(first, 10).unwrap())))\n\
    \   |                                         ^^^^^^^^^^ function or associated\
    \ item not found in `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbbnnhxv.rs:34:20\n\
    \   |\n18 |         let mut nums = arr.iter().cloned();\n   |                \
    \        ------------------- expected due to this value\n...\n34 |           \
    \  nums = nums.rev();\n   |                    ^^^^^^^^^^ expected struct `Cloned`,\
    \ found struct `Rev`\n   |\n   = note: expected struct `Cloned<std::slice::Iter<'_,\
    \ _>>`\n              found struct `Rev<Cloned<std::"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut new_arr = arr.clone();\n    new_arr.sort_unstable();\n\
    \    let mut names: Vec<String> = vec![];\n    new_arr.reverse();\n    let mut\
    \ cnt = 0;\n    while cnt < new_arr.len() {\n        let v = new_arr[cnt];\n \
    \       let n = name.by_number(v);\n        if n != Some(name) {\n           \
    \ names.push(n);\n        }\n        cnt += 1;\n    }\n    names\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpmiy3bqku.rs:24:17\n\
    \   |\n24 |         let n = name.by_number(v);\n   |                 ^^^^ help:\
    \ a local variable with a similar name exists: `names`\n\nerror[E0425]: cannot\
    \ find value `name` in this scope\n  --> /tmp/tmpmiy3bqku.rs:25:22\n   |\n25 |\
    \         if n != Some(name) {\n   |                      ^^^^ help: a local variable\
    \ with a similar name exists: `names`\n\nerror[E0277]: can't compare `String`\
    \ with `Option<_>`\n  --> /tmp/tmpmiy3bqku.rs:25:14\n   |\n25 |         if n !=\
    \ Some(name) {\n   |              ^^ no implementation for `String == Option<_>`\n\
    \   |\n   = help: the trait `PartialEq<Option<_>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut v = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    v.sort_unstable();\n    let mut out = vec![];\n    for i in v {\n       \
    \ if i < 10 {\n            out.push(String::from(\"One\"));\n        } else if\
    \ i >= 10 && i < 100 {\n            out.push(String::from(\"Two\"));\n       \
    \ } else if i >= 100 && i < 1000 {\n            out.push(String::from(\"Three\"\
    ));\n        } else if i >= 1000 && i < 10000 {\n            out.push(String::from(\"\
    Four\"));\n        } else if i >= 10000 && i < 100000 {\n            out.push(String::from(\"\
    Five\"));\n        } else if i >= 100000 && i < 1000000 {\n            out.push(String::from(\"\
    Six\"));\n        } else if i >= 1000000 && i < 10000000 {\n            out.push(String::from(\"\
    Seven\"));\n        } else if i >= 10000000 && i < 100000000 {\n            out.push(String::from(\"\
    Eight\"));\n        } else if i >= 100000000 && i < 1000000000 {\n           \
    \ out.push(String::from(\"Nine\"));\n        } else {\n            out.push(\"\
    NaN\");\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ipsi0x8.rs:41:22\n   |\n\
    41 |             out.push(\"NaN\");\n   |                      ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                      |\n   |\
    \                      expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut name_vec:\
    \ Vec<String> = vec![];\n    for i in arr {\n        name_vec.push(one_nine(i));\n\
    \    }\n    name_vec.reverse();\n    name_vec\n        .iter()\n        .map(|x|\
    \ String::from(x))\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `one_nine` in this scope\n  --> /tmp/tmpw2rtajuc.rs:16:23\n\
    \   |\n16 |         name_vec.push(one_nine(i));\n   |                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut new_arr = arr.to_vec();\n  \
    \  new_arr.reverse_iter().for_each(|a| {\n        match a {\n            1 =>\
    \ {\n                new_arr.insert((new_arr.len() - 1), \"One\");\n         \
    \   }\n            2 => {\n                new_arr.insert((new_arr.len() - 1),\
    \ \"Two\");\n            }\n            3 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Three\");\n            }\n            4 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Four\");\n            }\n            5 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Five\");\n            }\n            6 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Six\");\n            }\n            7 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Seven\");\n            }\n            8 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Eight\");\n            }\n            9 => {\n                new_arr.insert((new_arr.len()\
    \ - 1), \"Nine\");\n            }\n            _ => {\n            }\n       \
    \ }\n    });\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpxbzvtxtp.rs:22:32\n\
    \   |\n22 |                 new_arr.insert((new_arr.len() - 1), \"One\");\n  \
    \ |                                ^                 ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -                 new_arr.insert((new_arr.len()\
    \ - 1), \"One\");\n22 +                 new_arr.insert(new_arr.len() - 1, \"One\"\
    );\n   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpxbzvtxtp.rs:25:32\n\
    \   |\n25 |                 new_arr.insert((new_arr.len() - 1), \"Two\");\n  \
    \ |                                ^                 ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n25 -                 new_arr.insert((new_arr.len() - 1),\
    \ \"Two\");\n25 +                 new_arr.insert(new_arr.len() - 1, \"Two\");\n\
    \   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpxbzvtxtp.rs:28:32\n\
    \   |\n28 |                 new_arr.insert((new_arr.len() - 1), \"Three\");\n\
    \   |                                ^                 ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n28 -                 new_arr.insert((new_arr.len() - 1),\
    \ \"Three\");\n28 +                 new_arr.insert(new_arr.len() - 1, \"Three\"\
    );\n   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpxbzvtxtp.rs:31:32\n\
    \   |\n31 |                 new_arr.insert((new_arr.len() - 1), \"Four\");\n \
    \  |                                ^                 ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n31 -                 new_arr.insert((new_arr.len() - 1),\
    \ \"Four\");\n31 +                 new_arr.insert(new_arr.len() - 1, \"Four\"\
    );\n   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpxbzvtxtp.rs:34:32\n\
    \   |\n34 |                 new_arr.insert((new_arr.len() - 1), \"Five\");\n \
    \  |                                ^                 ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n34 -                 new_arr.insert((new_arr.len() - 1),\
    \ \"Five\");\n34 +                 new_arr.insert(new_arr.len() - 1, \"Five\"\
    );\n   | \n\nwarning: unnecessary parentheses aro"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut res = vec![];\n\n    for x in\
    \ arr {\n        if x <= 9 {\n            match x {\n                1 => res.push(String::from(\"\
    One\")),\n                2 => res.push(String::from(\"Two\")),\n            \
    \    3 => res.push(String::from(\"Three\")),\n                4 => res.push(String::from(\"\
    Four\")),\n                5 => res.push(String::from(\"Five\")),\n          \
    \      6 => res.push(String::from(\"Six\")),\n                7 => res.push(String::from(\"\
    Seven\")),\n                8 => res.push(String::from(\"Eight\")),\n        \
    \        9 => res.push(String::from(\"Nine\")),\n                _ => (),\n  \
    \          }\n        } else {\n            res.push(x);\n        }\n    }\n\n\
    \    res.reverse();\n\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptw97vu7l.rs:35:22\n   |\n\
    35 |             res.push(x);\n   |                      ^- help: try using a\
    \ conversion method: `.to_string()`\n   |                      |\n   |       \
    \               expected struct `String`, found `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted =\
    \ arr.clone(); // clone the array\n    std::mem::swap(&mut sorted, &mut sorted.iter_mut().rev());\
    \ // sort in reverse order\n    for &i in sorted {\n        i %= 10; // map 0-9\
    \ to \"One\", \"Two\", \"Three\", ...\n        arr[i.to_string()] = Some(String::from(&format_str_vec!(\"\
    {}\", i)));\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `format_str_vec` in this scope\n  --> /tmp/tmpnurdk6xm.rs:18:49\n\
    \   |\n18 |         arr[i.to_string()] = Some(String::from(&format_str_vec!(\"\
    {}\", i)));\n   |                                                 ^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnurdk6xm.rs:15:33\n   |\n15 |\
    \     std::mem::swap(&mut sorted, &mut sorted.iter_mut().rev()); // sort in reverse\
    \ order\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Rev`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<isize>`\n              found mutable reference `&mut Rev<std::slice::IterMut<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnurdk6xm.rs:16:9\n\
    \   |\n16 |     for &i in sorted {\n   |         ^^    ------ this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnurdk6xm.rs:20:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n20 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result: Vec<String>\
    \ = vec![];\n    for v in arr {\n        if v < 1 || v > 9 {\n            continue;\n\
    \        }\n        result.push(*to_name(v));\n    }\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_name` in this scope\n  --> /tmp/tmp77ul5qlu.rs:19:22\n\
    \   |\n19 |         result.push(*to_name(v));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut rev = arr.clone();\n    rev.sort();\n\
    \    rev.reverse();\n    rev.reverse();\n    arr.iter_mut().for_each(|i| {\n \
    \       if i > 0 && i % 10 == 0 {\n            *i = String::from(&rev.last());\n\
    \            rev.pop();\n        }\n    });\n    rev\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp77z42c4a.rs:22:16\n   |\n\
    22 |         if i > 0 && i % 10 == 0 {\n   |                ^\n   |          \
    \      |\n   |                expected `&mut isize`, found integer\n   |     \
    \           help: consider mutably borrowing here: `&mut 0`\n\nerror[E0369]: cannot\
    \ mod `&mut isize` by `{integer}`\n  --> /tmp/tmp77z42c4a.rs:22:23\n   |\n22 |\
    \         if i > 0 && i % 10 == 0 {\n   |                     - ^ -- {integer}\n\
    \   |                     |\n   |                     &mut isize\n   |\nhelp:\
    \ `%` can be used on `isize`, you can dereference `i`\n   |\n22 |         if i\
    \ > 0 && *i % 10 == 0 {\n   |                     +\n\nerror[E0277]: the trait\
    \ bound `String: From<&Option<&isize>>` is not satisfied\n  --> /tmp/tmp77z42c4a.rs:23:18\n\
    \   |\n23 |             *i = String::from(&rev.last());\n   |                \
    \  ^^^^^^^^^^^^ the trait `From<&Option<&isize>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp77z42c4a.rs:23:18\n   |\n23 |\
    \             *i = String::from(&rev.last());\n   |             --   ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77z42c4a.rs:27:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n27 |     rev\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_by_key(|x|\
    \ {\n        x.checked_mul(10).ok_or(Error::invalid_number(x))\n    }).reverse().iter()\n\
    \        .filter(|x| x.checked_sub(1..=9).is_err())\n        .map(|x| String::from(\n\
    \            &format!(\"{}\", x.checked_sub(1..=9).unwrap())[..],\n        ))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpj5f8apk7.rs:15:33\n   |\n15 |         x.checked_mul(10).ok_or(Error::invalid_number(x))\n\
    \   |                                 ^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::error::Error;\n \
    \  |\n1  | use std::fmt::Error;\n   |\n1  | use std::io::Error;\n   |\n\nerror[E0599]:\
    \ no method named `reverse` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpj5f8apk7.rs:16:8\n   |\n16 |     }).reverse().iter()\n   |        ^^^^^^^\
    \ method not found in `()`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    debug_assert!(arr.len()\
    \ > 0);\n    let mut v = arr.iter().cloned().collect::<Vec<String>>();\n    v.sort_by_key(|i|\
    \ i as isize);\n    v.reverse();\n    for d in v.iter() {\n        v.iter_mut().map(|&i|\
    \ if i == d { String::from(\"One\") } else { String::from(\"Nine\") }).collect();\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmp4imry1z8.rs:15:37\n     |\n15\
    \   |     let mut v = arr.iter().cloned().collect::<Vec<String>>();\n     |  \
    \                                   ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait\
    \ `FromIterator<isize>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4imry1z8.rs:19:27\n\
    \   |\n19 |         v.iter_mut().map(|&i| if i == d { String::from(\"One\") }\
    \ else { String::from(\"Nine\") }).collect();\n   |                          \
    \ ^--\n   |                           ||\n   |                           |expected\
    \ due to this\n   |                           types differ in mutability\n   |\
    \                           help: did you mean `i`: `&&mut String`\n   |\n   =\
    \ note: expected mutable reference `&mut String`\n                      found\
    \ reference `&_`\n\nerror[E0606]: casting `&String` as `isize` is invalid\n  -->\
    \ /tmp/tmp4imry1z8.rs:16:23\n   |\n16 |     v.sort_by_key(|i| i as isize);\n \
    \  |                       ^^^^^^^^^^\n   |\n   = help: cast through a raw pointer\
    \ first\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ret = vec![String::from(\"One\"\
    )];\n    for elem in arr.iter() {\n        let val = if elem < 10 { elem } else\
    \ {\n            match elem % 10 {\n                0 => \"Zero\",\n         \
    \       1 => \"One\",\n                2 => \"Two\",\n                3 => \"\
    Three\",\n                4 => \"Four\",\n                5 => \"Five\",\n   \
    \             6 => \"Six\",\n                7 => \"Seven\",\n               \
    \ 8 => \"Eight\",\n                9 => \"Nine\",\n            }\n        };\n\
    \        ret.push(val);\n    }\n    ret.rev();\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpshdkg4zm.rs:19:29\n   |\n\
    19 |         let val = if elem < 10 { elem } else {\n   |                    \
    \         ^^\n   |                             |\n   |                       \
    \      expected `&isize`, found integer\n   |                             help:\
    \ consider borrowing here: `&10`\n\nerror[E0308]: `if` and `else` have incompatible\
    \ types\n  --> /tmp/tmpshdkg4zm.rs:20:13\n   |\n19 |            let val = if elem\
    \ < 10 { elem } else {\n   |                      -              ---- expected\
    \ because of this\n   |   ___________________|\n   |  |\n20 |  |             match\
    \ elem % 10 {\n   |  |_____________^\n21 | ||                 0 => \"Zero\",\n\
    22 | ||                 1 => \"One\",\n23 | ||                 2 => \"Two\",\n\
    ...  ||\n30 | ||                 9 => \"Nine\",\n31 | ||             }\n   | ||_____________^\
    \ expected `isize`, found `str`\n32 |  |         };\n   |  |_________- `if` and\
    \ `else` have incompatible types\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&str`\n\nerror[E0599]: `Vec<String>` is not an\
    \ iterator\n   --> /tmp/tmpshdkg4zm.rs:35:9\n    |\n35  |       ret.rev();\n \
    \   |           ^^^ `Vec<String>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<String>: Iterator`\n    \
    \        which is required by `&mut Vec<String>: Iterator`\n            `[String]:\
    \ Iterator`\n            which is required by `&mut [String]: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut reversed\
    \ = arr\n        .into_iter()\n        .enumerate()\n        .filter_map(|(i,\
    \ s)| {\n            if i > 0\n                && (s + 1) > i\n              \
    \  && (s - 1) > i\n                && (s + 10) < i\n                && (s - 10)\
    \ < i\n            {\n                Some(s + 1 - i)\n            } else {\n\
    \                None\n            }\n        })\n        .collect::<Vec<_>>();\n\
    \    reversed.reverse();\n    let mut new_arr = vec![];\n    for d in reverse\
    \ {\n        new_arr.push(format!(\"{}\", d));\n    }\n    new_arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `reverse` in this scope\n  --> /tmp/tmpw7ykuqc6.rs:32:14\n\
    \   |\n32 |     for d in reverse {\n   |              ^^^^^^^ help: a local variable\
    \ with a similar name exists: `reversed`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpw7ykuqc6.rs:19:30\n   |\n19 |                 && (s + 1) > i\n \
    \  |                              ^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n19 |                 && (s + 1) > i.try_into().unwrap()\n   |   \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7ykuqc6.rs:20:30\n   |\n20 |                 && (s - 1)\
    \ > i\n   |                              ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |                 && (s - 1) > i.try_into().unwrap()\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7ykuqc6.rs:21:31\n   |\n21 |                 && (s + 10)\
    \ < i\n   |                               ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |                 && (s + 10) < i.try_into().unwrap()\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7ykuqc6.rs:22:31\n   |\n22 |                 && (s - 10)\
    \ < i\n   |                               ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 && (s - 10) < i.try_into().unwrap()\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw7ykuqc6.rs:24:30\n   |\n24 |                 Some(s +\
    \ 1 - i)\n   |                              ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpw7ykuqc6.rs:24:22\n\
    \   |\n24 |                 Som"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut v = vec![];\n\
    \n    for i in arr {\n        v.push(by_length(i));\n    }\n\n    if arr.is_empty()\
    \ {\n        return v;\n    }\n\n    let mut num_ones = 0;\n    let mut num_tens\
    \ = 0;\n    let mut num_hundreds = 0;\n\n    let mut i = 0;\n\n    while i < arr.len()\
    \ {\n        match arr[i] {\n            1 => {\n                v.push(String::from(\"\
    One\"));\n                num_ones += 1;\n                i += 1;\n          \
    \  }\n            10 => {\n                v.push(String::from(\"Ten\"));\n  \
    \              num_tens += 1;\n                i += 1;\n            }\n      \
    \      100 => {\n                v.push(String::from(\"Hundred\"));\n        \
    \        num_hundreds += 1;\n                i += 1;\n            }\n        \
    \    _ => i += 1,\n        }\n    }\n\n    if num_ones == 0 {\n        v.push(String::from(\"\
    One\"));\n    }\n\n    if num_tens == 0 && num_hundreds == 0 {\n        v.push(String::from(\"\
    Ten\"));\n    }\n\n    if num_tens == 0 && num_hundreds > 0 {\n        v.push(String::from(\"\
    Hundred\"));\n    }\n\n    if num_tens > 0 || num_hundreds > 0 {\n        v.push(String::from(\"\
    Other\"));\n    }\n\n    v\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:17:26\n   |\n\
    17 |         v.push(by_length(i));\n   |                          ^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:21:16\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n21 |         return v;\n   |                ^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<Vec<String>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:33:24\n\
    \   |\n33 |                 v.push(String::from(\"One\"));\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:38:24\n   |\n38 |\
    \                 v.push(String::from(\"Ten\"));\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:43:24\n   |\n43 |  \
    \               v.push(String::from(\"Hundred\"));\n   |                     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwg94oo5e.rs:52:16\n   |\n52 |\
    \         v.push(String::from(\"One\"));\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `String`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwg94oo5e.rs:56:16\n   |\n56 |         v.push(String::from(\"\
    Ten\"));\n   |                ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `String`\n   |\n   = note: expected stru"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for i in arr.iter() {\n        if i <= 9 {\n            result.push(\
    \ String::from(\"One\") );\n        } else if i <= 99 {\n            result.push(\
    \ String::from(\"Two\") );\n        } else if i <= 999 {\n            result.push(\
    \ String::from(\"Three\") );\n        } else if i <= 9999 {\n            result.push(\
    \ String::from(\"Four\") );\n        } else if i <= 99999 {\n            result.push(\
    \ String::from(\"Five\") );\n        } else if i <= 999999 {\n            result.push(\
    \ String::from(\"Six\") );\n        } else if i <= 9999999 {\n            result.push(\
    \ String::from(\"Seven\") );\n        } else if i <= 999999999 {\n           \
    \ result.push( String::from(\"Eight\") );\n        } else if i <= 99999999999\
    \ {\n            result.push( String::from(\"Nine\") );\n        } else {\n  \
    \          return Vec::new();\n        }\n    }\n    result.reverse_iter().for_each(|i|\
    \ {\n        match i {\n            1 => result.push( String::from(\"One\") ),\n\
    \            2 => result.push( String::from(\"Two\") ),\n            3 => result.push(\
    \ String::from(\"Three\") ),\n            4 => result.push( String::from(\"Four\"\
    ) ),\n            5 => result.push( String::from(\"Five\") ),\n            6 =>\
    \ result.push( String::from(\"Six\") ),\n            7 => result.push( String::from(\"\
    Seven\") ),\n            8 => result.push( String::from(\"Eight\") ),\n      \
    \      9 => result.push( String::from(\"Nine\") ),\n            x => {}\n    \
    \    }\n    });\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgowb714g.rs:16:17\n   |\n\
    16 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgowb714g.rs:18:24\n\
    \   |\n18 |         } else if i <= 99 {\n   |                        ^^\n   |\
    \                        |\n   |                        expected `&isize`, found\
    \ integer\n   |                        help: consider borrowing here: `&99`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgowb714g.rs:20:24\n   |\n20 |  \
    \       } else if i <= 999 {\n   |                        ^^^\n   |          \
    \              |\n   |                        expected `&isize`, found integer\n\
    \   |                        help: consider borrowing here: `&999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgowb714g.rs:22:24\n   |\n22 |         } else\
    \ if i <= 9999 {\n   |                        ^^^^\n   |                     \
    \   |\n   |                        expected `&isize`, found integer\n   |    \
    \                    help: consider borrowing here: `&9999`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgowb714g.rs:24:24\n   |\n24 |         } else if i <= 99999\
    \ {\n   |                        ^^^^^\n   |                        |\n   |  \
    \                      expected `&isize`, found integer\n   |                \
    \        help: consider borrowing here: `&99999`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgowb714g.rs:26:24\n   |\n26 |         } else if i <= 999999 {\n\
    \   |                        ^^^^^^\n   |                        |\n   |     \
    \                   expected `&isize`, found integer\n   |                   \
    \     help: consider borrowing here: `&999999`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgowb714g.rs:28:24\n   |\n28 |         } else if i <= 9999999 {\n\
    \   |                        ^^^^^^^\n   |                        |\n   |    \
    \                    expected `&isize`, found integer\n   |                  \
    \      help: consider borrowing here: `&9999999`\n\nerror[E0308]: mism"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    use std::cmp::Ordering;\n\
    \n    if arr.is_empty() {\n        return vec![];\n    }\n\n    if arr.len() ==\
    \ 1 {\n        return vec![String::from(\"One\")];\n    }\n\n    let mut lens\
    \ = vec![];\n\n    for n in arr {\n        if n > 9 {\n            lens.push(String::from(\"\
    Nine\"));\n        }\n        if n > 8 {\n            lens.push(String::from(\"\
    Eight\"));\n        }\n        if n > 7 {\n            lens.push(String::from(\"\
    Seven\"));\n        }\n        if n > 6 {\n            lens.push(String::from(\"\
    Six\"));\n        }\n        if n > 5 {\n            lens.push(String::from(\"\
    Five\"));\n        }\n        if n > 4 {\n            lens.push(String::from(\"\
    Four\"));\n        }\n        if n > 3 {\n            lens.push(String::from(\"\
    Three\"));\n        }\n        if n > 2 {\n            lens.push(String::from(\"\
    Two\"));\n        }\n        if n > 1 {\n            lens.push(String::from(\"\
    One\"));\n        }\n    }\n\n    lens.sort_by(|a, b| a.cmp(b));\n    lens.reverse();\n\
    \    for n in lens {\n        if n == String::from(\"One\") {\n            vec![String::from(\"\
    One\"), String::from(\"Two\"), String::from(\"Three\"), String::from(\"Four\"\
    ), String::from(\"Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"\
    Eight\"), String::from(\"Nine\")]\n        } else {\n            vec![n]\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpoohvn2nr.rs:14:9\n\
    \   |\n14 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoohvn2nr.rs:60:13\n   |\n59 | /         if n == String::from(\"\
    One\") {\n60 | |             vec![String::from(\"One\"), String::from(\"Two\"\
    ), String::from(\"Three\"), String::from(\"Four\"), String::from(\"Five\"), String::from(\"\
    Six\"), String::from(\"Seven\"), String::from(\"Eight\"), String::from(\"Nine\"\
    )]\n   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `Vec`\n61 | |         } else {\n62 | |         \
    \    vec![n]\n63 | |         }\n   | |_________- expected this to be `()`\n  \
    \ |\n   = note: expected unit type `()`\n                 found struct `Vec<String>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n63 |         };\n   |          +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoohvn2nr.rs:62:13\n   |\n59 | / ...   if n == String::from(\"One\")\
    \ {\n60 | | ...       vec![String::from(\"One\"), String::from(\"Two\"), String::from(\"\
    Three\"), String::from(\"Four\"), String::from(\"Five\"), String::from(...\n61\
    \ | | ...   } else {\n62 | | ...       vec![n]\n   | |           ^^^^^^^ expected\
    \ `()`, found struct `Vec`\n63 | | ...   }\n   | |_______- expected this to be\
    \ `()`\n   |\n   = note: expected unit type `()`\n                 found struct\
    \ `Vec<String>`\n   = note: this error originates in the macro `vec` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\nhelp: consider using a semicolon\
    \ here\n   |\n63 |         };\n   |          +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoohvn2nr.rs:58:5\n   |\n13 |   fn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n   |                                    ----------- e"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    for i in\
    \ arr.iter() {\n        if i <= 9 {\n            result.push(String::from(&format!(\"\
    {}\", i)));\n        }\n    }\n    for i in arr.iter_mut() {\n        if i >=\
    \ 1 && i <= 9 {\n            *i = format!(\"{}\", i).to_digit(10);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpke9nnlsj.rs:19:17\n   |\n\
    19 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpke9nnlsj.rs:24:17\n\
    \   |\n24 |         if i >= 1 && i <= 9 {\n   |                 ^\n   |      \
    \           |\n   |                 expected `&mut isize`, found integer\n   |\
    \                 help: consider mutably borrowing here: `&mut 1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpke9nnlsj.rs:24:27\n   |\n24 |         if i >=\
    \ 1 && i <= 9 {\n   |                           ^\n   |                      \
    \     |\n   |                           expected `&mut isize`, found integer\n\
    \   |                           help: consider mutably borrowing here: `&mut 9`\n\
    \nerror[E0599]: no method named `to_digit` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpke9nnlsj.rs:25:35\n   |\n25 |             *i = format!(\"\
    {}\", i).to_digit(10);\n   |                                   ^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        1 => vec![String::from(\"One\")],\n        2 =>\
    \ vec![String::from(\"Two\")],\n        3 => vec![String::from(\"Three\")],\n\
    \        4 => vec![String::from(\"Four\")],\n        5 => vec![String::from(\"\
    Five\")],\n        6 => vec![String::from(\"Six\")],\n        7 => vec![String::from(\"\
    Seven\")],\n        8 => vec![String::from(\"Eight\")],\n        9 => vec![String::from(\"\
    Nine\")],\n        _ => {\n            let mut v = vec![];\n            let mut\
    \ i = 0;\n            let mut max = arr.len();\n            while i < max {\n\
    \                if arr[i] < 9 {\n                    v.push(String::from(format!(\"\
    {}\", arr[i])));\n                    i += 1;\n                } else {\n    \
    \                let index = arr[i] - 10;\n                    let s = vec![\n\
    \                        String::from(\"One\"),\n                        String::from(\"\
    Two\"),\n                        String::from(\"Three\"),\n                  \
    \      String::from(\"Four\"),\n                        String::from(\"Five\"\
    ),\n                        String::from(\"Six\"),\n                        String::from(\"\
    Seven\"),\n                        String::from(\"Eight\"),\n                \
    \        String::from(\"Nine\"),\n                    ];\n                   \
    \ v.push(s.iter().nth(index).cloned());\n                    i += 1;\n       \
    \         }\n            }\n            v\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_481s0v.rs:46:41\n   |\n\
    46 |                     v.push(s.iter().nth(index).cloned());\n   |         \
    \                                ^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n46 |                     v.push(s.iter().nth(index.try_into().unwrap()).cloned());\n\
    \   |                                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf_481s0v.rs:46:28\n   |\n46 |              \
    \       v.push(s.iter().nth(index).cloned());\n   |                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut min = arr.iter().min();\n  \
    \  let mut max = arr.iter().max();\n    let mut i = 0;\n    let mut out = vec![];\n\
    \    while i <= 9 && i <= max {\n        if i <= 9 {\n            out.push(String::from(format!(\"\
    One\", i)));\n            i += 1;\n        } else {\n            if i >= min {\n\
    \                out.push(String::from(format!(\"Eight\", i)));\n            \
    \    i += 8;\n            } else {\n                out.push(String::from(format!(\"\
    Five\", i)));\n                i += 5;\n            }\n        }\n    }\n    while\
    \ i <= min {\n        out.push(String::from(format!(\"One\", i)));\n        i\
    \ += 1;\n    }\n    while i <= max {\n        out.push(String::from(format!(\"\
    Nine\", i)));\n        i += 9;\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpnveuit_9.rs:24:50\n   |\n24 |\
    \             out.push(String::from(format!(\"One\", i)));\n   |             \
    \                              -----  ^ argument never used\n   |            \
    \                               |\n   |                                      \
    \     formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpnveuit_9.rs:28:56\n\
    \   |\n28 |                 out.push(String::from(format!(\"Eight\", i)));\n \
    \  |                                               -------  ^ argument never used\n\
    \   |                                               |\n   |                  \
    \                             formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpnveuit_9.rs:31:55\n   |\n31 |                 out.push(String::from(format!(\"\
    Five\", i)));\n   |                                               ------  ^ argument\
    \ never used\n   |                                               |\n   |     \
    \                                          formatting specifier missing\n\nerror:\
    \ argument never used\n  --> /tmp/tmpnveuit_9.rs:37:46\n   |\n37 |         out.push(String::from(format!(\"\
    One\", i)));\n   |                                       -----  ^ argument never\
    \ used\n   |                                       |\n   |                   \
    \                    formatting specifier missing\n\nerror: argument never used\n\
    \  --> /tmp/tmpnveuit_9.rs:41:47\n   |\n41 |         out.push(String::from(format!(\"\
    Nine\", i)));\n   |                                       ------  ^ argument never\
    \ used\n   |                                       |\n   |                   \
    \                    formatting specifier missing\n\nerror[E0277]: can't compare\
    \ `{integer}` with `Option<&isize>`\n  --> /tmp/tmpnveuit_9.rs:22:23\n   |\n22\
    \ |     while i <= 9 && i <= max {\n   |                       ^^ no implementation\
    \ for `{integer} < Option<&isize>` and `{integer} > Option<&isize>`\n   |\n  \
    \ = help: the trait `PartialOrd<Option<&isize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        1 => vec![String::from(\"One\")],\n        _ =>\
    \ {\n            let mut numbers = vec![];\n            for i in arr.iter() {\n\
    \                numbers.push(String::from(numbers_to_names(i)));\n          \
    \  }\n            numbers.reverse();\n            numbers\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `numbers_to_names` in this scope\n \
    \ --> /tmp/tmpi4l5k9hs.rs:20:43\n   |\n20 |                 numbers.push(String::from(numbers_to_names(i)));\n\
    \   |                                           ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() > 9 {\n        return vec![String::from(\"\
    One\")];\n    }\n    if arr.len() < 1 {\n        return vec![];\n    }\n    if\
    \ arr.len() > 1 {\n        arr.sort_unstable_by_key(|&x| if x <= 9 { x } else\
    \ { x - 10 });\n    }\n    arr.reverse();\n    arr\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, &x)| {\n            let len = vec![];\n            while x\
    \ > 0 {\n                len.push(by_length(x));\n                x /= 10;\n \
    \           }\n            vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"][i..i + len.len()]\n        })\n   \
    \     .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe1ni2_7q.rs:33:36\n   |\n\
    33 |                 len.push(by_length(x));\n   |                           \
    \         ^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found type `isize`\n\nerror[E0277]: the size for\
    \ values of type `[&str]` cannot be known at compilation time\n   --> /tmp/tmpe1ni2_7q.rs:30:14\n\
    \    |\n30  |           .map(|(i, &x)| {\n    |  __________---_^\n    | |    \
    \      |\n    | |          required by a bound introduced by this call\n31  |\
    \ |             let len = vec![];\n32  | |             while x > 0 {\n33  | |\
    \                 len.push(by_length(x));\n...   |\n36  | |             vec![\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][i..i + len.len()]\n37  | |         })\n    | |_________^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `[&str]`\nnote: required by a bound in `map`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpe1ni2_7q.rs:30:14:\
    \ 37:10]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpe1ni2_7q.rs:38:10\n\
    \   |\n38 |           .collect()\n   |            ^^^^^^^ method cannot be called\
    \ on `Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpe1ni2_7q.rs:30:14:\
    \ 37:10]>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Map<Enumerate<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmpe1ni2_7q.rs:30:14: 37:10]>: Iterator`\n           which is\
    \ required by `&mut Map<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpe1ni2_7q.rs:30:14:\
    \ 37:10]>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut digits = arr.clone();\n\n    let length = digits.iter().map(|i| i.checked_digit(10).unwrap()).sum();\n\
    \    if length == 0 {\n        return result;\n    }\n\n    for d in digits.iter_mut()\
    \ {\n        if d > 9 {\n            break;\n        }\n\n        if d < 10 {\n\
    \            *d = (d - 10).checked_digit(10).unwrap();\n        }\n    }\n\n \
    \   let mut max_digit = digits[digits.len() - 1];\n    for digit in digits.iter()\
    \ {\n        if digit > 9 {\n            break;\n        }\n\n        if digit\
    \ < 10 {\n            max_digit = digit;\n        }\n    }\n\n    let mut reversed\
    \ = digits.iter().cloned().rev();\n    let mut count = 0;\n    while count < max_digit.checked_digit(10).unwrap()\
    \ {\n        count += 1;\n        reversed = reversed + vec![String::from(\"Zero\"\
    ), String::from(\"One\"), String::from(\"Two\"), String::from(\"Three\"), String::from(\"\
    Four\"), String::from(\"Five\"), String::from(\"Six\"), String::from(\"Seven\"\
    ), String::from(\"Eight\"), String::from(\"Nine\")];\n    }\n\n    for digit in\
    \ reversed {\n        result.push(digit);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_digit` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp11br5b08.rs:21:42\n   |\n21 |     let length\
    \ = digits.iter().map(|i| i.checked_digit(10).unwrap()).sum();\n   |         \
    \                                 ^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `checked_div`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp11br5b08.rs:27:16\n   |\n27 |         if d > 9 {\n   |             \
    \   ^\n   |                |\n   |                expected `&mut isize`, found\
    \ integer\n   |                help: consider mutably borrowing here: `&mut 9`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp11br5b08.rs:31:16\n   |\n31 |\
    \         if d < 10 {\n   |                ^^\n   |                |\n   |   \
    \             expected `&mut isize`, found integer\n   |                help:\
    \ consider mutably borrowing here: `&mut 10`\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `&mut isize`\n  --> /tmp/tmp11br5b08.rs:32:21\n   |\n32 | \
    \            *d = (d - 10).checked_digit(10).unwrap();\n   |                 \
    \  - ^ -- {integer}\n   |                   |\n   |                   &mut isize\n\
    \   |\nhelp: `-` can be used on `isize`, you can dereference `d`\n   |\n32 | \
    \            *d = (*d - 10).checked_digit(10).unwrap();\n   |                \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11br5b08.rs:38:20\n   |\n\
    38 |         if digit > 9 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp11br5b08.rs:42:20\n   |\n42 |         if digit < 10 {\n   |   \
    \                 ^^\n   |                    |\n   |                    expected\
    \ `&isize`, found integer\n   |                    help: consider borrowing here:\
    \ `&10`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp11br5b08.rs:43:25\n \
    \  |\n36 |     let mut max_digit = digits[digits.len() - 1];\n   |           \
    \              ------------------------ expected due to this value\n...\n43 |\
    \             max_"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut res = vec![];\n    let mut digits_vec\
    \ = vec![String::from(\"One\"), String::from(\"Two\"), String::from(\"Three\"\
    ), String::from(\"Four\"),\n                            String::from(\"Five\"\
    ), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"Eight\"),\n\
    \                            String::from(\"Nine\")];\n\n    let mut digits_arr\
    \ = arr.to_owned();\n\n    digits_arr.sort();\n\n    let mut counter = 1;\n\n\
    \    for d in digits_arr {\n        counter += 1;\n        let mut digit = String::from(digits_vec.get_mut(counter).unwrap());\n\
    \        if d < 10 {\n            digit = digit.clone();\n            digit =\
    \ digit.to_owned() + String::from(digits_vec.get_mut(counter + 1).unwrap());\n\
    \        } else {\n            digit = digit.clone();\n            digit = digit.to_owned()\
    \ + String::from(digits_vec.get_mut(counter + 1).unwrap());\n            digit\
    \ = digit.to_owned() + String::from(digits_vec.get_mut(counter + 2).unwrap());\n\
    \        }\n        res.push(digit);\n    }\n\n    res\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&mut String>` is not satisfied\n\
    \  --> /tmp/tmpumuadpc2.rs:31:38\n   |\n31 |         let mut digit = String::from(digits_vec.get_mut(counter).unwrap());\n\
    \   |                         ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `From<&mut String>`\n   |                 \
    \        |\n   |                         required by a bound introduced by this\
    \ call\n   |\nhelp: consider mutably borrowing here\n   |\n31 |         let mut\
    \ digit = String::from(&mut digits_vec.get_mut(counter).unwrap());\n   |     \
    \                                 ++++\n\nerror[E0277]: the trait bound `String:\
    \ From<&mut String>` is not satisfied\n  --> /tmp/tmpumuadpc2.rs:34:53\n   |\n\
    34 |             digit = digit.to_owned() + String::from(digits_vec.get_mut(counter\
    \ + 1).unwrap());\n   |                                        ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `From<&mut String>`\n   |                 \
    \                       |\n   |                                        required\
    \ by a bound introduced by this call\n   |\nhelp: consider mutably borrowing here\n\
    \   |\n34 |             digit = digit.to_owned() + String::from(&mut digits_vec.get_mut(counter\
    \ + 1).unwrap());\n   |                                                     ++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpumuadpc2.rs:34:40\n   |\n34 |\
    \             digit = digit.to_owned() + String::from(digits_vec.get_mut(counter\
    \ + 1).unwrap());\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                        |\n   |                         \
    \               expected `&str`, found struct `String`\n   |                 \
    \                       help: consider borrowing here: `&String::from(digits_vec.get_mut(counter\
    \ + 1).unwrap())`\n\nerror[E0277]: the trait bound `String: From<&mut String>`\
    \ is not satisfied\n  --> /tmp/tmpumuadpc2.rs:37:53\n   |\n37 |             digit\
    \ = digit.to_owned() + String::from(digits_vec.get_mut(counte"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ans = vec![];\n    let mut lengths\
    \ = arr.iter().map(|x| x.len()).collect::<Vec<_>>();\n    lengths.sort();\n  \
    \  let mut i = 0;\n    while lengths[i] != 0 {\n        ans.push(String::from(&arr[i\
    \ as usize][0].to_string()));\n        i += 1;\n    }\n    ans.reverse();\n  \
    \  ans\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpfpgbe07h.rs:18:44\n   |\n18 |     let mut lengths\
    \ = arr.iter().map(|x| x.len()).collect::<Vec<_>>();\n   |                   \
    \                         ^^^ method not found in `&isize`\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmpfpgbe07h.rs:22:32\n   |\n\
    22 |         ans.push(String::from(&arr[i as usize][0].to_string()));\n   |  \
    \                              ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result: Vec<String>\
    \ = Vec::new();\n    if arr.len() > 0 {\n        let mut current_num: isize =\
    \ 0;\n        let mut max_num: isize = 0;\n        for num in arr.iter() {\n \
    \           if num > 0 && num < 10 {\n                current_num = num;\n   \
    \         } else {\n                let name = match num {\n                 \
    \   0 => \"Zero\",\n                    1 => \"One\",\n                    2 =>\
    \ \"Two\",\n                    3 => \"Three\",\n                    4 => \"Four\"\
    ,\n                    5 => \"Five\",\n                    6 => \"Six\",\n   \
    \                 7 => \"Seven\",\n                    8 => \"Eight\",\n     \
    \               9 => \"Nine\",\n                    _ => String::from(\"Other\"\
    ),\n                };\n                result.push(name);\n                max_num\
    \ = num;\n            }\n        }\n        let mut final_num: isize = current_num;\n\
    \        for num in arr.iter() {\n            if num < 10 {\n                while\
    \ num < 10 {\n                    final_num = final_num * 10;\n              \
    \      final_num += num;\n                }\n            }\n        }\n      \
    \  let mut reverse = vec![String::from(\"Zero\"), String::from(\"One\"), String::from(\"\
    Two\"), String::from(\"Three\"), String::from(\"Four\"), String::from(\"Five\"\
    ), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"Eight\"), String::from(\"\
    Nine\")];\n        reverse.sort_unstable();\n        for num in reverse.iter()\
    \ {\n            if final_num > max_num {\n                let name = match num\
    \ {\n                    0 => \"Zero\",\n                    1 => \"One\",\n \
    \                   2 => \"Two\",\n                    3 => \"Three\",\n     \
    \               4 => \"Four\",\n                    5 => \"Five\",\n         \
    \           6 => \"Six\",\n                    7 => \"Seven\",\n             \
    \       8 => \"Eight\",\n                    9 => \"Nine\",\n                \
    \    _ => String::from(\"Other\"),\n                };\n                result.push(name);\n\
    \                final_num -= num;\n            } else {\n                break;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybqtgsfx.rs:19:22\n   |\n\
    19 |             if num > 0 && num < 10 {\n   |                      ^\n   | \
    \                     |\n   |                      expected `&isize`, found integer\n\
    \   |                      help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpybqtgsfx.rs:19:33\n   |\n19 |             if\
    \ num > 0 && num < 10 {\n   |                                 ^^\n   |       \
    \                          |\n   |                                 expected `&isize`,\
    \ found integer\n   |                                 help: consider borrowing\
    \ here: `&10`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybqtgsfx.rs:20:31\n\
    \   |\n16 |         let mut current_num: isize = 0;\n   |                    \
    \          ----- expected due to this type\n...\n20 |                 current_num\
    \ = num;\n   |                               ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |                 current_num\
    \ = *num;\n   |                               +\n\nerror[E0308]: `match` arms\
    \ have incompatible types\n  --> /tmp/tmpybqtgsfx.rs:33:26\n   |\n22 |       \
    \            let name = match num {\n   |  ____________________________-\n23 |\
    \ |                     0 => \"Zero\",\n24 | |                     1 => \"One\"\
    ,\n25 | |                     2 => \"Two\",\n...  |\n32 | |                  \
    \   9 => \"Nine\",\n   | |                          ------ this and all prior\
    \ arms are found to be of type `&str`\n33 | |                     _ => String::from(\"\
    Other\"),\n   | |                          ^^^^^^^^^^^^^^^^^^^^^\n   | |     \
    \                     |\n   | |                          expected `&str`, found\
    \ struct `String`\n   | |                          help: consider borrowing here:\
    \ `&String::from(\"Other\")`\n34 | |                 };\n   | |_________________-\
    \ `match` arms have incompatible types\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpybqtgsfx.rs:36:27\n   |\n17 |         let mut max_num: isize = 0;\n\
    \   |                          ----- expected due to this type\n...\n36 |   "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n    let mut counter: usize = 0;\n    let mut\
    \ arr2 = arr.iter().map(|x| if x <= 9 { counter += x; x } else { counter -= 10;\
    \ x }).collect::<Vec<_>>();\n    if counter == 0 {\n        return arr2;\n   \
    \ }\n    arr2.reverse();\n    arr.iter().cloned().for_each(|x| if x <= 9 { arr2.push((counter\
    \ + x).to_string()) } else { arr2.push((counter - 10).to_string()) });\n    arr2\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljv73806.rs:18:47\n   |\n\
    18 |     let mut arr2 = arr.iter().map(|x| if x <= 9 { counter += x; x } else\
    \ { counter -= 10; x }).collect::<Vec<_>>();\n   |                           \
    \                    ^\n   |                                               |\n\
    \   |                                               expected `&isize`, found integer\n\
    \   |                                               help: consider borrowing here:\
    \ `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpljv73806.rs:18:62\n  \
    \ |\n18 |     let mut arr2 = arr.iter().map(|x| if x <= 9 { counter += x; x }\
    \ else { counter -= 10; x }).collect::<Vec<_>>();\n   |                      \
    \                                        ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot add-assign `&isize` to `usize`\n  --> /tmp/tmpljv73806.rs:18:59\n\
    \   |\n18 |     let mut arr2 = arr.iter().map(|x| if x <= 9 { counter += x; x\
    \ } else { counter -= 10; x }).collect::<Vec<_>>();\n   |                    \
    \                                       ^^ no implementation for `usize += &isize`\n\
    \   |\n   = help: the trait `AddAssign<&isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpljv73806.rs:20:16\n   |\n13 |\
    \ fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                       \
    \           ----------- expected `Vec<String>` because of return type\n...\n20\
    \ |         return arr2;\n   |                ^^^^ expected struct `String`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpljv73806.rs:23:71\n\
    \   |\n23 |     arr.iter().cloned().for_each(|x| if x <= "
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut reversed\
    \ = arr;\n    reversed.reverse();\n    let mut result = Vec::new();\n    reversed.iter().for_each(|x|\n\
    \        match x {\n            1 => result.push(String::from(\"One\")),\n   \
    \         2 => result.push(String::from(\"Two\")),\n            3 => result.push(String::from(\"\
    Three\")),\n            4 => result.push(String::from(\"Four\")),\n          \
    \  5 => result.push(String::from(\"Five\")),\n            6 => result.push(String::from(\"\
    Six\")),\n            7 => result.push(String::from(\"Seven\")),\n           \
    \ 8 => result.push(String::from(\"Eight\")),\n            9 => result.push(String::from(\"\
    Nine\")),\n            _ => {}\n        }\n    );\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp0vre48sa.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut v = arr\n\
    \        .iter()\n        .cloned()\n        .filter(|x| x >= 1 && x <= 9)\n \
    \       .collect::<Vec<isize>>();\n\n    v.sort();\n    v.iter_mut().for_each(|x|\
    \ {\n        *x = if x < 10 { \"Zero\" } else { \"One\" };\n    });\n    v.iter()\n\
    \        .cloned()\n        .map(|x| String::from(*x))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfmhn0cu0.rs:17:26\n   |\n\
    17 |         .filter(|x| x >= 1 && x <= 9)\n   |                          ^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found integer\n   |                          help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmhn0cu0.rs:17:36\n  \
    \ |\n17 |         .filter(|x| x >= 1 && x <= 9)\n   |                        \
    \            ^\n   |                                    |\n   |              \
    \                      expected `&isize`, found integer\n   |                \
    \                    help: consider borrowing here: `&9`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfmhn0cu0.rs:22:21\n   |\n22 |         *x = if x < 10 {\
    \ \"Zero\" } else { \"One\" };\n   |                     ^^\n   |            \
    \         |\n   |                     expected `&mut isize`, found integer\n \
    \  |                     help: consider mutably borrowing here: `&mut 10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfmhn0cu0.rs:22:26\n   |\n22 |  \
    \       *x = if x < 10 { \"Zero\" } else { \"One\" };\n   |                  \
    \        ^^^^^^ expected `isize`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfmhn0cu0.rs:22:42\n   |\n22 |         *x = if x < 10 { \"Zero\"\
    \ } else { \"One\" };\n   |                                          ^^^^^ expected\
    \ `isize`, found `&str`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpfmhn0cu0.rs:26:31\n   |\n26 |         .map(|x| String::from(*x))\n\
    \   |                               ^^\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.into_iter();\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut mut rev_arr\
    \ = arr\n        .windows(4)\n        .flat_map(|v| {\n            if v.is_empty()\
    \ {\n                return vec![];\n            }\n            let mut v = v.into_iter();\n\
    \            let mut v1 = v\n                .windows(3)\n                .flat_map(|(v1,\
    \ v2, v3)| {\n                    if v1 == v2 {\n                        vec![v1,\
    \ String::from(\"One\"), v3]\n                    } else if v2 == v1 {\n     \
    \                   vec![v2, String::from(\"Two\"), v3]\n                    }\
    \ else if v1 == v3 {\n                        vec![v1, String::from(\"One\"),\
    \ v2]\n                    } else if v2 == v3 {\n                        vec![v2,\
    \ String::from(\"Two\"), v1]\n                    } else if v1 == v2 {\n     \
    \                   vec![v1, String::from(\"One\"), v3]\n                    }\
    \ else if v2 == v1 {\n                        vec![v2, String::from(\"Two\"),\
    \ v3]\n                    } else {\n                        vec![v1, String::from(\"\
    One\"), v2]\n                    }\n                })\n                .collect();\n\
    \            v1.reverse();\n            v1.extend(v2);\n            v1.extend(v3);\n\
    \            v1\n        })\n        .collect();\n    rev_arr.reverse();\n   \
    \ rev_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: `mut` on a binding may not be repeated\n  --> /tmp/tmp85i33ois.rs:18:13\n\
    \   |\n18 |     let mut mut rev_arr = arr\n   |             ^^^ help: remove the\
    \ additional `mut`s\n\nerror[E0425]: cannot find value `v2` in this scope\n  -->\
    \ /tmp/tmp85i33ois.rs:46:23\n   |\n46 |             v1.extend(v2);\n   |     \
    \                  ^^ help: a local variable with a similar name exists: `v`\n\
    \nerror[E0425]: cannot find value `v3` in this scope\n  --> /tmp/tmp85i33ois.rs:47:23\n\
    \   |\n47 |             v1.extend(v3);\n   |                       ^^ help: a\
    \ local variable with a similar name exists: `v`\n\nerror[E0658]: use of unstable\
    \ library feature 'exact_size_is_empty'\n  --> /tmp/tmp85i33ois.rs:15:12\n   |\n\
    15 |     if arr.is_empty() {\n   |            ^^^^^^^^\n   |\n   = note: see issue\
    \ #35428 <https://github.com/rust-lang/rust/issues/35428> for more information\n\
    \nerror[E0599]: no method named `windows` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp85i33ois.rs:19:10\n   |\n19 |         .windows(4)\n\
    \   |          ^^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599, E0658.\nFor more information about an error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for v in arr {\n        if 1 < v <= 9 {\n            result.push(String::from(v));\n\
    \        }\n    }\n\n    if result.is_empty() {\n        vec![]\n    } else {\n\
    \        Vec::from_iter(result)\n            .into_iter()\n            .map(|v|\
    \ {\n                if v == 1 {\n                    String::from(\"One\")\n\
    \                } else if v == 2 {\n                    String::from(\"Two\"\
    )\n                } else if v == 3 {\n                    String::from(\"Three\"\
    )\n                } else if v == 4 {\n                    String::from(\"Four\"\
    )\n                } else if v == 5 {\n                    String::from(\"Five\"\
    )\n                } else if v == 6 {\n                    String::from(\"Six\"\
    )\n                } else if v == 7 {\n                    String::from(\"Seven\"\
    )\n                } else if v == 8 {\n                    String::from(\"Eight\"\
    )\n                } else if v == 9 {\n                    String::from(\"Nine\"\
    )\n                } else {\n                    String::from(\"\")\n        \
    \        }\n            })\n            .collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpjic6gvw_.rs:16:14\n\
    \   |\n16 |         if 1 < v <= 9 {\n   |              ^   ^^\n   |\nhelp: split\
    \ the comparison into two\n   |\n16 |         if 1 < v && v <= 9 {\n   |     \
    \             ++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjic6gvw_.rs:16:21\n\
    \   |\n16 |         if 1 < v <= 9 {\n   |                     ^ expected `bool`,\
    \ found integer\n\nerror[E0277]: the trait bound `String: From<isize>` is not\
    \ satisfied\n  --> /tmp/tmpjic6gvw_.rs:17:25\n   |\n17 |             result.push(String::from(v));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0599]: no function or associated item named `from_iter` found for struct\
    \ `Vec<_, _>` in the current scope\n  --> /tmp/tmpjic6gvw_.rs:24:14\n   |\n24\
    \ |         Vec::from_iter(result)\n   |              ^^^^^^^^^ function or associated\
    \ item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut n = arr.len();\n\
    \    if n <= 0 {\n        return vec![];\n    }\n\n    let mut strings = vec![];\n\
    \n    // sort the integers between 1 and 9 inclusive\n    let mut ints = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    ints.sort_by_key(|x| *x).reverse();\n\n    // reorder digits\n    for &x\
    \ in ints.iter() {\n        if x > 9 {\n            if x % 10 == 0 {\n       \
    \         continue;\n            }\n\n            let digit = (x - 10) % 10;\n\
    \            let name = strings[digit].clone();\n            strings[digit] =\
    \ name;\n        }\n    }\n\n    let mut rem = String::from(\"Zero\");\n    for\
    \ digit in strings.iter() {\n        if let Some(name) = digit {\n           \
    \ rem.push_str(name);\n        } else {\n            rem.push_str(rem);\n    \
    \    }\n    }\n\n    strings\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmp3ahiiy9m.rs:23:30\n   |\n23 |     ints.sort_by_key(|x|\
    \ *x).reverse();\n   |                              ^^^^^^^ method not found in\
    \ `()`\n\nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp3ahiiy9m.rs:33:24\n\
    \   |\n33 |             let name = strings[digit].clone();\n   |             \
    \           ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[_]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmp3ahiiy9m.rs:34:13\n\
    \   |\n34 |             strings[digit] = name;\n   |             ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp3ahiiy9m.rs:40:16\n    |\n40  |         if let Some(name) = digit {\n\
    \    |                ^^^^^^^^^^ doesn't have a size known at compile-time\n \
    \   |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Some`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp3ahiiy9m.rs:39:18\n    |\n39  |\
    \     for digit in strings.iter() {\n    |                  ^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp3ahiiy9m.rs:33:24\n    |\n33  |             let name = strings[digit].clone();\n\
    \    |          "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut vec = vec![];\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut arr = arr.iter().map(|x|\
    \ x as i32).collect::<Vec<_>>();\n    vec.push(String::from(\"One\"));\n    vec.push(String::from(\"\
    Two\"));\n    vec.push(String::from(\"Three\"));\n    vec.push(String::from(\"\
    Four\"));\n    vec.push(String::from(\"Five\"));\n    vec.push(String::from(\"\
    Six\"));\n    vec.push(String::from(\"Seven\"));\n    vec.push(String::from(\"\
    Eight\"));\n    vec.push(String::from(\"Nine\"));\n    if arr.len() == 9 {\n \
    \       vec.push(String::from(\"Nine\"));\n        vec.push(String::from(\"Eight\"\
    ));\n        vec.push(String::from(\"Seven\"));\n        vec.push(String::from(\"\
    Six\"));\n        vec.push(String::from(\"Five\"));\n        vec.push(String::from(\"\
    Four\"));\n        vec.push(String::from(\"Three\"));\n        vec.push(String::from(\"\
    Two\"));\n        vec.push(String::from(\"One\"));\n    }\n    while arr.len()\
    \ > 0 {\n        if arr[0] < 10 {\n            vec.push(String::from(format!(\"\
    {}\", arr[0])));\n            arr.pop();\n        } else {\n            vec.push(String::from(format!(\"\
    {}\", arr.last())));\n            arr.last() = 0;\n        }\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Option<&i32>` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmprejn82si.rs:44:49\n   |\n44 |             vec.push(String::from(format!(\"\
    {}\", arr.last())));\n   |                                                 ^^^^^^^^^^\
    \ `Option<&i32>` cannot be formatted with the default formatter\n   |\n   = help:\
    \ the trait `std::fmt::Display` is not implemented for `Option<&i32>`\n   = note:\
    \ in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmprejn82si.rs:45:24\n   |\n\
    45 |             arr.last() = 0;\n   |             ---------- ^\n   |        \
    \     |\n   |             cannot assign to this expression\n\nerror[E0606]: casting\
    \ `&isize` as `i32` is invalid\n  --> /tmp/tmprejn82si.rs:18:38\n   |\n18 |  \
    \   let mut arr = arr.iter().map(|x| x as i32).collect::<Vec<_>>();\n   |    \
    \                                  -^^^^^^^\n   |                            \
    \          |\n   |                                      cannot cast `&isize` as\
    \ `i32`\n   |                                      help: dereference the expression:\
    \ `*x`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0070, E0277, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0070`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        1 => vec![String::from(\"One\")],\n        _ =>\
    \ {\n            let mut arr2 = arr.clone();\n            arr2.sort();\n     \
    \       arr2.reverse();\n            let mut output = vec![];\n            for\
    \ &n in arr2 {\n                let index = n.into();\n                let mut\
    \ s = String::from(\"One\");\n                match index {\n                \
    \    1 => s = String::from(\"Two\"),\n                    2 => s = String::from(\"\
    Three\"),\n                    3 => s = String::from(\"Four\"),\n            \
    \        4 => s = String::from(\"Five\"),\n                    5 => s = String::from(\"\
    Six\"),\n                    6 => s = String::from(\"Seven\"),\n             \
    \       7 => s = String::from(\"Eight\"),\n                    8 => s = String::from(\"\
    Nine\"),\n                    _ => (),\n                }\n                output.push(s);\n\
    \            }\n            output\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp604mkegi.rs:22:17\n   |\n\
    22 |             for &n in arr2 {\n   |                 ^^    ---- this expression\
    \ has type `Option<isize>`\n   |                 |\n   |                 expected\
    \ `isize`, found reference\n   |                 help: you can probably remove\
    \ the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.iter()\n    \
    \    .take(9)\n        .chain(arr.iter().skip(9))\n        .map(|i| format!(\"\
    {}\", i))\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpu52clxrf.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut i = 0;\n    loop {\n        match arr[i] {\n          \
    \  1 => result.push(\"One\"),\n            2 => result.push(\"Two\"),\n      \
    \      3 => result.push(\"Three\"),\n            4 => result.push(\"Four\"),\n\
    \            5 => result.push(\"Five\"),\n            6 => result.push(\"Six\"\
    ),\n            7 => result.push(\"Seven\"),\n            8 => result.push(\"\
    Eight\"),\n            9 => result.push(\"Nine\"),\n            _ => break,\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgchm0ntk.rs:31:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    31 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result: Vec<String>\
    \ = vec![];\n\n    match arr.len() {\n        0 => result.push(\"Zero\"),\n  \
    \      1 => result.push(\"One\"),\n        _ => {\n            let mut numbers:\
    \ Vec<_> = arr\n                .iter()\n                .map(|x| {\n        \
    \            if x >= 1 && x <= 9 {\n                        format!(\"{}\", x)\n\
    \                    } else {\n                        format!(\"Unnamed{}\",\
    \ x)\n                    }\n                })\n                .collect();\n\
    \            numbers.sort_by(|a, b| a.cmp(b));\n            numbers.reverse();\n\
    \            let mut index = numbers.len() - 1;\n            for n in numbers\
    \ {\n                if n >= 10 {\n                    result.push(format!(\"\
    {}\", index));\n                    index -= 1;\n                }\n         \
    \       result.push(n);\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpix9xlex4.rs:17:26\n   |\n\
    17 |         0 => result.push(\"Zero\"),\n   |                          ^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpix9xlex4.rs:18:26\n   |\n18 |\
    \         1 => result.push(\"One\"),\n   |                          ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpix9xlex4.rs:23:29\n   |\n23 |  \
    \                   if x >= 1 && x <= 9 {\n   |                             ^\n\
    \   |                             |\n   |                             expected\
    \ `&isize`, found integer\n   |                             help: consider borrowing\
    \ here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpix9xlex4.rs:23:39\n\
    \   |\n23 |                     if x >= 1 && x <= 9 {\n   |                  \
    \                     ^\n   |                                       |\n   |  \
    \                                     expected `&isize`, found integer\n   | \
    \                                      help: consider borrowing here: `&9`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpix9xlex4.rs:34:25\n   |\n34 |  \
    \               if n >= 10 {\n   |                         ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                         |\n   |  \
    \                       expected struct `String`, found integer\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    let mut remaining = arr;\n    let mut digit = &mut [];\n    while\
    \ !remaining.is_empty() {\n        let digit = remaining.pop();\n        if digit\
    \ < 1 || digit > 9 {\n            continue;\n        }\n\n        digit.push(String::from(\n\
    \            match digit {\n                1 => \"One\",\n                2 =>\
    \ \"Two\",\n                3 => \"Three\",\n                4 => \"Four\",\n\
    \                5 => \"Five\",\n                6 => \"Six\",\n             \
    \   7 => \"Seven\",\n                8 => \"Eight\",\n                9 => \"\
    Nine\",\n                _ => panic!(\"Invalid digit: {}\", digit),\n        \
    \    },\n        ));\n        result.extend(&digit);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmpifw73w.rs:19:20\n   |\n\
    19 |         if digit < 1 || digit > 9 {\n   |                    ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |         if digit < Some(1) || digit > 9 {\n   |                  \
    \  +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmpifw73w.rs:19:33\n\
    \   |\n19 |         if digit < 1 || digit > 9 {\n   |                        \
    \         ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n19 |         if digit < 1 || digit > Some(9) {\n\
    \   |                                 +++++ +\n\nerror[E0599]: no method named\
    \ `push` found for enum `Option` in the current scope\n  --> /tmp/tmpmpifw73w.rs:23:15\n\
    \   |\n23 |         digit.push(String::from(\n   |               ^^^^ method not\
    \ found in `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmpifw73w.rs:25:17\n\
    \   |\n24 |             match digit {\n   |                   ----- this expression\
    \ has type `Option<isize>`\n25 |                 1 => \"One\",\n   |         \
    \        ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n25 |                 Some(1) => \"One\",\n   |    \
    \             +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmpifw73w.rs:26:17\n\
    \   |\n24 |             match digit {\n   |                   ----- this expression\
    \ has type `Option<isize>`\n25 |                 1 => \"One\",\n26 |         \
    \        2 => \"Two\",\n   |                 ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the pattern in `Some`\n   |\n26 |                 Some(2) =>\
    \ \"Two\",\n   |                 +++++ +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpmpifw73w.rs:27:17\n   |\n24 |       "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    if arr.is_empty() {\n        return result;\n    }\n    let\
    \ mut ones: Vec<_> = vec![String::from(\"One\"), String::from(\"Two\"), String::from(\"\
    Three\"), String::from(\"Four\"), String::from(\"Five\"), String::from(\"Six\"\
    ), String::from(\"Seven\"), String::from(\"Eight\"), String::from(\"Nine\")];\n\
    \    let mut tens: Vec<_> = vec![String::from(\"Ten\"), String::from(\"Eleven\"\
    ), String::from(\"Twelve\"), String::from(\"Thirteen\"), String::from(\"Fourteen\"\
    ), String::from(\"Fifteen\"), String::from(\"Sixteen\"), String::from(\"Seventeen\"\
    ), String::from(\"Eighteen\"), String::from(\"Nineteen\")];\n    let mut teens:\
    \ Vec<_> = vec![String::from(\"Twenty\"), String::from(\"Twenty\"), String::from(\"\
    Twenty\"), String::from(\"Twenty\"), String::from(\"Twenty\"), String::from(\"\
    Twenty\"), String::from(\"Twenty\"), String::from(\"Twenty\"), String::from(\"\
    Twenty\"), String::from(\"Twenty\"), String::from(\"Twenty\")];\n\n    let mut\
    \ reverse = arr.rev();\n\n    for i in reverse {\n        if i >= 1 && i <= 9\
    \ {\n            result.push(i);\n            continue;\n        }\n\n       \
    \ if i == 19 {\n            result.push(String::from(\"Nineteen\"));\n       \
    \     continue;\n        }\n\n        if i == 20 {\n            result.push(String::from(\"\
    Twenty\"));\n            continue;\n        }\n\n        if i > 20 {\n       \
    \     let len: usize = (i as i32).log10() / 10;\n            if len <= 20 {\n\
    \                result.push(String::from(&tens[len]));\n                continue;\n\
    \            }\n        }\n\n        if i > 19 {\n            let len: usize =\
    \ (i as i32).log10() / 10;\n            if len <= 19 {\n                result.push(String::from(&teens[len]));\n\
    \                continue;\n            }\n        }\n\n        result.push(i);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg3urjsgn.rs:22:27\n\
    \    |\n22  |       let mut reverse = arr.rev();\n    |                      \
    \       ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmpg3urjsgn.rs:25:14\n \
    \  |\n25 |         if i >= 1 && i <= 9 {\n   |              ^^ no implementation\
    \ for `String < {integer}` and `String > {integer}`\n   |\n   = help: the trait\
    \ `PartialOrd<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialOrd<Rhs>`:\n             String\n      \
    \       str\n\nerror[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpg3urjsgn.rs:25:24\n\
    \   |\n25 |         if i >= 1 && i <= 9 {\n   |                        ^^ no implementation\
    \ for `String < {integer}` and `String > {integer}`\n   |\n   = help: the trait\
    \ `PartialOrd<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialOrd<Rhs>`:\n             String\n      \
    \       str\n\nerror[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpg3urjsgn.rs:30:14\n\
    \   |\n30 |         if i == 19 {\n   |              ^^ no implementation for `String\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `{integer}`\n  --> /tm"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() > 0\
    \ {\n        let mut num_strings = String::new();\n        let mut num_pos = 0;\n\
    \        let mut len = 0;\n        let mut num = arr[0];\n        let mut num\
    \ = arr[0];\n        for (i, n) in arr.iter().enumerate() {\n            if n\
    \ >= 1 && n <= 9 {\n                num_pos += 1;\n                if num_pos\
    \ == 1 && len == 0 {\n                    len = n;\n                }\n      \
    \          num = (num * 10 + n) as isize;\n            } else {\n            \
    \    if len != 0 {\n                    num_pos += 1;\n                    if\
    \ num_pos == 1 && len == 0 {\n                        len = n;\n             \
    \       }\n                }\n                if len > 0 {\n                 \
    \   num_strings.push(String::from(num.to_string().unwrap()));\n              \
    \  }\n                num_pos = 0;\n                num_strings.push(String::from(\"\
    Nine\"));\n                len = 0;\n                num = (num * 10 + n) as isize;\n\
    \            }\n        }\n        if num_pos != 1 {\n            num_strings.push(String::from(\"\
    Nine\"));\n        }\n        num_strings.push(String::from(\"One\"));\n     \
    \   num_strings\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8glvto6k.rs:21:21\n   |\n\
    21 |             if n >= 1 && n <= 9 {\n   |                     ^\n   |     \
    \                |\n   |                     expected `&isize`, found integer\n\
    \   |                     help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8glvto6k.rs:21:31\n   |\n21 |             if\
    \ n >= 1 && n <= 9 {\n   |                               ^\n   |             \
    \                  |\n   |                               expected `&isize`, found\
    \ integer\n   |                               help: consider borrowing here: `&9`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8glvto6k.rs:24:27\n   |\n17 |\
    \         let mut len = 0;\n   |                       - expected due to this\
    \ value\n...\n24 |                     len = n;\n   |                        \
    \   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n24 |                     len = *n;\n   |                     \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8glvto6k.rs:31:31\n\
    \   |\n17 |         let mut len = 0;\n   |                       - expected due\
    \ to this value\n...\n31 |                         len = n;\n   |            \
    \                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n31 |                         len = *n;\n   |             \
    \                  +\n\nerror[E0599]: no method named `unwrap` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp8glvto6k.rs:35:67\n   |\n35 | \
    \                    num_strings.push(String::from(num.to_string().unwrap()));\n\
    \   |                                                                   ^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8glvto6k.rs:35:38\n\
    \   |\n35 |                     num_strings.push(String::from(num.to_string().unwrap()));\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp8glvto6k.rs:38:34\n   |\n38 |                 n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut reversed = vec![];\n      \
    \  for &x in arr {\n            if x <= 9 {\n                let y = x * 10 +\
    \ x;\n                reversed.push(by_length_digit(&y));\n            } else\
    \ {\n                reversed.push(by_length_digit(&x));\n            }\n    \
    \    }\n        reversed.reverse();\n        reversed.iter().for_each(|x| replace(x,\
    \ \"One\", \"Eight\"));\n        reversed.iter().for_each(|x| replace(x, \"Two\"\
    , \"Seven\"));\n        reversed.iter().for_each(|x| replace(x, \"Three\", \"\
    Six\"));\n        reversed.iter().for_each(|x| replace(x, \"Four\", \"Five\"));\n\
    \        reversed.iter().for_each(|x| replace(x, \"Five\", \"Four\"));\n     \
    \   reversed.iter().for_each(|x| replace(x, \"Six\", \"Three\"));\n        reversed.iter().for_each(|x|\
    \ replace(x, \"Seven\", \"Six\"));\n        reversed.iter().for_each(|x| replace(x,\
    \ \"Eight\", \"One\"));\n        reversed.iter().for_each(|x| replace(x, \"Nine\"\
    , \"Two\"));\n        reversed\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length_digit` in this scope\n  -->\
    \ /tmp/tmp9yqodyj5.rs:21:31\n   |\n21 |                 reversed.push(by_length_digit(&y));\n\
    \   |                               ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `by_length_digit` in this scope\n  --> /tmp/tmp9yqodyj5.rs:23:31\n\
    \   |\n23 |                 reversed.push(by_length_digit(&x));\n   |        \
    \                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `replace` in this scope\n  --> /tmp/tmp9yqodyj5.rs:27:38\n\
    \   |\n27 |         reversed.iter().for_each(|x| replace(x, \"One\", \"Eight\"\
    ));\n   |                                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::replace;\n\
    \   |\n1  | use std::ptr::replace;\n   |\n\nerror[E0425]: cannot find function\
    \ `replace` in this scope\n  --> /tmp/tmp9yqodyj5.rs:28:38\n   |\n28 |       \
    \  reversed.iter().for_each(|x| replace(x, \"Two\", \"Seven\"));\n   |       \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::mem::replace;\n   |\n1  |\
    \ use std::ptr::replace;\n   |\n\nerror[E0425]: cannot find function `replace`\
    \ in this scope\n  --> /tmp/tmp9yqodyj5.rs:29:38\n   |\n29 |         reversed.iter().for_each(|x|\
    \ replace(x, \"Three\", \"Six\"));\n   |                                     \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::replace;\n   |\n1  | use std::ptr::replace;\n\
    \   |\n\nerror[E0425]: cannot find function `replace` in this scope\n  --> /tmp/tmp9yqodyj5.rs:30:38\n\
    \   |\n30 |         reversed.iter().for_each(|x| replace(x, \"Four\", \"Five\"\
    ));\n   |                                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::replace;\n\
    \   |\n1  | use std::ptr::replace;\n   |\n\nerror[E0425]: cannot find function\
    \ `replace` in this scope\n  --> /tmp/tmp9yqodyj5.rs:31:38\n   |\n31 |       \
    \  reversed.iter().f"
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut ret: Vec<String>\
    \ = vec![];\n    for i in arr {\n        if 1 <= i && i <= 9 {\n            ret.push(String::from(format!(\"\
    {}\", i)));\n        } else {\n            break;\n        }\n    }\n\n    ret.sort_by(|x,\
    \ y| x.cmp(y));\n    ret.reverse();\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpkq6sgyn3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        1 => vec![String::from(\"One\")],\n        2 =>\
    \ vec![String::from(\"Two\")],\n        3 => vec![String::from(\"Three\")],\n\
    \        4 => vec![String::from(\"Four\")],\n        5 => vec![String::from(\"\
    Five\")],\n        6 => vec![String::from(\"Six\")],\n        7 => vec![String::from(\"\
    Seven\")],\n        8 => vec![String::from(\"Eight\")],\n        9 => vec![String::from(\"\
    Nine\")],\n        _ => {\n            let mut to_sort = arr.to_vec();\n     \
    \       to_sort.sort_unstable_by_key(|v| v as isize);\n            let mut reverse_vec\
    \ = vec![String::from(\"\")].reserve(to_sort.len());\n            for v in to_sort.iter()\
    \ {\n                reverse_vec.push((9 - v) as isize);\n            }\n    \
    \        to_sort.iter().map(|v| reverse_vec.iter().cloned().nth(v)).collect()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpbnemzs0t.rs:30:29\n   |\n30 |                 reverse_vec.push((9\
    \ - v) as isize);\n   |                             ^^^^ method not found in `()`\n\
    \nerror[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpbnemzs0t.rs:32:48\n   |\n32 |             to_sort.iter().map(|v|\
    \ reverse_vec.iter().cloned().nth(v)).collect()\n   |                        \
    \                        ^^^^ method not found in `()`\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmpbnemzs0t.rs:27:46\n   |\n27 |\
    \             to_sort.sort_unstable_by_key(|v| v as isize);\n   |            \
    \                                  -^^^^^^^^^\n   |                          \
    \                    |\n   |                                              cannot\
    \ cast `&isize` as `isize`\n   |                                             \
    \ help: dereference the expression: `*v`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut s = String::new();\n\
    \    for n in arr {\n        if n > 0 {\n            s.push_str(&format!(\"{}\"\
    , n));\n        }\n    }\n    if s.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut reversed_arr: Vec<isize> = Vec::new();\n    let mut i: isize = 1;\n\
    \    while i < s.len() {\n        let digit = s.chars().nth(i).unwrap();\n   \
    \     if digit != '0' {\n            reversed_arr.push(i);\n        }\n      \
    \  i += 1;\n    }\n    for n in reversed_arr {\n        s.push_str(&format!(\"\
    {}\", n));\n    }\n    vec![s]\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp79iqw201.rs:25:15\n   |\n\
    25 |     while i < s.len() {\n   |               ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n25 |     while i < s.len().try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp79iqw201.rs:26:35\n   |\n26 |         let digit = s.chars().nth(i).unwrap();\n\
    \   |                                   ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |         let digit = s.chars().nth(i.try_into().unwrap()).unwrap();\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ count = 1;\n    for n in arr.iter() {\n        if n >= 1 && n <= 9 {\n     \
    \       count += 1;\n            result.push(String::from(format!(\"{}{}\", n,\
    \ count)));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8uwr9hoi.rs:20:17\n   |\n\
    20 |         if n >= 1 && n <= 9 {\n   |                 ^\n   |             \
    \    |\n   |                 expected `&isize`, found integer\n   |          \
    \       help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8uwr9hoi.rs:20:27\n   |\n20 |         if n >= 1 && n <= 9 {\n \
    \  |                           ^\n   |                           |\n   |     \
    \                      expected `&isize`, found integer\n   |                \
    \           help: consider borrowing here: `&9`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut len = arr.len();\n    if len >\
    \ 9 {\n        len = len - 9;\n    }\n    if len == 1 {\n        return vec![String::from(\"\
    One\")];\n    }\n    if len == 2 {\n        return vec![String::from(\"Two\"),\
    \ String::from(\"Two\")];\n    }\n    if len == 3 {\n        return vec![String::from(\"\
    Three\"), String::from(\"Three\")];\n    }\n    if len == 4 {\n        return\
    \ vec![String::from(\"Four\"), String::from(\"Four\")];\n    }\n    if len ==\
    \ 5 {\n        return vec![String::from(\"Five\"), String::from(\"Five\")];\n\
    \    }\n    if len == 6 {\n        return vec![String::from(\"Six\"), String::from(\"\
    Six\")];\n    }\n    if len == 7 {\n        return vec![String::from(\"Seven\"\
    ), String::from(\"Seven\")];\n    }\n    if len == 8 {\n        return vec![String::from(\"\
    Eight\"), String::from(\"Eight\")];\n    }\n    if len == 9 {\n        return\
    \ vec![String::from(\"Nine\"), String::from(\"Nine\")];\n    }\n    let mut s\
    \ = String::from(\"One\");\n    for i in 0..len {\n        s.push(*arr[len - i].to_string());\n\
    \    }\n    vec![s]\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3lb03uno.rs:50:16\n   |\n\
    50 |         s.push(*arr[len - i].to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_by_key(|&x|\
    \ {\n        if x < 1 || x > 9 {\n            return 0;\n        }\n        x\n\
    \    });\n    let mut res = vec![];\n    for i in arr.iter_mut().rev() {\n   \
    \     match i {\n            1 => res.push(String::from(\"One\")),\n         \
    \   2 => res.push(String::from(\"Two\")),\n            3 => res.push(String::from(\"\
    Three\")),\n            4 => res.push(String::from(\"Four\")),\n            5\
    \ => res.push(String::from(\"Five\")),\n            6 => res.push(String::from(\"\
    Six\")),\n            7 => res.push(String::from(\"Seven\")),\n            8 =>\
    \ res.push(String::from(\"Eight\")),\n            9 => res.push(String::from(\"\
    Nine\")),\n            _ => unreachable!(\"Unexpected number: {}\", i),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpwmp2igwi.rs:14:5\n   |\n13 |   fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                --- help: consider changing this to be\
    \ mutable: `mut arr`\n14 | /     arr.sort_by_key(|&x| {\n15 | |         if x <\
    \ 1 || x > 9 {\n16 | |             return 0;\n17 | |         }\n18 | |       \
    \  x\n19 | |     });\n   | |______^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `arr` as mutable, as it is not declared as mutable\n  --> /tmp/tmpwmp2igwi.rs:21:14\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \ --- help: consider changing this to be mutable: `mut arr`\n...\n21 |     for\
    \ i in arr.iter_mut().rev() {\n   |              ^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut new_arr = arr.into_iter().enumerate().collect();\n\
    \    new_arr.sort_by_key(|(_, elem)| elem as isize);\n    new_arr.map(|(index,\
    \ elem)| {\n        match elem {\n            1 => \"One\".to_owned(),\n     \
    \       2 => \"Two\".to_owned(),\n            3 => \"Three\".to_owned(),\n   \
    \         4 => \"Four\".to_owned(),\n            5 => \"Five\".to_owned(),\n \
    \           6 => \"Six\".to_owned(),\n            7 => \"Seven\".to_owned(),\n\
    \            8 => \"Eight\".to_owned(),\n            9 => \"Nine\".to_owned(),\n\
    \            _ => \"\".to_owned(),\n        }\n    });\n    new_arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp7s54uqnw.rs:18:5\n\
    \   |\n17 |     let mut new_arr = arr.into_iter().enumerate().collect();\n   |\
    \         ----------- consider giving `new_arr` a type\n18 |     new_arr.sort_by_key(|(_,\
    \ elem)| elem as isize);\n   |     ^^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() < 1\
    \ {\n        return vec![];\n    }\n\n    let mut name_vec = vec![];\n    for\
    \ num in arr {\n        if num >= 1 && num <= 9 {\n            let num = num as\
    \ char;\n            name_vec.push(String::from(format!(\"{}\", num as String)));\n\
    \        }\n    }\n    name_vec.sort_unstable();\n    name_vec.reverse();\n\n\
    \    let mut new_vec = vec![];\n    for num in arr {\n        if num >= 1 && num\
    \ <= 9 {\n            let num = num as char;\n            new_vec.push(String::from(format!(\"\
    {}\", num as String)));\n        }\n    }\n    new_vec.sort_unstable();\n    new_vec.reverse();\n\
    \    for num in arr {\n        if num >= 1 && num <= 9 {\n            let num\
    \ = num as char;\n            new_vec.push(String::from(format!(\"{}\", num as\
    \ String)));\n        }\n    }\n\n    for num in arr {\n        if num >= 1 &&\
    \ num <= 9 {\n            let num = num as char;\n            new_vec.push(String::from(format!(\"\
    {}\", num as String)));\n        }\n    }\n    new_vec\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp7ib6xh7g.rs:21:23\n\
    \   |\n21 |             let num = num as char;\n   |                       ^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp7ib6xh7g.rs:21:23\n   |\n21 |             let num = num as char;\n \
    \  |                       ^^^^^^^^^^^\n\nerror[E0605]: non-primitive cast: `char`\
    \ as `String`\n  --> /tmp/tmp7ib6xh7g.rs:22:54\n   |\n22 |             name_vec.push(String::from(format!(\"\
    {}\", num as String)));\n   |                                                \
    \      ^^^^^^^^^^^^^ help: consider using the `From` trait instead: `String::from(num)`\n\
    \   |\n   = note: an `as` expression can only be used to convert between primitive\
    \ types or to coerce to a specific trait object\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmp7ib6xh7g.rs:31:23\n   |\n31 |\
    \             let num = num as char;\n   |                       ^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp7ib6xh7g.rs:31:23\n\
    \   |\n31 |             let num = num as char;\n   |                       ^^^^^^^^^^^\n\
    \nerror[E0605]: non-primitive cast: `char` as `String`\n  --> /tmp/tmp7ib6xh7g.rs:32:53\n\
    \   |\n32 |             new_vec.push(String::from(format!(\"{}\", num as String)));\n\
    \   |                                                     ^^^^^^^^^^^^^ help:\
    \ consider using the `From` trait instead: `String::from(num)`\n   |\n   = note:\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `isize`\n  --> /tmp/tmp7ib6xh7g.rs:39:23\n   |\n39 |           \
    \  let num = num as char;\n   |                       ^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp7ib6xh7g.rs:39:23\n\
    \   |\n39 |             let num = num as char;\n   |                       ^^^^^^^^^^^\n\
    \nerror[E0605]: non-primitive cast: `char` as `String`\n  --> /tmp/tmp7ib6xh7g.rs:40:53\n\
    \   |\n40 |             "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut vec1 = vec![String::from(\"\
    One\"), String::from(\"Two\"), String::from(\"Three\"), String::from(\"Four\"\
    ), String::from(\"Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"\
    Eight\"), String::from(\"Nine\")];\n    let mut vec2 = vec![String::from(\"One\"\
    ), String::from(\"Two\"), String::from(\"Three\"), String::from(\"Four\"), String::from(\"\
    Five\"), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"Eight\"\
    ), String::from(\"Nine\")];\n\n    for v in arr.iter() {\n        if v <= 9 {\n\
    \            vec2.push(vec1[v]);\n        } else {\n            vec2.push(String::from(&vec1[(v\
    \ - 10)]));\n            vec2.push(String::from(&vec1[(v - 10)]));\n        }\n\
    \    }\n    vec2.reverse();\n    vec2.iter().map(|x| x.to_owned()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjyd2_9ef.rs:18:17\n   |\n\
    18 |         if v <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `&isize`\n  --> /tmp/tmpjyd2_9ef.rs:19:23\n   |\n19 |           \
    \  vec2.push(vec1[v]);\n   |                       ^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<String>`\n\nerror[E0277]: the type `[String]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpjyd2_9ef.rs:21:37\n   |\n21 |         \
    \    vec2.push(String::from(&vec1[(v - 10)]));\n   |                         \
    \            ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[String]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpjyd2_9ef.rs:22:37\n\
    \   |\n22 |             vec2.push(String::from(&vec1[(v - 10)]));\n   |      \
    \                               ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<String>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut arr = arr.to_vec();\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut counter =\
    \ 1;\n    for i in arr.iter() {\n        if i <= 9 {\n            continue;\n\
    \        }\n        if counter > 10 {\n            counter = 1;\n            arr.swap(0,\
    \ arr.len() - 1);\n        }\n        arr.swap(i, counter);\n        counter +=\
    \ 1;\n    }\n    vec![String::from(\"One\"),\n          String::from(\"Two\"),\n\
    \          String::from(\"Three\"),\n          String::from(\"Four\"),\n     \
    \     String::from(\"Five\"),\n          String::from(\"Six\"),\n          String::from(\"\
    Seven\"),\n          String::from(\"Eight\"),\n          String::from(\"Nine\"\
    )]\n        .iter()\n        .cloned()\n        .chain(arr.iter().cloned())\n\
    \        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy52tkp7q.rs:20:17\n   |\n\
    20 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy52tkp7q.rs:27:18\n\
    \   |\n27 |         arr.swap(i, counter);\n   |                  ^ expected `usize`,\
    \ found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::slice::Iter<'_,\
    \ isize> as Iterator>::Item == &String`\n   --> /tmp/tmpy52tkp7q.rs:41:16\n  \
    \  |\n41  |         .chain(arr.iter().cloned())\n    |          ----- ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n    |          |\n    |          required\
    \ by a bound introduced by this call\n    |\n    = note: expected reference `&String`\n\
    \               found reference `&isize`\n    = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, isize>>`\n\
    note: required by a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the\
    \ method `cloned` exists for struct `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, isize>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpy52tkp7q.rs:42:10\n   |\n42 |           .cloned()\n\
    \   |            ^^^^^^ method cannot be called on `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, isize>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `std::iter::Chain<Cloned<std::slice::Iter<'_,\
    \ String>>, Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n           which\
    \ is required by `&mut std::iter::Chain<Cloned<std::slice::Iter<'_, String>>,\
    \ Cloned<std::slice::Iter<'_, isize>>>: Iterator`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0271, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut reverse_vec = vec![];\n\n  \
    \  // Iterate over each integer in the vector, starting from largest to smallest\
    \ number\n    for i in (arr.len() - 1..).rev() {\n        // Grab each digit,\
    \ add it to our reverse vector\n        let digit = i % 10;\n        reverse_vec.push((digit\
    \ as char).to_string());\n        // Get the last digit and add it to the reverse\
    \ vector\n        let last_digit = arr[i..i].last().unwrap();\n        reverse_vec.push(&last_digit);\n\
    \    }\n\n    // Reverse the entire vector\n    reverse_vec.reverse();\n\n   \
    \ // Replace each digit in the reverse vector with its name from the \"One\",\
    \ \"Two\", ..., \"Nine\" strings\n    let mut index = 0;\n    for digit in reverse_vec\
    \ {\n        let digit_str = (&digit).to_string();\n        let digit = &str::from_str(&digit_str).unwrap();\n\
    \        if index == 0 {\n            index = digit.len();\n        }\n      \
    \  let name = digit.chars().nth(index).unwrap().to_string();\n        reverse_vec.push(name.clone());\n\
    \        index += 1;\n    }\n\n    reverse_vec\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `RangeFrom<usize>: DoubleEndedIterator` is\
    \ not satisfied\n    --> /tmp/tmp4sznvumj.rs:21:32\n     |\n21   |     for i in\
    \ (arr.len() - 1..).rev() {\n     |                                ^^^ the trait\
    \ `DoubleEndedIterator` is not implemented for `RangeFrom<usize>`\n     |\nnote:\
    \ required by a bound in `rev`\n\nerror[E0277]: the trait bound `RangeFrom<usize>:\
    \ DoubleEndedIterator` is not satisfied\n  --> /tmp/tmp4sznvumj.rs:21:14\n   |\n\
    21 |     for i in (arr.len() - 1..).rev() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^\
    \ the trait `DoubleEndedIterator` is not implemented for `RangeFrom<usize>`\n\
    \   |\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Rev<RangeFrom<usize>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<RangeFrom<usize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4sznvumj.rs:27:26\n   |\n27 |         reverse_vec.push(&last_digit);\n\
    \   |                          ^^^^^^^^^^^ expected struct `String`, found `&&isize`\n\
    \   |\nhelp: try using a conversion method\n   |\n27 |         reverse_vec.push((&last_digit).to_string());\n\
    \   |                          +           +++++++++++++\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for type `str` in the current scope\n\
    \  --> /tmp/tmp4sznvumj.rs:37:27\n   |\n37 |         let digit = &str::from_str(&digit_str).unwrap();\n\
    \   |                           ^^^^^^^^ function or associated item not found\
    \ in `str`\n\nerror[E0604]: only `u8` can be cast as `char`, not `usize`\n  -->\
    \ /tmp/tmp4sznvumj.rs:24:26\n   |\n24 |         reverse_vec.push((digit as char).to_string());\n\
    \   |                          ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp4sznvumj.rs:24:26\n   |\n24 |         reverse_vec.push((digit\
    \ as char).to_string());\n   |                          ^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599, E0604.\nFor more information about an error, try `rust"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut ret: Vec<String>\
    \ = vec![];\n    for el in arr {\n        match el {\n            1 => \"One\"\
    .into(),\n            2 => \"Two\".into(),\n            3 => \"Three\".into(),\n\
    \            4 => \"Four\".into(),\n            5 => \"Five\".into(),\n      \
    \      6 => \"Six\".into(),\n            7 => \"Seven\".into(),\n            8\
    \ => \"Eight\".into(),\n            9 => \"Nine\".into(),\n            _ => ret.append(String::from(&(el\
    \ as usize).to_string())),\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_kjvf1oc.rs:26:29\n   |\n\
    26 |             _ => ret.append(String::from(&(el as usize).to_string())),\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&mut Vec<String>`, found struct `String`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<String>`\n                         found struct `String`\n\
    \nerror[E0277]: the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:25:25\n\
    \   |\n25 |             9 => \"Nine\".into(),\n   |                         ^^^^\
    \ the trait `From<&str>` is not implemented for `()`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Into<()>` for `&str`\n\nerror[E0277]:\
    \ the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:24:26\n\
    \   |\n24 |             8 => \"Eight\".into(),\n   |                         \
    \ ^^^^ the trait `From<&str>` is not implemented for `()`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Into<()>` for `&str`\n\nerror[E0277]:\
    \ the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:23:26\n\
    \   |\n23 |             7 => \"Seven\".into(),\n   |                         \
    \ ^^^^ the trait `From<&str>` is not implemented for `()`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Into<()>` for `&str`\n\nerror[E0277]:\
    \ the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:22:24\n\
    \   |\n22 |             6 => \"Six\".into(),\n   |                        ^^^^\
    \ the trait `From<&str>` is not implemented for `()`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Into<()>` for `&str`\n\nerror[E0277]:\
    \ the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:21:25\n\
    \   |\n21 |             5 => \"Five\".into(),\n   |                         ^^^^\
    \ the trait `From<&str>` is not implemented for `()`\n   |\n   = note: required\
    \ because of the requirements on the impl of `Into<()>` for `&str`\n\nerror[E0277]:\
    \ the trait bound `(): From<&str>` is not satisfied\n  --> /tmp/tmp_kjvf1oc.rs:20:25\n\
    \ "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut buf: Vec<String> = vec![];\n\
    \n    for i in arr.iter() {\n        let mut digit: String = String::new();\n\n\
    \        while i >= 100 {\n            digit = format!(\"{}{}\", digit, String::from(\"\
    One\"));\n            i -= 100;\n        }\n\n        while i >= 10 {\n      \
    \      digit = format!(\"{}{}\", digit, String::from(\"Two\"));\n            i\
    \ -= 10;\n        }\n\n        while i >= 1 {\n            digit = format!(\"\
    {}{}\", digit, String::from(\"Three\"));\n            i -= 1;\n        }\n\n \
    \       while i >= 0 {\n            digit = format!(\"{}{}\", digit, String::from(\"\
    Four\"));\n            i -= 0;\n        }\n\n        buf.push(digit);\n    }\n\
    \n    buf\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_pdj5f3.rs:23:20\n   |\n\
    23 |         while i >= 100 {\n   |                    ^^^\n   |             \
    \       |\n   |                    expected `&isize`, found integer\n   |    \
    \                help: consider borrowing here: `&100`\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpt_pdj5f3.rs:25:13\n\
    \   |\n25 |             i -= 100;\n   |             -^^^^^^^\n   |           \
    \  |\n   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can\
    \ be used on `isize`, you can dereference `i`\n   |\n25 |             *i -= 100;\n\
    \   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_pdj5f3.rs:28:20\n\
    \   |\n28 |         while i >= 10 {\n   |                    ^^\n   |        \
    \            |\n   |                    expected `&isize`, found integer\n   |\
    \                    help: consider borrowing here: `&10`\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpt_pdj5f3.rs:30:13\n\
    \   |\n30 |             i -= 10;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `i`\n   |\n30 |             *i -= 10;\n   |\
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_pdj5f3.rs:33:20\n\
    \   |\n33 |         while i >= 1 {\n   |                    ^\n   |          \
    \          |\n   |                    expected `&isize`, found integer\n   | \
    \                   help: consider borrowing here: `&1`\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpt_pdj5f3.rs:35:13\n\
    \   |\n35 |             i -= 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `i`\n   |\n35 |             *i -= 1;\n   | \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_pdj5f3.rs:38:20\n\
    \   |\n38 |         while i >= 0 {\n   |                    ^\n   |          \
    \          |\n   |                    expe"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n\n    match arr.len() {\n        0 => return vec![],\n        _ =>\
    \ {\n            for val in arr {\n                let idx = val % 10;\n     \
    \           let digit = idx as isize;\n\n                if digit == 1 {\n   \
    \                 result.push(String::from(\"One\"));\n                } else\
    \ if digit == 2 {\n                    result.push(String::from(\"Two\"));\n \
    \               } else if digit == 3 {\n                    result.push(String::from(\"\
    Three\"));\n                } else if digit == 4 {\n                    result.push(String::from(\"\
    Four\"));\n                } else if digit == 5 {\n                    result.push(String::from(\"\
    Five\"));\n                } else if digit == 6 {\n                    result.push(String::from(\"\
    Six\"));\n                } else if digit == 7 {\n                    result.push(String::from(\"\
    Seven\"));\n                } else if digit == 8 {\n                    result.push(String::from(\"\
    Eight\"));\n                } else if digit == 9 {\n                    result.push(String::from(\"\
    Nine\"));\n                } else {\n                    result\n            \
    \    };\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpgywrg3a4.rs:42:21\n\
    \   |\n39 |                   } else if digit == 9 {\n   |  ________________________-\n\
    40 | |                     result.push(String::from(\"Nine\"));\n   | |      \
    \               ---------------------------------- expected because of this\n\
    41 | |                 } else {\n42 | |                     result\n   | |   \
    \                  ^^^^^^ expected `()`, found struct `Vec`\n43 | |          \
    \       };\n   | |_________________- `if` and `else` have incompatible types\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut output =\
    \ vec![];\n    let mut len = arr.len() as isize;\n\n    while len > 0 {\n    \
    \    if len % 2 == 1 {\n            let mut s = String::from(\"\");\n        \
    \    if len % 10 == 0 {\n                s = String::from(format!(\"{}\", arr[len\
    \ / 10 as usize - 1]));\n            } else {\n                s = String::from(format!(\"\
    {}{}\", arr[len / 10 as usize - 1], arr[len / 10 as usize - 1]));\n          \
    \  }\n            s.reverse();\n            output.push(s);\n        } else {\n\
    \            let mut s = String::from(\"\");\n            if len % 10 == 0 {\n\
    \                s = String::from(format!(\"{}\", arr[len / 10 as usize - 1]));\n\
    \            } else {\n                s = String::from(format!(\"{}{}\", arr[len\
    \ / 10 as usize - 1], arr[len / 10 as usize - 1]));\n            }\n         \
    \   output.push(s);\n        }\n        len -= 2;\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprbk6sumk.rs:21:58\n   |\n\
    21 |                 s = String::from(format!(\"{}\", arr[len / 10 as usize -\
    \ 1]));\n   |                                                          ^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n\
    \  --> /tmp/tmprbk6sumk.rs:21:56\n   |\n21 |                 s = String::from(format!(\"\
    {}\", arr[len / 10 as usize - 1]));\n   |                                    \
    \                    ^ no implementation for `isize / usize`\n   |\n   = help:\
    \ the trait `Div<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprbk6sumk.rs:21:48\n  \
    \ |\n21 |                 s = String::from(format!(\"{}\", arr[len / 10 as usize\
    \ - 1]));\n   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprbk6sumk.rs:23:60\n   |\n23 |              \
    \   s = String::from(format!(\"{}{}\", arr[len / 10 as usize - 1], arr[len / 10\
    \ as usize - 1]));\n   |                                                     \
    \       ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot divide\
    \ `isize` by `usize`\n  --> /tmp/tmprbk6sumk.rs:23:58\n   |\n23 |            \
    \     s = String::from(format!(\"{}{}\", arr[len / 10 as usize - 1], arr[len /\
    \ 10 as usize - 1]));\n   |                                   "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut sorted_arr = arr\n        .iter()\n\
    \        .cloned()\n        .filter(|&x| x >= 1 && x <= 9)\n        .cloned()\n\
    \        .cloned()\n        .collect::<Vec<_>>();\n\n    sort_vec(&mut sorted_arr);\n\
    \n    let mut result = vec![];\n    for x in sorted_arr.iter().cloned() {\n  \
    \      let name = NAMES[x as usize].cloned();\n        result.push(name);\n  \
    \  }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_vec` in this scope\n  --> /tmp/tmp5ke3bzzh.rs:26:5\n\
    \   |\n26 |     sort_vec(&mut sorted_arr);\n   |     ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `NAMES` in this scope\n  --> /tmp/tmp5ke3bzzh.rs:30:20\n\
    \   |\n30 |         let name = NAMES[x as usize].cloned();\n   |             \
    \       ^^^^^ not found in this scope\n\nerror[E0271]: type mismatch resolving\
    \ `<std::slice::Iter<'_, isize> as Iterator>::Item == &&_`\n  --> /tmp/tmp5ke3bzzh.rs:22:10\n\
    \   |\n22 |         .cloned()\n   |          ^^^^^^ expected reference, found\
    \ `isize`\n   |\n   = note: expected reference `&&_`\n              found reference\
    \ `&isize`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<std::slice::Iter<'_, isize>>`\n   = note: 1 redundant requirement\
    \ hidden\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp5ke3bzzh.rs:21:17:\
    \ 21:38]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmp5ke3bzzh.rs:22:10\n\
    \   |\n21 |         .filter(|&x| x >= 1 && x <= 9)\n   |                 ---------------------\
    \ found signature of `for<'r> fn(&'r isize) -> _`\n22 |         .cloned()\n  \
    \ |          ^^^^^^ expected signature of `for<'r> fn(&'r &_) -> _`\n   |\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp5ke3bzzh.rs:21:17: 21:38]>`\n\nerror[E0599]: the method\
    \ `cloned` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmp5ke3bzzh.rs:21:17: 21:38]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp5ke3bzzh.rs:23:10\n   |\n23 |            .cloned()\n\
    \   |             ^^^^^^ method cannot be called on `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp5ke3bzzh.rs:21:17: 21:38]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Filter<Cloned<std::slice::Iter<'_, isize>>, [closure@/tmp/tm"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut res = vec![];\n    let mut counter\
    \ = 1;\n\n    for x in arr {\n        let n = *x as isize;\n        counter =\
    \ counter * n;\n        if n != 1 && n != 9 {\n            res.push(format!(\"\
    {}\", counter));\n            counter = 1;\n        }\n    }\n    res.push(format!(\"\
    {}\", counter));\n\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpp9ekyt3g.rs:22:17\n\
    \   |\n22 |         let n = *x as isize;\n   |                 ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut a = arr.clone();\n    let mut\
    \ b = a.clone();\n    let mut i = 0;\n    let mut digit = a.len() - 1;\n\n   \
    \ while i < digit {\n        // Find first digit that is not 0 or 9.\n       \
    \ while i >= digit && !(b[i] == 0 || b[i] == 9) {\n            i -= 1;\n     \
    \   }\n\n        // Swap the first digit to front.\n        if i < digit {\n \
    \           b.swap(i, 0);\n        }\n\n        // Find digit before first digit\
    \ that isn't 0 or 9.\n        while i <= digit && !(b[i] == 0 || b[i] == 9) {\n\
    \            i += 1;\n        }\n\n        // Swap the digit before first digit\
    \ to front.\n        if i <= digit {\n            b.swap(i, 0);\n        }\n \
    \   }\n\n    b.reverse();\n    a.iter().map(|&x| String::from(\n        match\
    \ x.to_digit() {\n            Some(d) => \"One\".to_string(),\n            None\
    \ => \"Nine\".to_string(),\n        },\n    )).collect()\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp0scye4a8.rs:47:17\n   |\n47 |         match x.to_digit()\
    \ {\n   |                 ^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        1 => vec![String::from(\"One\")],\n        2 =>\
    \ vec![String::from(\"Two\")],\n        3 => vec![String::from(\"Three\")],\n\
    \        4 => vec![String::from(\"Four\")],\n        5 => vec![String::from(\"\
    Five\")],\n        6 => vec![String::from(\"Six\")],\n        7 => vec![String::from(\"\
    Seven\")],\n        8 => vec![String::from(\"Eight\")],\n        9 => vec![String::from(\"\
    Nine\")],\n        _ => {\n            let mut reversed = vec![];\n          \
    \  let mut one = String::from(\"One\");\n            let mut two = String::from(\"\
    Two\");\n            let mut three = String::from(\"Three\");\n            let\
    \ mut four = String::from(\"Four\");\n            let mut five = String::from(\"\
    Five\");\n            let mut six = String::from(\"Six\");\n            let mut\
    \ seven = String::from(\"Seven\");\n            let mut eight = String::from(\"\
    Eight\");\n            let mut nine = String::from(\"Nine\");\n            for\
    \ i in arr.iter() {\n                match i {\n                    1 => reversed.push(one),\n\
    \                    2 => reversed.push(two),\n                    3 => reversed.push(three),\n\
    \                    4 => reversed.push(four),\n                    5 => reversed.push(five),\n\
    \                    6 => reversed.push(six),\n                    7 => reversed.push(seven),\n\
    \                    8 => reversed.push(eight),\n                    9 => reversed.push(nine),\n\
    \                    _ => continue,\n                };\n                one =\
    \ String::from(\"One\");\n                two = String::from(\"Two\");\n     \
    \           three = String::from(\"Three\");\n                four = String::from(\"\
    Four\");\n                five = String::from(\"Five\");\n                six\
    \ = String::from(\"Six\");\n                seven = String::from(\"Seven\");\n\
    \                eight = String::from(\"Eight\");\n                nine = String::from(\"\
    Nine\");\n            }\n            reversed.reverse()\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpelsjunhf.rs:59:13\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    59 |             reversed.reverse()\n   |             ^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n \
    \          found unit type `()`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    match arr.len() {\n\
    \        0 => vec![],\n        _ => arr.iter()\n            .rev()\n         \
    \   .enumerate()\n            .filter_map(|(idx, val)| {\n                if val\
    \ >= 1 && val <= 9 {\n                    Some(String::from(format!(\"{}\", val)))\n\
    \                } else {\n                    None\n                }\n     \
    \       })\n            .collect::<Vec<String>>()\n    }\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphef3w_3c.rs:20:27\n   |\n\
    20 |                 if val >= 1 && val <= 9 {\n   |                         \
    \  ^\n   |                           |\n   |                           expected\
    \ `&isize`, found integer\n   |                           help: consider borrowing\
    \ here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphef3w_3c.rs:20:39\n\
    \   |\n20 |                 if val >= 1 && val <= 9 {\n   |                  \
    \                     ^\n   |                                       |\n   |  \
    \                                     expected `&isize`, found integer\n   | \
    \                                      help: consider borrowing here: `&9`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut counter: Vec<usize> = vec![0;\
    \ 10];\n    for val in arr {\n        if val > 9 {\n            counter[val -\
    \ 1] += 1;\n        } else {\n            counter[0] += 1;\n        }\n    }\n\
    \n    let mut result = vec![];\n    let mut reverse_arr = arr.clone();\n    for\
    \ i in 0..10 {\n        match reverse_arr.len() {\n            0 => {\n      \
    \          // if there are only ones, return them immediately\n              \
    \  if counter[i] > 1 {\n                    result.push(i.to_string());\n    \
    \            }\n                break;\n            }\n            n => {\n  \
    \              // if there are more than one digit in the number, then return\
    \ them in\n                // descending order\n                let mut pos =\
    \ 0;\n                while pos < n && counter[pos] > 1 {\n                  \
    \  pos += 1;\n                }\n\n                let mut tmp_pos = 0;\n    \
    \            while tmp_pos < pos && counter[tmp_pos] > 1 {\n                 \
    \   tmp_pos += 1;\n                }\n                if tmp_pos < pos {\n   \
    \                 result.push(String::from(&reverse_arr[tmp_pos]))\n         \
    \       }\n                reverse_arr.swap_remove(pos);\n                break;\n\
    \            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[usize]` cannot be indexed by `isize`\n  --> /tmp/tmpfn3pkke1.rs:21:13\n\
    \   |\n21 |             counter[val - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[usize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<usize>`\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpfn3pkke1.rs:51:33\n\
    \   |\n51 |                     result.push(String::from(&reverse_arr[tmp_pos]))\n\
    \   |                                 ^^^^^^^^^^^^ the trait `From<&isize>` is\
    \ not implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr\n        .iter()\n\
    \        .filter(|e| e > 1 && e < 9)\n        .map(|e| match e {\n           \
    \ 1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n         \
    \   3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n    \
    \        5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n \
    \           7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => format!(\"{:?}\", e).to_string(),\n\
    \        })\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1br4hob_.rs:16:25\n   |\n\
    16 |         .filter(|e| e > 1 && e < 9)\n   |                         ^ expected\
    \ `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1br4hob_.rs:16:34\n\
    \   |\n16 |         .filter(|e| e > 1 && e < 9)\n   |                        \
    \          ^ expected `&&isize`, found integer\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min = arr.min_by(|&x, &y| x.cmp(&y));\n\
    \    let mut max = arr.max_by(|&x, &y| x.cmp(&y));\n    let mut res = vec![String::from(\"\
    \".to_string())];\n    while min != max {\n        let n = max.cmp(&min) as isize;\n\
    \        res.insert(n, String::from(ONE_TO_NINE [min]));\n        min = max;\n\
    \        max = arr.min_by(|&x, &y| x.cmp(&y));\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ONE_TO_NINE` in this scope\n  --> /tmp/tmpx7kbxtdo.rs:22:36\n\
    \   |\n22 |         res.insert(n, String::from(ONE_TO_NINE [min]));\n   |    \
    \                                ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpx7kbxtdo.rs:17:23\n    |\n17\
    \  |       let mut min = arr.min_by(|&x, &y| x.cmp(&y));\n    |              \
    \           ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpx7kbxtdo.rs:18:23\n    |\n18\
    \  |       let mut max = arr.max_by(|&x, &y| x.cmp(&y));\n    |              \
    \           ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmpx7kbxtdo.rs:24:19\n    |\n24\
    \  |           max = arr.min_by(|&x, &y| x.cmp(&y));\n    |                  \
    \   ^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<isize>: Iterator`\n           \
    \ which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n\
    \            which is required by `&mut [isize]: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut n = 1;\n    let mut result = vec![];\n\
    \    let mut reversed = arr;\n    reversed.sort();\n    for i in reversed.iter()\
    \ {\n        if i <= 9 {\n            result.push(String::from(format!(\"{}\"\
    , i)));\n        } else {\n            n += 1;\n            if n == 10 || n >=\
    \ 100 {\n                result.push(String::from(\"Ten\"));\n               \
    \ n = 0;\n            }\n            if n == 1 || n >= 10 {\n                result.push(String::from(\"\
    One\"));\n                n = 1;\n            }\n            if n == 2 || n >=\
    \ 20 {\n                result.push(String::from(\"Two\"));\n                n\
    \ = 2;\n            }\n            if n == 3 || n >= 30 {\n                result.push(String::from(\"\
    Three\"));\n                n = 3;\n            }\n            if n == 4 || n\
    \ >= 40 {\n                result.push(String::from(\"Four\"));\n            \
    \    n = 4;\n            }\n            if n == 5 || n >= 50 {\n             \
    \   result.push(String::from(\"Five\"));\n                n = 5;\n           \
    \ }\n            if n == 6 || n >= 60 {\n                result.push(String::from(\"\
    Six\"));\n                n = 6;\n            }\n            if n == 7 || n >=\
    \ 70 {\n                result.push(String::from(\"Seven\"));\n              \
    \  n = 7;\n            }\n            if n == 8 || n >= 80 {\n               \
    \ result.push(String::from(\"Eight\"));\n                n = 8;\n            }\n\
    \            if n == 9 || n >= 90 {\n                result.push(String::from(\"\
    Nine\"));\n                n = 9;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0n88zudr.rs:22:17\n   |\n\
    22 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut sorted_arr\
    \ = arr.sort_by_key(|x| x.cmp(&1));\n    let mut result = vec![];\n    let mut\
    \ counter = 1;\n\n    for val in sorted_arr {\n        // check if we should keep\
    \ this element\n        if val == 1 && counter == 2 {\n            result.push(String::from(\"\
    One\"));\n            counter = 1;\n        } else if val == 2 && counter == 3\
    \ {\n            result.push(String::from(\"Two\"));\n            counter = 1;\n\
    \        } else if val == 3 && counter == 4 {\n            result.push(String::from(\"\
    Three\"));\n            counter = 1;\n        } else if val == 4 && counter ==\
    \ 5 {\n            result.push(String::from(\"Four\"));\n            counter =\
    \ 1;\n        } else if val == 5 && counter == 6 {\n            result.push(String::from(\"\
    Five\"));\n            counter = 1;\n        } else if val == 6 && counter ==\
    \ 7 {\n            result.push(String::from(\"Six\"));\n            counter =\
    \ 1;\n        } else if val == 7 && counter == 8 {\n            result.push(String::from(\"\
    Seven\"));\n            counter = 1;\n        } else if val == 8 && counter ==\
    \ 9 {\n            result.push(String::from(\"Eight\"));\n            counter\
    \ = 1;\n        } else if val == 9 && counter == 10 {\n            result.push(String::from(\"\
    Nine\"));\n            counter = 1;\n        } else {\n            result.push(String::from(val));\n\
    \        }\n        counter++;\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2fvho_wd.rs:50:16\n\
    \   |\n50 |         counter++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n50 |         { let tmp = counter; counter\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n50 -  \
    \       counter++;\n50 +         counter += 1;\n   | \n\nerror[E0277]: `()` is\
    \ not an iterator\n  --> /tmp/tmp2fvho_wd.rs:18:16\n   |\n18 |     for val in\
    \ sorted_arr {\n   |                ^^^^^^^^^^ `()` is not an iterator\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `()`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_unstable();\n\
    \    let mut result = vec![];\n    for i in arr {\n        let mut str = String::from(\"\
    \");\n        str.push_str(&\"One\".to_string());\n        if i > 0 && i <= 9\
    \ {\n            str.push_str(&\"Ten\".to_string());\n            if i % 10 ==\
    \ 0 {\n                str.push_str(&\"One\".to_string());\n            }\n  \
    \      }\n        result.push(str);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmppxzjndk7.rs:14:5\n   |\n13 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |              --- help: consider changing this to be mutable:\
    \ `mut arr`\n14 |     arr.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_unstable();\n\
    \    arr\n        .iter()\n        .map(|x| match x {\n            0 => \"Zero\"\
    ,\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            other => other,\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp4p_9sofi.rs:28:22\n\
    \   |\n17 |           .map(|x| match x {\n   |  __________________-\n18 | |  \
    \           0 => \"Zero\",\n19 | |             1 => \"One\",\n20 | |         \
    \    2 => \"Two\",\n...  |\n27 | |             9 => \"Nine\",\n   | |        \
    \          ------ this and all prior arms are found to be of type `&str`\n28 |\
    \ |             other => other,\n   | |                      ^^^^^ expected `str`,\
    \ found `isize`\n29 | |         })\n   | |_________- `match` arms have incompatible\
    \ types\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res: Vec<String>\
    \ = vec![];\n    let mut len = arr.len();\n    let mut cur = String::from(\"One\"\
    );\n    let mut prev = String::from(\"One\");\n\n    while len > 0 {\n       \
    \ // If there's an odd number of 1's, pick which one is first\n        if len\
    \ % 2 == 1 {\n            cur = cur.to_string();\n            prev = (arr.len()\
    \ as u32).to_string();\n        }\n\n        let i = len - 1;\n        let t =\
    \ &arr[len - 2].to_string();\n\n        // If there's a 2, then swap them and\
    \ increment the number of swaps\n        if t == &\"Two\" {\n            swap(&mut\
    \ arr[i], &mut arr[i + 1]);\n            res.push(*prev);\n            prev =\
    \ (arr.len() as u32).to_string();\n        }\n\n        // If there's a 3, then\
    \ swap them and increment the number of swaps\n        if t == &\"Three\" {\n\
    \            swap(&mut arr[i], &mut arr[i + 1]);\n            res.push(*prev);\n\
    \            prev = (arr.len() as u32).to_string();\n        }\n\n        // If\
    \ there's a 4, then swap them and increment the number of swaps\n        if t\
    \ == &\"Four\" {\n            swap(&mut arr[i], &mut arr[i + 1]);\n          \
    \  res.push(*prev);\n            prev = (arr.len() as u32).to_string();\n    \
    \    }\n\n        // If there's a 5, then swap them and increment the number of\
    \ swaps\n        if t == &\"Five\" {\n            swap(&mut arr[i], &mut arr[i\
    \ + 1]);\n            res.push(*prev);\n            prev = (arr.len() as u32).to_string();\n\
    \        }\n\n        // If there's a 6, then swap them and increment the number\
    \ of swaps\n        if t == &\"Six\" {\n            swap(&mut arr[i], &mut arr[i\
    \ + 1]);\n            res.push(*prev);\n            prev = (arr.len() as u32).to_string();\n\
    \        }\n\n        // If there's a 7, then swap them and increment the number\
    \ of swaps\n        if t == &\"Seven\" {\n            swap(&mut arr[i], &mut arr[i\
    \ + 1]);\n            res.push(*prev);\n            prev = (arr.len() as u32).to_string();\n\
    \        }\n\n        // If there's a 8, then swap them and increment the number\
    \ of swaps\n        if t == &\"Eight\" {\n            swap(&mut arr[i], &mut arr[i\
    \ + 1]);\n            res.push(*prev);\n            prev = (arr.len() as u32).to_string();\n\
    \        }\n\n        // If there's a 9, then swap them and increment the number\
    \ of swaps\n        if t == &\"Nine\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp2fwwgwaw.rs:88:110\n\
    \   |\n88 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n   |  ______________________________________________________________________________________________________________^\n\
    89 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut reversed = arr.iter().rev();\n\
    \        reversed.for_each(|&i| {\n            match i {\n                1 =>\
    \ return,\n                -1 => reversed.pop(),\n                0 => return,\n\
    \                _ => {}\n            }\n        });\n\n        let mut res =\
    \ vec![];\n        for i in reversed {\n            if i % 10 == 1 {\n       \
    \         res.push(String::from(\"One\"));\n            }\n            if i %\
    \ 10 == 2 || i % 10 == 3 {\n                res.push(String::from(\"Two\"));\n\
    \            }\n            if i % 10 == 4 || i % 10 == 5 {\n                res.push(String::from(\"\
    Three\"));\n            }\n            if i % 10 == 6 || i % 10 == 7 {\n     \
    \           res.push(String::from(\"Four\"));\n            }\n            if i\
    \ % 10 == 8 || i % 10 == 9 {\n                res.push(String::from(\"Five\"));\n\
    \            }\n            if i % 10 == 10 || i % 10 == 0 {\n               \
    \ res.push(String::from(\"Six\"));\n            }\n            if i % 10 == 11\
    \ || i % 10 == 12 {\n                res.push(String::from(\"Seven\"));\n    \
    \        }\n            if i % 10 == 13 || i % 10 == 14 {\n                res.push(String::from(\"\
    Eight\"));\n            }\n            if i % 10 == 15 || i % 10 == 16 {\n   \
    \             res.push(String::from(\"Nine\"));\n            }\n            if\
    \ i % 10 == 17 || i % 10 == 18 {\n                res.push(String::from(\"Ten\"\
    ));\n            }\n            if i % 10 == 19 || i % 10 == 20 {\n          \
    \      res.push(String::from(\"Eleven\"));\n            }\n            if i %\
    \ 10 == 21 || i % 10 == 22 {\n                res.push(String::from(\"Twelve\"\
    ));\n            }\n            if i % 10 == 23 || i % 10 == 24 {\n          \
    \      res.push(String::from(\"Thirteen\"));\n            }\n            if i\
    \ % 10 == 25 || i % 10 == 26 {\n                res.push(String::from(\"Fourteen\"\
    ));\n            }\n            if i % 10 == 27 || i % 10 == 28 {\n          \
    \      res.push(String::from(\"Fifteen\"));\n            }\n            if i %\
    \ 10 == 29 || i % 10 == 30 {\n                res.push(String::from(\"Sixteen\"\
    ));\n            }\n            if i % 10 == 31 || i % 10 == 32 {\n          \
    \      res.push(String::from(\"Seventeen\"));\n            }\n            if i\
    \ % 10 == 33 || i % 10 == 34 {\n                res.push(String::from(\"Eighteen\"\
    ));\n            }\n            if i % \n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7tpi73uf.rs:93:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     } else {\n\
    \   |            - unclosed delimiter\n...\n28 |         for i in reversed {\n\
    \   |                           - this delimiter might not be properly closed...\n\
    ...\n84 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    93 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp7tpi73uf.rs:84:1\n\
    \   |\n84 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `pop`\
    \ found for struct `Rev` in the current scope\n  --> /tmp/tmp7tpi73uf.rs:21:32\n\
    \   |\n21 |                 -1 => reversed.pop(),\n   |                      \
    \          ^^^ method not found in `Rev<std::slice::Iter<'_, isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7tpi73uf.rs:16:12\n   |\n16 |       } else {\n\
    \   |  ____________^\n17 | |         let mut reversed = arr.iter().rev();\n18\
    \ | |         reversed.for_each(|&i| {\n19 | |             match i {\n...  |\n\
    92 | |     assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"\
    Eight\"), String::from(\"Four\")]);\n93 | | }\n   | |__^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<String>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut len = arr.len();\n    let mut\
    \ count = 0;\n    let mut s = String::new();\n    let mut i = 0;\n    for num\
    \ in arr {\n        if num >= 1 && num <= 9 {\n            i += 1;\n         \
    \   if i == len {\n                count += 1;\n                i += 1;\n    \
    \        }\n        } else {\n            break;\n        }\n    }\n\n    if count\
    \ > len / 2 {\n        return vec![String::from(\"One\")];\n    }\n\n    while\
    \ i < len - 1 {\n        i += 1;\n        let a = String::from(\"One\");\n   \
    \     let b = String::from(\"Two\");\n        let c = String::from(\"Three\");\n\
    \        let d = String::from(\"Four\");\n        let e = String::from(\"Five\"\
    );\n        let f = String::from(\"Six\");\n        let g = String::from(\"Seven\"\
    );\n        let h = String::from(\"Eight\");\n        let j = String::from(\"\
    Nine\");\n        if arr.iter().nth(i).unwrap() >= 1 && arr.iter().nth(i).unwrap()\
    \ <= 9 {\n            if arr.iter().nth(i).unwrap() == 1 {\n                s\
    \ = s.replace(\"One\", a);\n            } else {\n                s = s.replace(\"\
    One\", b);\n            }\n        } else {\n            if arr.iter().nth(i).unwrap()\
    \ == 10 {\n                s = s.replace(\"Nine\", j);\n            } else {\n\
    \                s = s.replace(\"Nine\", h);\n            }\n        }\n     \
    \   if arr.iter().nth(i).unwrap() == 8 {\n            s = s.replace(\"Eight\"\
    , e);\n        } else {\n            s = s.replace(\"Eight\", f);\n        }\n\
    \        if arr.iter().nth(i).unwrap() == 7 {\n            s = s.replace(\"Seven\"\
    , g);\n        } else {\n            s = s.replace(\"Seven\", f);\n        }\n\
    \        if arr.iter().nth(i).unwrap() == 6 {\n            s = s.replace(\"Six\"\
    , f);\n        } else {\n            s = s.replace(\"Six\", g);\n        }\n \
    \       if arr.iter().nth(i).unwrap() == 5 {\n            s = s.replace(\"Five\"\
    , e);\n        } else {\n            s = s.replace(\"Five\", f);\n        }\n\
    \        if arr.iter().nth(i).unwrap() == 4 {\n            s = s.replace(\"Four\"\
    , d);\n        } else {\n            s = s.replace(\"Four\", c);\n        }\n\
    \        if arr.iter().nth(i).unwrap() == 3 {\n            s = s.replace(\"Three\"\
    , c);\n        } else {\n            s = s.replace(\"Three\", b);\n        }\n\
    \        if arr.iter().nth(i).unwrap() == 2 {\n            s = s.replace(\"Two\"\
    , b);\n        } else {\n            s = s.replace(\"Two\", a);\n        }\n \
    \       if arr.iter\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9sdblbgu.rs:107:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n38  |     while\
    \ i < len - 1 {\n    |                       - this delimiter might not be properly\
    \ closed...\n...\n98  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n107 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmp9sdblbgu.rs:98:1\n   |\n97 |         if arr.iter\n   |         -- this\
    \ `if` expression has a condition, but no block\n98 | }\n   | ^ expected `{`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9sdblbgu.rs:49:42\n   |\n49 |\
    \         if arr.iter().nth(i).unwrap() >= 1 && arr.iter().nth(i).unwrap() <=\
    \ 9 {\n   |                                          ^\n   |                 \
    \                         |\n   |                                          expected\
    \ `&isize`, found integer\n   |                                          help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sdblbgu.rs:49:77\n\
    \   |\n49 |         if arr.iter().nth(i).unwrap() >= 1 && arr.iter().nth(i).unwrap()\
    \ <= 9 {\n   |                                                               \
    \              ^\n   |                                                       \
    \                      |\n   |                                               \
    \                              expected `&isize`, found integer\n   |        \
    \                                                                     help: consider\
    \ borrowing here: `&9`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmp9sdblbgu.rs:50:43\n   |\n50 |             if arr.iter().nth(i).unwrap()\
    \ == 1 {\n   |                                           ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n\n    let mut sorted_by_length = arr.clone();\n\
    \    sorted_by_length.sort_by_key(|x| x as isize);\n\n    // get reverse sorted\
    \ array for \"Fifteen\", \"Four\", ..., \"One\"\n    let mut reversed_array =\
    \ sorted_by_length.clone();\n    reversed_array.reverse();\n\n    let mut reversed_by_length:\
    \ Vec<String> = vec![];\n    for i in 0..(reversed_array.len() / 10).unwrap()\
    \ {\n        let mut j = i;\n        let mut temp: isize = 0;\n        while j\
    \ >= 0 && reversed_array[j] >= 10 {\n            reversed_by_length.push(String::from(reversed_array[j]\
    \ - 10 + temp));\n            j -= 1;\n        }\n        reversed_by_length.push(String::from(reversed_array[j]\
    \ + temp));\n    }\n\n    // now get \"One\", \"Two\", ..., \"Nine\"\n    for\
    \ i in 0..(reversed_by_length.len() / 10).unwrap() {\n        let mut j = i;\n\
    \        let mut temp: isize = 0;\n        while j >= 0 && reversed_by_length[j]\
    \ >= 10 {\n            reversed_by_length.push(String::from(reversed_by_length[j]\
    \ - 10 + temp));\n            j -= 1;\n        }\n        reversed_by_length.push(String::from(reversed_by_length[j]\
    \ + temp));\n    }\n    reversed_by_length.reverse();\n    return reversed_by_length;\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp_9m340q_.rs:26:45\n   |\n26 |     for i in 0..(reversed_array.len()\
    \ / 10).unwrap() {\n   |                                             ^^^^^^ method\
    \ not found in `usize`\n\nerror[E0277]: the trait bound `String: From<isize>`\
    \ is not satisfied\n  --> /tmp/tmp_9m340q_.rs:30:37\n   |\n30 |             reversed_by_length.push(String::from(reversed_array[j]\
    \ - 10 + temp));\n   |                                     ^^^^^^^^^^^^ the trait\
    \ `From<isize>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the trait bound\
    \ `String: From<isize>` is not satisfied\n  --> /tmp/tmp_9m340q_.rs:33:33\n  \
    \ |\n33 |         reversed_by_length.push(String::from(reversed_array[j] + temp));\n\
    \   |                                 ^^^^^^^^^^^^ the trait `From<isize>` is\
    \ not implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp_9m340q_.rs:37:49\n   |\n37\
    \ |     for i in 0..(reversed_by_length.len() / 10).unwrap() {\n   |         \
    \                                        ^^^^^^ method not found in `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_9m340q_.rs:40:50\n   |\n40 |  \
    \       while j >= 0 && reversed_by_length[j] >= 10 {\n   |                  \
    \                                ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                                  |\n   |          "
  stdout: ''
  timestamp: 1659976650
- exit_code: 101
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.len() == 0\
    \ {\n        return vec![];\n    }\n    let mut vec = vec![];\n    for i in arr\
    \ {\n        if i <= 9 {\n            vec.push(String::from(format!(\"{}\", i)));\n\
    \        } else {\n            vec.push(String::from(format!(\"{}\", i)));\n \
    \           vec.push(String::from(format!(\"{}\", (i + 9 - 1) % 10)));\n     \
    \   }\n    }\n    vec.reverse();\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmppn3faijs.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976651
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    if arr.is_empty() {\n        return result;\n    }\n    let mut\
    \ digits = arr.iter().cloned().collect::<Vec<_>>();\n    digits = digits.reverse();\n\
    \    let mut digit = 0;\n    let mut pos = 0;\n    while digit < 10 {\n      \
    \  if pos == digits.len() {\n            break;\n        }\n        let mut cur_digit\
    \ = digits[pos].to_string();\n        digit += cur_digit.chars().next().unwrap().to_string().parse().unwrap();\n\
    \        pos = pos + 1;\n    }\n    if pos == digits.len() {\n        return result;\n\
    \    }\n    let mut digit = digits[pos].to_string();\n    let mut pos = pos +\
    \ 1;\n    while digit < 10 {\n        let mut cur_digit = digits[pos].to_string();\n\
    \        result.push(String::from(cur_digit.chars().next().unwrap().to_string()));\n\
    \        digit = digit + 1;\n        pos = pos + 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_r6vl4i.rs:19:14\n   |\n\
    18 |     let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n   |     \
    \                 --------------------------------------- expected due to this\
    \ value\n19 |     digits = digits.reverse();\n   |              ^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_r6vl4i.rs:35:19\n\
    \   |\n35 |     while digit < 10 {\n   |                   ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                   |\n   |        \
    \           expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo_r6vl4i.rs:38:25\n   |\n38 |         digit = digit + 1;\n\
    \   |                         ^ expected `&str`, found integer\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.sort_by(|a, b|\
    \ b.cmp(&a));\n    arr.iter().rev().map(|&a| by_digit_name(a)).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit_name` in this scope\n  -->\
    \ /tmp/tmpttodtztn.rs:15:31\n   |\n15 |     arr.iter().rev().map(|&a| by_digit_name(a)).collect()\n\
    \   |                               ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut output: Vec<String>\
    \ = vec![];\n\n    for i in arr {\n        if i < 10 {\n            output.push(String::from(&format!(\"\
    {}\", i)));\n        } else {\n            let j = i / 10;\n            let k\
    \ = i % 10;\n            output.push(by_length(vec![j, k]).rev().collect::<Vec<_>>());\n\
    \        }\n    }\n\n    if output.is_empty() {\n        output\n    } else {\n\
    \        let mut reverse = output\n            .into_iter()\n            .reverse()\n\
    \            .collect::<Vec<_>>();\n        let mut result = vec![];\n       \
    \ for i in reverse {\n            result.push(by_digit(&i).unwrap());\n      \
    \  }\n        result\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp8mo9pnbr.rs:35:25\n\
    \   |\n35 |             result.push(by_digit(&i).unwrap());\n   |            \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0599]: `Vec<String>`\
    \ is not an iterator\n   --> /tmp/tmp8mo9pnbr.rs:22:47\n    |\n22  |         \
    \      output.push(by_length(vec![j, k]).rev().collect::<Vec<_>>());\n    |  \
    \                                               ^^^ `Vec<String>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `std::vec::IntoIter` in the current scope\n  --> /tmp/tmp8mo9pnbr.rs:31:14\n\
    \   |\n31 |             .reverse()\n   |              ^^^^^^^ method not found\
    \ in `std::vec::IntoIter<String>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let mut\
    \ i = 0;\n    while i < arr.len() {\n        let len = &arr[i..i].iter().take(3).count();\n\
    \        if len > 1 {\n            let start = i as isize + 1;\n            let\
    \ end = start + len - 1;\n            result.append(&arr[start..end]);\n     \
    \       i += len;\n        } else {\n            result.append(&arr[i..i + 1]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0zo_zv4j.rs:21:18\n   |\n\
    21 |         if len > 1 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&usize`, found integer\n   |                \
    \  help: consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0zo_zv4j.rs:23:31\n   |\n23 |             let end = start + len - 1;\n\
    \   |                               ^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add `&usize` to `isize`\n  --> /tmp/tmp0zo_zv4j.rs:23:29\n   |\n23 |\
    \             let end = start + len - 1;\n   |                             ^ no\
    \ implementation for `isize + &usize`\n   |\n   = help: the trait `Add<&usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `std::ops::Range<isize>`\n  --> /tmp/tmp0zo_zv4j.rs:24:28\n   |\n24 |   \
    \          result.append(&arr[start..end]);\n   |                            ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `std::ops::Range<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <std::ops::Range<usize> as SliceIndex<[T]>>\n             <std::ops::Range<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<std::ops::Range<isize>>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0zo_zv4j.rs:24:27\n   |\n24 |             result.append(&arr[start..end]);\n\
    \   |                           ^^^^^^^^^^^^^^^^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \     found reference `&_`\n\nerror["
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut len = arr.len() - 1;\n    \
    \    let mut rev_vec = vec![];\n        while len >= 0 {\n            if arr[len]\
    \ == 1 || arr[len] == -1 || arr[len] == 0 {\n                len -= 1;\n     \
    \       } else {\n                rev_vec.push(String::from(by_length(arr[..len])))\n\
    \            }\n        }\n        if rev_vec.is_empty() {\n            vec![]\n\
    \        } else {\n            rev_vec.reverse();\n            let mut i = 0;\n\
    \            let mut j = 0;\n            while i < rev_vec.len() {\n         \
    \       if rev_vec[j] == String::from(\"One\") {\n                    i += 1;\n\
    \                } else if rev_vec[j] == String::from(\"Two\") {\n           \
    \         i += 1;\n                } else if rev_vec[j] == String::from(\"Three\"\
    ) {\n                    i += 1;\n                } else if rev_vec[j] == String::from(\"\
    Four\") {\n                    i += 1;\n                } else if rev_vec[j] ==\
    \ String::from(\"Five\") {\n                    i += 1;\n                } else\
    \ if rev_vec[j] == String::from(\"Six\") {\n                    i += 1;\n    \
    \            } else if rev_vec[j] == String::from(\"Seven\") {\n             \
    \       i += 1;\n                } else if rev_vec[j] == String::from(\"Eight\"\
    ) {\n                    i += 1;\n                } else if rev_vec[j] == String::from(\"\
    Nine\") {\n                    i += 1;\n                } else {\n           \
    \         i += 1;\n                }\n                j += 1;\n            }\n\
    \            rev_vec\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpscqwi8lh.rs:23:53\n   |\n\
    23 |                 rev_vec.push(String::from(by_length(arr[..len])))\n   | \
    \                                                    ^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                                     \
    \                |\n   |                                                     expected\
    \ struct `Vec`, found slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found slice `[isize]`\n\nerror[E0277]: the trait bound `String:\
    \ From<Vec<String>>` is not satisfied\n  --> /tmp/tmpscqwi8lh.rs:23:43\n   |\n\
    23 |                 rev_vec.push(String::from(by_length(arr[..len])))\n   | \
    \                             ------------ ^^^^^^^^^^^^^^^^^^^^^ the trait `From<Vec<String>>`\
    \ is not implemented for `String`\n   |                              |\n   | \
    \                             required by a bound introduced by this call\n  \
    \ |\n   = help: the following other types implement trait `From<T>`:\n       \
    \      <String as From<&String>>\n             <String as From<&mut str>>\n  \
    \           <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        vec![]\n    }\n    let mut result = vec![];\n    let mut counter\
    \ = 0;\n    for num in arr {\n        if num == 1 && num > 9 {\n            counter\
    \ = 1;\n        }\n        if num >= 1 && num <= 9 {\n            if counter ==\
    \ 0 {\n                result.push(String::from(\"One\"));\n                counter\
    \ = 1;\n            } else {\n                result.push(String::from(\"Two\"\
    ));\n                counter = 2;\n            }\n        }\n        if num >=\
    \ 10 && num <= 99 {\n            if counter == 0 {\n                result.push(String::from(\"\
    Ten\"));\n                counter = 1;\n            } else {\n               \
    \ result.push(String::from(\"Eleven\"));\n                counter = 2;\n     \
    \       }\n        }\n        if num >= 100 && num <= 999 {\n            if counter\
    \ == 0 {\n                result.push(String::from(\"Twelve\"));\n           \
    \     counter = 1;\n            } else {\n                result.push(String::from(\"\
    Thirteen\"));\n                counter = 2;\n            }\n        }\n      \
    \  if num >= 1000 && num <= 999999 {\n            if counter == 0 {\n        \
    \        result.push(String::from(\"Fourteen\"));\n                counter = 1;\n\
    \            } else {\n                result.push(String::from(\"Fifteen\"));\n\
    \                counter = 2;\n            }\n        }\n        if num >= 1000000\
    \ && num <= 999999999 {\n            if counter == 0 {\n                result.push(String::from(\"\
    Sixteen\"));\n                counter = 1;\n            } else {\n           \
    \     result.push(String::from(\"Seventeen\"));\n                counter = 2;\n\
    \            }\n        }\n        if num >= 1000000000 && num <= 9999999999 {\n\
    \            if counter == 0 {\n                result.push(String::from(\"Eighteen\"\
    ));\n                counter = 1;\n            } else {\n                result.push(String::from(\"\
    Nineteen\"));\n                counter = 2;\n            }\n        }\n      \
    \  if num >= 100000000000 && num <= 99999999999999 {\n            if counter ==\
    \ 0 {\n                result.push(String::from(\"Ninety\"));\n              \
    \  counter = 1;\n            } else {\n                result.push(String::from(\"\
    Onety\"));\n                counter = 2;\n            }\n        }\n        if\
    \ num > 999999999 {\n            if counter == 0 {\n                result.push(String::from(\"\
    Ten\"));\n                counter = 1;\n            } else {\n               \
    \ result.push(String::from(\"Eleven\"));\n                counter = 2;\n     \
    \       }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8zsd4ibj.rs:15:9\n   |\n\
    14 | /     if arr.is_empty() {\n15 | |         vec![]\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n16 | |     }\n   | |_____- expected this to be `()`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<_>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n16 |     };\n   |      +\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    arr.into_iter().map(|x|\
    \ get_by_length(x)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_by_length` in this scope\n  -->\
    \ /tmp/tmpw2waweny.rs:14:29\n   |\n14 |     arr.into_iter().map(|x| get_by_length(x)).collect()\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    if arr.len() == 1 {\n        vec![\"One\"\
    ]\n    }\n    else if arr.len() == 2 {\n        vec![String::from(\"Two\"), String::from(\"\
    One\")]\n    }\n    else if arr.len() == 3 {\n        vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]\n    }\n    else if arr.len()\
    \ == 4 {\n        vec![String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]\n    }\n    else if arr.len() == 5 {\n        vec![String::from(\"\
    Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"\
    ), String::from(\"One\")]\n    }\n    else if arr.len() == 6 {\n        vec![String::from(\"\
    Six\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]\n    }\n    else if arr.len()\
    \ == 7 {\n        vec![String::from(\"Seven\"), String::from(\"Six\"), String::from(\"\
    Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"\
    ), String::from(\"One\")]\n    }\n    else if arr.len() == 8 {\n        vec![String::from(\"\
    Eight\"), String::from(\"Seven\"), String::from(\"Six\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]\n    }\n    else if arr.len() == 9 {\n        vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Seven\"), String::from(\"Six\"), String::from(\"\
    Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"\
    ), String::from(\"One\")]\n    }\n    else {\n        vec![String::from(\"One\"\
    )]\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzxxcv_ma.rs:18:14\n   |\n\
    18 |         vec![\"One\"]\n   |              ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |              |\n   |              expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut res: Vec<String>\
    \ = Vec::new();\n    let mut len = arr.len();\n    if len == 0 {\n        return\
    \ res;\n    }\n    let min_idx = if len <= 9 { 0 } else { len - 9 };\n    for\
    \ i in min_idx ..= len - 1 {\n        let idx = i % 10;\n        res.extend_from_slice(&arr[i\
    \ as usize]);\n        res[idx as usize] = String::from(&vec![\n            \"\
    Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"][idx as usize]);\n    }\n    res.reverse();\n    res\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj9dqjhsv.rs:22:31\n   |\n\
    22 |         res.extend_from_slice(&arr[i as usize]);\n   |                  \
    \             ^^^^^^^^^^^^^^^^ expected slice, found `isize`\n   |\n   = note:\
    \ expected reference `&[String]`\n              found reference `&isize`\n\nerror[E0277]:\
    \ the trait bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmpj9dqjhsv.rs:23:29\n\
    \   |\n23 |         res[idx as usize] = String::from(&vec![\n   |            \
    \                 ^^^^^^^^^^^^ the trait `From<&&str>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ Vec::new();\n    for number in arr {\n        if number <= 9 {\n           \
    \ result.push(by_length_digit(number));\n        } else {\n            result.push(by_length_word_to_string(number\
    \ % 10));\n            result.push(by_length_word_to_string(number / 10));\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_length_digit` in this scope\n  -->\
    \ /tmp/tmpxe90ij9q.rs:17:25\n   |\n17 |             result.push(by_length_digit(number));\n\
    \   |                         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `by_length_word_to_string` in this scope\n  --> /tmp/tmpxe90ij9q.rs:19:25\n\
    \   |\n19 |             result.push(by_length_word_to_string(number % 10));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `by_length_word_to_string` in this scope\n\
    \  --> /tmp/tmpxe90ij9q.rs:20:25\n   |\n20 |             result.push(by_length_word_to_string(number\
    \ / 10));\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut sorted = arr.iter().cloned().sort();\n\
    \    let mut res: Vec<String> = vec![];\n    for i in sorted {\n        if i <=\
    \ 9 {\n            res.push_back(String::from(\"One\"));\n        } else if i\
    \ > 9 && i <= 99 {\n            res.push_back(String::from(\"Two\"));\n      \
    \  } else if i > 99 && i <= 999 {\n            res.push_back(String::from(\"Three\"\
    ));\n        } else if i > 999 && i <= 9999 {\n            res.push_back(String::from(\"\
    Four\"));\n        } else if i > 9999 && i <= 99999 {\n            res.push_back(String::from(\"\
    Five\"));\n        } else if i > 99999 && i <= 999999 {\n            res.push_back(String::from(\"\
    Six\"));\n        } else if i > 999999 && i <= 9999999 {\n            res.push_back(String::from(\"\
    Seven\"));\n        } else if i > 9999999 && i <= 999999999 {\n            res.push_back(String::from(\"\
    Eight\"));\n        } else if i > 999999999 && i <= 9999999999 {\n           \
    \ res.push_back(String::from(\"Nine\"));\n        } else {\n            return\
    \ vec![];\n        }\n    }\n    for d in &res {\n        d += &format!(\"\",\
    \ \"\");\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpx_55xh3k.rs:43:27\n   |\n43 |\
    \         d += &format!(\"\", \"\");\n   |                       --  ^^ argument\
    \ never used\n   |                       |\n   |                       formatting\
    \ specifier missing\n\nerror[E0599]: no method named `sort` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpx_55xh3k.rs:17:42\n   |\n17 |     let mut\
    \ sorted = arr.iter().cloned().sort();\n   |                                 \
    \         ^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]:\
    \ no method named `push_back` found for struct `Vec<String>` in the current scope\n\
    \  --> /tmp/tmpx_55xh3k.rs:21:17\n   |\n21 |             res.push_back(String::from(\"\
    One\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\n\
    error[E0599]: no method named `push_back` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpx_55xh3k.rs:23:17\n   |\n23 |             res.push_back(String::from(\"\
    Two\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\n\
    error[E0599]: no method named `push_back` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpx_55xh3k.rs:25:17\n   |\n25 |             res.push_back(String::from(\"\
    Three\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmpx_55xh3k.rs:27:17\n   |\n27 |             res.push_back(String::from(\"\
    Four\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\n\
    error[E0599]: no method named `push_back` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpx_55xh3k.rs:29:17\n   |\n29 |             res.push_back(String::from(\"\
    Five\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\n\
    error[E0599]: no method named `push_back` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpx_55xh3k.rs:31:17\n   |\n31 |             res.push_back(String::from(\"\
    Six\"));\n   |                 ^^^^^^^^^ method not found in `Vec<String>`\n\n\
    error[E0599]: no me"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    for i in arr.iter().filter(|&i| i <= 9 || i >= 1) {\n        match\
    \ i {\n            1 => result.push(String::from(\"One\")),\n            2 =>\
    \ result.push(String::from(\"Two\")),\n            3 => result.push(String::from(\"\
    Three\")),\n            4 => result.push(String::from(\"Four\")),\n          \
    \  5 => result.push(String::from(\"Five\")),\n            6 => result.push(String::from(\"\
    Six\")),\n            7 => result.push(String::from(\"Seven\")),\n           \
    \ 8 => result.push(String::from(\"Eight\")),\n            9 => result.push(String::from(\"\
    Nine\")),\n            _ => unreachable!(),\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaec4lzgi.rs:15:42\n   |\n\
    15 |     for i in arr.iter().filter(|&i| i <= 9 || i >= 1) {\n   |           \
    \                               ^\n   |                                      \
    \    |\n   |                                          expected `&isize`, found\
    \ integer\n   |                                          help: consider borrowing\
    \ here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaec4lzgi.rs:15:52\n\
    \   |\n15 |     for i in arr.iter().filter(|&i| i <= 9 || i >= 1) {\n   |    \
    \                                                ^\n   |                     \
    \                               |\n   |                                      \
    \              expected `&isize`, found integer\n   |                        \
    \                            help: consider borrowing here: `&1`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut counters = vec![0; 10];\n  \
    \  arr.sort_unstable();\n    arr.iter().cloned().for_each(|i| counters[i] += 1);\n\
    \    arr.iter().cloned().for_each(|i| {\n        if counters[i] >= 1 && counters[i]\
    \ <= 9 {\n            counters[i] -= 1;\n            counters[i] %= 10;\n    \
    \        arr[i] = String::from(format!(\"{}\", i));\n        }\n    });\n\n  \
    \  arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmp830nwce4.rs:20:38\n   |\n20 |     arr.iter().cloned().for_each(|i| counters[i]\
    \ += 1);\n   |                                      ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp830nwce4.rs:22:12\n   |\n22 |  \
    \       if counters[i] >= 1 && counters[i] <= 9 {\n   |            ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp830nwce4.rs:22:32\n\
    \   |\n22 |         if counters[i] >= 1 && counters[i] <= 9 {\n   |          \
    \                      ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp830nwce4.rs:23:13\n   |\n23 |             counters[i]\
    \ -= 1;\n   |             ^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed "
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut digits = arr.clone();\n    let\
    \ mut nums = arr.clone();\n    let mut len = arr.len();\n    let mut last_pos\
    \ = 0;\n    while len > 0 {\n        let mut pos = 0;\n        while pos < len\
    \ {\n            let v = nums[pos];\n            if v < 1 || v > 9 {\n       \
    \         pos = len + 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        digits.swap_remove(pos - 1, pos);\n        nums.swap_remove(pos\
    \ - 1, pos);\n        len = len - 1;\n        last_pos = pos;\n    }\n    let\
    \ mut result = Vec::with_capacity(last_pos + 1);\n    for i in 0..last_pos {\n\
    \        result.push(format!(\"{}\", digits[i as usize]));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpx11moeqt.rs:31:16\n     |\n31   |         digits.swap_remove(pos\
    \ - 1, pos);\n     |                ^^^^^^^^^^^ -------  --- supplied 2 arguments\n\
    \     |                |\n     |                expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 2 arguments were supplied\n    --> /tmp/tmpx11moeqt.rs:32:14\n\
    \     |\n32   |         nums.swap_remove(pos - 1, pos);\n     |              ^^^^^^^^^^^\
    \ -------  --- supplied 2 arguments\n     |              |\n     |           \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result: Vec<String>\
    \ = vec![];\n    for x in arr.iter() {\n        if x < 1 || x > 9 {\n        \
    \    continue;\n        }\n        result.push(String::from(format!(\"{}\", x)));\n\
    \    }\n    result.reverse();\n    result.into_iter().map(|x| String::from(format!(\"\
    {}\", x))).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbaet0j6r.rs:16:16\n   |\n\
    16 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbaet0j6r.rs:16:25\n\
    \   |\n16 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    // If there is no\
    \ input, just return an empty vector.\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    // Otherwise, sort the numbers and return them in reverse\
    \ order.\n    let mut sorted_vec = arr.sort_unstable();\n    // Then reverse the\
    \ vector and get the names of digits.\n    let mut reversed_vec = sorted_vec.rev();\n\
    \    let mut digit_names: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    // Loop through the\
    \ vector, find the corresponding digit and append it to the reversed_vec.\n  \
    \  for digit in reversed_vec {\n        let digit_index = digit_names.iter().position(|name|\
    \ name == &digit).unwrap();\n        match digit_index {\n            Some(index)\
    \ => {\n                reversed_vec.push(digit_names[index]);\n            }\n\
    \            None => {\n                warn!(\"unknown digit: {}\", digit);\n\
    \            }\n        }\n    }\n    reversed_vec\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `warn` in this scope\n  --> /tmp/tmpf860e_i5.rs:31:17\n\
    \   |\n31 |                 warn!(\"unknown digit: {}\", digit);\n   |       \
    \          ^^^^\n   |\n   = note: `warn` is in scope, but it is an attribute:\
    \ `#[warn]`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpf860e_i5.rs:21:39\n\
    \   |\n21 |     let mut reversed_vec = sorted_vec.rev();\n   |               \
    \                        ^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf860e_i5.rs:22:45\n   |\n22 |     let mut digit_names: Vec<String> =\
    \ vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"];\n   |                                             ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \                     |\n   |                                             expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf860e_i5.rs:27:13\n\
    \   |\n26 |         match digit_index {\n   |               ----------- this expression\
    \ has type `usize`\n27 |             Some(index) => {\n   |             ^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf860e_i5.rs:30:13\n   |\n26 |         match digit_index {\n   |    \
    \           ----------- this expression has type `usize`\n...\n30 |          \
    \   None => {\n   |             ^^^^ expected `usize`, found enum `Option`\n \
    \  |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976650
- exit_code: 1
  program: "/// Given a vector of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting vector, and then replace each digit\
    \ by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty,\
    \ return an empty vector:\n/// >>> by_length(vec![])\n/// vec![]\n/// If the vector\
    \ has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"\
    One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result =\
    \ vec![];\n    loop {\n        if arr.len() > 0 {\n            let mut first =\
    \ String::from(\"One\");\n            let mut last = String::from(\"One\");\n\
    \            for digit in arr.iter().rev() {\n                let index = digit.min(9).max(1);\n\
    \                last = String::from(\n                    index.to_string()\n\
    \                        .to_string()\n                        .chars()\n    \
    \                    .enumerate()\n                        .fold(\n          \
    \                  vec![],\n                            |mut acc: Vec<(String,\
    \ isize)>, (_, index)| {\n                                acc.push((\n       \
    \                             String::from(\n                                \
    \        \"Nine\".to_string()\n                                            .to_string()\n\
    \                                            .chars()\n                      \
    \                      .enumerate()\n                                        \
    \    .fold(\n                                                vec![],\n       \
    \                                         |mut acc: Vec<(String, isize)>, (_,\
    \ index)| {\n                                                    acc.push((\n\
    \                                                        String::from(\n     \
    \                                                       index.to_string()\n  \
    \                                                              .to_string()\n\
    \                                                                .chars()\n  \
    \                                                              .enumerate()\n\
    \                                                                .fold(\n    \
    \                                                                vec![],\n   \
    \                                                                 |mut acc: Vec<(String,\
    \ isize)>, (_, index)| {\n                                                   \
    \                     acc.push((\n                                           \
    \                                 String::from(\n                            \
    \                                                    index.to_string()\n     \
    \                                                                            \
    \   .to_string()\n                                                           \
    \                         .chars()\n                                         \
    \                                           .enumerate()\n                   \
    \                                                                 .fold(\n   \
    \                                                                            \
    \         vec![],\n                                                          \
    \                              |mut acc: Vec<(String, isize)>, (_, index)| {\n\
    \                                                                            \
    \                acc.push((\n                                                \
    \                                                String::from(\n             \
    \                                                                            \
    \           index.to_string()\n                                              \
    \                                                          .to_string()\n    \
    \                                                                            \
    \                        .chars()\n                                          \
    \                                                              .enumerate()\n\
    \                                                                            \
    \                            .fold(\n                                        \
    \                                                                    vec![],\n\
    \                                                                            \
    \                                |mut acc: Vec<(String, isize)>, (_, index)| {\n\
    \                                                                            \
    \                                    acc.push((\n                            \
    \                                                                            \
    \            String::from(\n                                                 \
    \                                                                       index.to_string()\n\
    \                                                                            \
    \                                                .to_string()\n              \
    \                                                                            \
    \                                  .chars()\n                                \
    \                                                                            \
    \                .enumerate()\n                                              \
    \                                                                            \
    \  .fold(\n                                                                  \
    \                                                              vec![],\n     \
    \                                                                            \
    \                                               |mut acc: Vec<(String, isize)>,\
    \ (_, index)| {\n                                                            \
    \                                                                        acc.push((\n\
    \                                                                            \
    \                                                            String::from(\n \
    \                                                                            \
    \                                                               index.to_string()\n\
    \                                                                            \
    \                                                                    .to_string()\n\
    \                                                                            \
    \                                                                    .chars()\n\
    \                                                                            \
    \                                                                    .enumerate()\n\
    \                                                                            \
    \                                                                    .fold(\n\
    \                                                                            \
    \                                                                        vec![],\n\
    \                                                                            \
    \                                                                        |mut\
    \ acc: Vec<(String, isize)>, (_, index)| {\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpel7p3h9u.rs:92:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n14 |     let mut result\
    \ = vec![];\n15 |     loop {\n   |          - unclosed delimiter\n16 |       \
    \  if arr.len() > 0 {\n   |                          - unclosed delimiter\n...\n\
    19 |             for digit in arr.iter().rev() {\n   |                       \
    \                    - unclosed delimiter\n20 |                 let index = digit.min(9).max(1);\n\
    21 |                 last = String::from(\n   |                              \
    \      - unclosed delimiter\n...\n26 |                         .fold(\n   |  \
    \                            - unclosed delimiter\n27 |                      \
    \       vec![],\n28 |                             |mut acc: Vec<(String, isize)>,\
    \ (_, index)| {\n   |                                                        \
    \                 - unclosed delimiter\n29 |                                 acc.push((\n\
    \   |                                         -- unclosed delimiter\n   |    \
    \                                     |\n   |                                \
    \         unclosed delimiter\n30 |                                     String::from(\n\
    \   |                                                 - unclosed delimiter\n...\n\
    35 |                                             .fold(\n   |                \
    \                                  - unclosed delimiter\n36 |                \
    \                                 vec![],\n37 |                              \
    \                   |mut acc: Vec<(String, isize)>, (_, index)| {\n   |      \
    \                                                                            \
    \           - unclosed delimiter\n38 |                                       \
    \              acc.push((\n   |                                              \
    \               -- unclosed delimiter\n   |                                  \
    \                           |\n   |                                          \
    \                   unclosed delimiter\n39 |    "
  stdout: ''
  timestamp: 1659976650
