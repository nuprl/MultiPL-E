language: rs
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0isize;\n    let mut collision_points\
    \ = vec![0; n];\n    fn find_collisions(x: isize) -> isize {\n        collisions\
    \ += 1;\n        collision_points[x - 1] += 1;\n        collision_points[x + 1]\
    \ += 1;\n        collision_points[x - 1] -= 1;\n        collision_points[x + 1]\
    \ -= 1;\n        if x == n / 2 {\n            collision_points.into_iter().filter(|&p|\
    \ p == 0).count().unwrap() as isize\n        } else {\n            collision_points[x\
    \ - 1]\n                + collision_points[x + 1]\n                + collision_points[x\
    \ - 1]\n                + collision_points[x + 1]\n                + collision_points.into_iter().filter(|&p|\
    \ p == 0).count().unwrap()\n            as isize\n        }\n    }\n    for i\
    \ in 0..n / 2 {\n        find_collisions(i);\n    }\n    find_collisions(n - 1);\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:13:9\n\
    \   |\n13 |         collisions += 1;\n   |         ^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:14:9\n   |\n14 |       \
    \  collision_points[x - 1] += 1;\n   |         ^^^^^^^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:15:9\n   |\n15 |       \
    \  collision_points[x + 1] += 1;\n   |         ^^^^^^^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:16:9\n   |\n16 |       \
    \  collision_points[x - 1] -= 1;\n   |         ^^^^^^^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:17:9\n   |\n17 |       \
    \  collision_points[x + 1] -= 1;\n   |         ^^^^^^^^^^^^^^^^\n   |\n   = help:\
    \ use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:18:17\n   |\n18 |      \
    \   if x == n / 2 {\n   |                 ^\n   |\n   = help: use the `|| { ...\
    \ }` closure form instead\n\nerror[E0434]: can't capture dynamic environment in\
    \ a fn item\n  --> /tmp/tmp9hc8xrib.rs:19:13\n   |\n19 |             collision_points.into_iter().filter(|&p|\
    \ p == 0).count().unwrap() as isize\n   |             ^^^^^^^^^^^^^^^^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:21:13\n   |\n21\
    \ |             collision_points[x - 1]\n   |             ^^^^^^^^^^^^^^^^\n \
    \  |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't\
    \ capture dynamic environment in a fn item\n  --> /tmp/tmp9hc8xrib.rs:22:19\n\
    \   |\n22 |                 + collision_points[x + 1]\n   |                  \
    \ ^^^^^^^^^^^^^^^^\n   |\n   = hel"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut race_length = vec![0; n];\n    for i in 0..n\
    \ {\n        race_length[i] = sqrt(i * i);\n    }\n    let mut colliding_count\
    \ = 0;\n    for j in 0..n {\n        for i in 0..n {\n            let dx = j *\
    \ i;\n            let a = dx;\n            let b = race_length[j];\n         \
    \   let c = race_length[i];\n            let d = sqrt(dx * dx);\n            let\
    \ e = sqrt(a * a);\n            let f = sqrt(b * b);\n            if c > e {\n\
    \                continue;\n            }\n            if f > e {\n          \
    \      continue;\n            }\n            let g = (e + d) * (e - f);\n    \
    \        let x = (d - e) * (e - f);\n            if g > 0 {\n                continue;\n\
    \            }\n            let y = (g + x) * (g + x);\n            if y > 0 {\n\
    \                continue;\n            }\n            colliding_count += 1;\n\
    \        }\n    }\n    return colliding_count;\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmp69o7n6iq.rs:12:26\n\
    \   |\n12 |         race_length[i] = sqrt(i * i);\n   |                      \
    \    ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sqrt`\
    \ in this scope\n  --> /tmp/tmp69o7n6iq.rs:21:21\n   |\n21 |             let d\
    \ = sqrt(dx * dx);\n   |                     ^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmp69o7n6iq.rs:22:21\n\
    \   |\n22 |             let e = sqrt(a * a);\n   |                     ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `sqrt` in this scope\n\
    \  --> /tmp/tmp69o7n6iq.rs:23:21\n   |\n23 |             let f = sqrt(b * b);\n\
    \   |                     ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp69o7n6iq.rs:10:35\n   |\n10 |     let mut race_length =\
    \ vec![0; n];\n   |                                   ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n10 |     let mut race_length = vec![0; n.try_into().unwrap()];\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp69o7n6iq.rs:12:9\n\
    \   |\n12 |         race_length[i] = sqrt(i * i);\n   |         ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmp69o7n6iq.rs:19:21\n\
    \   |\n19 |             let b = race_length[j];\n   |                     ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: requir"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut cur_x = 0;\n\
    \    let mut cur_y = 0;\n    let mut cur_speed = 0;\n    let mut cur_speed_change\
    \ = 0;\n    let mut cur_speed_max = 0;\n    let mut next_x = 0;\n    let mut next_y\
    \ = 0;\n    let mut next_speed = 0;\n    let mut next_speed_change = 0;\n    let\
    \ mut next_speed_max = 0;\n    let mut obstacle_x = 1;\n    let mut obstacle_y\
    \ = 1;\n    let mut obstacle_speed = 0;\n    let mut obstacle_speed_change = 0;\n\
    \    let mut obstacle_speed_max = 0;\n    // TODO: This can probably be cleaned\
    \ up a lot\n    // We want to loop around n times (n = number of obstacles)\n\
    \    // So that we can go through the entire obstacle list once\n    // This helps\
    \ us do some work without using an iterator.\n    for i in 0..n {\n        next_x\
    \ = cur_x;\n        next_y = cur_y;\n        next_speed = cur_speed;\n       \
    \ next_speed_change = cur_speed_change;\n        next_speed_max = cur_speed_max;\n\
    \        // Since we know that obstacles are infinitely long, they should never\
    \ collide\n        collision_count = obstacle_race_collision(next_x, next_y, next_speed,\
    \ next_speed_change, next_speed_max);\n        cur_x += obstacle_x;\n        cur_y\
    \ += obstacle_y;\n        cur_speed += obstacle_speed;\n        cur_speed_change\
    \ += obstacle_speed_change;\n        cur_speed_max += obstacle_speed_max;\n  \
    \      obstacle_x += 1;\n        obstacle_y += 1;\n        obstacle_speed += 1;\n\
    \        obstacle_speed_change += 1;\n        obstacle_speed_max += 1;\n    }\n\
    \    return collision_count;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `obstacle_race_collision` in this scope\n\
    \  --> /tmp/tmpw8205h3j.rs:37:27\n   |\n37 |         collision_count = obstacle_race_collision(next_x,\
    \ next_y, next_speed, next_speed_change, next_speed_max);\n   |              \
    \             ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // Number of collisions\n   \
    \ let mut speed = 1; // Speed to make collisions occur\n    let mut first_collision\
    \ = false;\n    let mut next_collision_start = 0;\n    let mut next_collision_end\
    \ = 0;\n    loop {\n        if collisions > 0 && !first_collision { // No collisions\
    \ yet\n            collisions = 0;\n            speed *= 2;\n            next_collision_start\
    \ = 0;\n            next_collision_end = 0;\n        } else {\n            if\
    \ next_collision_start >= n { // Collision ends soon\n                next_collision_start\
    \ = 0;\n                collisions++;\n            } else {\n                next_collision_start\
    \ = next_collision_start + 1;\n            }\n            if next_collision_end\
    \ >= n { // Collision ends soon\n                next_collision_end = 0;\n   \
    \             collisions++;\n            } else {\n                next_collision_end\
    \ = next_collision_end + 1;\n            }\n        }\n        if first_collision\
    \ && collisions == 0 { // First collision ends soon\n            first_collision\
    \ = false;\n        }\n        if collisions > 0 { // Collisions occur\n     \
    \       next_collision_start = speed * 2;\n            next_collision_end = speed\
    \ * 2;\n        }\n        if first_collision { // First collision ends soon\n\
    \            first_collision = false;\n            speed *= 2;\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmptmdp57yc.rs:24:27\n\
    \   |\n24 |                 collisions++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |       \
    \          { let tmp = collisions; collisions += 1; tmp };\n   |             \
    \    +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n24 -                 collisions++;\n\
    24 +                 collisions += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmptmdp57yc.rs:30:27\n   |\n30 |                 collisions++;\n\
    \   |                           ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n30 |                 { let tmp = collisions; collisions\
    \ += 1; tmp };\n   |                 +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    30 -                 collisions++;\n30 +                 collisions += 1;\n  \
    \ | \n\nwarning: unreachable expression\n  --> /tmp/tmptmdp57yc.rs:47:5\n   |\n\
    15 | /     loop {\n16 | |         if collisions > 0 && !first_collision { // No\
    \ collisions yet\n17 | |             collisions = 0;\n18 | |             speed\
    \ *= 2;\n...  |\n45 | |         }\n46 | |     }\n   | |_____- any code following\
    \ this expression is unreachable\n47 |       collisions\n   |       ^^^^^^^^^^\
    \ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    fn collide_left(&self) -> bool {\n        (&self.x1)\n\
    \            .checked_add(self.dx * CAR_WIDTH)\n            .unwrap_or(&self.x1)\
    \ > self.x2\n    }\n\n    fn collide_right(&self) -> bool {\n        (&self.x2)\n\
    \            .checked_add(-self.dx * CAR_WIDTH)\n            .unwrap_or(&self.x2)\
    \ < self.x1\n    }\n\n    fn collide(&self) -> bool {\n        collide_left(self)\
    \ && collide_right(self)\n    }\n\n    fn collisions(&self) -> isize {\n     \
    \   (0..n)\n            .filter(move |i| {\n                let next = i + (*self\
    \ as f32).len();\n                next.checked_add(1)\n                    .ok()\n\
    \                    .and_then(|next| {\n                        let collided\
    \ = next.checked_add(next as f32)\n                            .checked_add(next\
    \ as f32)\n                            .checked_add((*self as f32).len())\n  \
    \                          .ok()\n                            .unwrap_or(next);\n\
    \                        collided.checked_add(-1)\n                          \
    \  .ok()\n                            .and_then(|next| {\n                   \
    \             next.checked_add(next as f32)\n                                \
    \    .checked_add(next as f32)\n                                    .checked_add(next\
    \ as f32)\n                                    .checked_add((*self as f32).len())\n\
    \                                    .ok()\n                                 \
    \   .unwrap_or(next)\n                            })\n                    })\n\
    \            })\n            .filter(move |i| !collide(i))\n            .count()\n\
    \    }\n\n    collisions(n)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: `self` parameter is only allowed in associated functions\n  -->\
    \ /tmp/tmp0j92sxza.rs:10:21\n   |\n10 |     fn collide_left(&self) -> bool {\n\
    \   |                     ^^^^^ not semantically valid as function parameter\n\
    \   |\n   = note: associated functions are those in `impl` or `trait` definitions\n\
    \nerror: `self` parameter is only allowed in associated functions\n  --> /tmp/tmp0j92sxza.rs:16:22\n\
    \   |\n16 |     fn collide_right(&self) -> bool {\n   |                      ^^^^^\
    \ not semantically valid as function parameter\n   |\n   = note: associated functions\
    \ are those in `impl` or `trait` definitions\n\nerror: `self` parameter is only\
    \ allowed in associated functions\n  --> /tmp/tmp0j92sxza.rs:22:16\n   |\n22 |\
    \     fn collide(&self) -> bool {\n   |                ^^^^^ not semantically\
    \ valid as function parameter\n   |\n   = note: associated functions are those\
    \ in `impl` or `trait` definitions\n\nerror: `self` parameter is only allowed\
    \ in associated functions\n  --> /tmp/tmp0j92sxza.rs:26:19\n   |\n26 |     fn\
    \ collisions(&self) -> isize {\n   |                   ^^^^^ not semantically\
    \ valid as function parameter\n   |\n   = note: associated functions are those\
    \ in `impl` or `trait` definitions\n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmp0j92sxza.rs:27:13\n   |\n27 |         (0..n)\n \
    \  |             ^\n   |\n   = help: use the `|| { ... }` closure form instead\n\
    \nerror[E0425]: cannot find value `CAR_WIDTH` in this scope\n  --> /tmp/tmp0j92sxza.rs:12:36\n\
    \   |\n12 |             .checked_add(self.dx * CAR_WIDTH)\n   |              \
    \                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_WIDTH` in this scope\n  --> /tmp/tmp0j92sxza.rs:18:37\n   |\n\
    18 |             .checked_add(-self.dx * CAR_WIDTH)\n   |                    \
    \                 ^^^^^^^^^ not found in this scope\n\nerror[E0689]: can't call\
    \ method `checked_add` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp0j92sxza.rs:30:22\n\
    \   |\n30 |                 next.checked_add(1)\n   |                      ^^^^^^^^^^^\n\
    \   |\nhelp: you must"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       let mut first_collision = true;\n        for j in 0..n {\n           \
    \ if first_collision {\n                if car_race_collision_helper(n,&j,&j,false)\
    \ != 2 {\n                    collision_count = collision_count + 1;\n       \
    \         }\n                first_collision = false;\n            } else {\n\
    \                if car_race_collision_helper(n,&j,&j+1,false) != 1 {\n      \
    \              collision_count = collision_count + 1;\n                }\n   \
    \         }\n        }\n    }\n    collision_count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmp2hcj0r76.rs:15:20\n   |\n15 |                 if car_race_collision_helper(n,&j,&j,false)\
    \ != 2 {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmp2hcj0r76.rs:20:20\n   |\n20 |                 if car_race_collision_helper(n,&j,&j+1,false)\
    \ != 1 {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncars = n;\n    let mut car_collisions: isize\
    \ = 0;\n    while ncars > 2 {\n        let mut collisions = 0;\n        let mut\
    \ c0 = 0.0;\n        let mut c1 = 0.0;\n        let mut c2 = 0.0;\n        while\
    \ ncars > 0 {\n            let car_id = if ncars > 1 { ncars - 1 } else { 0 };\n\
    \            let c = (c1 + c2) / (c1 + c2);\n            let x = (c0 + (c2 - c0)\
    \ * c) / (1.0 + c);\n            let y = x * x;\n            if y > 1.0 * ncars\
    \ {\n                break;\n            }\n            if y > car_collisions\
    \ {\n                collisions = car_collisions;\n            }\n           \
    \ if x < car_id {\n                let mut car_id = car_id;\n                let\
    \ mut c1 = c;\n            } else {\n                let mut c2 = c;\n       \
    \     }\n            ncars -= 1;\n        }\n        if collisions == car_collisions\
    \ {\n            // This is an obvious contradiction.  Therefore, there are two\n\
    \            // cars that would collide, with each one colliding with itself\n\
    \            // at some point after car #car_id has moved beyond its current\n\
    \            // position.  This happens when car_id is 0, and car_id + 1 is\n\
    \            // ncars - 1.\n            car_collisions += 1;\n        }\n    \
    \    ncars += 1;\n    }\n    car_collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `{float}` by `isize`\n  --> /tmp/tmpmmt4ve98.rs:22:24\n\
    \   |\n22 |             if y > 1.0 * ncars {\n   |                        ^ no\
    \ implementation for `{float} * isize`\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmmt4ve98.rs:25:20\n\
    \   |\n25 |             if y > car_collisions {\n   |                    ^^^^^^^^^^^^^^\
    \ expected floating-point number, found `isize`\n\nerror[E0277]: can't compare\
    \ `{float}` with `isize`\n  --> /tmp/tmpmmt4ve98.rs:25:18\n   |\n25 |        \
    \     if y > car_collisions {\n   |                  ^ no implementation for `{float}\
    \ < isize` and `{float} > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmmt4ve98.rs:28:20\n   |\n28 |             if x < car_id {\n   |    \
    \                ^^^^^^ expected floating-point number, found `isize`\n\nerror[E0277]:\
    \ can't compare `{float}` with `isize`\n  --> /tmp/tmpmmt4ve98.rs:28:18\n   |\n\
    28 |             if x < car_id {\n   |                  ^ no implementation for\
    \ `{float} < isize` and `{float} > isize`\n   |\n   = help: the trait `PartialOrd<isize>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n      "
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cnt = 0;\n    fn collide(a: isize, s: isize,\
    \ b: isize) -> isize {\n        a + s + b\n    }\n    for i in 0..n {\n      \
    \  let a = i;\n        let s = n - i;\n        let b = n + i;\n        if collide(a,\
    \ s, b) > n {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkw8m8xv5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut car_speed =\
    \ Vec::new();\n    let mut car_pos = Vec::new();\n    let mut car_direction =\
    \ Vec::new();\n    let mut car_speeds_left = Vec::new();\n    let mut car_speeds_right\
    \ = Vec::new();\n\n    for _ in 0..n {\n        car_speed = vec![0.0, 0.0];\n\
    \        car_pos = vec![0.0, 0.0];\n        car_direction = vec![0.0, 0.0];\n\n\
    \        for _ in 0..n {\n            car_speed = car_speed + vec![0., 0.];\n\
    \            car_pos.push(0.0);\n            car_direction.push(0.0);\n\n    \
    \        if car_speeds_left.len() != car_speeds_right.len() {\n              \
    \  car_speeds_left.push(car_speed);\n            }\n            if car_speeds_right.len()\
    \ != car_speeds_left.len() {\n                car_speeds_right.push(car_speed);\n\
    \            }\n        }\n\n        if car_speeds_left.len() > car_speeds_right.len()\
    \ {\n            car_speeds_right.push(car_speed);\n        } else {\n       \
    \     car_speeds_left.push(car_speed);\n        }\n\n        if car_speeds_left.len()\
    \ > car_speeds_right.len() {\n            collision_count += 1;\n        } else\
    \ {\n            collision_count += n;\n        }\n    }\n\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `Vec<{float}>` to `Vec<{float}>`\n  --> /tmp/tmpyaie3cda.rs:23:35\n\
    \   |\n23 |             car_speed = car_speed + vec![0., 0.];\n   |          \
    \               --------- ^ ------------ Vec<{float}>\n   |                  \
    \       |\n   |                         Vec<{float}>\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut race_result: Vec<_> = (0..(n + 1)).collect();\n\
    \    let mut collision_count: Vec<_> = (0..(n + 1)).collect();\n    for mut i\
    \ in 0..(n + 1) {\n        collision_count[i] = 0;\n        race_result[i] = i;\n\
    \    }\n    for i in 0..(n + 1) {\n        for j in i + 1..(n + 1) {\n       \
    \     let mut collision: isize = 0;\n            let mut current_speed = 1.0;\n\
    \            while collision > 0 && collision_count > 0 &&\n               race_result[j]\
    \ > race_result[i] {\n                if i == j {\n                    collision_count\
    \ -= 1;\n                    continue;\n                }\n                if\
    \ car_speed_collision(current_speed, race_result[i], race_result[j]) {\n     \
    \               collision += 1;\n                    collision_count--;\n    \
    \            }\n                current_speed *= 0.5;\n            }\n       \
    \     collision_count = collision_count;\n            race_result[i] = race_result[j];\n\
    \        }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpq2ykrncl.rs:28:38\n\
    \   |\n28 |                     collision_count--;\n   |                     \
    \                 ^ expected expression\n\nerror[E0425]: cannot find function\
    \ `car_speed_collision` in this scope\n  --> /tmp/tmpq2ykrncl.rs:26:20\n   |\n\
    26 |                 if car_speed_collision(current_speed, race_result[i], race_result[j])\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq2ykrncl.rs:13:9\n\
    \   |\n13 |         collision_count[i] = 0;\n   |         ^^^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpq2ykrncl.rs:14:9\n   |\n14 |   \
    \      race_result[i] = i;\n   |         ^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2ykrncl.rs:20:54\n\
    \   |\n20 |             while collision > 0 && collision_count > 0 &&\n   |  \
    \                                                    ^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `{integer}`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpq2ykrncl.rs:21:16\n   |\n21 |                race_result[j]\
    \ > race_result[i] {\n   |                ^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = Vec::new();\n\n    for (i, j) in\
    \ ((0, 0), (0, n)) {\n        // The second \"for\" loop checks collisions between\
    \ cars i and j.\n        // The two \"for\" loops below are nested for two reasons:\
    \ they check if\n        // cars i and j are colliding, and they also check if\
    \ cars i and j are moving\n        // at the same speed.  They can be nested because\
    \ if any of them are colliding\n        // then the function returns immediately.\n\
    \        //\n        // The code below checks cars i and j are colliding.\n  \
    \      for k in range(i + 1, n) { // k is bounded by j + 1\n            if car_collision(&mut\
    \ collisions, i, j, k) {\n                return collisions.len();\n         \
    \   }\n        }\n        for k in range(j + 1, n) { // k is bounded by i + 1\n\
    \            if car_collision(&mut collisions, i, j, k) {\n                return\
    \ collisions.len();\n            }\n        }\n    }\n    collisions.len()\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp9s0sek2p.rs:20:18\n\
    \   |\n20 |         for k in range(i + 1, n) { // k is bounded by j + 1\n   |\
    \                  ^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot\
    \ find function `car_collision` in this scope\n  --> /tmp/tmp9s0sek2p.rs:21:16\n\
    \   |\n21 |             if car_collision(&mut collisions, i, j, k) {\n   |   \
    \             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `range` in this scope\n  --> /tmp/tmp9s0sek2p.rs:25:18\n   |\n25 |\
    \         for k in range(j + 1, n) { // k is bounded by i + 1\n   |          \
    \        ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function\
    \ `car_collision` in this scope\n  --> /tmp/tmp9s0sek2p.rs:26:16\n   |\n26 | \
    \            if car_collision(&mut collisions, i, j, k) {\n   |              \
    \  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `(({integer}, {integer}),\
    \ ({integer}, isize))` is not an iterator\n  --> /tmp/tmp9s0sek2p.rs:12:19\n \
    \  |\n12 |     for (i, j) in ((0, 0), (0, n)) {\n   |                   ^^^^^^^^^^^^^^^^\
    \ `(({integer}, {integer}), ({integer}, isize))` is not an iterator\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `(({integer}, {integer}),\
    \ ({integer}, isize))`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `(({integer}, {integer}), ({integer}, isize))`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9s0sek2p.rs:22:24\n   |\n22 |  \
    \               return collisions.len();\n   |                        ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |           \
    \      return collisions.len().try_into().unwrap();\n   |                    \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9s0sek2p.rs:31:5\n   |\n9  | fn car_race_coll"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for i in 1..n {\n      \
    \  for j in i..n {\n            if j != i && car_collision(&i, &j) {\n       \
    \         collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpg446np_h.rs:13:26\n   |\n13 |             if j != i && car_collision(&i,\
    \ &j) {\n   |                          ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut race_collision_count = 0;\n    let mut n_race\
    \ = n - 1;\n    while n_race > 0 {\n        race_collision_count = race_collision_count\
    \ + 1;\n        n_race = n_race - 1;\n    }\n    race_collision_count\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppgs32hy9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collided = 0;\n    for _ in 0..n {\n    \
    \    let x0 = rand::random::<f32>(0.0, 1.0);\n        let y0 = rand::random::<f32>(0.0,\
    \ 1.0);\n        let x1 = x0;\n        let y1 = y0;\n        for _ in 0..n {\n\
    \            let x2 = x1;\n            let y2 = y1;\n            let distance\
    \ = sqrt((x2 - x0).powf(2.0) + (y2 - y0).powf(2.0));\n            if distance\
    \ <= 0.2 {\n                continue;\n            }\n            let angle =\
    \ atan2(y2 - y0, x2 - x0);\n            if f32::fma(distance, 2.0, angle) < f32::EPSILON\
    \ {\n                break;\n            }\n            x1 = x2;\n           \
    \ y1 = y2;\n        }\n        if x1 == x0 {\n            num_collided++;\n  \
    \      }\n    }\n    num_collided\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd6uo2jvt.rs:31:25\n\
    \   |\n31 |             num_collided++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |         \
    \    { let tmp = num_collided; num_collided += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n31 -             num_collided++;\n31\
    \ +             num_collided += 1;\n   | \n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpd6uo2jvt.rs:12:18\n\
    \   |\n12 |         let x0 = rand::random::<f32>(0.0, 1.0);\n   |            \
    \      ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpd6uo2jvt.rs:13:18\n\
    \   |\n13 |         let y0 = rand::random::<f32>(0.0, 1.0);\n   |            \
    \      ^^^^ use of undeclared crate or module `rand`\n\nerror[E0425]: cannot find\
    \ function `sqrt` in this scope\n  --> /tmp/tmpd6uo2jvt.rs:19:28\n   |\n19 | \
    \            let distance = sqrt((x2 - x0).powf(2.0) + (y2 - y0).powf(2.0));\n\
    \   |                            ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `atan2` in this scope\n  --> /tmp/tmpd6uo2jvt.rs:23:25\n\
    \   |\n23 |             let angle = atan2(y2 - y0, x2 - x0);\n   |           \
    \              ^^^^^ not found in this scope\n\nerror[E0599]: no function or associated\
    \ item named `fma` found for type `f32` in the current scope\n  --> /tmp/tmpd6uo2jvt.rs:24:21\n\
    \   |\n24 |             if f32::fma(distance, 2.0, angle) < f32::EPSILON {\n \
    \  |                     ^^^ function or associated item not found in `f32`\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The two cars are at \"n\" cars apart\n    // and they\
    \ move at a constant speed\n    let mut sum: isize = 0;\n\n    for _ in range(n)\
    \ {\n        // Find the index of the car that's moving to the left of car2\n\
    \        let left = n - 1;\n\n        // Find the index of the car that's moving\
    \ to the right of car2\n        let right = n - 1;\n\n        // Find the index\
    \ into car2 that's moving to the left of car1\n        for _ in 0..left {\n  \
    \          right -= 1;\n        }\n        // Find the index into car2 that's\
    \ moving to the right of car1\n        for _ in 0..right {\n            left +=\
    \ 1;\n        }\n\n        // If left and right point to the same index, then\
    \ we have collided\n        if left == right {\n            sum += 1;\n      \
    \  }\n    }\n\n    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpcd7aa9_1.rs:14:14\n\
    \   |\n14 |     for _ in range(n) {\n   |              ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = 1\n    while n < n {\n        if n % 2u ==\
    \ 0\n            && car_collision(n, n % 2u)\n            && car_collision(n,\
    \ (n + 1) % 2u)\n        {\n            n += 1;\n        }\n        n += 1;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `while`\n  --> /tmp/tmp0llij5zc.rs:10:18\n\
    \   |\n10 |     let mut n = 1\n   |                  ^ help: add `;` here\n11\
    \ |     while n < n {\n   |     ----- unexpected token\n\nerror: invalid suffix\
    \ `u` for number literal\n  --> /tmp/tmp0llij5zc.rs:12:16\n   |\n12 |        \
    \ if n % 2u == 0\n   |                ^^ invalid suffix `u`\n   |\n   = help:\
    \ the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\n\
    error: invalid suffix `u` for number literal\n  --> /tmp/tmp0llij5zc.rs:13:37\n\
    \   |\n13 |             && car_collision(n, n % 2u)\n   |                    \
    \                 ^^ invalid suffix `u`\n   |\n   = help: the suffix must be one\
    \ of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix\
    \ `u` for number literal\n  --> /tmp/tmp0llij5zc.rs:14:43\n   |\n14 |        \
    \     && car_collision(n, (n + 1) % 2u)\n   |                                \
    \           ^^ invalid suffix `u`\n   |\n   = help: the suffix must be one of\
    \ the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror[E0425]: cannot find\
    \ function `car_collision` in this scope\n  --> /tmp/tmp0llij5zc.rs:13:16\n  \
    \ |\n13 |             && car_collision(n, n % 2u)\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmp0llij5zc.rs:14:16\n   |\n14 |             && car_collision(n,\
    \ (n + 1) % 2u)\n   |                ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for _ in 0..n {\n       \
    \ let mut speed = 1.0;\n        let mut turn = 0.0;\n        let mut collide =\
    \ false;\n        for _ in 0..n {\n            collisions += (speed + turn) %\
    \ 2 == 0;\n            if collide {\n                break;\n            }\n \
    \           speed += 0.1;\n            turn +=  (speed + turn) % 1.0;\n      \
    \      if turn >= 1.0 {\n                turn = 0.0;\n            }\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp8jpju6az.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for _ in 0..n {\n   |     --- unexpected token\n\nerror[E0277]:\
    \ cannot mod `{float}` by `{integer}`\n  --> /tmp/tmp8jpju6az.rs:16:42\n   |\n\
    16 |             collisions += (speed + turn) % 2 == 0;\n   |                \
    \                          ^ no implementation for `{float} % {integer}`\n   |\n\
    \   = help: the trait `Rem<{integer}>` is not implemented for `{float}`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as\
    \ Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]:\
    \ cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmp8jpju6az.rs:16:24\n \
    \  |\n16 |             collisions += (speed + turn) % 2 == 0;\n   |          \
    \              ^^ no implementation for `{integer} += bool`\n   |\n   = help:\
    \ the trait `AddAssign<bool>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0isize;\n    for i in (0..n).rev()\
    \ {\n        for j in (i + 1).rev().chain(n - i - 1) {\n            if let Some(m)\
    \ = car_collides(i, j) {\n                collisions += 1;\n            }\n  \
    \      }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collides` in this scope\n  -->\
    \ /tmp/tmpc8ovwyk2.rs:13:30\n   |\n13 |             if let Some(m) = car_collides(i,\
    \ j) {\n   |                              ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmpc8ovwyk2.rs:12:26\n\
    \   |\n12 |         for j in (i + 1).rev().chain(n - i - 1) {\n   |          \
    \                ^^^ `isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `&mut isize: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n\n    let mut c\
    \ = 0\n    for _ in 0..n {\n        c += car_race_collision(n);\n    }\n    c\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfno2q1na.rs:14:18\n\
    \   |\n14 |     let mut c = 0\n   |                  ^ help: add `;` here\n15\
    \ |     for _ in 0..n {\n   |     --- unexpected token\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // A counter for counting the number of collisions\n\
    \    let mut collision_count = 0;\n\n    // A random car has x coordinate between\
    \ 0 and (n-1)\n    let mut x = n - rand::random::<isize>();\n\n    // A random\
    \ car has y coordinate between 0 and (n-1)\n    let mut y = n - rand::random::<isize>();\n\
    \n    // While the random car has a y coordinate that is less than the y coordinate\n\
    \    // of the next car\n    while y > x + 1 {\n        // Increase the y coordinate\
    \ by 1.\n        y += 1;\n\n        // Increase the x coordinate by 1.\n     \
    \   x += 1;\n\n        // If the y coordinate is now equal to the x coordinate\
    \ of the next car,\n        // then we found a collision!\n        if y == x {\n\
    \            collision_count += 1;\n        }\n    }\n    collision_count\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp2hce02nr.rs:14:21\n   |\n14 |     let mut x = n - rand::random::<isize>();\n\
    \   |                     ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmp2hce02nr.rs:17:21\n\
    \   |\n17 |     let mut y = n - rand::random::<isize>();\n   |               \
    \      ^^^^ use of undeclared crate or module `rand`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in (0..n).rev()\
    \ {\n        for j in (i..n).rev() {\n            if car_collided(&i, &j) || car_collided(&j,\
    \ &i) {\n                collisions += 1;\n            }\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collided` in this scope\n  -->\
    \ /tmp/tmpvi3jx_ud.rs:13:16\n   |\n13 |             if car_collided(&i, &j) ||\
    \ car_collided(&j, &i) {\n   |                ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `car_collided` in this scope\n  --> /tmp/tmpvi3jx_ud.rs:13:40\n\
    \   |\n13 |             if car_collided(&i, &j) || car_collided(&j, &i) {\n  \
    \ |                                        ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).filter(|i| {\n        (0..n).any(|j| {\n     \
    \       i != j && car_collides(i, j)\n        })\n    }).count() + car_race_collisions(n)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collides` in this scope\n  -->\
    \ /tmp/tmpr3watmni.rs:12:23\n   |\n12 |             i != j && car_collides(i,\
    \ j)\n   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_race_collisions` in this scope\n  --> /tmp/tmpr3watmni.rs:14:18\n\
    \   |\n14 |     }).count() + car_race_collisions(n)\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmpr3watmni.rs:12:15\n   |\n12 |             i != j && car_collides(i,\
    \ j)\n   |               ^^ no implementation for `&isize == isize`\n   |\n  \
    \ = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3watmni.rs:10:5\n   |\n9  | \
    \  fn car_race_collision(n: isize) -> isize {\n   |                          \
    \            ----- expected `isize` because of return type\n10 | /     (0..n).filter(|i|\
    \ {\n11 | |         (0..n).any(|j| {\n12 | |             i != j && car_collides(i,\
    \ j)\n13 | |         })\n14 | |     }).count() + car_race_collisions(n)\n   |\
    \ |_______________________________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n10 ~     ((0..n).filter(|i| {\n11 |         (0..n).any(|j|\
    \ {\n12 |             i != j && car_collides(i, j)\n13 |         })\n14 ~    \
    \ }).count() + car_race_collisions(n)).try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0\n    let mut cars = Vec::new();\n \
    \   let mut cars_right = Vec::new();\n    let mut cars_left = Vec::new();\n  \
    \  let mut start = vec![vec![0; n]; 2];\n    start.transpose();\n    for _ in\
    \ 0..n {\n        cars.push(start.clone());\n        cars_right.append(start.clone());\n\
    \        cars_left.append(start.clone());\n        start.insert(0, vec![0; n]);\n\
    \    }\n    for row in start.iter() {\n        if row[0] == row[1] {\n       \
    \     for col in 0..n {\n                if row[col] == col {\n              \
    \      count++;\n                    let mut row = start.clone();\n          \
    \          row[col] = row[0]\n                        .iter()\n              \
    \          .cloned()\n                        .zip2(row[1], |x, y| if x == y {\
    \ x } else { x })\n                        .take_while(|&(a, b)| b != b)\n   \
    \                     .collect();\n                }\n            }\n        }\n\
    \    }\n    for car in cars.iter() {\n        for car2 in cars_right.iter() {\n\
    \            if car == car2 {\n                for col in 0..n {\n           \
    \         if car[col] == col {\n                        count++;\n           \
    \             let mut row = car.clone();\n                        row[col] = row[0]\n\
    \                            .iter()\n                            .cloned()\n\
    \                            .zip2(car2, |x, y| if x == y { x } else { x })\n\
    \                            .take_while(|&(a, b)| b != b)\n                 \
    \           .collect();\n                    }\n                }\n          \
    \  }\n        }\n    }\n    for car in cars_left.iter() {\n        for car2 in\
    \ cars.iter() {\n            if car == car2 {\n                for col in 0..n\
    \ {\n                    if car[col] == col {\n                        count++;\n\
    \                        let mut row = car.clone();\n                        row[col]\
    \ = row[0]\n                            .iter()\n                            .cloned()\n\
    \                            .zip2(car2, |x, y| if x == y { x } else { x })\n\
    \                            .take_while(|&(a, b)| b != b)\n                 \
    \           .collect();\n                    }\n                }\n          \
    \  }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpoujxhe0d.rs:10:22\n\
    \   |\n10 |     let mut count = 0\n   |                      ^ help: add `;` here\n\
    11 |     let mut cars = Vec::new();\n   |     --- unexpected token\n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpoujxhe0d.rs:26:26\n   |\n26\
    \ |                     count++;\n   |                          ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |               \
    \      { let tmp = count; count += 1; tmp };\n   |                     +++++++++++\
    \      ~~~~~~~~~~~~~~~~~~~\n26 -                     count++;\n26 +          \
    \           count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpoujxhe0d.rs:43:30\n   |\n43 |                         count++;\n\
    \   |                              ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n43 |                         { let tmp = count; count\
    \ += 1; tmp };\n   |                         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    43 -                         count++;\n43 +                         count += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpoujxhe0d.rs:61:30\n\
    \   |\n61 |                         count++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n61\
    \ |                         { let tmp = count; count += 1; tmp };\n   |      \
    \                   +++++++++++      ~~~~~~~~~~~~~~~~~~~\n61 -               \
    \          count++;\n61 +                         count += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoujxhe0d.rs:14:34\n   |\n14 |     let mut start\
    \ = vec![vec![0; n]; 2];\n   |                                  ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     let mut start = vec![vec![0;\
    \ n.try_into().unwrap()]; 2];\n   |                                   ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `transpose` found for struct `Vec<Vec<{integer}>>`\
    \ in the current scope\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Collisions are when two cars collide; we define this\
    \ as two pairs of cars\n    // moving in the same direction.\n    let mut collisions\
    \ = 0\n    for (car1, car2) in 0..(n) {\n        // If they are the same car,\
    \ skip this iteration.\n        if car1 == car2 {\n            continue;\n   \
    \     }\n        // Compute the sum of distances between this car and all other\
    \ cars.\n        // Let the cars move left to right.\n        let mut d = 0;\n\
    \        for _ in 0..(car1 - car2) {\n            d += 1;\n        }\n       \
    \ let mut d2 = d;\n        // Let the cars move right to left.\n        for _\
    \ in 0..(car1 - car2) {\n            d2 += 1;\n        }\n        // If the cars\
    \ are moving in the same direction, check for collisions.\n        if d2 == d\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp_sc1v1zo.rs:12:27\n\
    \   |\n12 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n13 |     for (car1, car2) in 0..(n) {\n   |     --- unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_sc1v1zo.rs:13:9\n  \
    \ |\n13 |     for (car1, car2) in 0..(n) {\n   |         ^^^^^^^^^^^^    ------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    let mut i = 0;\n    while i <\
    \ n {\n        let j = i;\n        while j < n {\n            total += if i +\
    \ 1 < n && j + 1 < n {\n                car_collision(i, j)\n            } else\
    \ 0; // no collision\n            i += 1;\n            j += 1;\n        }\n  \
    \      i += 1;\n    }\n    total\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `0`\n  --> /tmp/tmpu82nut0r.rs:17:20\n   |\n\
    17 |             } else 0; // no collision\n   |                    ^ expected\
    \ `{`\n   |\nhelp: try placing this code inside a block\n   |\n17 |          \
    \   } else { 0 }; // no collision\n   |                    +   +\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n % 2 != 0 {\n        return n * car_race_collision(n\
    \ - 1) as isize;\n    }\n    car_race_collision(n / 2)\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977944
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    if n % 2 ==\
    \ 0 {\n        return car_race_collision(n - 1) + car_race_collision(n - 2); //\
    \ Fill this in.\n    }\n    car_race_collision(n - 1) + (n - 2) / 4\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpwshjdqcf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if j > i {\n                let dx = i - j;\n \
    \               let dy = i - j;\n                let dz = i - j;\n           \
    \     if dx == 1 && dz == 1 { // diagonal\n                    collision += 2;\n\
    \                }\n                if dx == 1 && dy == 1 { // diagonal\n    \
    \                collision += 1;\n                }\n            }\n        }\n\
    \    }\n    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp2dsj4ow4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n * n) / 2 + n\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `9`', /tmp/tmpos5h_gwk.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (2 * n - 1) * 10\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `30`,\n right: `4`', /tmp/tmplf0f_0ee.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n - 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpr_9dxrah.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // There are two sets of n cars moving left to right;\
    \ there are n-1 sets of n-1 cars\n    // moving right to left.\n    let n1 = n\
    \ - 1;\n    let n2 = n - 2;\n    if n1 == 0 {\n        return n2;\n    }\n   \
    \ if n2 == 0 {\n        return n1;\n    }\n    // The smallest and largest possible\
    \ velocities of each set.  There's a lot of wasted\n    // space here, so we use\
    \ a smaller number than n\n    let v1 = ((1.1 + 2.2 * n1) * 3.0 + (2.8 * n1) *\
    \ n1) * 1e-3;\n    let v2 = ((1.1 + 2.2 * n2 * 2.6) * 3.0 + (2.8 * n2 * 2.6) *\
    \ n2) * 1e-3;\n    let mut collisions = 0;\n    // We are going through all combinations\
    \ of moving right to left, moving left to right,\n    // and moving in straight\
    \ lines.  There are n1 pairs of right to left cars; there are n2\n    // of left\
    \ to right cars.  All pairs of cars start at the same initial velocity.\n    //\
    \ We begin by finding the right to left collisions; the left and right collisions\
    \ become\n    // smaller as we move from left to right.\n    let collision_vec:\
    \ Vec<isize> = (0..n1).collect();\n    for j in (n1..n1 + n2).rev() {\n      \
    \  for i in 0..(n1 * n2) {\n            // The velocities are constant for both\
    \ sets of cars\n            let v = v1 * 2.;\n            // The initial positions\
    \ are the same; we only change directions\n            let x0 = 0.;\n        \
    \    let y0 = 0.;\n            // The next step depends on where we are (either\
    \ left or right)\n            let xnext = x1 * 2.;\n            let ynext = y1\
    \ * 2.;\n            // A collision occurs if we get too close\n            if\
    \ abs(xnext - x0) > 1e-10 {\n                continue;\n            }\n      \
    \      if abs(ynext - y0) > 1e-10 {\n                continue;\n            }\n\
    \            // If the cars are in collision, we're done\n            if ((xnext\
    \ + x0) / 2. < (xnext + x0) / 2.) && ((ynext + y0) / 2. < (ynext + y0) / 2.) {\n\
    \                continue;\n            }\n            // Otherwise, we need to\
    \ see if the cars collide\n            collisions += 1;\n            // Move in\
    \ the new direction\n            x1 += xnext;\n            y1 += ynext;\n    \
    \        // Move in the other direction\n            x0 += xnext;\n          \
    \  y0 += ynext;\n            collision_vec[j] = i;\n        }\n    }\n    // We\
    \ now have all collisions.  We now need to find which collision vector colli\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `x1` in this scope\n  --> /tmp/tmpl4v0qigk.rs:39:25\n\
    \   |\n39 |             let xnext = x1 * 2.;\n   |                         ^^\
    \ help: a local variable with a similar name exists: `n1`\n\nerror[E0425]: cannot\
    \ find value `y1` in this scope\n  --> /tmp/tmpl4v0qigk.rs:40:25\n   |\n40 | \
    \            let ynext = y1 * 2.;\n   |                         ^^ help: a local\
    \ variable with a similar name exists: `n1`\n\nerror[E0425]: cannot find function\
    \ `abs` in this scope\n  --> /tmp/tmpl4v0qigk.rs:42:16\n   |\n42 |           \
    \  if abs(xnext - x0) > 1e-10 {\n   |                ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpl4v0qigk.rs:45:16\n\
    \   |\n45 |             if abs(ynext - y0) > 1e-10 {\n   |                ^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `x1` in this scope\n\
    \  --> /tmp/tmpl4v0qigk.rs:55:13\n   |\n55 |             x1 += xnext;\n   |  \
    \           ^^ help: a local variable with a similar name exists: `n1`\n\nerror[E0425]:\
    \ cannot find value `y1` in this scope\n  --> /tmp/tmpl4v0qigk.rs:56:13\n   |\n\
    56 |             y1 += ynext;\n   |             ^^ help: a local variable with\
    \ a similar name exists: `n1`\n\nerror[E0277]: cannot multiply `{float}` by `isize`\n\
    \  --> /tmp/tmpl4v0qigk.rs:22:26\n   |\n22 |     let v1 = ((1.1 + 2.2 * n1) *\
    \ 3.0 + (2.8 * n1) * n1) * 1e-3;\n   |                          ^ no implementation\
    \ for `{float} * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0277]: cannot multiply `{float}` by `isize`\n  --> /tmp/tmpl4v0qigk.rs:22:45\n\
    \   |\n22 |     let v1 = ((1.1 + 2.2 * n1) * 3.0 + (2.8 * n1) * n1) * 1e-3;\n\
    \   |                 "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for (i, left_to_right) in\
    \ n.iter().enumerate() {\n        let mut collisions_to_left = 0;\n        if\
    \ left_to_right {\n            let mut left_to_right_iter = n.iter().skip_while(|&x|\
    \ x == i);\n            let mut right_to_left_iter = n.iter().skip_while(|&x|\
    \ x == i).rev();\n            collisions_to_left = car_race_collision(left_to_right_iter)\
    \ + car_race_collision(right_to_left_iter);\n        }\n        collisions +=\
    \ collisions_to_left;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwccsk3wp.rs:11:33\n   |\n11 |     for (i, left_to_right)\
    \ in n.iter().enumerate() {\n   |                                 ^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `iter` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpwccsk3wp.rs:14:44\n   |\n14 |  \
    \           let mut left_to_right_iter = n.iter().skip_while(|&x| x == i);\n \
    \  |                                            ^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpwccsk3wp.rs:15:44\n   |\n15 |             let mut right_to_left_iter\
    \ = n.iter().skip_while(|&x| x == i).rev();\n   |                            \
    \                ^^^^ method not found in `isize`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       let direction_left = vec![1; 3];\n        let direction_right = vec![3;\
    \ 1];\n        let direction = direction_left * direction_right;\n        let\
    \ mut collision = false;\n        for _ in 0..n {\n            let car_direction\
    \ = vec![(direction_left.dot(vec![1, 0]) as isize)/\n                        \
    \            (direction_left.len() as isize),\n                              \
    \       (direction_left.dot(vec![0, 1]) as isize)/\n                         \
    \           (direction_left.len() as isize),\n                               \
    \      (direction_left.dot(vec![1, 1]) as isize)/\n                          \
    \          (direction_left.len() as isize)];\n            let mut car_speed =\
    \ vec![3; 3];\n            for _ in 0..n {\n                if !collision {\n\
    \                    car_speed[0] = (direction_left.dot(&car_direction[0]) as\
    \ isize);\n                    car_speed[1] = (direction_left.dot(&car_direction[1])\
    \ as isize);\n                    car_speed[2] = (direction_left.dot(&car_direction[2])\
    \ as isize);\n                    let car_direction_dot = car_speed.dot(&direction);\n\
    \                    if car_direction_dot < 1.0 {\n                        collision\
    \ = true;\n                        collision_count = collision_count + 1;\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmptsmcgus1.rs:26:36\n\
    \   |\n26 |                     car_speed[0] = (direction_left.dot(&car_direction[0])\
    \ as isize);\n   |                                    ^                      \
    \                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n26 -                     car_speed[0] =\
    \ (direction_left.dot(&car_direction[0]) as isize);\n26 +                    \
    \ car_speed[0] = direction_left.dot(&car_direction[0]) as isize;\n   | \n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmptsmcgus1.rs:27:36\n\
    \   |\n27 |                     car_speed[1] = (direction_left.dot(&car_direction[1])\
    \ as isize);\n   |                                    ^                      \
    \                        ^\n   |\nhelp: remove these parentheses\n   |\n27 - \
    \                    car_speed[1] = (direction_left.dot(&car_direction[1]) as\
    \ isize);\n27 +                     car_speed[1] = direction_left.dot(&car_direction[1])\
    \ as isize;\n   | \n\nwarning: unnecessary parentheses around assigned value\n\
    \  --> /tmp/tmptsmcgus1.rs:28:36\n   |\n28 |                     car_speed[2]\
    \ = (direction_left.dot(&car_direction[2]) as isize);\n   |                  \
    \                  ^                                              ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n28 -                     car_speed[2] = (direction_left.dot(&car_direction[2])\
    \ as isize);\n28 +                     car_speed[2] = direction_left.dot(&car_direction[2])\
    \ as isize;\n   | \n\nerror[E0369]: cannot multiply `Vec<{integer}>` by `Vec<{integer}>`\n\
    \  --> /tmp/tmptsmcgus1.rs:14:40\n   |\n14 |         let direction = direction_left\
    \ * direction_right;\n   |                         -------------- ^ ---------------\
    \ Vec<{integer}>\n   |                         |\n   |                       \
    \  Vec<{integer}>\n\nerror[E0599]: no method named `dot` found for struct `Vec<{integer}>`\
    \ in the current scope\n  --> /tmp/tmptsmcgus1.rs:17:54\n   |\n17 |          \
    \   let car_direction = vec![(direction_left.d"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncars: isize = 0;\n    let mut ncollisions: isize\
    \ = 0;\n    let mut collision_speed: f64 = 1.0;\n    for i in 0..n {\n       \
    \ collision_speed = 1.0;\n        for j in i..n {\n            if i != j && car_collision(i\
    \ - 1, i, j) && car_collision(i, j, i + 1) && car_collision(j + 1, i, j) {\n \
    \               ncollisions += 1;\n                collision_speed *= 0.5;\n \
    \           }\n        }\n        ncars += 1;\n    }\n    collision_speed * (ncollisions\
    \ as f64 / ncars)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmp2qfbf_29.rs:16:26\n   |\n16 |             if i != j && car_collision(i\
    \ - 1, i, j) && car_collision(i, j, i + 1) && car_collision(j + 1, i, j) {\n \
    \  |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmp2qfbf_29.rs:16:56\n\
    \   |\n16 |             if i != j && car_collision(i - 1, i, j) && car_collision(i,\
    \ j, i + 1) && car_collision(j + 1, i, j) {\n   |                            \
    \                            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmp2qfbf_29.rs:16:86\n\
    \   |\n16 |             if i != j && car_collision(i - 1, i, j) && car_collision(i,\
    \ j, i + 1) && car_collision(j + 1, i, j) {\n   |                            \
    \                                                          ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: cannot divide `f64` by `isize`\n  --> /tmp/tmp2qfbf_29.rs:23:43\n\
    \   |\n23 |     collision_speed * (ncollisions as f64 / ncars)\n   |         \
    \                                  ^ no implementation for `f64 / isize`\n   |\n\
    \   = help: the trait `Div<isize>` is not implemented for `f64`\n   = help: the\
    \ following other types implement trait `Div<Rhs>`:\n             <&'a f32 as\
    \ Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n\
    \             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n    \
    \         <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n          \
    \   <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0\n    }\n\n    let mut collisions\
    \ = 0;\n    let mut car_positions = [0; n + 1];\n\n    for _ in 0..n {\n     \
    \   let mut closest_x = std::i32::MAX;\n        let mut closest_y = std::i32::MAX;\n\
    \n        for _x in 0..n {\n            let cx = *car_positions + _x + 1;\n  \
    \          let cy = *car_positions + _x + 2;\n            let dx = cx - x;\n \
    \           let dy = cy - y;\n            let distance = std::hypot(dx, dy);\n\
    \n            if distance < closest_x {\n                closest_x = distance;\n\
    \                closest_y = _y;\n            }\n        }\n\n        collisions\
    \ += 1;\n        *car_positions = closest_x + closest_y + 1;\n    }\n\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp8xf9mzyq.rs:15:33\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n...\n15 | \
    \    let mut car_positions = [0; n + 1];\n   |                               \
    \  ^\n\nerror[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmp8xf9mzyq.rs:24:27\n\
    \   |\n24 |             let dx = cx - x;\n   |                           ^ help:\
    \ a local variable with a similar name exists: `_x`\n\nerror[E0425]: cannot find\
    \ value `y` in this scope\n  --> /tmp/tmp8xf9mzyq.rs:25:27\n   |\n25 |       \
    \      let dy = cy - y;\n   |                           ^ help: a local variable\
    \ with a similar name exists: `cy`\n\nerror[E0425]: cannot find function `hypot`\
    \ in crate `std`\n  --> /tmp/tmp8xf9mzyq.rs:26:33\n   |\n26 |             let\
    \ distance = std::hypot(dx, dy);\n   |                                 ^^^^^ not\
    \ found in `std`\n\nerror[E0425]: cannot find value `_y` in this scope\n  -->\
    \ /tmp/tmp8xf9mzyq.rs:30:29\n   |\n30 |                 closest_y = _y;\n   |\
    \                             ^^ help: a local variable with a similar name exists:\
    \ `_x`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0435.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut left_to_right\
    \ = true;\n    for _ in 0..n {\n        let speed = left_to_right ? 1 : -1;\n\
    \        let dir = left_to_right ? +1 : -1;\n        for _ in 0..n {\n       \
    \     let next_dir = left_to_right ? +1 : -1;\n            let next_speed = left_to_right\
    \ ? 1 : -1;\n            let pos = left_to_right ? 2 : -2;\n            collisions\
    \ += if pos == 1 {\n                if left_to_right {\n                    1\n\
    \                } else {\n                    -1\n                }\n       \
    \     } else if pos == -2 {\n                if left_to_right {\n            \
    \        -1\n                } else {\n                    1\n               \
    \ }\n            } else if pos == 2 {\n                if left_to_right {\n  \
    \                  0\n                } else {\n                    0\n      \
    \          }\n            } else {\n                if left_to_right {\n     \
    \               0\n                } else {\n                    0\n         \
    \       }\n            };\n            left_to_right = next_dir;\n           \
    \ let new_dir = left_to_right ? +1 : -1;\n            let new_speed = left_to_right\
    \ ? 1 : -1;\n            left_to_right = new_dir;\n            left_to_right =\
    \ next_speed;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmpuy6incgd.rs:13:37\n   |\n13 |         let speed = left_to_right\
    \ ? 1 : -1;\n   |                                     ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 1usize;\n    while i < n * n {\n        if\
    \ i % 2 == 0 {\n            // first car moving right to left\n            for\
    \ j in 1..(n + 1) {\n                if j != i {\n                    if i * j\
    \ % n == 0 {\n                        i -= 1;\n                        i += 1;\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           // first car moving left to right\n            for j in 1..(n + 1)\
    \ {\n                if j != i {\n                    if i * j % n != 0 {\n  \
    \                      i += 1;\n                        i -= 1;\n            \
    \        }\n                }\n            }\n        }\n        i += 1;\n   \
    \ }\n    i\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6aos2ylm.rs:11:15\n   |\n\
    11 |     while i < n * n {\n   |               ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     while i < (n * n).try_into().unwrap() {\n\
    \   |               +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6aos2ylm.rs:15:25\n   |\n15 |                 if j != i {\n   |\
    \                         ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n15 |                 if j != i.try_into().unwrap() {\n   |            \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6aos2ylm.rs:16:28\n\
    \   |\n16 |                     if i * j % n == 0 {\n   |                    \
    \        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply `usize`\
    \ by `isize`\n  --> /tmp/tmp6aos2ylm.rs:16:26\n   |\n16 |                    \
    \ if i * j % n == 0 {\n   |                          ^ no implementation for `usize\
    \ * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6aos2ylm.rs:16:32\n   |\n16 |              \
    \       if i * j % n == 0 {\n   |                                ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot mod `usize` by `isize`\n  --> /tmp/tmp6aos2ylm.rs:16:30\n\
    \   |\n16 |                     if i * j % n == 0 {\n   |                    \
    \          ^ no implementation for `usize % isize`\n   |\n   = help: the trait\
    \ `Rem<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement t"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    // The race starts off\
    \ very far from each other.  We can accelerate\n    // the race by starting far\
    \ enough from one side (left or right) that\n    // it can complete one turn.\n\
    \    let mut acc = std::f32::consts::Pi / n as f32;\n\n    // Now that the race\
    \ has started a turn we can get closer each turn\n    // and get more turns before\
    \ the race is finished.\n    let mut acc2 = std::f32::consts::Pi / n as f32;\n\
    \n    // The cars start off moving at the same speed; acceleration increases\n\
    \    // the speed of each car on the way to its destination.\n    let mut speed\
    \ = std::f32::consts::Pi as f32 / n as f32;\n\n    // Since we've started the\
    \ race so close to one side we can\n    // just move right to the left side until\
    \ we hit a car in collision.\n    speed += acc;\n    collisions += car_collision(n,\
    \ &acc, &speed, &acc2);\n\n    // Now move back to the right side and move as\
    \ far as we can.\n    speed -= acc;\n    collisions += car_collision(n, &acc,\
    \ &speed, &acc2);\n\n    // Now move back to the left side and move as far as\
    \ we can.\n    speed += acc;\n    collisions += car_collision(n, &acc, &speed,\
    \ &acc2);\n\n    // Now move back to the right side and move as far as we can.\n\
    \    speed -= acc;\n    collisions += car_collision(n, &acc, &speed, &acc2);\n\
    \n    // Now move back to the left side and move as far as we can.\n    speed\
    \ += acc;\n    collisions += car_collision(n, &acc, &speed, &acc2);\n\n    //\
    \ Now move back to the right side and move as far as we can.\n    speed -= acc;\n\
    \    collisions += car_collision(n, &acc, &speed, &acc2);\n\n    // Now move back\
    \ to the left side and move as far as we can.\n    speed += acc;\n    collisions\
    \ += car_collision(n, &acc, &speed, &acc2);\n\n    // Now move back to the right\
    \ side and move as far as we can.\n    speed -= acc;\n    collisions += car_collision(n,\
    \ &acc, &speed, &acc2);\n\n    // Now move back to the left side and move as far\
    \ as we can.\n    speed += acc;\n    collisions += car_collision(n, &acc, &speed,\
    \ &acc2);\n\n    // Now move back to the right side and move as far as we \n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `Pi` in module `std::f32::consts`\n   -->\
    \ /tmp/tmpgl5fgch1.rs:15:37\n    |\n15  |     let mut acc = std::f32::consts::Pi\
    \ / n as f32;\n    |                                     ^^ help: a constant with\
    \ a similar name exists (notice the capitalization): `PI`\n\nerror[E0425]: cannot\
    \ find value `Pi` in module `std::f32::consts`\n   --> /tmp/tmpgl5fgch1.rs:19:38\n\
    \    |\n19  |     let mut acc2 = std::f32::consts::Pi / n as f32;\n    |     \
    \                                 ^^ help: a constant with a similar name exists\
    \ (notice the capitalization): `PI`\n\nerror[E0425]: cannot find value `Pi` in\
    \ module `std::f32::consts`\n   --> /tmp/tmpgl5fgch1.rs:23:39\n    |\n23  |  \
    \   let mut speed = std::f32::consts::Pi as f32 / n as f32;\n    |           \
    \                            ^^ help: a constant with a similar name exists (notice\
    \ the capitalization): `PI`\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpgl5fgch1.rs:28:19\n   |\n28 |     collisions +=\
    \ car_collision(n, &acc, &speed, &acc2);\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpgl5fgch1.rs:32:19\n   |\n32 |     collisions +=\
    \ car_collision(n, &acc, &speed, &acc2);\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpgl5fgch1.rs:36:19\n   |\n36 |     collisions +=\
    \ car_collision(n, &acc, &speed, &acc2);\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpgl5fgch1.rs:40:19\n   |\n40 |     collisions +=\
    \ car_collision(n, &acc, &speed, &acc2);\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collision`\
    \ in this scope\n  --> /tmp/tmpgl5fgch1.rs:44:19\n   |\n44 |     collisions +=\
    \ car_collision(n, &acc, &speed, &acc2);\n   |                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_collisi"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| i % 2 == 1).count() // 2\n        +\
    \ n.into_iter().filter(|i| i % 2 == 0).count()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmpcw7np53f.rs:11:13\n\
    \   |\n11 |         + n.into_iter().filter(|i| i % 2 == 0).count()\n   |     \
    \        ^^^^^^^^^ `isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `isize: IntoIterator`\n           `&isize: Iterator`\n      \
    \     which is required by `&isize: IntoIterator`\n           `&mut isize: Iterator`\n\
    \           which is required by `&mut isize: IntoIterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcw7np53f.rs:10:5\n   |\n9  |   fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n10 | /     (1..n).filter(|i| i % 2 == 1).count()\
    \ // 2\n11 | |         + n.into_iter().filter(|i| i % 2 == 0).count()\n   | |______________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 ~     ((1..n).filter(|i|\
    \ i % 2 == 1).count() // 2\n11 ~         + n.into_iter().filter(|i| i % 2 == 0).count()).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cnt = 0;\n\n    for _ in 0..n {\n        cnt\
    \ += 1;\n    }\n\n    for _ in 0..n {\n        cnt -= 1;\n    }\n\n    cnt\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp_xs1r7br.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count_collide = n;\n    for _ in 0..n {\n   \
    \     // let a = 2 * n - 1;\n        let a = ((2 * n - 1) * n) / 2;\n        let\
    \ b = n - 1;\n        // let c = 2 * (n - 1);\n        let c = ((2 * n - 1) *\
    \ n) / 2;\n\n        for _ in 0..n + 1 {\n            // let d = 2 * n - 1;\n\
    \            let d = ((2 * n - 1) * n) / 2;\n            if a >= d - c {\n   \
    \             count_collide--;\n                // let a = a + d;\n          \
    \      a += d;\n                // let b = b - d;\n                b -= d;\n \
    \           }\n        }\n    }\n    count_collide\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmprha0t6vo.rs:22:32\n\
    \   |\n22 |                 count_collide--;\n   |                           \
    \     ^ expected expression\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_1 = Car::new(1, 0);\n    let mut car_2 =\
    \ Car::new(n, 0);\n    let mut collision_count = 0;\n\n    // Simulate the race\
    \ by moving one car at a time.\n    let mut car_1_state: State = (-car_1.x, -car_1.y);\n\
    \    let mut car_2_state: State = (-car_2.x, -car_2.y);\n    while car_1_state.x\
    \ != 0 || car_2_state.x != 0 {\n        car_1.move(&mut car_1_state);\n      \
    \  car_2.move(&mut car_2_state);\n        if car_1.collides(&car_2) {\n      \
    \      collision_count = collision_count + 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `move`\n  --> /tmp/tmpjsp7ohkj.rs:18:15\n\
    \   |\n18 |         car_1.move(&mut car_1_state);\n   |               ^^^^ expected\
    \ identifier, found keyword\n   |\nhelp: escape `move` to use it as an identifier\n\
    \   |\n18 |         car_1.r#move(&mut car_1_state);\n   |               ++\n\n\
    error: expected identifier, found keyword `move`\n  --> /tmp/tmpjsp7ohkj.rs:19:15\n\
    \   |\n19 |         car_2.move(&mut car_2_state);\n   |               ^^^^ expected\
    \ identifier, found keyword\n   |\nhelp: escape `move` to use it as an identifier\n\
    \   |\n19 |         car_2.r#move(&mut car_2_state);\n   |               ++\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpjsp7ohkj.rs:10:21\n\
    \   |\n10 |     let mut car_1 = Car::new(1, 0);\n   |                     ^^^\
    \ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Car`\n  --> /tmp/tmpjsp7ohkj.rs:11:21\n   |\n11 |     let mut car_2 =\
    \ Car::new(n, 0);\n   |                     ^^^ use of undeclared type `Car`\n\
    \nerror[E0412]: cannot find type `State` in this scope\n  --> /tmp/tmpjsp7ohkj.rs:15:26\n\
    \   |\n15 |     let mut car_1_state: State = (-car_1.x, -car_1.y);\n   |     \
    \                     ^^^^^ not found in this scope\n\nerror[E0412]: cannot find\
    \ type `State` in this scope\n  --> /tmp/tmpjsp7ohkj.rs:16:26\n   |\n16 |    \
    \ let mut car_2_state: State = (-car_2.x, -car_2.y);\n   |                   \
    \       ^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = 0;\n    let mut max_speed = 1.0;\n    for\
    \ i in 1..n {\n        for j in 1..n {\n            if i != j {\n            \
    \    let speed = 2 * max_speed * f32::cosf(f32::consts::PI * i / n);\n       \
    \         let distance = f32::hypot(i - j, speed * speed);\n                let\
    \ speed = speed * distance;\n                if speed < max_speed {\n        \
    \            n += 1;\n                    max_speed = speed;\n               \
    \ }\n            }\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `{integer}` by `{float}`\n  --> /tmp/tmpz3ivzzka.rs:15:31\n\
    \   |\n15 |                 let speed = 2 * max_speed * f32::cosf(f32::consts::PI\
    \ * i / n);\n   |                               ^ no implementation for `{integer}\
    \ * {float}`\n   |\n   = help: the trait `Mul<{float}>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: no function or associated item named `cosf` found\
    \ for type `f32` in the current scope\n  --> /tmp/tmpz3ivzzka.rs:15:50\n   |\n\
    15 |                 let speed = 2 * max_speed * f32::cosf(f32::consts::PI * i\
    \ / n);\n   |                                                  ^^^^\n   |    \
    \                                              |\n   |                       \
    \                           function or associated item not found in `f32`\n \
    \  |                                                  help: there is an associated\
    \ function with a similar name: `cos`\n\nerror[E0223]: ambiguous associated type\n\
    \  --> /tmp/tmpz3ivzzka.rs:15:55\n   |\n15 |                 let speed = 2 * max_speed\
    \ * f32::cosf(f32::consts::PI * i / n);\n   |                                \
    \                       ^^^^^^^^^^^\n   |\nhelp: you are looking for the module\
    \ in `std`, not the primitive type\n   |\n15 |                 let speed = 2 *\
    \ max_speed * f32::cosf(std::f32::consts::PI * i / n);\n   |                 \
    \                                      ~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz3ivzzka.rs:16:43\n   |\n16 |                 let distance\
    \ = f32::hypot(i - j, speed * speed);\n   |                                  \
    \         ^^^^^ expected `f32`, found integer\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanation"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We need a map of the positions of all the cars in\
    \ the race\n    let mut positions: Vec<(isize, isize)> = vec![(isize, isize)];\n\
    \    for i in 0..n {\n        positions.push((i, 0));\n    }\n\n    let mut collided_at_start\
    \ = false;\n\n    // The first car will always collide with the second car.\n\
    \    for i in 0..n {\n        for j in i..n {\n            if i != j && positions[i].0\
    \ < positions[j].0 {\n                // The cars at position (i, j) will never\
    \ collide\n                positions[(i as usize, j as usize)].0 += 1;\n     \
    \       }\n        }\n    }\n\n    for car in &positions {\n        if car.0.0\
    \ < car.1 {\n            if collided_at_start {\n                return 1;\n \
    \           }\n            collided_at_start = true;\n        }\n    }\n    return\
    \ 0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmphlvw7fmy.rs:11:52\n\
    \   |\n11 |     let mut positions: Vec<(isize, isize)> = vec![(isize, isize)];\n\
    \   |                                                    ^^^^^ not a value\n\n\
    error[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmphlvw7fmy.rs:11:59\n\
    \   |\n11 |     let mut positions: Vec<(isize, isize)> = vec![(isize, isize)];\n\
    \   |                                                           ^^^^^ not a value\n\
    \nerror[E0277]: the type `[(isize, isize)]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmphlvw7fmy.rs:21:26\n   |\n21 |             if i != j && positions[i].0\
    \ < positions[j].0 {\n   |                          ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize,\
    \ isize)]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<(isize, isize)>`\n\nerror[E0277]: the\
    \ type `[(isize, isize)]` cannot be indexed by `isize`\n  --> /tmp/tmphlvw7fmy.rs:21:43\n\
    \   |\n21 |             if i != j && positions[i].0 < positions[j].0 {\n   | \
    \                                          ^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize,\
    \ isize)]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<(isize, isize)>`\n\nerror[E0277]: the\
    \ type `[(isize, isize)]` cannot be indexed by `(usize, usize)`\n  --> /tmp/tmphlvw7fmy.rs:23:17\n\
    \   |\n23 |                 positions[(i as usize, j as usize)].0 += 1;\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize,\
    \ isize)]>` is not implemented for `(usize, usize)`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `(Bound<usize>, Bound<usize>)`\n   ="
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0usize;\n    let mut last_collision_time = 0u64;\n    let mut last_collision_pos\
    \ = 0;\n    let mut last_collision_direction = Direction::Left;\n    for _ in\
    \ 0..n {\n        let mut collision_time = now_millis();\n        last_collision_time\
    \ = collision_time;\n        for _ in 0..n {\n            last_collision_pos +=\
    \ 1;\n            let mut collision_direction = Direction::Left;\n           \
    \ let mut collision_pos = last_collision_pos;\n            if collision_pos <\
    \ 0 {\n                collision_pos = 0;\n                collision_direction\
    \ = Direction::Right;\n            }\n            if collision_pos > n - 1 {\n\
    \                collision_pos = n - 1;\n                collision_direction =\
    \ Direction::Left;\n            }\n            if last_collision_direction !=\
    \ collision_direction {\n                collisions += 1;\n                last_collision_direction\
    \ = collision_direction;\n            }\n            if collision_time != last_collision_time\
    \ {\n                collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Direction`\n \
    \ --> /tmp/tmpxsykajt6.rs:16:40\n   |\n16 |     let mut last_collision_direction\
    \ = Direction::Left;\n   |                                        ^^^^^^^^^ use\
    \ of undeclared type `Direction`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Direction`\n  --> /tmp/tmpxsykajt6.rs:22:43\n   |\n22 |             let\
    \ mut collision_direction = Direction::Left;\n   |                           \
    \                ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpxsykajt6.rs:26:39\n\
    \   |\n26 |                 collision_direction = Direction::Right;\n   |    \
    \                                   ^^^^^^^^^ use of undeclared type `Direction`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpxsykajt6.rs:30:39\n\
    \   |\n30 |                 collision_direction = Direction::Left;\n   |     \
    \                                  ^^^^^^^^^ use of undeclared type `Direction`\n\
    \nerror[E0425]: cannot find function `now_millis` in this scope\n  --> /tmp/tmpxsykajt6.rs:18:34\n\
    \   |\n18 |         let mut collision_time = now_millis();\n   |             \
    \                     ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxsykajt6.rs:41:5\n   |\n9  | fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                    ----- expected `isize` because\
    \ of return type\n...\n41 |     collisions\n   |     ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n41 |     collisions.try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // count of collisions, initially\
    \ 0\n    for _ in 0..n { // n cars moving left to right\n        let car_right_to_left\
    \ = random_car_right_to_left();\n        let car_left_to_right = random_car_left_to_right();\n\
    \        if car_left_to_right != car_right_to_left {\n            // Two cars\
    \ collide\n            collisions += 1;\n        }\n    }\n    return collisions;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `random_car_right_to_left` in this scope\n\
    \  --> /tmp/tmpmewhvdus.rs:12:33\n   |\n12 |         let car_right_to_left = random_car_right_to_left();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `random_car_left_to_right` in this\
    \ scope\n  --> /tmp/tmpmewhvdus.rs:13:33\n   |\n13 |         let car_left_to_right\
    \ = random_car_left_to_right();\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 1 {\n        return 1;\n    }\n\n    let mut\
    \ count = 0;\n\n    // The goal is to count cars moving left to right that are\
    \ colliding with\n    // cars moving right to left.\n    let mut left = [0; n];\n\
    \    let mut right = [0; n];\n    let mut leftmost = n - 1;\n    let mut rightmost\
    \ = 0;\n    let mut colliding = false;\n\n    // The only way for cars to collide\
    \ is if they move the same distance in\n    // one direction (left, right, both,\
    \ or neither).\n    // To simplify the algorithm, we can assume that none of the\
    \ cars is ever\n    // moving in the opposite direction.\n    for _ in 0..n {\n\
    \        match left[leftmost] {\n            None => (),\n            Some(_)\
    \ => (),\n        }\n        match right[rightmost] {\n            None => (),\n\
    \            Some(_) => (),\n        }\n\n        // Set a flag that will tell\
    \ us if cars are colliding.\n        colliding = false;\n\n        // The cars\
    \ that would move right to left are those whose rightmost\n        // neighbor\
    \ is moving to the left.  We can use these to determine if\n        // the cars\
    \ are colliding.\n        for j in rightmost..n {\n            // If this neighbor\
    \ is moving right, they can't collide.\n            if right[j] == 1 {\n     \
    \           continue;\n            }\n            // If the neighbor is not moving,\
    \ they can collide.\n            match left[j] {\n                1 => colliding\
    \ = true,\n                _ => (),\n            }\n        }\n\n        // The\
    \ cars that would move left to right are those whose leftmost\n        // neighbor\
    \ is moving to the right.  We can use these to determine if\n        // the cars\
    \ are colliding.\n        for j in 0..leftmost {\n            // If this neighbor\
    \ is moving left, they can't collide.\n            if left[j] == 1 {\n       \
    \         continue;\n            }\n            // If the neighbor is not moving,\
    \ they can collide.\n            match right[j] {\n                1 => colliding\
    \ = true,\n                _ => (),\n            }\n        }\n\n        // Now\
    \ we know that cars are colliding.  We can just increment the count.\n       \
    \ if colliding {\n            count += 1;\n        }\n\n        // Now that we're\
    \ done with the cars that are colliding, we can update our\n        // lists of\
    \ right and left.  Do this by moving right and left one car\n        // at a time.\n\
    \        for j in 0..n {\n            // Move the car from the right to the left.\n\
    \            if left[j] == 1 {\n                left[j] = 0;\n            } else\
    \ {\n                left[j] = 1;\n            }\n            // Move the \n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6c0rji0w.rs:96:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n28 |     for _ in 0..n {\n\
    \   |                   - unclosed delimiter\n...\n79 |         for j in 0..n\
    \ {\n   |                       - this delimiter might not be properly closed...\n\
    ...\n87 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    96 | }\n   |   ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n\
    \  --> /tmp/tmp6c0rji0w.rs:18:24\n   |\n9  | fn car_race_collision(n: isize) ->\
    \ isize {\n   |                       - this would need to be a `const`\n...\n\
    18 |     let mut left = [0; n];\n   |                        ^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmp6c0rji0w.rs:19:25\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - this would need to be a `const`\n...\n19 |     let mut right = [0; n];\n\
    \   |                         ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6c0rji0w.rs:28:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n28\
    \ | /     for _ in 0..n {\n29 | |         match left[leftmost] {\n30 | |     \
    \        None => (),\n31 | |             Some(_) => (),\n...  |\n95 | |     assert_eq!(candidate(10),\
    \ 100);\n96 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0435.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 { return 0; }\n    if n == 1 { return 1; }\n\
    \    if n == 2 { return 0; }\n    if n == 3 { return 1; }\n    if n == 4 { return\
    \ 2; }\n    if n == 5 { return 1; }\n    if n == 6 { return 1; }\n    if n ==\
    \ 7 { return 1; }\n    if n == 8 { return 1; }\n    if n == 9 { return 1; }\n\
    \    if n == 10 { return 1; }\n    if n == 11 { return 1; }\n    if n == 12 {\
    \ return 1; }\n    if n == 13 { return 1; }\n    if n == 14 { return 1; }\n  \
    \  if n == 15 { return 1; }\n    if n == 16 { return 1; }\n    if n == 17 { return\
    \ 1; }\n    if n == 18 { return 1; }\n    if n == 19 { return 1; }\n    if n ==\
    \ 20 { return 1; }\n    if n == 21 { return 1; }\n    if n == 22 { return 1; }\n\
    \    if n == 23 { return 1; }\n    if n == 24 { return 1; }\n    if n == 25 {\
    \ return 1; }\n    if n == 26 { return 1; }\n    if n == 27 { return 1; }\n  \
    \  if n == 28 { return 1; }\n    if n == 29 { return 1; }\n    if n == 30 { return\
    \ 1; }\n    if n == 31 { return 1; }\n    if n == 32 { return 1; }\n    if n ==\
    \ 33 { return 1; }\n    if n == 34 { return 1; }\n    if n == 35 { return 1; }\n\
    \    if n == 36 { return 1; }\n    if n == 37 { return 1; }\n    if n == 38 {\
    \ return 1; }\n    if n == 39 { return 1; }\n    if n == 40 { return 1; }\n  \
    \  if n == 41 { return 1; }\n    if n == 42 { return 1; }\n    if n == 43 { return\
    \ 1; }\n    if n == 44 { return 1; }\n    if n == 45 { return 1; }\n    if n ==\
    \ 46 { return 1; }\n    if n == 47 { return 1; }\n    if n == 48 { return 1; }\n\
    \    if n == 49 { return 1; }\n    if n == 50 { return 1; }\n    if n == 51 {\
    \ return 1; }\n    if n == 52 { return 1; }\n    if n == 53 { return 1; }\n  \
    \  if n == 54 { return 1; }\n    if n == 55 { return 1; }\n    if n == 56 { return\
    \ 1; }\n    if n == 57 { return 1; }\n    if n == 58 { return 1; }\n    if n ==\
    \ 59 { return 1; }\n    if n == 60 { return 1; }\n    if n == 61 { return 1; }\n\
    \    if n == 62 { return 1; }\n    if n == 63 { return 1; }\n    if n == 64 {\
    \ return 1; }\n    if n == 65 { return 1; }\n    if n == 66 { return 1; }\n  \
    \  if n == 67 { return 1; }\n    if n == 68 { return 1; }\n    if n == 69\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp2i7qcs2u.rs:80:1\n   |\n\
    79 |     if n == 69\n   |     -- this `if` expression has a condition, but no\
    \ block\n80 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for left in (0..n).rev()\
    \ {\n        for right in (left..(n-1)).rev() {\n            let left_speed =\
    \ (left as f64 * 2.) - 1.;\n            let right_speed = (right as f64 * 2.)\
    \ - 1.;\n            collision_count += left_speed * right_speed / 2.;\n     \
    \   }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `f64` to `{integer}`\n  --> /tmp/tmp_odzeovp.rs:15:29\n\
    \   |\n15 |             collision_count += left_speed * right_speed / 2.;\n  \
    \ |                             ^^ no implementation for `{integer} += f64`\n\
    \   |\n   = help: the trait `AddAssign<f64>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut nn = n - 1;\n\
    \    let mut collision_dist = Vec::new();\n    let mut speed = Vec::new();\n \
    \   while nn > 0 {\n        let mut collision_dist = Vec::new();\n        for\
    \ j in 0..n {\n            let dist = std::f64::hypot(vehicle.x_pos[j], vehicle.x_pos[j\
    \ + 1]);\n            let d = vehicle.x_pos[j + 1] - vehicle.x_pos[j];\n     \
    \       collision_dist.push(dist);\n            if dist < vehicle.length {\n \
    \               let s = vehicle.speed_mps[j + 1] - vehicle.speed_mps[j];\n   \
    \             collision_dist.push(s);\n                speed.push(s);\n      \
    \      }\n        }\n        let mut max = 0;\n        let mut index_of_max =\
    \ collision_dist.iter().max().unwrap();\n        let mut max_index = collision_dist.iter().max().unwrap();\n\
    \        for j in 0..n {\n            if collision_dist[j] == collision_dist[max_index]\
    \ {\n                collision_count = collision_count + 1;\n                max\
    \ = collision_dist[j];\n                max_index = j;\n            }\n      \
    \  }\n        nn = nn-1;\n        vehicle.speed_mps[max_index] = vehicle.speed_mps[max_index]\
    \ * 1.05;\n        vehicle.speed_mps[max_index + 1] = vehicle.speed_mps[max_index\
    \ + 1] * 0.9;\n        vehicle.x_pos[max_index + 1] = vehicle.x_pos[max_index]\
    \ - collision_dist[max_index] * 0.15;\n        vehicle.x_pos[max_index] = vehicle.x_pos[max_index]\
    \ - collision_dist[max_index] * 0.15;\n        vehicle.x_pos[max_index + 1] =\
    \ vehicle.x_pos[max_index + 1] + collision_dist[max_index] * 0.15;\n        vehicle.x_pos[max_index]\
    \ = vehicle.x_pos[max_index + 1] + collision_dist[max_index] * 0.15;\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `hypot` in module `std::f64`\n  -->\
    \ /tmp/tmp3xby914r.rs:17:34\n   |\n17 |             let dist = std::f64::hypot(vehicle.x_pos[j],\
    \ vehicle.x_pos[j + 1]);\n   |                                  ^^^^^ not found\
    \ in `std::f64`\n\nerror[E0425]: cannot find value `vehicle` in this scope\n \
    \ --> /tmp/tmp3xby914r.rs:17:40\n   |\n17 |             let dist = std::f64::hypot(vehicle.x_pos[j],\
    \ vehicle.x_pos[j + 1]);\n   |                                        ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `vehicle` in this\
    \ scope\n  --> /tmp/tmp3xby914r.rs:17:58\n   |\n17 |             let dist = std::f64::hypot(vehicle.x_pos[j],\
    \ vehicle.x_pos[j + 1]);\n   |                                               \
    \           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `vehicle` in this scope\n  --> /tmp/tmp3xby914r.rs:18:21\n   |\n18 |       \
    \      let d = vehicle.x_pos[j + 1] - vehicle.x_pos[j];\n   |                \
    \     ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `vehicle`\
    \ in this scope\n  --> /tmp/tmp3xby914r.rs:18:44\n   |\n18 |             let d\
    \ = vehicle.x_pos[j + 1] - vehicle.x_pos[j];\n   |                           \
    \                 ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `vehicle` in this scope\n  --> /tmp/tmp3xby914r.rs:20:23\n   |\n20 | \
    \            if dist < vehicle.length {\n   |                       ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `vehicle` in this scope\n\
    \  --> /tmp/tmp3xby914r.rs:21:25\n   |\n21 |                 let s = vehicle.speed_mps[j\
    \ + 1] - vehicle.speed_mps[j];\n   |                         ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `vehicle` in this scope\n \
    \ --> /tmp/tmp3xby914r.rs:21:52\n   |\n21 |                 let s = vehicle.speed_mps[j\
    \ + 1] - vehicle.speed_mps[j];\n   |                                         \
    \           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `vehicle` in this scope\n  --> /tmp/tmp3xby914r.rs:37:9\n   |\n37 |        \
    \ vehicle.speed"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut speed = 1.0;\n    let\
    \ mut position = (0.0, 0.0);\n    let mut move_in_direction = (0.0, 0.0);\n  \
    \  let mut collide_with = (0.0, 0.0);\n    let mut collision_distance = 0.0;\n\
    \n    // The initial position and direction of the first car\n    let initial_position\
    \ = if n == 0 {\n        (0.0, 0.0)\n    } else {\n        position = (0.0, 0.0)\n\
    \    };\n\n    // The initial direction of the first car\n    let initial_direction\
    \ = if n == 0 {\n        (0.0, 0.0)\n    } else {\n        move_in_direction =\
    \ (0.0, 0.0)\n    };\n\n    // The initial position and direction of the second\
    \ car\n    let second_position = if n == 0 {\n        (0.0, 0.0)\n    } else {\n\
    \        (position.0, position.0 + 10.0)\n    };\n\n    // The initial direction\
    \ of the second car\n    let second_direction = if n == 0 {\n        (0.0, 0.0)\n\
    \    } else {\n        (move_in_direction.0, move_in_direction.0 + 10.0)\n   \
    \ };\n\n    // The initial position and direction of the third car\n    let third_position\
    \ = if n == 0 {\n        (0.0, 0.0)\n    } else {\n        (second_position.0,\
    \ second_position.0 + 10.0)\n    };\n\n    // The initial direction of the third\
    \ car\n    let third_direction = if n == 0 {\n        (0.0, 0.0)\n    } else {\n\
    \        (second_direction.0, second_direction.0 + 10.0)\n    };\n\n    // The\
    \ initial position and direction of the fourth car\n    let fourth_position =\
    \ if n == 0 {\n        (0.0, 0.0)\n    } else {\n        (third_position.0, third_position.0\
    \ + 10.0)\n    };\n\n    // The initial direction of the fourth car\n    let fourth_direction\
    \ = if n == 0 {\n        (0.0, 0.0)\n    } else {\n        (third_direction.0,\
    \ third_direction.0 + 10.0)\n    };\n\n    let mut speed_delta = if n == 0 {\n\
    \        (0.0, 0.0)\n    } else {\n        (0.0, 0.0)\n    };\n\n    // The initial\
    \ speed of the first car\n    let initial_speed = if n == 0 {\n        1.0\n \
    \   } else {\n        speed\n    };\n\n    // The initial speed of the second\
    \ car\n    let second_speed = if n == 0 {\n        1.0\n    } else {\n       \
    \ speed * 2.0\n    };\n\n    // The initial speed of the third car\n    let third_speed\
    \ = if n == 0 {\n        1.0\n    } else {\n        speed * 3.0\n    };\n\n  \
    \  // The initial speed of the fourth car\n    let fourth_speed = if n == 0 {\n\
    \        1.0\n    } else {\n        speed * 4.0\n    };\n\n    while counter <\
    \ n {\n        // Update position and direction of car\n        position = position\
    \ + speed_delta;\n\n        // Update direction of car\n        move_in_direction\
    \ = move_in_direction + speed_delta;\n\n        // Update the speed of the car\n\
    \n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbptl0psg.rs:125:3\n\
    \    |\n9   | fn car_race_collision(n: isize) -> isize {\n    |              \
    \                            - unclosed delimiter\n...\n107 |     while counter\
    \ < n {\n    |                       - this delimiter might not be properly closed...\n\
    ...\n116 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n125 | }\n    |   ^\n\nerror[E0308]: `if` and `else` have incompatible types\n\
    \  --> /tmp/tmpbptl0psg.rs:21:9\n   |\n18 |       let initial_position = if n\
    \ == 0 {\n   |  ____________________________-\n19 | |         (0.0, 0.0)\n   |\
    \ |         ---------- expected because of this\n20 | |     } else {\n21 | | \
    \        position = (0.0, 0.0)\n   | |         ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found `()`\n22 | |     };\n   | |_____- `if` and `else` have incompatible\
    \ types\n   |\n   = note:  expected tuple `({float}, {float})`\n           found\
    \ unit type `()`\n\nerror[E0308]: `if` and `else` have incompatible types\n  -->\
    \ /tmp/tmpbptl0psg.rs:28:9\n   |\n25 |       let initial_direction = if n == 0\
    \ {\n   |  _____________________________-\n26 | |         (0.0, 0.0)\n   | | \
    \        ---------- expected because of this\n27 | |     } else {\n28 | |    \
    \     move_in_direction = (0.0, 0.0)\n   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `()`\n29 | |     };\n   | |_____- `if` and `else` have\
    \ incompatible types\n   |\n   = note:  expected tuple `({float}, {float})`\n\
    \           found unit type `()`\n\nerror[E0369]: cannot add `({float}, {float})`\
    \ to `({float}, {float})`\n   --> /tmp/tmpbptl0psg.rs:109:29\n    |\n109 |   \
    \      position = position + speed_delta;\n    |                    -------- ^\
    \ ----------- ({float}, {float})\n    |                    |\n    |          \
    \          ({float}, {float})\n\nerror[E0369]: cannot add `({float}, {float})`\
    \ to `({float}, {float})`\n   --> /tmp/tmpbptl0psg.rs:112:47\n    |\n112 |   \
    \      move_in_direction = move_in_direction + speed_delta;\n    |           \
    \                  ----------------- ^ ----------- ({float}, {float})\n    | \
    \   "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = n;\n    for _ in 0..n {\n      \
    \  let direction = vec![vec![-1.0, 0.0, 0.0], vec![0.0, -1.0, 0.0],\n        \
    \                     vec![0.0, 0.0, -1.0]];\n        let start = vec![-1.0, 0.0,\
    \ 0.0];\n        let end = vec![0.0, 1.0, 0.0];\n        let dir = start.rotate_2d(&direction);\n\
    \        let offset = vec![-3.0, 0.0, 0.0];\n        let speed = 20.0;\n     \
    \   collisions += 0..n {\n            let pos = start.rotate_2d(&dir).add_2d(&offset);\n\
    \            if dir_squared::<f32>(&dir) != 0.0 {\n                let offset\
    \ = vec![3.0, 0.0, 0.0];\n                let dir = end.rotate_2d(&direction);\n\
    \                let speed = 20.0;\n                if dir_squared::<f32>(&dir)\
    \ != 0.0 {\n                    let offset = vec![-3.0, 0.0, 0.0];\n         \
    \           let dir = end.rotate_2d(&direction);\n                    let speed\
    \ = 20.0;\n                    if dir_squared::<f32>(&dir) != 0.0 {\n        \
    \                let offset = vec![-3.0, 0.0, 0.0];\n                        let\
    \ dir = end.rotate_2d(&direction);\n                        let speed = 20.0;\n\
    \                    }\n                }\n            }\n            car_collision(&pos,\
    \ &dir, &speed, &dir)\n        };\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmpado6b2sa.rs:20:13\n\
    \   |\n19 |         collisions += 0..n {\n   |                          - while\
    \ parsing this struct\n20 |             let pos = start.rotate_2d(&dir).add_2d(&offset);\n\
    \   |             ^^^ expected identifier, found keyword\n\nerror: expected identifier,\
    \ found `&`\n  --> /tmp/tmpado6b2sa.rs:36:33\n   |\n19 |         collisions +=\
    \ 0..n {\n   |                          - while parsing this struct\n...\n36 |\
    \             car_collision(&pos, &dir, &speed, &dir)\n   |                  \
    \               ^ expected identifier\n\nerror: expected identifier, found `&`\n\
    \  --> /tmp/tmpado6b2sa.rs:36:39\n   |\n19 |         collisions += 0..n {\n  \
    \ |                          - while parsing this struct\n...\n36 |          \
    \   car_collision(&pos, &dir, &speed, &dir)\n   |                            \
    \           ^ expected identifier\n\nerror: expected identifier, found `&`\n \
    \ --> /tmp/tmpado6b2sa.rs:36:47\n   |\n19 |         collisions += 0..n {\n   |\
    \                          - while parsing this struct\n...\n36 |            \
    \ car_collision(&pos, &dir, &speed, &dir)\n   |                              \
    \                 ^ expected identifier\n\nerror[E0574]: expected struct, variant\
    \ or union type, found local variable `n`\n  --> /tmp/tmpado6b2sa.rs:19:26\n \
    \  |\n19 |         collisions += 0..n {\n   |                          ^ not a\
    \ struct, variant or union type\n\nerror[E0599]: no method named `rotate_2d` found\
    \ for struct `Vec<{float}>` in the current scope\n  --> /tmp/tmpado6b2sa.rs:16:25\n\
    \   |\n16 |         let dir = start.rotate_2d(&direction);\n   |             \
    \            ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `rotate_left`\n\nerror[E0277]: cannot add-assign `std::ops::Range<{integer}>`\
    \ to `isize`\n  --> /tmp/tmpado6b2sa.rs:19:20\n   |\n19 |         collisions +=\
    \ 0..n {\n   |                    ^^ no implementation for `isize += std::ops::Range<{integer}>`\n\
    \   |\n   = help: the trait `AddAssign<std::ops::Range<{integer}>>` is not implemented\
    \ for `isize`\n   = help: the follow"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut hits: isize = 0;\n    let mut collision_distance:\
    \ isize = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n           \
    \ let distance = (car_distance(&i) as i64) + (car_distance(&j) as i64);\n    \
    \        if distance < collision_distance {\n                collision_distance\
    \ = distance;\n                hits = 1;\n            }\n        }\n    }\n  \
    \  hits\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_distance` in this scope\n  -->\
    \ /tmp/tmpf4wmiv6n.rs:14:29\n   |\n14 |             let distance = (car_distance(&i)\
    \ as i64) + (car_distance(&j) as i64);\n   |                             ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `car_distance`\
    \ in this scope\n  --> /tmp/tmpf4wmiv6n.rs:14:57\n   |\n14 |             let distance\
    \ = (car_distance(&i) as i64) + (car_distance(&j) as i64);\n   |             \
    \                                            ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![n];\n    cars.sort();\n    let mut\
    \ collide = 0;\n    for _ in 0..n {\n        let mut colliding = false;\n    \
    \    for idx in 0..cars.len() {\n            if cars[idx] > cars[idx+1] {\n  \
    \              collide++;\n                colliding = true;\n            }\n\
    \        }\n        if colliding {\n            break;\n        }\n        cars.push(1);\n\
    \    }\n    collide\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpmys5_78o.rs:17:24\n\
    \   |\n17 |                 collide++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |               \
    \  { let tmp = collide; collide += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n17 -                 collide++;\n17 +        \
    \         collide += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n * n) / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxyooih78.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| i % 2).count()\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ubn09d4.rs:10:23\n   |\n\
    10 |     (1..n).filter(|i| i % 2).count()\n   |                       ^^^^^ expected\
    \ `bool`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ubn09d4.rs:10:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n10 |     (1..n).filter(|i|\
    \ i % 2).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |     (1..n).filter(|i| i % 2).count().try_into().unwrap()\n\
    \   |                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: usize = 0;\n    let mut left_to_right\
    \ = n - 1;\n    let mut right_to_left = n - 1;\n\n    for _ in 1..n {\n      \
    \  if left_to_right == 0 {\n            return collisions;\n        }\n\n    \
    \    let car_right = left_to_right % 2;\n\n        let car_left = left_to_right\
    \ / 2;\n\n        if car_right == car_left {\n            left_to_right /= 2;\n\
    \        } else {\n            left_to_right = ((left_to_right % 2) + left_to_right\
    \ + right_to_left) % 2;\n            right_to_left = (right_to_left + left_to_right\
    \ + left_to_right / 2 + 1) % 2;\n        }\n\n        collisions += 1;\n    }\n\
    \n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzqfq3c_i.rs:16:20\n   |\n\
    16 |             return collisions;\n   |                    ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |             return\
    \ collisions.try_into().unwrap();\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzqfq3c_i.rs:33:5\n   |\n9  | fn\
    \ car_race_collision(n: isize) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n33 |     collisions\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    33 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for (i, left) in n.iter().enumerate()\
    \ {\n        for right in n.iter().rev() {\n            if left == right {\n \
    \               continue;\n            }\n            if left == right + 1 {\n\
    \                collisions += 1;\n            }\n            if left == right\
    \ - 1 {\n                collisions += 1;\n            }\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmph5p9r136.rs:11:24\n   |\n11 |     for (i, left) in n.iter().enumerate()\
    \ {\n   |                        ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmph5p9r136.rs:12:24\n\
    \   |\n12 |         for right in n.iter().rev() {\n   |                      \
    \  ^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // the number of collisions\n\
    \n    // Create a vector from each car to another.\n    let mut a_x = Vec::new();\n\
    \    let mut a_y = Vec::new();\n    let mut b_x = Vec::new();\n    let mut b_y\
    \ = Vec::new();\n    for _ in 0..n {\n        a_x.push(rand::random::<f32>());\n\
    \        a_y.push(rand::random::<f32>());\n        b_x.push(rand::random::<f32>());\n\
    \        b_y.push(rand::random::<f32>());\n    }\n    for _ in 0..n {\n      \
    \  a_x.pop();\n        a_y.pop();\n        b_x.pop();\n        b_y.pop();\n  \
    \  }\n\n    // Set the length of the trajectory to be as long as a \"perfectly\
    \ straight line\"\n    // of the given length.\n    let mut a_length = a.length();\n\
    \    let mut b_length = b.length();\n    while a_length > b_length {\n       \
    \ a_length -= b_length;\n        b_length -= a_length;\n    }\n\n    // Calculate\
    \ the vector from the second car back to the first car.\n    let b_back_to_a =\
    \ b - a;\n\n    // Calculate the velocity of the second car.\n    let b_velocity\
    \ = b_back_to_a.dot(&b_back_to_a);\n\n    // Find the two closest points of the\
    \ two cars.\n    let (a_closest, b_closest) = a_x.iter().enumerate()\n       \
    \ .map(|(i, x| *x = a_x.binary_search(&x).unwrap()))\n        .zip(a_y.iter().enumerate().map(|(i,\
    \ y| *y = a_y.binary_search(&y).unwrap())))\n        .collect();\n\n    // Calculate\
    \ the length of the collision\n    let collision_length = a_length + b_length\
    \ - b_velocity;\n\n    // If the collision length is less than zero then there\
    \ is a collision.\n    if collision_length < 0.0 {\n        collisions += 1;\n\
    \    }\n\n    // Calculate the distance between the two closest points.\n    let\
    \ collision_distance = collision_length\n        .sqrt() // sqrt returns the distance\
    \ squared, so we have to divide by the square root.\n        .powf(2.0); // ^2\
    \ raises the distance to a power.\n\n    // Calculate the time the two cars are\
    \ separated.\n    let collision_time = collision_distance / b_velocity;\n\n  \
    \  // Calculate the time the two cars are traveling.\n    let collision_time_a\
    \ = collision_time - a_closest.to_f32();\n    let collision_time_b = collision_time\
    \ - b_closest.to_f32();\n\n    // Calculate the time the two cars are traveling\
    \ at half speed.\n    let collision_time_\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `*`\n  --> /tmp/tmpw39sb4tx.rs:47:22\n \
    \  |\n47 |         .map(|(i, x| *x = a_x.binary_search(&x).unwrap()))\n   |  \
    \                 -  ^ expected pattern\n   |                   |\n   |      \
    \             while parsing this or-pattern starting here\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpw39sb4tx.rs:18:18\n\
    \   |\n18 |         a_x.push(rand::random::<f32>());\n   |                  ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpw39sb4tx.rs:19:18\n\
    \   |\n19 |         a_y.push(rand::random::<f32>());\n   |                  ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpw39sb4tx.rs:20:18\n\
    \   |\n20 |         b_x.push(rand::random::<f32>());\n   |                  ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmpw39sb4tx.rs:21:18\n\
    \   |\n21 |         b_y.push(rand::random::<f32>());\n   |                  ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0425]: cannot find value\
    \ `a` in this scope\n  --> /tmp/tmpw39sb4tx.rs:32:24\n   |\n32 |     let mut a_length\
    \ = a.length();\n   |                        ^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror[E0425]: cannot find value `b` in this scope\n  -->\
    \ /tmp/tmpw39sb4tx.rs:33:24\n   |\n33 |     let mut b_length = b.length();\n \
    \  |                        ^ help: a local variable with a similar name exists:\
    \ `n`\n\nerror[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmpw39sb4tx.rs:40:23\n\
    \   |\n40 |     let b_back_to_a = b - a;\n   |                       ^ help: a\
    \ local variable with a similar name exists: `n`\n\nerror[E0425]: cannot find\
    \ value `a` in this scope\n  --> /tmp/tmpw39sb4tx.rs:40:27\n   |\n40 |     let\
    \ b_back_to_a = b - a;\n   |                           ^ help: a local variable\
    \ with a similar name exists: `n`\n\nerror: aborting due to 9 pre"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    if n == 0 {\n        return\
    \ 0;\n    }\n    let mut collisions: isize = 0;\n\n    if n % 2 == 0 {\n     \
    \   // Even number of cars starting at the first index\n        for left in 0..n/2\
    \ - 1 {\n            for right in 0..n/2 - 1 {\n                let mut collision:\
    \ Option<usize> = None;\n                // Only one collision possible - if left\
    \ and right are both moving\n                // away from each other\n       \
    \         if left == right {\n                    // If both cars are moving in\
    \ opposite directions, they\n                    // will collide\n           \
    \         collision = Some(left);\n                    collision = Some(right);\n\
    \                }\n                collisions = collisions.saturating_add(1);\n\
    \                if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 2);\n                }\n                if collision.is_some() {\n     \
    \               collision = collision.map(|x| x * 3);\n                }\n   \
    \             if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 4);\n                }\n                if collision.is_some() {\n     \
    \               collision = collision.map(|x| x * 5);\n                }\n   \
    \             if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 6);\n                }\n                if collision.is_some() {\n     \
    \               collision = collision.map(|x| x * 7);\n                }\n   \
    \             if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 8);\n                }\n                if collision.is_some() {\n     \
    \               collision = collision.map(|x| x * 9);\n                }\n   \
    \             if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 10);\n                }\n                if collision.is_some() {\n    \
    \                collision = collision.map(|x| x * 11);\n                }\n \
    \               if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 12);\n                }\n                if collision.is_some() {\n    \
    \                collision = collision.map(|x| x * 13);\n                }\n \
    \               if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 14);\n                }\n                if collision.is_some() {\n    \
    \                collision = collision.map(|x| x * 15);\n                }\n \
    \               if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 16);\n                }\n                if collision.is_some() {\n    \
    \                collision = collision.map(|x| x * 17);\n                }\n \
    \               if collision.is_some() {\n                    collision = collision.map(|x|\
    \ x * 18);\n                }\n                if collision.is_some() {\n    \
    \                collision = collision.map(|x| x * 19);\n                }\n \
    \               if collision.is_some\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu8qu01bo.rs:94:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n16 |     if n % 2 == 0 {\n\
    \   |                   - unclosed delimiter\n17 |         // Even number of cars\
    \ starting at the first index\n18 |         for left in 0..n/2 - 1 {\n   |   \
    \                             - unclosed delimiter\n19 |             for right\
    \ in 0..n/2 - 1 {\n   |                                     - this delimiter might\
    \ not be properly closed...\n...\n85 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n94 | }\n   |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpu8qu01bo.rs:85:1\n   |\n84 |                 if collision.is_some\n\
    \   |                 -- this `if` expression has a condition, but no block\n\
    85 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu8qu01bo.rs:18:9\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n18\
    \ | /         for left in 0..n/2 - 1 {\n19 | |             for right in 0..n/2\
    \ - 1 {\n20 | |                 let mut collision: Option<usize> = None;\n21 |\
    \ |                 // Only one collision possible - if left and right are both\
    \ moving\n...  |\n93 | |     assert_eq!(candidate(10), 100);\n94 | | }\n   | |__^\
    \ expected `isize`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncollisions = 0;\n    let mut current_car = 1;\n\
    \n    for car1 in 1..=n {\n        for car2 in 1..=n {\n            if car1 !=\
    \ car2 && (car1 == 0 || car2 == 0) {\n                let x = current_car % 10000;\n\
    \                let y = current_car / 10000;\n                if (car1 == 0 &&\
    \ car2 == 0) || (car2 == 0 && car1 == 0) {\n                    // don't do anything\
    \ for zero\n                    continue;\n                }\n               \
    \ if car1 > car2 {\n                    // swap car1 and car2\n              \
    \      let tmp = car1;\n                    car1 = car2;\n                   \
    \ car2 = tmp;\n                }\n                let dist = sqrt(x*x + y*y);\n\
    \                let dmin = std::min(dist - car1, dist - car2);\n            \
    \    let dmax = std::max(dist - car1, dist - car2);\n                if dmin <\
    \ car1 + car2 && dmin < dmax {\n                    ncollisions += 1;\n      \
    \          }\n            }\n        }\n    }\n    ncollisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sqrt` in this scope\n  --> /tmp/tmpv69u0sz2.rs:28:28\n\
    \   |\n28 |                 let dist = sqrt(x*x + y*y);\n   |                \
    \            ^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `min` in crate `std`\n  --> /tmp/tmpv69u0sz2.rs:29:33\n   |\n29 |          \
    \       let dmin = std::min(dist - car1, dist - car2);\n   |                 \
    \                ^^^ not found in `std`\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\nhelp: if you import `min`, refer to it directly\n\
    \   |\n29 -                 let dmin = std::min(dist - car1, dist - car2);\n29\
    \ +                 let dmin = min(dist - car1, dist - car2);\n   | \n\nerror[E0425]:\
    \ cannot find function `max` in crate `std`\n  --> /tmp/tmpv69u0sz2.rs:30:33\n\
    \   |\n30 |                 let dmax = std::max(dist - car1, dist - car2);\n \
    \  |                                 ^^^ not found in `std`\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\nhelp: if you import\
    \ `max`, refer to it directly\n   |\n30 -                 let dmax = std::max(dist\
    \ - car1, dist - car2);\n30 +                 let dmax = max(dist - car1, dist\
    \ - car2);\n   | \n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut current_direction\
    \ = Vec::new();\n    let mut move_dir = Vec::new();\n    for _ in 0..n {\n   \
    \     // Pick a random start position.\n        let x = (rand::random::<f64>()\
    \ * 2.0) - 1.0;\n        let y = (rand::random::<f64>() * 2.0) - 1.0;\n      \
    \  let theta = rand::random::<f64>() * 2.0 * M_PI;\n        // Find the direction\
    \ vector for this particular point.\n        let dir = Vec::new();\n        dir.push(x);\n\
    \        dir.push(y);\n        dir.push(theta);\n        // Keep track of how\
    \ far we're moved each iteration.\n        current_direction.push(dir);\n    \
    \    move_dir.push(dir);\n        // Iterate until we've moved enough times.\n\
    \        let mut move_counter = 0;\n        while move_counter < 6 {\n       \
    \     move_counter += 1;\n            // Move the car until it hits a moving right\
    \ car.\n            let mut moved = false;\n            loop {\n             \
    \   if !moved {\n                    let dir = move_dir[move_counter % move_dir.len()];\n\
    \                    let new_x = dir.clone().dot(dir).unwrap();\n            \
    \        let new_y = dir.clone().dot(dir + dir).unwrap();\n                  \
    \  if new_x > 0.0 {\n                        break;\n                    }\n \
    \                   let new_theta = dir.dot(dir + dir + dir).unwrap();\n     \
    \               if new_theta < 0.0 {\n                        break;\n       \
    \             }\n                }\n                moved = true;\n          \
    \      let theta = rand::random::<f64>() * 2.0 * M_PI;\n                let new_dir\
    \ = Vec::new();\n                new_dir.push(new_x);\n                new_dir.push(new_y);\n\
    \                new_dir.push(theta);\n                // Move the car\n     \
    \           let movement_x = dir.clone().dot(dir + dir).unwrap();\n          \
    \      let movement_y = dir.clone().dot(dir).unwrap();\n                let movement_theta\
    \ = dir.dot(dir + dir + dir).unwrap();\n                let new_x = movement_x\
    \ + x;\n                let new_y = movement_y + y;\n                let new_theta\
    \ = movement_theta + theta;\n                let new_dir = Vec::new();\n     \
    \           new_dir.push(new_x);\n                new_dir.push(new_y);\n     \
    \           new_dir.push(new_theta);\n                // Keep track of how far\
    \ we've moved each iteration.\n                move_dir.push(new_dir);\n     \
    \           current_direction.push(new_dir);\n                // Update our position.\n\
    \                x = new_x;\n                y = new_y;\n                theta\
    \ = new_theta;\n                // Break if the car is moving too much.\n    \
    \            if new_x > 0.0 {\n                    break;\n                }\n\
    \n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplwfd19gh.rs:83:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n13 |     for _ in 0..n {\n\
    \   |                   - unclosed delimiter\n...\n28 |         while move_counter\
    \ < 6 {\n   |                                - unclosed delimiter\n...\n32 | \
    \            loop {\n   |                  - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n83 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `rand`\n  --> /tmp/tmplwfd19gh.rs:15:18\n   |\n15 |         let x\
    \ = (rand::random::<f64>() * 2.0) - 1.0;\n   |                  ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `rand`\n  --> /tmp/tmplwfd19gh.rs:16:18\n   |\n16 |        \
    \ let y = (rand::random::<f64>() * 2.0) - 1.0;\n   |                  ^^^^ use\
    \ of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `rand`\n  --> /tmp/tmplwfd19gh.rs:17:21\n   |\n\
    17 |         let theta = rand::random::<f64>() * 2.0 * M_PI;\n   |           \
    \          ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmplwfd19gh.rs:46:29\n\
    \   |\n46 |                 let theta = rand::random::<f64>() * 2.0 * M_PI;\n\
    \   |                             ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0425]: cannot find value `M_PI` in this scope\n  --> /tmp/tmplwfd19gh.rs:17:51\n\
    \   |\n17 |         let theta = rand::random::<f64>() * 2.0 * M_PI;\n   |    \
    \                                               ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `M_PI` in this scope\n  --> /tmp/tmplwfd19gh.rs:46:59\n\
    \   |\n46 |                 let theta = rand::random::<f64>() * 2.0 * M_PI;\n\
    \   |                                                           ^^^^ not found\
    \ in this scope\n\nerror[E0425]: ca"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // let mut collisions: Vec<isize> = vec![0; n];\n   \
    \ let mut collisions = 0;\n    let mut car1 = Car::new(true, false);\n    let\
    \ mut car2 = Car::new(false, true);\n    let mut car3 = Car::new(false, false);\n\
    \    let mut car4 = Car::new(true, false);\n    let mut car5 = Car::new(true,\
    \ true);\n    let mut car6 = Car::new(true, true);\n\n    let mut car7 = Car::new(true,\
    \ false);\n    let mut car8 = Car::new(false, true);\n    let mut car9 = Car::new(false,\
    \ false);\n    let mut car10 = Car::new(true, false);\n    let mut car11 = Car::new(true,\
    \ true);\n\n    let mut car12 = Car::new(true, false);\n    let mut car13 = Car::new(false,\
    \ true);\n    let mut car14 = Car::new(false, false);\n    let mut car15 = Car::new(true,\
    \ false);\n    let mut car16 = Car::new(true, true);\n\n    for _ in 0..n {\n\
    \        collisions += car1.collide(car2);\n        collisions += car1.collide(car3);\n\
    \        collisions += car1.collide(car4);\n        collisions += car1.collide(car5);\n\
    \        collisions += car1.collide(car6);\n        collisions += car1.collide(car7);\n\
    \        collisions += car1.collide(car8);\n        collisions += car1.collide(car9);\n\
    \        collisions += car1.collide(car10);\n        collisions += car1.collide(car11);\n\
    \        collisions += car1.collide(car12);\n        collisions += car1.collide(car13);\n\
    \        collisions += car1.collide(car14);\n        collisions += car1.collide(car15);\n\
    \        collisions += car1.collide(car16);\n        car1.update();\n        car2.update();\n\
    \        car3.update();\n        car4.update();\n        car5.update();\n    \
    \    car6.update();\n        car7.update();\n        car8.update();\n        car9.update();\n\
    \        car10.update();\n        car11.update();\n        car12.update();\n \
    \       car13.update();\n        car14.update();\n        car15.update();\n  \
    \      car16.update();\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:12:20\n\
    \   |\n12 |     let mut car1 = Car::new(true, false);\n   |                  \
    \  ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:13:20\n   |\n13 |     let mut\
    \ car2 = Car::new(false, true);\n   |                    ^^^ use of undeclared\
    \ type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n\
    \  --> /tmp/tmpqc5sjth0.rs:14:20\n   |\n14 |     let mut car3 = Car::new(false,\
    \ false);\n   |                    ^^^ use of undeclared type `Car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:15:20\n\
    \   |\n15 |     let mut car4 = Car::new(true, false);\n   |                  \
    \  ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:16:20\n   |\n16 |     let mut\
    \ car5 = Car::new(true, true);\n   |                    ^^^ use of undeclared\
    \ type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n\
    \  --> /tmp/tmpqc5sjth0.rs:17:20\n   |\n17 |     let mut car6 = Car::new(true,\
    \ true);\n   |                    ^^^ use of undeclared type `Car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:19:20\n\
    \   |\n19 |     let mut car7 = Car::new(true, false);\n   |                  \
    \  ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:20:20\n   |\n20 |     let mut\
    \ car8 = Car::new(false, true);\n   |                    ^^^ use of undeclared\
    \ type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n\
    \  --> /tmp/tmpqc5sjth0.rs:21:20\n   |\n21 |     let mut car9 = Car::new(false,\
    \ false);\n   |                    ^^^ use of undeclared type `Car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpqc5sjth0.rs:22:21\n\
    \   |\n22 |     let mut car10 = Car::new(true, false);\n   |                 \
    \    ^^^ use of undeclared type `Car`\n\nerror["
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut current_velocity\
    \ = Vec::with_capacity(2 * n);\n    current_velocity.push(0);\n    for i in 0..n\
    \ {\n        for j in 0..n {\n            if i != j {\n                if ((i\
    \ + 1) % n == (j + 1) % n) {\n                    current_velocity[i] += 1;\n\
    \                } else {\n                    current_velocity[j] += 1;\n   \
    \             }\n            }\n        }\n        if !check_collision(current_velocity)\
    \ {\n            collision_count += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_collision` in this scope\n  -->\
    \ /tmp/tmpu_xzottj.rs:23:13\n   |\n23 |         if !check_collision(current_velocity)\
    \ {\n   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmpu_xzottj.rs:16:20\n   |\n16\
    \ |                 if ((i + 1) % n == (j + 1) % n) {\n   |                  \
    \  ^                          ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n16 -                 if ((i\
    \ + 1) % n == (j + 1) % n) {\n16 +                 if (i + 1) % n == (j + 1) %\
    \ n {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu_xzottj.rs:11:51\n\
    \   |\n11 |     let mut current_velocity = Vec::with_capacity(2 * n);\n   |  \
    \                                                 ^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n11 |     let mut current_velocity = Vec::with_capacity((2\
    \ * n).try_into().unwrap());\n   |                                           \
    \        +     +++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpu_xzottj.rs:17:21\n   |\n17 |         \
    \            current_velocity[i] += 1;\n   |                     ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpu_xzottj.rs:19:21\n\
    \   |\n19 |                     current_velocity[j] += 1;\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       let left_lane = vec![vec![0; 5], vec![0; 5], vec![0; 5]];\n        let\
    \ right_lane = vec![vec![0; 5], vec![0; 5], vec![0; 5]];\n        for _ in 0..n\
    \ {\n            left_lane[0].iter_mut().enumerate().for_each(|(i, x)| {\n   \
    \             left_lane[1].iter_mut().enumerate().for_each(|(j, y)| {\n      \
    \              left_lane[2].iter_mut().enumerate().for_each(|(j, z)| {\n     \
    \                   right_lane[0].iter_mut().enumerate().for_each(|(i, x)| {\n\
    \                            right_lane[1].iter_mut().enumerate().for_each(|(j,\
    \ y)| {\n                                right_lane[2].iter_mut().enumerate().for_each(|(j,\
    \ z)| {\n                                    if abs(x) + abs(y) + abs(z) <= 1\
    \ && abs(x) + abs(y) + abs(z) <= 1 {\n                                       \
    \ collision_count += 1;\n                                        if x != 0 &&\
    \ y != 0 && z != 0 {\n                                            println!(\"\
    left_lane: {} right_lane: {}\", left_lane, right_lane);\n                    \
    \                    }\n                                    }\n              \
    \                  });\n                            });\n                    \
    \    });\n                    });\n                });\n            });\n    \
    \    }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1yx76wr8.rs:21:40\n\
    \   |\n21 | ...                   if abs(x) + abs(y) + abs(z) <= 1 && abs(x) +\
    \ abs(y) + abs(z) <= 1 {\n   |                          ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1yx76wr8.rs:21:49\n\
    \   |\n21 | ...                   if abs(x) + abs(y) + abs(z) <= 1 && abs(x) +\
    \ abs(y) + abs(z) <= 1 {\n   |                                   ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  -->\
    \ /tmp/tmp1yx76wr8.rs:21:58\n   |\n21 | ...                   if abs(x) + abs(y)\
    \ + abs(z) <= 1 && abs(x) + abs(y) + abs(z) <= 1 {\n   |                     \
    \                       ^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `abs` in this scope\n  --> /tmp/tmp1yx76wr8.rs:21:73\n   |\n21 | ...\
    \                   if abs(x) + abs(y) + abs(z) <= 1 && abs(x) + abs(y) + abs(z)\
    \ <= 1 {\n   |                                                           ^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n\
    \  --> /tmp/tmp1yx76wr8.rs:21:82\n   |\n21 | ...                   if abs(x) +\
    \ abs(y) + abs(z) <= 1 && abs(x) + abs(y) + abs(z) <= 1 {\n   |              \
    \                                                      ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1yx76wr8.rs:21:91\n\
    \   |\n21 | ...                   if abs(x) + abs(y) + abs(z) <= 1 && abs(x) +\
    \ abs(y) + abs(z) <= 1 {\n   |                                               \
    \                              ^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&mut {integer}` with `{integer}`\n  --> /tmp/tmp1yx76wr8.rs:23:46\n\
    \   |\n23 | ...                   if x != 0 && y != 0 && z != 0 {\n   |      \
    \                      ^^ no implementation for `&mut {integer} == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&mut\
    \ {integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_race_table: Vec<isize> = (0..n).collect();\n\
    \    for x in car_race_table.iter() {\n        car_race_table[x] = car_race_table[x]\
    \ % n + x;\n    }\n    let mut collisions: isize = 0;\n    for x in 0..car_race_table.len()\
    \ {\n        for y in car_race_table.iter().rev() {\n            if car_race_table[x]\
    \ > car_race_table[y] && car_race_table[x] != x {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpzn5gqqq_.rs:12:9\n\
    \   |\n12 |         car_race_table[x] = car_race_table[x] % n + x;\n   |     \
    \    ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpzn5gqqq_.rs:12:29\n\
    \   |\n12 |         car_race_table[x] = car_race_table[x] % n + x;\n   |     \
    \                        ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpzn5gqqq_.rs:17:36\n   |\n17 |             if car_race_table[x]\
    \ > car_race_table[y] && car_race_table[x] != x {\n   |                      \
    \              ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzn5gqqq_.rs:17:78\n\
    \   |\n17 |             if car_race_table[x] > car_race_table[y] && car_race_table[x]\
    \ != x {\n   |                                                               \
    \               ^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    17 |             if car_race_table[x] > car_race_table[y] && car_race_table[x]\
    \ != x.try_into().unwrap() {\n   |                            "
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 0;\n    while i * 2 < n {\n        i += 1;\n\
    \    }\n    i - (n * 2)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `4`', /tmp/tmpkko3pq3a.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n)\n        .map(|x| {\n            let mut speed\
    \ = 100.0;\n            if x <= n / 2 {\n                speed += 100.0;\n   \
    \         }\n            if n > x / 2 {\n                speed += 100.0;\n   \
    \         }\n            if x > n / 2 {\n                speed += 100.0;\n   \
    \         }\n            speed\n        })\n        .filter(|x| x < 1000)\n  \
    \      .count()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2hbinvr3.rs:24:25\n   |\n\
    24 |         .filter(|x| x < 1000)\n   |                         ^^^^\n   |  \
    \                       |\n   |                         expected reference, found\
    \ integer\n   |                         help: consider borrowing here: `&1000`\n\
    \   |\n   = note: expected reference `&_`\n                   found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2hbinvr3.rs:10:5\n   |\n9  | \
    \  fn car_race_collision(n: isize) -> isize {\n   |                          \
    \            ----- expected `isize` because of return type\n10 | /     (0..n)\n\
    11 | |         .map(|x| {\n12 | |             let mut speed = 100.0;\n13 | | \
    \            if x <= n / 2 {\n...  |\n24 | |         .filter(|x| x < 1000)\n25\
    \ | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| i % 2 == 0)\n        .count_while(|i|\
    \ i % 2 == 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count_while` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpfghd6aic.rs:11:10\n   |\n11 |         .count_while(|i|\
    \ i % 2 == 1)\n   |          ^^^^^^^^^^^ method not found in `Filter<std::ops::Range<isize>,\
    \ [closure@/tmp/tmpfghd6aic.rs:10:19: 10:33]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count: isize = 0;\n    let mut car_positions\
    \ = [0..=n].collect::<Vec<_>>();\n    let mut positions_to_collide = vec![Position\
    \ {x: 0, y: 0}];\n    let mut positions_to_collide_with = vec![Position {x: 0,\
    \ y: 0}];\n    for car_position in car_positions {\n        positions_to_collide.push(Position\
    \ {x: car_position.x, y: car_position.y});\n        positions_to_collide_with.push(Position\
    \ {x: car_position.x, y: car_position.y});\n    }\n    \n    for _ in 0..n {\n\
    \        for _ in 0..n {\n            // Calculate the position to test for the\
    \ next collision.\n            let next_position = Position {x: car_positions[car_positions.len()\
    \ - 1].x + 1, y: car_positions[car_positions.len() - 1].y};\n            let collision_test1\
    \ = positions_to_collide.iter().filter(|position| position.x == next_position.x\
    \ && position.y == next_position.y).count();\n            let collision_test2\
    \ = positions_to_collide_with.iter().filter(|position| position.x == next_position.x\
    \ && position.y == next_position.y).count();\n\n            if collision_test1\
    \ > 0 && collision_test2 > 0 {\n                // collision\n               \
    \ collision_count += 1;\n                car_positions.push(next_position);\n\
    \                positions_to_collide.push(next_position);\n                positions_to_collide_with.push(next_position);\n\
    \            } else if collision_test1 < 0 || collision_test2 < 0 {\n        \
    \        // not a collision\n                car_positions.push(next_position);\n\
    \                positions_to_collide.push(next_position);\n                positions_to_collide_with.push(next_position);\n\
    \            }\n        }\n    }\n    collision_count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0422]: cannot find struct, variant or union type `Position` in this\
    \ scope\n  --> /tmp/tmpwppfa86e.rs:12:41\n   |\n12 |     let mut positions_to_collide\
    \ = vec![Position {x: 0, y: 0}];\n   |                                       \
    \  ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant\
    \ or union type `Position` in this scope\n  --> /tmp/tmpwppfa86e.rs:13:46\n  \
    \ |\n13 |     let mut positions_to_collide_with = vec![Position {x: 0, y: 0}];\n\
    \   |                                              ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Position`\
    \ in this scope\n  --> /tmp/tmpwppfa86e.rs:15:35\n   |\n15 |         positions_to_collide.push(Position\
    \ {x: car_position.x, y: car_position.y});\n   |                             \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant\
    \ or union type `Position` in this scope\n  --> /tmp/tmpwppfa86e.rs:16:40\n  \
    \ |\n16 |         positions_to_collide_with.push(Position {x: car_position.x,\
    \ y: car_position.y});\n   |                                        ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0422]: cannot find struct, variant or union type\
    \ `Position` in this scope\n  --> /tmp/tmpwppfa86e.rs:22:33\n   |\n22 |      \
    \       let next_position = Position {x: car_positions[car_positions.len() - 1].x\
    \ + 1, y: car_positions[car_positions.len() - 1].y};\n   |                   \
    \              ^^^^^^^^ not found in this scope\n\nerror[E0599]: `[RangeInclusive<isize>;\
    \ 1]` is not an iterator\n  --> /tmp/tmpwppfa86e.rs:11:37\n   |\n11 |     let\
    \ mut car_positions = [0..=n].collect::<Vec<_>>();\n   |                     \
    \                ^^^^^^^ `[RangeInclusive<isize>; 1]` is not an iterator; try\
    \ calling `.into_iter()` or `.iter()`\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[RangeInclusive<isize>; 1]: Iterator`\n   \
    \        which is required by `&mut [RangeInclusive<isize>; 1]: Iterator`\n  \
    \         `[RangeInclusive<isize>]: Iterator`\n           which is required by\
    \ `&mut [RangeInclusive<isize>]: Iterato"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n+1 {\n        for\
    \ j in 1..i+1 {\n            if j % 2 != 0 {\n                if j-i == 0 {\n\
    \                    let mut temp_i = i;\n                    let mut temp_j =\
    \ j;\n                    while temp_j != 0 {\n                        let temp\
    \ = temp_i;\n                        temp_i = temp_j;\n                      \
    \  temp_j = temp / 2;\n                    }\n                    let res = temp_i\
    \ * temp_j;\n                    if res > n {\n                        result\
    \ += 1;\n                    }\n                }\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp5nu2icfo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n_collisions = 0; \n    // The cars can move\
    \ left to right, but they can never move right to left.  That means\n    // that\
    \ if one car is moving right to left on a straight line, then no other car can\n\
    \    // move left to right on the same line.\n    // So if there are n cars that\
    \ are already moving right to left, then they are\n    // guaranteed not to collide.\n\
    \    let mut right_to_left_cars = vec![n];\n    let mut left_to_right_cars = vec![n];\n\
    \    \n    for car_index in 0..n {\n        let mut car_movement_direction = vec![];\n\
    \        let current_car = Car::new(\n                position: (0.0, 0.0),\n\
    \                velocity: vec![]\n                );\n        if car_index ==\
    \ 0 { \n            // If the first car is already moving left to the right, then\
    \ there is no\n            // right to left car, so we must add it.\n        \
    \    left_to_right_cars.push_back(0);\n        } else {\n            // Otherwise,\
    \ we must find another car to move right to left on.\n            // We iterate\
    \ through the list of left cars, and if the first car is at index\n          \
    \  // 0, then we know that it has already moved right to left.  That means \n\
    \            // that there is no collision with the first car.\n            for\
    \ car in left_to_right_cars.iter() {\n                if car == 0 {\n        \
    \            break;\n                }\n                // We only care if the\
    \ first car has moved right to left.\n                car_movement_direction =\
    \ car_movement_direction.iter()\n                    .map(|x| *x + (*x - current_car.position[1]).sqrt()\
    \ as f32)\n                    .collect::<Vec<f32>>();\n            }\n      \
    \  }\n        \n        if car_movement_direction.len() == 0 {\n            //\
    \ If there are no cars that can move right to left on the current line, then\n\
    \            // we do not need to worry about a collision with this car.\n   \
    \         continue;\n        }\n        \n        // If there are cars that can\
    \ move right to left on the current line,\n        // then we must start moving\
    \ them right to left.\n        // We also keep track of the cars already moving\
    \ right to left.  We will need\n        // to find another one to move left to\
    \ right.\n        if car_index != 0 {\n            // If the current car already\
    \ moved right to left, there is no left to\n            // right car.  That means\
    \ no collision with this car.\n            for car in right_to_left_cars.iter()\
    \ {\n                if car == 0 {\n                    break;\n             \
    \   }\n                // We only care if the first car has moved right to left.\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp77zv95ms.rs:72:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n19 |     for car_index in\
    \ 0..n {\n   |                           - unclosed delimiter\n...\n55 |     \
    \    if car_index != 0 {\n   |                           - unclosed delimiter\n\
    ...\n58 |             for car in right_to_left_cars.iter() {\n   |           \
    \                                       - this delimiter might not be properly\
    \ closed...\n...\n63 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n72 | }\n   |   ^\n\nerror: invalid `struct` delimiters or `fn` call arguments\n\
    \  --> /tmp/tmp77zv95ms.rs:21:27\n   |\n21 |           let current_car = Car::new(\n\
    \   |  ___________________________^\n22 | |                 position: (0.0, 0.0),\n\
    23 | |                 velocity: vec![]\n24 | |                 );\n   | |_________________^\n\
    \   |\nhelp: if `Car::new` is a struct, use braces as delimiters\n   |\n21 ~ \
    \        let current_car = Car::new { \n22 |                 position: (0.0, 0.0),\n\
    23 |                 velocity: vec![]\n24 ~                  };\n   |\nhelp: if\
    \ `Car::new` is a function, use the arguments directly\n   |\n22 ~           \
    \      (0.0, 0.0),\n23 ~                 vec![]\n   |\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<isize>` in the current scope\n  -->\
    \ /tmp/tmp77zv95ms.rs:28:32\n   |\n28 |             left_to_right_cars.push_back(0);\n\
    \   |                                ^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp77zv95ms.rs:35:24\n\
    \   |\n35 |                 if car == 0 {\n   |                        ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isiz"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut sum = 0;\n    let mut cur = 0;\n    while cur\
    \ < n {\n        sum += car_race_collision_one(cur);\n        cur += 1;\n    }\n\
    \    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_one` in this scope\n\
    \  --> /tmp/tmpw6wpgocw.rs:13:16\n   |\n13 |         sum += car_race_collision_one(cur);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    debug_assert_ne!(n,0);\n\n    let mut collisions = 0;\n\
    \n    loop {\n        collisions += car_race_collision_helper(n);\n        n *=\
    \ 2;\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpj01u7894.rs:15:23\n   |\n15 |         collisions += car_race_collision_helper(n);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nwarning: unreachable expression\n  --> /tmp/tmpj01u7894.rs:19:5\n   |\n14 |\
    \ /     loop {\n15 | |         collisions += car_race_collision_helper(n);\n16\
    \ | |         n *= 2;\n17 | |     }\n   | |_____- any code following this expression\
    \ is unreachable\n18 | \n19 |       collisions\n   |       ^^^^^^^^^^ unreachable\
    \ expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total_collisions = n * (n - 1) * (n - 2) / 6;\n\
    \    for a in (0..n).rev() {\n        for b in (a + 1).rev().rev().rev().rev()\
    \ {\n            if a == b {\n                continue;\n            }\n     \
    \       let mut c = 0;\n            for &(car1, car2) in &[&[a, b], &[b, a], &[a,\
    \ b], &[b, a], &[a, b], &[b, a]] {\n                let distance = car_distance(car1,\
    \ car2);\n                c += if distance == 0 { 0 } else { 1 } * distance *\
    \ distance / 4;\n            }\n            total_collisions += c;\n        }\n\
    \    }\n    total_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_distance` in this scope\n  -->\
    \ /tmp/tmps1ltxzje.rs:18:32\n   |\n18 |                 let distance = car_distance(car1,\
    \ car2);\n   |                                ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmps1ltxzje.rs:12:26\n\
    \   |\n12 |         for b in (a + 1).rev().rev().rev().rev() {\n   |         \
    \                 ^^^ `isize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `isize: Iterator`\n           which\
    \ is required by `&mut isize: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps1ltxzje.rs:17:18\n   |\n17 |             for &(car1, car2) in &[&[a,\
    \ b], &[b, a], &[a, b], &[b, a], &[a, b], &[b, a]] {\n   |                  ^^^^^^^^^^^^\
    \    ------------------------------------------------------- this expression has\
    \ type `Option<&&[isize; 2]>`\n   |                  |\n   |                 \
    \ expected array `[isize; 2]`, found tuple\n   |\n   = note: expected array `[isize;\
    \ 2]`\n              found tuple `(_, _)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut speeds = [0; n];\n\n\
    \    for _ in 0..n {\n        speeds[n - 1] = (speeds[n - 1] - 1);\n        speeds[n]\
    \ = (n * speeds[n]);\n    }\n\n    for _ in 0..n {\n        for _ in 0..n {\n\
    \            if speeds[n - 1] > speeds[n] {\n                counter = counter\
    \ + 1;\n                speeds[n - 1] = (speeds[n - 1] - 1);\n               \
    \ speeds[n] = (n * speeds[n]);\n            }\n        }\n    }\n\n    counter\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp_jqljd05.rs:11:26\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n10 |     let\
    \ mut counter = 0;\n11 |     let mut speeds = [0; n];\n   |                  \
    \        ^\n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp_jqljd05.rs:14:25\n\
    \   |\n14 |         speeds[n - 1] = (speeds[n - 1] - 1);\n   |               \
    \          ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by\
    \ default\nhelp: remove these parentheses\n   |\n14 -         speeds[n - 1] =\
    \ (speeds[n - 1] - 1);\n14 +         speeds[n - 1] = speeds[n - 1] - 1;\n   |\
    \ \n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp_jqljd05.rs:15:21\n\
    \   |\n15 |         speeds[n] = (n * speeds[n]);\n   |                     ^ \
    \            ^\n   |\nhelp: remove these parentheses\n   |\n15 -         speeds[n]\
    \ = (n * speeds[n]);\n15 +         speeds[n] = n * speeds[n];\n   | \n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmp_jqljd05.rs:22:33\n\
    \   |\n22 |                 speeds[n - 1] = (speeds[n - 1] - 1);\n   |       \
    \                          ^                 ^\n   |\nhelp: remove these parentheses\n\
    \   |\n22 -                 speeds[n - 1] = (speeds[n - 1] - 1);\n22 +       \
    \          speeds[n - 1] = speeds[n - 1] - 1;\n   | \n\nwarning: unnecessary parentheses\
    \ around assigned value\n  --> /tmp/tmp_jqljd05.rs:23:29\n   |\n23 |         \
    \        speeds[n] = (n * speeds[n]);\n   |                             ^    \
    \         ^\n   |\nhelp: remove these parentheses\n   |\n23 -                \
    \ speeds[n] = (n * speeds[n]);\n23 +                 speeds[n] = n * speeds[n];\n\
    \   | \n\nerror: aborting due to previous error; 4 warnings emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count: isize = 0;\n    for _ in 0..n\
    \ {\n        if n % 2 == 0 {\n            if n / 2 < 2 {\n                collision_count\
    \ += 1;\n            }\n        } else {\n            if n / 2 < 4 {\n       \
    \         collision_count += 1;\n            }\n        }\n        n /= 2;\n \
    \   }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp33motq6b.rs:21:9\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - help: consider making this binding mutable: `mut n`\n...\n21 |      \
    \   n /= 2;\n   |         ^^^^^^ cannot assign to immutable argument\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions: isize = 0;\n    for i in 0..n\
    \ {\n        for j in i + 1..n {\n            if i != j && car_race_collision_test((i,\
    \ j)) {\n                num_collisions += 1;\n            }\n        }\n    }\n\
    \    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_test` in this scope\n\
    \  --> /tmp/tmp0ixlfw9y.rs:13:26\n   |\n13 |             if i != j && car_race_collision_test((i,\
    \ j)) {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    \n    if n\
    \ <= 2 {\n        return 0;\n    }\n\n    if n <= 6 {\n        return 2 * car_race_collision(n\
    \ - 2) + 1;\n    }\n\n    let mut collision_counter = 0;\n    for _ in 0..n {\n\
    \        let mut left = false, right = false;\n        for _ in 0..n {\n     \
    \       if right {\n                collision_counter += 2;\n                left\
    \ = true;\n                break;\n            }\n            \n            if\
    \ left {\n                collision_counter++;\n                right = true;\n\
    \                break;\n            }\n        }\n    }\n\n    collision_counter\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n\
    \  --> /tmp/tmpa4u9nmye.rs:24:29\n   |\n24 |         let mut left = false, right\
    \ = false;\n   |                             ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n - 1) * (n - 2) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpt3z4vh79.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // This algorithm is not efficient, but it is the only\
    \ algorithm that can solve the problem in linear time.\n    // This is probably\
    \ an excellent example of why it's important for you to understand the underlying\
    \ algorithms\n    // before you implement this one.\n    let mut collided_cars\
    \ = 1;\n    let mut collided_car_left = vec![0; n];\n    let mut collided_car_right\
    \ = vec![0; n];\n    let mut collided_car_left = vec![0; n];\n    let mut collided_car_right\
    \ = vec![0; n];\n    let mut car_right = vec![0; n];\n    let mut car_left = vec![0;\
    \ n];\n    let mut car_traveled = vec![0; n];\n    // The cars are going right\
    \ to left, so start with car_right.\n    for car_i in 0..n {\n        let mut\
    \ car_left_old = car_left[car_i];\n        let mut car_right_old = car_right[car_i];\n\
    \        car_right[car_i] = car_i + 1;\n        while car_right_old < n && car_left[car_right_old]\
    \ == car_right_old {\n            car_right_old += 1;\n        }\n        if car_right_old\
    \ == n {\n            collided_cars += 1;\n            car_right[car_i] = 0;\n\
    \        }\n        let mut car_left_old = car_left[car_i];\n        car_left[car_i]\
    \ = car_i + 1;\n        while car_left_old < n && car_right[car_left_old] == car_left_old\
    \ {\n            car_left_old += 1;\n        }\n        if car_left_old == n {\n\
    \            collided_cars += 1;\n            car_left[car_i] = 0;\n        }\n\
    \    }\n    // The cars are going left to right, so start with car_left.\n   \
    \ for car_i in 0..n {\n        let mut car_left_old = car_left[car_i];\n     \
    \   let mut car_right_old = car_right[car_i];\n        car_left[car_i] = car_i\
    \ - 1;\n        while car_left_old > 0 && car_right[car_left_old] == car_right_old\
    \ {\n            car_left_old -= 1;\n        }\n        if car_left_old == 0 {\n\
    \            collided_cars += 1;\n            car_left[car_i] = 0;\n        }\n\
    \        let mut car_right_old = car_right[car_i];\n        car_right[car_i] =\
    \ car\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprskc7yph.rs:66:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n44 |     for car_i in 0..n\
    \ {\n   |                       - this delimiter might not be properly closed...\n\
    ...\n57 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    66 | }\n   |   ^\n\nerror[E0425]: cannot find value `car` in this scope\n  -->\
    \ /tmp/tmprskc7yph.rs:56:28\n   |\n56 |         car_right[car_i] = car\n   | \
    \                           ^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprskc7yph.rs:14:41\n   |\n14 |     let mut collided_car_left\
    \ = vec![0; n];\n   |                                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     let mut collided_car_left\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprskc7yph.rs:15:42\n\
    \   |\n15 |     let mut collided_car_right = vec![0; n];\n   |               \
    \                           ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |     let mut collided_car_right = vec![0; n.try_into().unwrap()];\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprskc7yph.rs:16:41\n   |\n16 |     let mut collided_car_left\
    \ = vec![0; n];\n   |                                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     let mut collided_car_left\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprskc7yph.rs:17:42\n\
    \   |\n17 |     let mut collided_car_right = vec![0; n];\n   |               \
    \                 "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut speed = vec![0;\
    \ n];\n    let mut collision_count = 0;\n    for j in (0..(n-1)).rev() {\n   \
    \     for i in 0..(n-1) {\n            speed[i] = speed[i+1];\n            if\
    \ i != j {\n                // If the i-th and j-th cars collide\n           \
    \     collisions += car_collision(speed[i], speed[j]);\n                collision_count\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmptz6t3b65.rs:18:31\n   |\n18 |                 collisions += car_collision(speed[i],\
    \ speed[j]);\n   |                               ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptz6t3b65.rs:11:29\n \
    \  |\n11 |     let mut speed = vec![0; n];\n   |                             ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ speed = vec![0; n.try_into().unwrap()];\n   |                              ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmptz6t3b65.rs:15:13\n\
    \   |\n15 |             speed[i] = speed[i+1];\n   |             ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmptz6t3b65.rs:15:24\n\
    \   |\n15 |             speed[i] = speed[i+1];\n   |                        ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmptz6t3b65.rs:18:45\n\
    \   |\n18 |                 collisions += car_collision(speed[i], speed[j]);\n\
    \   |                                             ^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required be"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    2 * n / 3\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpd5ft2dj0.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // First we calculate the distances from each car to\
    \ its next car.  They\n    // will then be sorted in ascending order (left to\
    \ right then right to\n    // left).  We will stop when we get to a car that has\
    \ exactly one distance\n    // less than or equal to n.\n    let mut distances\
    \ = vec![(0., n)];\n    for _ in 0..n {\n        distances.push(0);\n    }\n \
    \   let mut i = 1;\n    let mut collisions = 0;\n    while i < distances.len()\
    \ {\n        let distance = distances[i];\n        let distance2 = distances[i\
    \ - 1];\n        if distance == distance2 {\n            i += 1;\n           \
    \ continue;\n        }\n        if distance > distance2 {\n            // No collision.\n\
    \            if distance < n {\n                i += 1;\n                continue;\n\
    \            }\n            break;\n        }\n        let distance = distances[i];\n\
    \        let distance2 = distances[i - 1];\n        if distance > distance2 {\n\
    \            // Collision\n            collisions += 1;\n            if distance\
    \ < n {\n                i += 1;\n                continue;\n            }\n \
    \           break;\n        }\n        i += 1;\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp60ly88xn.rs:16:24\n   |\n\
    16 |         distances.push(0);\n   |                        ^ expected tuple,\
    \ found integer\n   |\n   = note: expected tuple `({float}, isize)`\n        \
    \       found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp60ly88xn.rs:29:27\n\
    \   |\n29 |             if distance < n {\n   |                           ^ expected\
    \ tuple, found `isize`\n   |\n   = note: expected tuple `({float}, isize)`\n \
    \              found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp60ly88xn.rs:40:27\n\
    \   |\n40 |             if distance < n {\n   |                           ^ expected\
    \ tuple, found `isize`\n   |\n   = note: expected tuple `({float}, isize)`\n \
    \              found type `isize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 1 {\n        // No collisions.\n        return\
    \ 0;\n    }\n\n    if n % 2 == 0 {\n        // The cars are moving in opposite\
    \ directions simultaneously.\n        return car_race_collision(n / 2);\n    }\n\
    \n    let mut collisions: isize = 0;\n    let mut min_speed: isize = n * (n -\
    \ 1) / 2;\n    let mut prev_speed = min_speed / 2;\n    let mut cur_speed = min_speed\
    \ / 2;\n    let mut cur_pos: Vec<isize> = Vec::new();\n    let mut next_pos: Vec<isize>\
    \ = Vec::new();\n\n    for _ in 0..n {\n        // The cars are moving at the\
    \ same speed initially.  Find out how much speed\n        // each car will need\
    \ in order to collide.\n        cur_speed += min_speed;\n\n        // At this\
    \ point, the speed of each car will be in range [min_speed, cur_speed].\n    \
    \    // Find out where it will collide, and push it onto `collisions`.\n     \
    \   let collision = cur_speed + prev_speed + min_speed;\n        if collision\
    \ < min_speed {\n            // Collision will happen at the end of a race and\
    \ we want the cars to have\n            // the same speed at the start of the\
    \ next race.\n            cur_speed -= min_speed;\n        }\n        cur_pos.push(cur_speed);\n\
    \        collisions += 1;\n        if collision == collisions {\n            //\
    \ No collision yet!  So figure out where they will collide next.\n           \
    \ prev_speed = cur_speed;\n            cur_speed = min_speed;\n            min_speed\
    \ -= 1;\n        }\n\n        // Push `next_pos` onto the next time around (which\
    \ is after all previous pushes).\n        // We want the cars to collide at the\
    \ next time around too, in order to\n        // complete the race.\n        next_pos.push(min_speed);\n\
    \    }\n\n    // At this point, the cars will have collided in range [collisions,\
    \ collisions + 1].\n    // We should find out where they will collide next and\
    \ push it onto `collisions`.\n    let collision = cur_speed + prev_speed + min_speed\
    \ + next_pos[0];\n    if collision < collisions + 1 {\n        // Collision will\
    \ happen at the end of a race and we want the cars to have\n        // the same\
    \ speed at the start of the next race.\n        cur_speed -= min_speed;\n    }\n\
    \    cur_pos.push(cur_speed);\n    collisions += 1;\n\n    // At this point, `collisions`\
    \ and `next_pos` should be full of colliding speeds.\n    // Find the final speed\
    \ they will collide at\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6tq45a8b.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The next line is important; it calculates the number\
    \ of collisions required\n    // to race n cars.\n    let mut collisions: isize\
    \ = 1;\n    for i in 1..n {\n        if i % 2 == 0 {\n            // Collisions\
    \ with each other\n            if i != n {\n                collisions += 1;\n\
    \            }\n        } else {\n            // Collisions against themselves\n\
    \            if i == n {\n                collisions += 1;\n            }\n  \
    \      }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0ugwumls.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    use std::cmp::Ordering;\n    let mut car_race_state =\
    \ {\n        let mut x = Vec::new();\n        let mut y = Vec::new();\n      \
    \  for (; n < 4; n += 2) {\n            x.push((n - 1) as f64);\n            y.push(n\
    \ as f64);\n        }\n        (x, y)\n    };\n    for _ in 0..100 {\n       \
    \ let mut x = Vec::new();\n        let mut y = Vec::new();\n        for (; n <\
    \ 4; n += 2) {\n            x.push((n - 1) as f64);\n            y.push(n as f64);\n\
    \        }\n        let mut x_min = x.min();\n        let mut x_max = x.max();\n\
    \        let mut y_min = y.min();\n        let mut y_max = y.max();\n        for\
    \ (xx, yy) in car_race_state {\n            if xx < x_min {\n                x_min\
    \ = xx;\n            }\n            if xx > x_max {\n                x_max = xx;\n\
    \            }\n            if yy < y_min {\n                y_min = yy;\n   \
    \         }\n            if yy > y_max {\n                y_max = yy;\n      \
    \      }\n        }\n        let mut x_offset = x_min as f64;\n        if x_min\
    \ > x_max {\n            x_offset = x_max;\n        }\n        let mut y_offset\
    \ = y_min as f64;\n        if y_min > y_max {\n            y_offset = y_max;\n\
    \        }\n        car_race_state = (x_offset, y_offset);\n    }\n    car_race_state.iter().filter(|&(x,\
    \ y)| {\n        let x_offset = x;\n        let y_offset = y;\n        x_offset\
    \ > 2 * x_min && x_offset < 2 * x_max &&\n            y_offset > 2 * y_min &&\
    \ y_offset < 2 * y_max\n    }).count()\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `;`\n  --> /tmp/tmp0wvcxmpg.rs:14:14\n \
    \  |\n14 |         for (; n < 4; n += 2) {\n   |              ^ expected pattern\n\
    \nerror: expected pattern, found `;`\n  --> /tmp/tmp0wvcxmpg.rs:23:14\n   |\n\
    23 |         for (; n < 4; n += 2) {\n   |              ^ expected pattern\n\n\
    error[E0425]: cannot find value `x_min` in this scope\n  --> /tmp/tmp0wvcxmpg.rs:58:24\n\
    \   |\n58 |         x_offset > 2 * x_min && x_offset < 2 * x_max &&\n   |    \
    \                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `x_max` in this scope\n  --> /tmp/tmp0wvcxmpg.rs:58:48\n   |\n58 |   \
    \      x_offset > 2 * x_min && x_offset < 2 * x_max &&\n   |                 \
    \                               ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `y_min` in this scope\n  --> /tmp/tmp0wvcxmpg.rs:59:28\n \
    \  |\n59 |             y_offset > 2 * y_min && y_offset < 2 * y_max\n   |    \
    \                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `y_max` in this scope\n  --> /tmp/tmp0wvcxmpg.rs:59:52\n   |\n59\
    \ |             y_offset > 2 * y_min && y_offset < 2 * y_max\n   |           \
    \                                         ^^^^^ not found in this scope\n\nwarning:\
    \ unused import: `std::cmp::Ordering`\n  --> /tmp/tmp0wvcxmpg.rs:10:9\n   |\n\
    10 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 2 || n == 0 {\n        return 0;\n    }\n   \
    \ // The function returns a negative value when the second car hits the first\
    \ car.\n    let mut collisions = 1;\n    while n > 0 {\n        // Each car has\
    \ its own unique x,y position.\n        let x = (n - 2) as i32;\n        let y\
    \ = (n - 1) as i32;\n        let mut collision = false;\n        let mut y_value\
    \ = y;\n        while y_value != 0 {\n            if collision {\n           \
    \     return -collisions;\n            }\n            collision = (x + y_value)\
    \ % n == 0;\n            collisions = (collisions + 1) % n\n        }\n      \
    \  n = n - 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphfl3tbus.rs:25:41\n   |\n\
    25 |             collision = (x + y_value) % n == 0;\n   |                   \
    \                      ^ expected `i32`, found `isize`\n\nerror[E0277]: cannot\
    \ mod `i32` by `isize`\n  --> /tmp/tmphfl3tbus.rs:25:39\n   |\n25 |          \
    \   collision = (x + y_value) % n == 0;\n   |                                \
    \       ^ no implementation for `i32 % isize`\n   |\n   = help: the trait `Rem<isize>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    // This map associates the\
    \ speed of the car with a vector of cars at\n    // that speed\n    let speeds\
    \ = Vec::new();\n    // The starting positions of the cars are the center of each\
    \ circle\n    let start_pos = Vec::new();\n    // A map associating the speed\
    \ of each car with a vector of cars at that speed\n    let speeds_vec = Vec::new();\n\
    \    let mut speed = 1.0;\n    for _ in 0..n {\n        // The starting positions\
    \ of each car are the same\n        start_pos.push((0.0, 0.0));\n        // The\
    \ speed is the same\n        speeds.push(speed);\n        speeds_vec.push(speeds);\n\
    \        speed += 1.0;\n    }\n\n    let mut current_speed = speeds_vec[0];\n\
    \    for car in start_pos.iter_mut() {\n        car[1] += current_speed;\n   \
    \     if car[1] >= 1.0 {\n            car[1] -= 1.0;\n            current_speed\
    \ = speeds_vec[1];\n        }\n    }\n\n    for car in start_pos.iter_mut() {\n\
    \        if car[0] < -n || car[0] > n {\n            collisions += 1;\n      \
    \  }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpw2y4m5gq.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n...\n13 |     let speeds = Vec::new();\n   |     --- unexpected\
    \ token\n\nerror[E0608]: cannot index into a value of type `&mut ({float}, {float})`\n\
    \  --> /tmp/tmpw2y4m5gq.rs:30:9\n   |\n30 |         car[1] += current_speed;\n\
    \   |         ^^^^^^\n\nerror[E0608]: cannot index into a value of type `&mut\
    \ ({float}, {float})`\n  --> /tmp/tmpw2y4m5gq.rs:31:12\n   |\n31 |         if\
    \ car[1] >= 1.0 {\n   |            ^^^^^^\n\nerror[E0608]: cannot index into a\
    \ value of type `&mut ({float}, {float})`\n  --> /tmp/tmpw2y4m5gq.rs:32:13\n \
    \  |\n32 |             car[1] -= 1.0;\n   |             ^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `&mut ({float}, {float})`\n  --> /tmp/tmpw2y4m5gq.rs:38:12\n\
    \   |\n38 |         if car[0] < -n || car[0] > n {\n   |            ^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `&mut ({float}, {float})`\n  -->\
    \ /tmp/tmpw2y4m5gq.rs:38:27\n   |\n38 |         if car[0] < -n || car[0] > n {\n\
    \   |                           ^^^^^^\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for car1 in 0..n {\n    \
    \    for car2 in (car1 + 1) % n {\n            let distance = (car1 - car2) *\
    \ 1.0;\n            if distance <= 0.0 {\n                continue;\n        \
    \    }\n            let distance2 = distance * distance;\n            let speed\
    \ = (1.0 + distance2) * 3.0;\n            if speed > 10.0 {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpj9femu6a.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for car1 in 0..n {\n   |     --- unexpected token\n\n\
    error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpj9femu6a.rs:12:21\n  \
    \ |\n12 |         for car2 in (car1 + 1) % n {\n   |                     ^^^^^^^^^^^^^^\
    \ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut cnt\
    \ = 0;\n    let mut j = 0;\n    while j < n {\n        let j0 = j;\n        j\
    \ = j + 1;\n        while j > j0 + 1 {\n            let a = n - j;\n         \
    \   let b = j + n - 1;\n            let mut collision = false;\n            let\
    \ mut jj = j;\n            while jj < b {\n                if collision {\n  \
    \                  break;\n                }\n                collision = car_race_collision(b\
    \ - jj);\n                jj = jj + 1;\n            }\n            if collision\
    \ {\n                cnt = cnt + 1;\n            }\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2mq27k54.rs:27:29\n   |\n\
    21 |             let mut collision = false;\n   |                            \
    \     ----- expected due to this value\n...\n27 |                 collision =\
    \ car_race_collision(b - jj);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision = 0;\n    let mut collide = |x: isize|\
    \ -> bool { collision += x; true; }\n    if n >= 2 {\n        for xi in 0..n {\n\
    \            let y = collide(xi / n);\n            for xj in xi..n+1 {\n     \
    \           if y == collide(xj / n) {\n                    collision += 1;\n \
    \               }\n            }\n        }\n    }\n    collision\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpwroci5kq.rs:11:67\n\
    \   |\n11 |     let mut collide = |x: isize| -> bool { collision += x; true; }\n\
    \   |                                                                   ^ help:\
    \ add `;` here\n12 |     if n >= 2 {\n   |     -- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwroci5kq.rs:11:42\n   |\n11 |     let mut collide\
    \ = |x: isize| -> bool { collision += x; true; }\n   |                       \
    \                   ^^^^^^^^^^^^^^^^^^^^^^-^^\n   |                          \
    \                |                     |\n   |                               \
    \           |                     help: remove this semicolon\n   |          \
    \                                expected `bool`, found `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut current_x =\
    \ 0;\n    let mut current_y = 0;\n    let mut next_x = 0;\n    let mut next_y\
    \ = 0;\n    let mut speed = 1;\n    let mut prev_x;\n    let mut prev_y;\n   \
    \ let mut current_speed = 1;\n    let mut next_speed;\n    let mut collision_speed\
    \ = 1.0;\n    let mut speed = speed;\n    for _ in 0..n {\n        next_x = current_x;\n\
    \        next_y = current_y;\n        prev_x = current_x;\n        prev_y = current_y;\n\
    \        current_x = next_x;\n        current_y = next_y;\n        speed = collision_speed;\n\
    \        next_speed = collision_speed;\n        prev_x = current_x;\n        prev_y\
    \ = current_y;\n        collision_count = collision_count + 1;\n        current_speed\
    \ += collision_speed;\n        next_speed += collision_speed;\n        for _ in\
    \ 0..n {\n            let x = current_x + speed * current_speed;\n           \
    \ let y = current_y + speed * current_speed;\n            if x < 0 {\n       \
    \         current_speed *= -1;\n                current_x = prev_x;\n        \
    \        current_y = prev_y;\n            } else {\n                current_speed\
    \ *= -1;\n                current_x = x;\n                current_y = y;\n   \
    \         }\n        }\n    }\n    collision_count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ytf9ab5.rs:29:17\n   |\n\
    21 |     let mut speed = speed;\n   |                     ----- expected due to\
    \ this value\n...\n29 |         speed = collision_speed;\n   |               \
    \  ^^^^^^^^^^^^^^^ expected integer, found floating-point number\n\nerror[E0277]:\
    \ cannot add-assign `{float}` to `{integer}`\n  --> /tmp/tmp4ytf9ab5.rs:34:23\n\
    \   |\n34 |         current_speed += collision_speed;\n   |                  \
    \     ^^ no implementation for `{integer} += {float}`\n   |\n   = help: the trait\
    \ `AddAssign<{float}>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // number of collisions\n   \
    \ let mut first_collision = false;  // flag indicating whether a collision has\
    \ occurred\n\n    // The distance between two points in the CarRace graph is equal\
    \ to the length of\n    // the line segment connecting the two points.\n    let\
    \ mut length: isize = n;\n\n    // The initial speeds are chosen randomly.\n \
    \   let mut speed_left: f32 = 2.0 * rand::random::<f32>() / RAND_MAX;\n    let\
    \ mut speed_right: f32 = 2.0 * rand::random::<f32>() / RAND_MAX;\n\n    // While\
    \ the cars are not colliding, keep updating their positions.\n    // This loop\
    \ terminates if a collision occurs.\n    // The two speed differences keep decreasing\
    \ until they become negative or 0.\n    loop {\n        // Compute the car's new\
    \ positions.\n        let new_left_x = speed_left * length / n; // x component\
    \ of new position\n        let new_left_y = speed_left * length / n; // y component\
    \ of new position\n\n        let new_right_x = speed_right * length / n; // x\
    \ component of new position\n        let new_right_y = speed_right * length /\
    \ n; // y component of new position\n\n        // Check for collisions.\n    \
    \    if ((new_left_x + new_right_x) <= 0.0) {\n            // The cars are colliding.\n\
    \            collisions += 1;\n            first_collision = true;\n        }\n\
    \        if ((new_left_y + new_right_y) <= 0.0) {\n            // The cars are\
    \ colliding.\n            collisions += 1;\n            first_collision = true;\n\
    \        }\n\n        // Update speed.\n        if first_collision {\n       \
    \     speed_right -= 1.0 * collisions / n; // update speed with collision rate\n\
    \            speed_left -= 1.0 * collisions / n; // update speed with collision\
    \ rate\n        } else {\n            speed_right -= collisions / n; // update\
    \ speed without collision rate\n            speed_left -= collisions / n; // update\
    \ speed without collision rate\n        }\n\n        // Update length.\n     \
    \   length -= 1.0 * collisions / n; // update length without collision rate\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp6drbur59.rs:18:37\n   |\n18 |     let mut speed_left: f32 = 2.0\
    \ * rand::random::<f32>() / RAND_MAX;\n   |                                  \
    \   ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `rand`\n  --> /tmp/tmp6drbur59.rs:19:38\n\
    \   |\n19 |     let mut speed_right: f32 = 2.0 * rand::random::<f32>() / RAND_MAX;\n\
    \   |                                      ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0425]: cannot find value `RAND_MAX` in this scope\n  --> /tmp/tmp6drbur59.rs:18:61\n\
    \   |\n18 |     let mut speed_left: f32 = 2.0 * rand::random::<f32>() / RAND_MAX;\n\
    \   |                                                             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `RAND_MAX` in this scope\n\
    \  --> /tmp/tmp6drbur59.rs:19:62\n   |\n19 |     let mut speed_right: f32 = 2.0\
    \ * rand::random::<f32>() / RAND_MAX;\n   |                                  \
    \                            ^^^^^^^^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmp6drbur59.rs:33:12\n   |\n33\
    \ |         if ((new_left_x + new_right_x) <= 0.0) {\n   |            ^      \
    \                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by\
    \ default\nhelp: remove these parentheses\n   |\n33 -         if ((new_left_x\
    \ + new_right_x) <= 0.0) {\n33 +         if (new_left_x + new_right_x) <= 0.0\
    \ {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6drbur59.rs:38:12\n\
    \   |\n38 |         if ((new_left_y + new_right_y) <= 0.0) {\n   |           \
    \ ^                                 ^\n   |\nhelp: remove these parentheses\n\
    \   |\n38 -         if ((new_left_y + new_right_y) <= 0.0) {\n38 +         if\
    \ (new_left_y + new_right_y) <= 0.0 {\n   | \n\nerror[E0277]: cannot multiply\
    \ `f32` by `isize`\n  --> /tmp/tmp6drbur59.rs:26:37\n   |\n26 |         let new_left_x\
    \ = speed_left * length / n; // x component of new position\n   |            \
    \                    "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n\n    for i in 0..n {\n        let\
    \ mut j = 0;\n        for j in 0..n {\n            if i == j && !(i == 0 || i\
    \ == n || j == 0 || j == n) {\n                continue;\n            }\n\n  \
    \          if i < (n / 2) && (j > n / 2) && !(j == 0 || j == n) {\n          \
    \      continue;\n            }\n\n            let speed = (i * (n + 1) + j *\
    \ (n - i)) / 2.0;\n            if !(0.0 <= speed && speed <= 10.0) {\n       \
    \         continue;\n            }\n\n            let mut collide = false;\n \
    \           if i < n && j < n {\n                collide = car_collision(i, j,\
    \ &mut count);\n            }\n\n            if collide {\n                break;\n\
    \            }\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpsc2qduyi.rs:30:27\n   |\n30 |                 collide = car_collision(i,\
    \ j, &mut count);\n   |                           ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0277]: cannot divide `isize` by `{float}`\n  --> /tmp/tmpsc2qduyi.rs:23:53\n\
    \   |\n23 |             let speed = (i * (n + 1) + j * (n - i)) / 2.0;\n   | \
    \                                                    ^ no implementation for `isize\
    \ / {float}`\n   |\n   = help: the trait `Div<{float}>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return n;\n    }\n    let mut i\
    \ = 1i32;\n    let mut c = 0i32;\n    while i < n {\n        if i % 2 == 0 {\n\
    \            c += car_race_collision(i);\n        }\n        i += 2;\n    }\n\
    \    return c;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqn6i_7zv.rs:15:15\n   |\n\
    15 |     while i < n {\n   |               ^ expected `i32`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n15 |     while i < n.try_into().unwrap() {\n   |  \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqn6i_7zv.rs:17:37\n\
    \   |\n17 |             c += car_race_collision(i);\n   |                    \
    \                 ^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    17 |             c += car_race_collision(i.try_into().unwrap());\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqn6i_7zv.rs:17:18\n   |\n17 |             c += car_race_collision(i);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `isize`\n\n\
    error[E0277]: cannot add-assign `isize` to `i32`\n  --> /tmp/tmpqn6i_7zv.rs:17:15\n\
    \   |\n17 |             c += car_race_collision(i);\n   |               ^^ no\
    \ implementation for `i32 += isize`\n   |\n   = help: the trait `AddAssign<isize>`\
    \ is not implemented for `i32`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqn6i_7zv.rs:21:12\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n21 | \
    \    return c;\n   |            ^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |     return c.try_into().unwrap();\n   |             ++++++++++++++++++++\n\
    \nerror: aborting due to "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collides = 0;\n    let mut speed = 0;\n    let\
    \ mut time = 0;\n\n    for i in 0..n {\n        let mut collision = false;\n\n\
    \        for j in i..n {\n            collision = collision || car_race_collision(j);\n\
    \n            if collision && i != j {\n                speed += 1;\n        \
    \        time += 1;\n                collision = false;\n            }\n     \
    \   }\n\n        if collision {\n            collides += 1;\n        }\n    }\n\
    \n    if speed == 0 && !(n % 2) {\n        collides += 1;\n    }\n\n    collides\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu2qaxk5x.rs:18:38\n   |\n\
    18 |             collision = collision || car_race_collision(j);\n   |       \
    \                               ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu2qaxk5x.rs:32:22\n   |\n32 |\
    \     if speed == 0 && !(n % 2) {\n   |                      ^^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for _ in range(n) {\n  \
    \      let mut first_collision = false;\n        let mut second_collision = false;\n\
    \        let mut first_distance = -1;\n        let mut second_distance = -1;\n\
    \        let mut first_speed = -1;\n        let mut second_speed = -1;\n     \
    \   for car_number in 0..n + 1 {\n            if car_number == 0 {\n         \
    \       continue;\n            }\n            let car_speed = if car_number <\
    \ n {\n                car_number % n\n            } else {\n                0\n\
    \            };\n            if first_collision {\n                if first_speed\
    \ != car_speed {\n                    first_distance -= 1;\n                 \
    \   first_speed -= 1;\n                } else {\n                    first_collision\
    \ = false;\n                }\n            } else {\n                first_collision\
    \ = true;\n                first_distance = car_number;\n                first_speed\
    \ = car_speed;\n            }\n            if second_collision {\n           \
    \     if second_speed != car_speed {\n                    second_distance -= 1;\n\
    \                    second_speed -= 1;\n                } else {\n          \
    \          second_collision = false;\n                }\n            } else {\n\
    \                second_collision = true;\n                second_distance = car_number;\n\
    \                second_speed = car_speed;\n            }\n        }\n       \
    \ if first_distance == second_distance {\n            collisions += 1;\n     \
    \   }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmphzsj0nj6.rs:11:14\n\
    \   |\n11 |     for _ in range(n) {\n   |              ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for _ in 0..n {\n       \
    \ for _ in 0..n {\n            collisions += (n - 1) / 2;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmpu0pirko9.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for _ in 0..n {\n   |     --- unexpected token\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0isize;\n    // For each possible\
    \ starting position, count the number of\n    // collisions ending in this position.\n\
    \    let mut positions = Vec::new();\n    positions.push(vec![0, 0]);\n    for\
    \ pos in (0..n).rev() {\n        let start = positions.last().unwrap();\n    \
    \    let mut new_pos = vec![0, 0];\n        \n        let new_start = start.clone();\n\
    \        for d in (0..).rev() {\n            let new_dir = vec![0, d];\n     \
    \       new_pos += new_dir;\n            new_pos.push(new_dir);\n            collision_count\
    \ += if new_pos == start { 1 } else { 0 };\n        }\n        positions.push(new_pos);\n\
    \    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `RangeFrom<{integer}>: DoubleEndedIterator`\
    \ is not satisfied\n    --> /tmp/tmp10nouvp3.rs:20:24\n     |\n20   |        \
    \ for d in (0..).rev() {\n     |                        ^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `RangeFrom<{integer}>`\n     |\nnote: required by a bound\
    \ in `rev`\n\nerror[E0277]: the trait bound `RangeFrom<{integer}>: DoubleEndedIterator`\
    \ is not satisfied\n  --> /tmp/tmp10nouvp3.rs:20:18\n   |\n20 |         for d\
    \ in (0..).rev() {\n   |                  ^^^^^^^^^^^ the trait `DoubleEndedIterator`\
    \ is not implemented for `RangeFrom<{integer}>`\n   |\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Rev<RangeFrom<{integer}>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Rev<RangeFrom<{integer}>>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<{integer}>`\n  --> /tmp/tmp10nouvp3.rs:22:13\n\
    \   |\n22 |             new_pos += new_dir;\n   |             -------^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp10nouvp3.rs:23:26\n   |\n23 |\
    \             new_pos.push(new_dir);\n   |                          ^^^^^^^ expected\
    \ integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n  \
    \          found struct `Vec<{integer}>`\n\nerror[E0277]: can't compare `Vec<{integer}>`\
    \ with `&Vec<{integer}>`\n  --> /tmp/tmp10nouvp3.rs:24:43\n   |\n24 |        \
    \     collision_count += if new_pos == start { 1 } else { 0 };\n   |         \
    \                                  ^^ no implementation for `Vec<{integer}> ==\
    \ &Vec<{integer}>`\n   |\n   = help: the trait `PartialEq<&Vec<{integer}>>` is\
    \ not implemented for `Vec<{integer}>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    let mut distance = (1\
    \ / (2.0 * M_PI) * 2.0).sqrt() as isize;\n\n    while distance > 0.0 {\n     \
    \   let a = ((n * M_PI) / distance).f64;\n        let b = ((n * M_PI) / distance).f64;\n\
    \n        let left = 2.0 * M_PI * a - (1.0 * M_PI * b);\n        let right = 2.0\
    \ * M_PI * a + (1.0 * M_PI * b);\n\n        let left = left.ceil() as isize;\n\
    \        let right = right.ceil() as isize;\n\n        if left >= -n && left <=\
    \ n && right >= -n && right <= n {\n            num_collisions += 1;\n       \
    \ }\n        distance -= 1.0;\n    }\n    num_collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `M_PI` in this scope\n  --> /tmp/tmpy_zx89v0.rs:11:36\n\
    \   |\n11 |     let mut distance = (1 / (2.0 * M_PI) * 2.0).sqrt() as isize;\n\
    \   |                                    ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `M_PI` in this scope\n  --> /tmp/tmpy_zx89v0.rs:14:23\n  \
    \ |\n14 |         let a = ((n * M_PI) / distance).f64;\n   |                 \
    \      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `M_PI`\
    \ in this scope\n  --> /tmp/tmpy_zx89v0.rs:15:23\n   |\n15 |         let b = ((n\
    \ * M_PI) / distance).f64;\n   |                       ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `M_PI` in this scope\n  --> /tmp/tmpy_zx89v0.rs:17:26\n\
    \   |\n17 |         let left = 2.0 * M_PI * a - (1.0 * M_PI * b);\n   |      \
    \                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `M_PI` in this scope\n  --> /tmp/tmpy_zx89v0.rs:17:44\n   |\n17 |    \
    \     let left = 2.0 * M_PI * a - (1.0 * M_PI * b);\n   |                    \
    \                        ^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `M_PI` in this scope\n  --> /tmp/tmpy_zx89v0.rs:18:27\n   |\n18 |\
    \         let right = 2.0 * M_PI * a + (1.0 * M_PI * b);\n   |               \
    \            ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `M_PI`\
    \ in this scope\n  --> /tmp/tmpy_zx89v0.rs:18:45\n   |\n18 |         let right\
    \ = 2.0 * M_PI * a + (1.0 * M_PI * b);\n   |                                 \
    \            ^^^^ not found in this scope\n\nerror[E0277]: cannot divide `{integer}`\
    \ by `{float}`\n  --> /tmp/tmpy_zx89v0.rs:11:27\n   |\n11 |     let mut distance\
    \ = (1 / (2.0 * M_PI) * 2.0).sqrt() as isize;\n   |                          \
    \ ^ no implementation for `{integer} / {float}`\n   |\n   = help: the trait `Div<{float}>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut speed = 1.0;\n\
    \    let mut max_speed = 100.0;\n\n    for _ in 0..n {\n        let car_left =\
    \ Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n        let car_right = Speed(car2_x,\
    \ car2_y, car2_vx, car2_vy, car2_a);\n\n        let intersection = line_length(&car_left,\
    \ &car_right);\n        if intersection > max_speed {\n            max_speed =\
    \ intersection;\n        }\n\n        if car_left.speed > car_right.speed {\n\
    \            collisions += 1;\n            speed += car_left.speed - car_right.speed;\n\
    \        } else {\n            collisions += 1;\n            speed += car_right.speed\
    \ - car_left.speed;\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Speed`\
    \ in this scope\n  --> /tmp/tmpfgnc4tgv.rs:15:24\n   |\n15 |         let car_left\
    \ = Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n   |                   \
    \     ^^^^^ help: a local variable with a similar name exists (notice the capitalization):\
    \ `speed`\n\nerror[E0425]: cannot find value `car1_x` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:15:30\n\
    \   |\n15 |         let car_left = Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n\
    \   |                              ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `car1_y` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:15:38\n\
    \   |\n15 |         let car_left = Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n\
    \   |                                      ^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `car1_vx` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:15:46\n\
    \   |\n15 |         let car_left = Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n\
    \   |                                              ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `car1_vy` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:15:55\n\
    \   |\n15 |         let car_left = Speed(car1_x, car1_y, car1_vx, car1_vy, car1_a);\n\
    \   |                                                       ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `car1_a` in this scope\n  -->\
    \ /tmp/tmpfgnc4tgv.rs:15:64\n   |\n15 |         let car_left = Speed(car1_x, car1_y,\
    \ car1_vx, car1_vy, car1_a);\n   |                                           \
    \                     ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function, tuple struct or tuple variant `Speed` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:16:25\n\
    \   |\n16 |         let car_right = Speed(car2_x, car2_y, car2_vx, car2_vy, car2_a);\n\
    \   |                         ^^^^^ help: a local variable with a similar name\
    \ exists (notice the capitalization): `speed`\n\nerror[E0425]: cannot find value\
    \ `car2_x` in this scope\n  --> /tmp/tmpfgnc4tgv.rs:16:31\n   |\n16 |        \
    \ let car_right = Speed(car2_x, c"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut race_direction =\
    \ Random::<i32>::new();\n\n    for i in 1..n {\n        for j in 1..i {\n    \
    \        if race_direction.is_positive() {\n                if race_direction\
    \ == 1 {\n                    collisions += 1;\n                    race_direction\
    \ = 0;\n                } else {\n                    race_direction = 1;\n  \
    \              }\n            } else {\n                if race_direction == 0\
    \ {\n                    collisions += 1;\n                    race_direction\
    \ = 1;\n                } else {\n                    race_direction = 0;\n  \
    \              }\n            }\n        }\n    }\n\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Random`\n  -->\
    \ /tmp/tmprmr92w89.rs:11:30\n   |\n11 |     let mut race_direction = Random::<i32>::new();\n\
    \   |                              ^^^^^^ use of undeclared type `Random`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // A straight line from (0,0) to (1,1) will collide with\
    \ itself.\n    assert!(n >= 2);\n    let mut collisions = 0;\n    for _ in 0..n\
    \ {\n        // The line from (x0, y0) to (x1, y1) is a straight line if and only\
    \ if x1=y1.\n        let (x0, y0) = (0.0, 0.0);\n        let (x1, y1) = (1.0,\
    \ 1.0);\n\n        // Pick a point in the straight line at random and check if\
    \ it collides with any\n        // point on the other side of the straight line.\n\
    \        let x = x0 + ((x1 - x0) * rand::random());\n        let y = y0 + ((y1\
    \ - y0) * rand::random());\n        let (x2, y2) = (x, y);\n\n        if x2 <\
    \ x1 {\n            // If x2 < x1, then x2 collides with x1.  Increment the collision\
    \ count.\n            collisions += 1;\n        }\n        if y2 < y1 {\n    \
    \        // If y2 < y1, then y2 collides with y1.  Increment the collision count.\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpzpplt9q3.rs:20:35\n   |\n20 |         let x = x0 + ((x1 - x0) *\
    \ rand::random());\n   |                                   ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `rand`\n  --> /tmp/tmpzpplt9q3.rs:21:35\n   |\n21 |        \
    \ let y = y0 + ((y1 - y0) * rand::random());\n   |                           \
    \        ^^^^ use of undeclared crate or module `rand`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    let mut speed_left = n.wrapping_mul(10);\n\
    \    let mut speed_right = n.wrapping_mul(10);\n    for (i, _) in speed_left.pairs()\
    \ {\n        for (_, j) in speed_right.pairs() {\n            if (speed_left -\
    \ j).abs() <= 1 && speed_right + i <= n\n                && (speed_left - j).abs()\
    \ > speed_right + i\n            {\n                collisions += 1;\n       \
    \     }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pairs` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_ibf65kg.rs:13:30\n   |\n13 |     for (i, _) in speed_left.pairs()\
    \ {\n   |                              ^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `pairs` found for type `isize` in the current scope\n  --> /tmp/tmp_ibf65kg.rs:14:35\n\
    \   |\n14 |         for (_, j) in speed_right.pairs() {\n   |                \
    \                   ^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       for _ in 0..n {\n            collision_count += 1;\n        }\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < n {\n        i += 1;\n        let k = i + 1;\n        while j <\
    \ n {\n            j += 1;\n            if j == i {\n                continue;\n\
    \            }\n            if j > i && car_collision(i) ^ car_collision(j) {\n\
    \                c += 1;\n            }\n        }\n    }\n    c\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpzy58jqvu.rs:21:25\n   |\n21 |             if j > i && car_collision(i)\
    \ ^ car_collision(j) {\n   |                         ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `car_collision` in this scope\n\
    \  --> /tmp/tmpzy58jqvu.rs:21:44\n   |\n21 |             if j > i && car_collision(i)\
    \ ^ car_collision(j) {\n   |                                            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The first thing we need is a map of \"previous position\
    \ to new position\" for\n    // each car.  We'll use a list of tuple pairs for\
    \ this.\n    let mut prev_to_new: Vec<(Vec<Vec<i32>>, Vec<Vec<i32>>)> = Vec::new();\n\
    \    let mut car_map: Vec<i32> = Vec::new();\n    let mut car_map_inv = Vec::new();\n\
    \    for i in 0..n {\n        prev_to_new.push((Vec::new(), Vec::new()));\n  \
    \      car_map.push(0);\n        car_map_inv.push(0);\n    }\n    \n    // The\
    \ second thing we need is a map of \"position to collide\" for each car.\n   \
    \ // We'll use a list of tuple pairs for this.\n    let mut position_to_collide:\
    \ Vec<(Vec<i32>, Vec<i32>)> = Vec::new();\n    let mut position_to_collide_inv:\
    \ Vec<(i32, i32)> = Vec::new();\n    for i in 0..n {\n        position_to_collide.push((Vec::new(),\
    \ Vec::new()));\n        position_to_collide_inv.push((i, 0));\n    }\n    \n\
    \    // Now we'll need another two maps to track which cars collide with which\n\
    \    // cars.\n    let mut collide_to_other_car: Vec<Vec<i32>> = Vec::new();\n\
    \    let mut collide_to_other_car_inv: Vec<(i32, i32)> = Vec::new();\n    let\
    \ mut collide_to_self_car: Vec<Vec<i32>> = Vec::new();\n    let mut collide_to_self_car_inv:\
    \ Vec<(i32, i32)> = Vec::new();\n    \n    // And now the actual logic of the\
    \ race collisions.\n    for i in 0..n {\n        let mut collisions = false;\n\
    \        for j in 0..n {\n            let mut prev_new_pos = prev_to_new[j].0;\n\
    \            let mut new_pos = prev_to_new[j].1;\n            \n            //\
    \ First we check that the cars are in different directions.\n            if prev_new_pos[i]\
    \ != new_pos[i] {\n                collisions = true;\n                break;\n\
    \            }\n            \n            // Next we check that the cars are in\
    \ different positions.\n            if prev_new_pos[i] != (Vec::new(), Vec::new())\
    \ {\n                // The cars are in the same position.  Now, we need to see\
    \ if there\n                // is another collision.\n                \n     \
    \           // The \"position to collide\" map stores a pair of positions and\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8gaqydfe.rs:65:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n38 |     for i in 0..n {\n\
    \   |                   - unclosed delimiter\n39 |         let mut collisions\
    \ = false;\n40 |         for j in 0..n {\n   |                       - unclosed\
    \ delimiter\n...\n51 |             if prev_new_pos[i] != (Vec::new(), Vec::new())\
    \ {\n   |                                                            - this delimiter\
    \ might not be properly closed...\n...\n56 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n65 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8gaqydfe.rs:27:39\n   |\n27 |         position_to_collide_inv.push((i,\
    \ 0));\n   |                                       ^ expected `i32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         position_to_collide_inv.push((i.try_into().unwrap(),\
    \ 0));\n   |                                        ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[(Vec<Vec<i32>>, Vec<Vec<i32>>)]` cannot be indexed by `isize`\n \
    \ --> /tmp/tmp8gaqydfe.rs:41:36\n   |\n41 |             let mut prev_new_pos =\
    \ prev_to_new[j].0;\n   |                                    ^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[(Vec<Vec<i32>>, Vec<Vec<i32>>)]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<(Vec<Vec<i32>>,\
    \ Vec<Vec<i32>>)>`\n\nerror[E0277]: the type `[(Vec<Vec<i32>>, Vec<Vec<i32>>)]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp8gaqydfe.rs:42:31\n   |\n42 |  \
    \           let mut new_pos = prev_to_new[j].1;\n   |                        \
    \       ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[(Vec<Vec<i32>>, Vec<Vec<i32>>)]>` is\
    \ not imple"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0; // number of collisions\n   \
    \ for (i, left_car) in left_cars.iter_mut().enumerate() {\n        // find another\
    \ car to drive right to left\n        for (j, right_car) in right_cars.iter_mut().enumerate()\
    \ {\n            if i != j {\n                // if two cars don't collide, add\
    \ one collision\n                if car_race_collision(n - 1)\n              \
    \      != 0 // don't add one collision if it's a dead end\n                  \
    \  && left_car.x == right_car.x && left_car.y == right_car.y\n               \
    \ {\n                    collisions += 1;\n                }\n               \
    \ // otherwise, break out of loop\n                break\n            }\n    \
    \    }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left_cars` in this scope\n  --> /tmp/tmpk692mzwj.rs:11:26\n\
    \   |\n11 |     for (i, left_car) in left_cars.iter_mut().enumerate() {\n   |\
    \                          ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right_cars` in this scope\n  --> /tmp/tmpk692mzwj.rs:13:31\n\
    \   |\n13 |         for (j, right_car) in right_cars.iter_mut().enumerate() {\n\
    \   |                               ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for a in 0..n {\n \
    \       for b in 0..n {\n            let a_b = a + b as *const usize;\n      \
    \      let a_a = a - 1;\n            let b_b = b + 1;\n            let b_a = b\
    \ - 1;\n\n            // Check for two collisions between the same pair of cars.\n\
    \            if a_b == a_a && b_b == b_a {\n                collision_count +=\
    \ 1;\n            }\n\n            // Check for two collisions between different\
    \ pair of cars.\n            if a_b == b_b && b_b == a_a {\n                collision_count\
    \ += 1;\n            }\n\n            // Check for two collisions between a different\
    \ pair of cars.\n            if a_b != b_a && a_b != a_b && b_b != b_a && b_b\
    \ != b_b {\n                collision_count += 1;\n            }\n        }\n\
    \    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `*const usize` to `isize`\n  --> /tmp/tmpptk04gu6.rs:13:25\n\
    \   |\n13 |             let a_b = a + b as *const usize;\n   |               \
    \          ^ no implementation for `isize + *const usize`\n   |\n   = help: the\
    \ trait `Add<*const usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    for _ in 0..n {\n        for\
    \ _ in 0..n {\n            total += 1;\n        }\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut first_collision\
    \ = vec![];\n\n    for first_car in (0..n / 2).rev() {\n        for second_car\
    \ in (0..n / 2).rev() {\n            if first_car == second_car {\n          \
    \      continue;\n            }\n\n            let is_colliding = collision_is_colliding(first_car,\
    \ second_car);\n\n            if is_colliding {\n                collision_count\
    \ += 1;\n                first_collision.push(first_car);\n            }\n   \
    \     }\n    }\n\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `collision_is_colliding` in this scope\n\
    \  --> /tmp/tmpazpb4eiu.rs:19:32\n   |\n19 |             let is_colliding = collision_is_colliding(first_car,\
    \ second_car);\n   |                                ^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_pos = [0; 2 * n];\n    let mut car_speed\
    \ = [0; 2 * n];\n\n    // initialize all cars moving to the right\n    for (i,\
    \ &pos) in car_pos.iter_mut().zip(&car_speed) {\n        *pos = -i;\n    }\n\n\
    \    let mut collisions = 0;\n    while car_pos.len() > 0 {\n        let collision_speed\
    \ = if car_pos[0] < 0 {\n            -car_speed[0]\n        } else {\n       \
    \     car_speed[0]\n        };\n\n        // for each car at the front of our\
    \ car_pos list,\n        // move it upward a little bit\n        let mut car_pos_new\
    \ = [0; 2 * n];\n        for i in 0..n {\n            car_pos_new[2 * i] += collision_speed;\n\
    \        }\n\n        // for each car at the back of our car_pos list,\n     \
    \   // move it downward a little bit\n        let mut car_pos_new1 = [0; 2 * n];\n\
    \        for i in 0..n {\n            car_pos_new1[2 * i + 1] += collision_speed;\n\
    \        }\n\n        // compare the new car positions to the original to find\
    \ out where\n        // they collided\n        let collisions = if car_pos_new\
    \ == car_pos {\n            car_pos.len()\n        } else {\n            car_pos\
    \ - car_pos_new\n        };\n\n        // put back the new positions of both cars\n\
    \        car_pos = car_pos_new1;\n\n        // move the cars back to their original\
    \ position\n        for (i, &pos) in car_pos.iter_mut().zip(&car_speed) {\n  \
    \          *pos = *pos + collision_speed * i;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp8cl0gmts.rs:10:31\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n10 |     let\
    \ mut car_pos = [0; 2 * n];\n   |                               ^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmp8cl0gmts.rs:11:33\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - this would need to be a `const`\n10 |     let mut car_pos = [0; 2 * n];\n\
    11 |     let mut car_speed = [0; 2 * n];\n   |                               \
    \  ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp8cl0gmts.rs:28:39\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n...\n28 | \
    \        let mut car_pos_new = [0; 2 * n];\n   |                             \
    \          ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n\
    \  --> /tmp/tmp8cl0gmts.rs:35:40\n   |\n9  | fn car_race_collision(n: isize) ->\
    \ isize {\n   |                       - this would need to be a `const`\n...\n\
    35 |         let mut car_pos_new1 = [0; 2 * n];\n   |                        \
    \                ^\n\nerror[E0600]: cannot apply unary operator `-` to type `&mut\
    \ {integer}`\n  --> /tmp/tmp8cl0gmts.rs:15:16\n   |\n15 |         *pos = -i;\n\
    \   |                ^^ cannot apply unary operator `-`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0435, E0600.\n\
    For more information about an error, try `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for _ in 0..n {\n      \
    \  if contains_collision(&mut collisions) {\n            collisions += 1;\n  \
    \      }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `contains_collision` in this scope\n\
    \  --> /tmp/tmp711kfsgg.rs:12:12\n   |\n12 |         if contains_collision(&mut\
    \ collisions) {\n   |            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut max_speed =\
    \ n;\n    let mut min_speed = n;\n    let mut speed = n;\n\n    let mut speeds\
    \ = Vec::new();\n\n    // Keep track of whether we have seen at least one collision\
    \ before now.\n    let mut seen_collision = false;\n\n    // Keep track of cars\
    \ that are moving in one direction.\n    let mut left_to_right = Vec::new();\n\
    \    let mut right_to_left = Vec::new();\n\n    // Keep track of cars that have\
    \ been travelling in the opposite direction.\n    let mut left_to_left_travelled\
    \ = Vec::new();\n    let mut right_to_right_travelled = Vec::new();\n\n    //\
    \ Keep track of cars that are moving in the opposite direction.\n    let mut left_to_right_travelled\
    \ = Vec::new();\n    let mut right_to_left_travelled = Vec::new();\n\n    // Keep\
    \ track of cars that are moving right to left and moving left to right.\n    let\
    \ mut left_to_left_and_right_to_left = Vec::new();\n    let mut right_to_left_and_left_to_right\
    \ = Vec::new();\n\n    // Keep track of cars that are colliding with each other.\n\
    \    let mut collision_left_to_right = Vec::new();\n    let mut collision_right_to_left\
    \ = Vec::new();\n\n    // Keep track of cars that are colliding with each other.\n\
    \    let mut collision_left_to_left_and_right_to_left = Vec::new();\n    let mut\
    \ collision_right_to_left_and_left_to_right = Vec::new();\n\n    // Keep track\
    \ of cars that are colliding with each other.\n    let mut collision_left_to_right_and_left_to_left\
    \ = Vec::new();\n    let mut collision_right_to_left_and_right_to_right = Vec::new();\n\
    \n    // Keep track of cars that are colliding with each other.\n    let mut collision_left_to_right_and_left_to_left_and_right_to_right\
    \ = Vec::new();\n    let mut collision_right_to_left_and_right_to_left_and_left_to_right\
    \ = Vec::new();\n\n    // Keep track of cars that are colliding with each other.\n\
    \    let mut collision_left_to_right_and_left_to_left_and_right_to_left_and_right_to_right\
    \ = Vec::new();\n    let mut collision_right_to_left_and_right_to_left_and_left_to_right_and_left_to_right\
    \ = Vec::new();\n\n    // Keep track of cars that are colliding with each other.\n\
    \    let mut collision_left_to_right_and_left_to_left_and_right_to_left_and_right_to_left_and_right_to_right\
    \ = Vec::new();\n    let mut collision_right_to_left_and_right_\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9v7wvibt.rs:58:47\n   |\n\
    58 |     let mut collision_right_to_left_and_right_\n   |                    \
    \                           ^ help: add `;` here\n59 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp9v7wvibt.rs:9:36\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Each car moves at a constant speed of 100m/s, and\
    \ each car collides with itself\n    // only once if n < 2.  So there are 2**n\
    \ possible car-collisions, each of which has exactly n colliding pairs.\n    //\
    \ Therefore, the total possible collisions is (2**n) / (n - 1).  We know that\
    \ n <= 32\n    // and so 2**32 <= 2**(n - 1).  Therefore, 2**32 <= n * (n - 1)\
    \ / 2\n    let mut collision_count = isize::from(1);\n    for _ in 0..n {\n  \
    \      collision_count = collision_count + isize::from(2);\n    }\n    collision_count\
    \ = collision_count * (n - 1) / 2;\n    collision_count\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: From<i32>` is not satisfied\n  -->\
    \ /tmp/tmpezwbzgsx.rs:14:31\n   |\n14 |     let mut collision_count = isize::from(1);\n\
    \   |                               ^^^^^^^^^^^ the trait `From<i32>` is not implemented\
    \ for `isize`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <f32 as From<i16>>\n             <f32 as From<i8>>\n           \
    \  <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n\
    \             <f64 as From<i16>>\n             <f64 as From<i32>>\n          \
    \   <f64 as From<i8>>\n           and 67 others\n\nerror[E0277]: the trait bound\
    \ `isize: From<i32>` is not satisfied\n  --> /tmp/tmpezwbzgsx.rs:16:45\n   |\n\
    16 |         collision_count = collision_count + isize::from(2);\n   |       \
    \                                      ^^^^^^^^^^^ the trait `From<i32>` is not\
    \ implemented for `isize`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n\
    \             <f32 as From<u16>>\n             <f32 as From<u8>>\n           \
    \  <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n\
    \             <f64 as From<i8>>\n           and 67 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for _ in 0..n {\n      \
    \  let mut cars_driving = [0; n];\n        cars_driving[0] = !cars_driving[0];\n\
    \        for a in 0..n {\n            for b in a..n {\n                if cars_driving[a]\
    \ != cars_driving[b] {\n                    collisions += 1;\n               \
    \ }\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpvzw68pra.rs:12:36\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n...\n12 | \
    \        let mut cars_driving = [0; n];\n   |                                \
    \    ^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0u64;\n    let mut car_x = 0.0;\n\
    \    let mut car_y = 0.0;\n    for _ in 0..n {\n        car_x += 0.01;\n     \
    \   car_y += 0.01;\n        for _x in -1..1 {\n            for _y in -1..1 {\n\
    \                if car_x == 0.0 || car_y == 0.0 {\n                    car_x\
    \ = 0.0;\n                    car_y = 0.0;\n                    continue;\n  \
    \              }\n                let xx = car_x + _x;\n                let yy\
    \ = car_y + _y;\n                if xx * xx + yy * yy < 0.25 {\n             \
    \       collisions += 1;\n                }\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add an integer to a float\n  --> /tmp/tmpktwm_4vj.rs:23:32\n\
    \   |\n23 |                 let xx = car_x + _x;\n   |                       \
    \         ^ no implementation for `{float} + {integer}`\n   |\n   = help: the\
    \ trait `Add<{integer}>` is not implemented for `{float}`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ add an integer to a float\n  --> /tmp/tmpktwm_4vj.rs:24:32\n   |\n24 |     \
    \            let yy = car_y + _y;\n   |                                ^ no implementation\
    \ for `{float} + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n\
    \             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n  \
    \           <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n      \
    \       <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n        \
    \   and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpktwm_4vj.rs:31:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n31 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found `u64`\n   |\nhelp:\
    \ you can convert a `u64` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n31 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    let mut speed_left = 100;\n\
    \    let mut speed_right = 100;\n\n    // Initialize collision variables\n   \
    \ let mut collision_left = false; // left car collides with left car\n    let\
    \ mut collision_right = false; // right car collides with right car\n\n    //\
    \ Initialize left and right cars\n    let mut left_car = Car::new();\n    let\
    \ mut right_car = Car::new();\n\n    // Initialize cars moving left to right\n\
    \    let mut left_car_pos = Vec::<isize>::new();\n    let mut right_car_pos =\
    \ Vec::<isize>::new();\n\n    // Initialize collision position (left car, right\
    \ car)\n    let mut left_collision_pos = [0; 2];\n    let mut right_collision_pos\
    \ = [0; 2];\n\n    // Keep track of collisions\n    while collisions < n {\n\n\
    \        // Update speed of left and right cars\n        speed_left -= 1;\n  \
    \      speed_right += 1;\n\n        // Update the position of left and right cars\n\
    \        left_car_pos[left_car.pos] += 1;\n        right_car_pos[right_car.pos]\
    \ -= 1;\n\n        // Check for collision\n        if left_car_pos[left_car.pos]\
    \ > left_car.radius {\n            collision_left = true;\n            left_car_pos[left_car.pos]\
    \ -= 1;\n            left_collision_pos[0] += 1;\n        } else {\n         \
    \   left_collision_pos[0] += 1;\n        }\n\n        if right_car_pos[right_car.pos]\
    \ < right_car.radius {\n            collision_right = true;\n            right_car_pos[right_car.pos]\
    \ += 1;\n            right_collision_pos[1] += 1;\n        } else {\n        \
    \    right_collision_pos[1] += 1;\n        }\n\n        // Update left and right\
    \ cars\n        left_car.move(&speed_left);\n        right_car.move(&speed_right);\n\
    \n        // Check for collision\n        if collision_left && collision_right\
    \ {\n            collisions += 1;\n        }\n    }\n\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `move`\n  --> /tmp/tmpcg52qd4o.rs:60:18\n\
    \   |\n60 |         left_car.move(&speed_left);\n   |                  ^^^^ expected\
    \ identifier, found keyword\n   |\nhelp: escape `move` to use it as an identifier\n\
    \   |\n60 |         left_car.r#move(&speed_left);\n   |                  ++\n\n\
    error: expected identifier, found keyword `move`\n  --> /tmp/tmpcg52qd4o.rs:61:19\n\
    \   |\n61 |         right_car.move(&speed_right);\n   |                   ^^^^\
    \ expected identifier, found keyword\n   |\nhelp: escape `move` to use it as an\
    \ identifier\n   |\n61 |         right_car.r#move(&speed_right);\n   |       \
    \            ++\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n\
    \  --> /tmp/tmpcg52qd4o.rs:20:24\n   |\n20 |     let mut left_car = Car::new();\n\
    \   |                        ^^^ use of undeclared type `Car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpcg52qd4o.rs:21:25\n\
    \   |\n21 |     let mut right_car = Car::new();\n   |                        \
    \ ^^^ use of undeclared type `Car`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut sum = 0;\n    let mut speed: isize = 100;\n \
    \   for _ in 0..n {\n        let mut direction = rand::random::<i32>() % 360;\n\
    \        let mut speed2 = speed;\n        while speed2 > 50 {\n            direction\
    \ = rand::random::<i32>() % 360;\n            speed2 = speed;\n        }\n   \
    \     sum += std::cmp::min(\n            &direction - 90,\n            &direction\
    \ + 90,\n        );\n        speed += speed2;\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpda22zeea.rs:13:29\n   |\n13 |         let mut direction = rand::random::<i32>()\
    \ % 360;\n   |                             ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `rand`\n  --> /tmp/tmpda22zeea.rs:16:25\n   |\n16 |             direction =\
    \ rand::random::<i32>() % 360;\n   |                         ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).map(|i| {\n        let mut collisions = 0; //\
    \ the total number of collisions so far\n        loop {\n            let mut speed\
    \ = 20.0; // current speed\n            loop {\n                speed += 1.0;\
    \ // add a new speed increment\n                if speed > 100.0 {\n         \
    \           break;\n                }\n                if collisions(&mut collisions,\
    \ i, speed) {\n                    break;\n                }\n            }\n\
    \        }\n        collisions\n    }).max()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `{integer}`\n  --> /tmp/tmpqjyxdyo2.rs:19:20\n\
    \   |\n11 |         let mut collisions = 0; // the total number of collisions\
    \ so far\n   |             -------------- `collisions` has type `{integer}`\n\
    ...\n19 |                 if collisions(&mut collisions, i, speed) {\n   |   \
    \                 ^^^^^^^^^^---------------------------\n   |                \
    \    |\n   |                    call expression requires function\n\nwarning:\
    \ unreachable expression\n  --> /tmp/tmpqjyxdyo2.rs:24:9\n   |\n12 | /       \
    \  loop {\n13 | |             let mut speed = 20.0; // current speed\n14 | | \
    \            loop {\n15 | |                 speed += 1.0; // add a new speed increment\n\
    ...  |\n22 | |             }\n23 | |         }\n   | |_________- any code following\
    \ this expression is unreachable\n24 |           collisions\n   |           ^^^^^^^^^^\
    \ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqjyxdyo2.rs:10:5\n   |\n9  | \
    \  fn car_race_collision(n: isize) -> isize {\n   |                          \
    \            ----- expected `isize` because of return type\n10 | /     (0..n).map(|i|\
    \ {\n11 | |         let mut collisions = 0; // the total number of collisions\
    \ so far\n12 | |         loop {\n13 | |             let mut speed = 20.0; // current\
    \ speed\n...  |\n24 | |         collisions\n25 | |     }).max()\n   | |____________^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<{integer}>`\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0618.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in 0..n {\n\
    \        let mut j = n - i - 1;\n        for j in 0..n {\n            if i !=\
    \ j && &i_car_locations(i, n)[..] == &j_car_locations(j, n) {\n              \
    \  collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `i_car_locations` in this scope\n  -->\
    \ /tmp/tmp1i7j3oc3.rs:14:27\n   |\n14 |             if i != j && &i_car_locations(i,\
    \ n)[..] == &j_car_locations(j, n) {\n   |                           ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `j_car_locations`\
    \ in this scope\n  --> /tmp/tmp1i7j3oc3.rs:14:57\n   |\n14 |             if i\
    \ != j && &i_car_locations(i, n)[..] == &j_car_locations(j, n) {\n   |       \
    \                                                  ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total_collisions: isize = 0;\n\n    for _ in\
    \ 0..n {\n        let x = rand::random::<i32>();\n        let y = rand::random::<i32>();\n\
    \n        assert!(!is_collision_possible(x));\n        assert!(!is_collision_possible(y));\n\
    \n        if x == 3 && y == 0 {\n            total_collisions += 1;\n        }\n\
    \    }\n\n    total_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp_o03di2t.rs:13:17\n   |\n13 |         let x = rand::random::<i32>();\n\
    \   |                 ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmp_o03di2t.rs:14:17\n\
    \   |\n14 |         let y = rand::random::<i32>();\n   |                 ^^^^\
    \ use of undeclared crate or module `rand`\n\nerror[E0425]: cannot find function\
    \ `is_collision_possible` in this scope\n  --> /tmp/tmp_o03di2t.rs:16:18\n   |\n\
    16 |         assert!(!is_collision_possible(x));\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_collision_possible`\
    \ in this scope\n  --> /tmp/tmp_o03di2t.rs:17:18\n   |\n17 |         assert!(!is_collision_possible(y));\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    let mut prev = (n - 2) as\
    \ usize;\n    let mut speed = Vec::<f64>::new();\n\n    // Calculate the speed\
    \ of cars 1 and 2, and put them in a vector\n    speed[0] = (-prev - 2) as f64;\n\
    \    speed[1] = (prev - 2) as f64;\n\n    // Calculate the distance traveled per\
    \ frame\n    let dt = 2 * pi / n;\n\n    // Go through each frame\n    for (frame)\
    \ in (0..n)  {\n        // Calculate the next car\n        let next = (frame +\
    \ 1) as usize;\n        let next_speed = speed[next];\n\n        // Calculate\
    \ the distance traveled by the car\n        let dist_traveled: (next_speed - speed[0]).ln()\
    \ / dt.ln();\n\n        // If the cars collide, increment the collisions\n   \
    \     if dist_traveled < 0.0 {\n            collisions += 1;\n        }\n\n  \
    \      // Calculate the next car's speed\n        speed[next] = next_speed;\n\
    \    }\n\n    // Return the number of collisions\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `-`\n\
    \  --> /tmp/tmp6gvc8hzo.rs:28:40\n   |\n28 |         let dist_traveled: (next_speed\
    \ - speed[0]).ln() / dt.ln();\n   |                                        ^ expected\
    \ one of 7 possible tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The collision system is a very efficient collision\
    \ detection system. Given a set of\n    // n objects, each object has an array\
    \ of n entries.\n    // Each entry represents if there is a car at a given index\
    \ of the array which\n    // collides with another car, and where it collides.\n\
    \    // The colliding cars themselves are unbounded.\n    let mut collisions:\
    \ Vec<(bool, isize)> = vec![(0, n)].into_iter().collect();\n    // For simplicity,\
    \ we'll assume that the cars move in a straight line, where\n    // the cars never\
    \ collide (at first).  We'll also assume that there are no cars\n    // moving\
    \ backwards or upwards while they are travelling. We'll assume that the\n    //\
    \ cars move right to left.\n    \n    let mut cars_traveling_right = [false, false];\n\
    \n    // We need to keep track of where we are in the trajectory.\n    let mut\
    \ trajectory_index = 0;\n\n    // The cars start at one end of the trajectory\
    \ at a time; this gives us the\n    // initial direction to move into.\n    let\
    \ mut cars_traveled_from_left = [true, true];\n\n    for _ in 0..n {\n       \
    \ // The first entry for each object is always the next car to move\n        //\
    \ in, even if it is a different car.\n        let next_car = cars_traveling_right[trajectory_index];\n\
    \n        // If there aren't any cars left to move in, move in a straight line.\n\
    \        if !cars_traveling_right[trajectory_index+1] {\n            collisions.push((next_car,\
    \ trajectory_index));\n            cars_traveling_right[trajectory_index] = true;\n\
    \        } else {\n            // Move to the right of the next car.\n       \
    \     collisions.push((next_car, trajectory_index+1));\n\n            // Move\
    \ to the left of the next car.\n            cars_traveling_right[trajectory_index+1]\
    \ = false;\n        }\n\n        // Increment the trajectory index, wrapping around\
    \ to the beginning of the\n        // trajectory once it reaches the end.\n  \
    \      trajectory_index = (trajectory_index + 1) % n;\n    }\n\n    // The final\
    \ entry in the array represents the last car in the trajectory\n    // to move\
    \ into.\n    let last_car = cars_traveling_right[trajectory_index];\n    collisions.push((last_car,\
    \ trajectory_index));\n    collisions.iter().map(|(collision, index)| (collision,\
    \ index)).collect()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(bool, isize)>` cannot be built from\
    \ an iterator over elements of type `({integer}, isize)`\n    --> /tmp/tmp9nqc_91p.rs:15:71\n\
    \     |\n15   |     let mut collisions: Vec<(bool, isize)> = vec![(0, n)].into_iter().collect();\n\
    \     |                                                                      \
    \ ^^^^^^^ value of type `Vec<(bool, isize)>` cannot be built from `std::iter::Iterator<Item=({integer},\
    \ isize)>`\n     |\n     = help: the trait `FromIterator<({integer}, isize)>`\
    \ is not implemented for `Vec<(bool, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nqc_91p.rs:37:40\n   |\n37 |             collisions.push((next_car,\
    \ trajectory_index));\n   |                                        ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n37 |           \
    \  collisions.push((next_car, trajectory_index.try_into().unwrap()));\n   |  \
    \                                                      ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9nqc_91p.rs:41:40\n   |\n41 |  \
    \           collisions.push((next_car, trajectory_index+1));\n   |           \
    \                             ^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n41 |             collisions.push((next_car, (trajectory_index+1).try_into().unwrap()));\n\
    \   |                                        +                  +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9nqc_91p.rs:49:53\n   |\n49 |\
    \         trajectory_index = (trajectory_index + 1) % n;\n   |               \
    \                                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `usize` by `isize`\n  --> /tmp/tmp9nqc_91p.rs:49:51\n   |\n49 | \
    \        trajectory_index = (trajectory_index + 1) % n;\n   |                \
    \         "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for i in 0..n {\n \
    \       for j in 0..n {\n            if i != j && car_collision(&mut i, &mut j)\
    \ == false {\n                collision_count++;\n            }\n        }\n \
    \   }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp6ao8o3m_.rs:14:32\n\
    \   |\n14 |                 collision_count++;\n   |                         \
    \       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    14 |                 { let tmp = collision_count; collision_count += 1; tmp };\n\
    \   |                 +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    14 -                 collision_count++;\n14 +                 collision_count\
    \ += 1;\n   | \n\nerror[E0425]: cannot find function `car_collision` in this scope\n\
    \  --> /tmp/tmp6ao8o3m_.rs:13:26\n   |\n13 |             if i != j && car_collision(&mut\
    \ i, &mut j) == false {\n   |                          ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).map(|i| {\n        (1..i).map(|j| {\n        \
    \    let mut i = j;\n            loop {\n                if i == 0 {\n       \
    \             break;\n                }\n                let x = i as i32;\n \
    \               let y = i as i32;\n                let x1 = x as i32;\n      \
    \          let y1 = x as i32;\n                let x2 = y as i32;\n          \
    \      let y2 = y as i32;\n                if x2 == x1 {\n                   \
    \ i = y1;\n                    i -= 1;\n                } else if y2 == y1 {\n\
    \                    i = x1;\n                    i -= 1;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  i\n        })\n    }).flatten()\n        .filter(|&x| x.iter().all(|&x| x ==\
    \ x))\n        .count();\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsi73h0ok.rs:24:25\n   |\n\
    12 |             let mut i = j;\n   |                         - expected due to\
    \ this value\n...\n24 |                     i = y1;\n   |                    \
    \     ^^ expected `isize`, found `i32`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsi73h0ok.rs:27:25\n   |\n12 |             let mut i = j;\n   |     \
    \                    - expected due to this value\n...\n27 |                 \
    \    i = x1;\n   |                         ^^ expected `isize`, found `i32`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpsi73h0ok.rs:36:24\n   |\n36 |         .filter(|&x| x.iter().all(|&x|\
    \ x == x))\n   |                        ^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpsi73h0ok.rs:9:36\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncars = n;\n    let mut first_collision = 0;\n\
    \    let mut first_collision_i = -1;\n\n    // The first collision always involves\
    \ exactly one car.\n    if n == 1 {\n        first_collision = 1;\n        first_collision_i\
    \ = 0;\n    }\n\n    // Otherwise, there are n collisions.\n    for (i, ncars)\
    \ in n.iter_mut().zip(vec![n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n\
    \ - 8, n - 9, n - 10]) {\n        let mut second_collision = 0;\n        let mut\
    \ second_collision_i = -1;\n\n        // The second collision always involves\
    \ exactly two cars.\n        if ncars == 2 {\n            second_collision = 1;\n\
    \            second_collision_i = 1;\n        }\n\n        // Otherwise, there\
    \ are ncars collisions.\n        for (j, ncars_2) in ncars.iter_mut().zip(ncars_2.iter_mut())\
    \ {\n            let mut third_collision = 0;\n            let mut third_collision_i\
    \ = -1;\n\n            // The third collision always involves exactly three cars.\n\
    \            if ncars_2 == 3 {\n                third_collision = 1;\n       \
    \         third_collision_i = 1;\n            }\n\n            // Otherwise, there\
    \ are ncars_2 collisions.\n            for (k, ncars_3) in ncars.iter_mut().zip(ncars_3.iter_mut())\
    \ {\n                let mut fourth_collision = 0;\n                let mut fourth_collision_i\
    \ = -1;\n\n                // The fourth collision always involves exactly four\
    \ cars.\n                if ncars_3 == 4 {\n                    fourth_collision\
    \ = 1;\n                    fourth_collision_i = 1;\n                }\n\n   \
    \             // Otherwise, there are ncars_3 collisions.\n                for\
    \ (l, ncars_4) in ncars.iter_mut().zip(ncars_4.iter_mut()) {\n               \
    \     let mut fifth_collision = 0;\n                    let mut fifth_collision_i\
    \ = -1;\n\n                    // The fifth collision always involves exactly\
    \ five cars.\n                    if ncars_4 == 5 {\n                        fifth_collision\
    \ = 1;\n                        fifth_collision_i = 1;\n                    }\n\
    \n                    // Otherwise, there are ncars_4 collisions.\n          \
    \          for (m, ncars_5) in ncars.iter_mut().zip(ncars_5.iter_mut()) {\n  \
    \                      let mut sixth_collision = 0;\n                        let\
    \ mut sixth_collision_i = -1;\n\n                        // The sixth collision\
    \ always involves exactly six cars.\n                        if ncars_5 == 6 {\n\
    \                            sixth_collision = 1;\n                          \
    \  sixth_collision_i = 1;\n                        }\n\n\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdqic_vpq.rs:85:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n21 |     for (i, ncars) in\
    \ n.iter_mut().zip(vec![n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n - 8,\
    \ n - 9, n - 10]) {\n   |                                                    \
    \                                                                 - unclosed delimiter\n\
    ...\n32 |         for (j, ncars_2) in ncars.iter_mut().zip(ncars_2.iter_mut())\
    \ {\n   |                                                                    \
    \  - unclosed delimiter\n...\n43 |             for (k, ncars_3) in ncars.iter_mut().zip(ncars_3.iter_mut())\
    \ {\n   |                                                                    \
    \      - unclosed delimiter\n...\n54 |                 for (l, ncars_4) in ncars.iter_mut().zip(ncars_4.iter_mut())\
    \ {\n   |                                                                    \
    \          - unclosed delimiter\n...\n65 |                     for (m, ncars_5)\
    \ in ncars.iter_mut().zip(ncars_5.iter_mut()) {\n   |                        \
    \                                                          - this delimiter might\
    \ not be properly closed...\n...\n76 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n85 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `ncars_2` in this scope\n  --> /tmp/tmpdqic_vpq.rs:32:50\n   |\n32 | \
    \        for (j, ncars_2) in ncars.iter_mut().zip(ncars_2.iter_mut()) {\n   |\
    \                                                  ^^^^^^^ help: a local variable\
    \ with a similar name exists: `ncars`\n\nerror[E0425]: cannot find value `ncars_3`\
    \ in this scope\n  --> /tmp/tmpdqic_vpq.rs:43:54\n   |\n43 |             for (k,\
    \ ncars_3) in ncars.iter_mut().zip(ncars_3.iter_mut()) {\n   |               \
    \                                       ^^^^^^^ help: a local variable with a\
    \ similar name exists: `ncars_2`\n\nerror[E0425]: cannot find value `ncars_4`\
    \ in this scope\n  --> /tmp/tmpdqic_vpq.rs:54:58\n   |\n54 |                 for "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: usize = 0;\n    let mut i = 1usize;\n\
    \    while i <= n {\n        // Move right to left.\n        if i != n && i %\
    \ 2 == 0 {\n            i += 1;\n        } else {\n            // Move left to\
    \ right.\n            i -= 1;\n        }\n        if i % 2 == 0 {\n          \
    \  collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5zb_hnzv.rs:12:16\n   |\n\
    12 |     while i <= n {\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     while i <= n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5zb_hnzv.rs:14:17\n   |\n14 |         if i != n && i % 2 == 0 {\n  \
    \ |                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    14 |         if i != n.try_into().unwrap() && i % 2 == 0 {\n   |             \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5zb_hnzv.rs:24:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n24 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for _ in 0..n {\n \
    \       for _ in 0..n {\n            collision_count += 1;\n        }\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    1.into() * (n - 1.into()) * (n - 1.into()) * n\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpptwxt65n.rs:10:7\n\
    \   |\n10 |     1.into() * (n - 1.into()) * (n - 1.into()) * n\n   |     --^^^^--\n\
    \   |     | |\n   |     | cannot infer type for type parameter `T` declared on\
    \ the trait `Into`\n   |     this method call resolves to `T`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).fold(0, |x, y| x + y * car_race_collision_coefficient())\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_coefficient` in\
    \ this scope\n  --> /tmp/tmpj23dy9lo.rs:10:35\n   |\n10 |     (0..n).fold(0, |x,\
    \ y| x + y * car_race_collision_coefficient())\n   |                         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ count = 1;\n    let mut collisions = 1;\n\n    let mut left_to_right = true;\n\
    \    while count < n {\n        let mut i = n - count;\n        if left_to_right\
    \ {\n            i -= 1;\n        }\n        let mut collision = i;\n        while\
    \ collision > 0 {\n            collision -= 1;\n            let mut j = count\
    \ + collision;\n            if j < n {\n                j += 1;\n            \
    \    collision += 1;\n            }\n\n            if j < i {\n              \
    \  count += 1;\n                collisions += 1;\n                break;\n   \
    \         }\n        }\n        left_to_right = !left_to_right;\n    }\n\n   \
    \ count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977945
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = 0\n    for j in 1..n {\n        for i in\
    \ 1..n {\n            if j != i && car_collision(&mut i, j) {\n              \
    \  n += 1;\n            }\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmptd7z42uq.rs:10:18\n\
    \   |\n10 |     let mut n = 0\n   |                  ^ help: add `;` here\n11\
    \ |     for j in 1..n {\n   |     --- unexpected token\n\nerror[E0425]: cannot\
    \ find function `car_collision` in this scope\n  --> /tmp/tmptd7z42uq.rs:13:26\n\
    \   |\n13 |             if j != i && car_collision(&mut i, j) {\n   |        \
    \                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n - 1) * (n - 2) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpt3z4vh79.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0\n    }\n    let mut collisions:\
    \ isize = 0;\n    for _ in 0..n {\n        for _ in 0..n {\n            collisions\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_races = n - 1;\n    let mut collisions =\
    \ 0u64;\n\n    let mut c1 = Car::new(0, 0, 0);\n    let mut c2 = Car::new(0, 0,\
    \ 0);\n\n    let mut c1_next = &mut c1;\n    let mut c2_next = &mut c2;\n\n  \
    \  // Driver car 1\n    while c1.is_colliding(c2_next, &mut c1_next) {\n     \
    \   c1.move();\n        c1_next = &mut c1;\n        collisions += 1;\n    }\n\n\
    \    // Driver car 2\n    while c2.is_colliding(c1_next, &mut c2_next) {\n   \
    \     c2.move();\n        c2_next = &mut c2;\n        collisions += 1;\n    }\n\
    \n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `move`\n  --> /tmp/tmp1im6zxjc.rs:21:12\n\
    \   |\n21 |         c1.move();\n   |            ^^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `move` to use it as an identifier\n   |\n21 |  \
    \       c1.r#move();\n   |            ++\n\nerror: expected identifier, found\
    \ keyword `move`\n  --> /tmp/tmp1im6zxjc.rs:28:12\n   |\n28 |         c2.move();\n\
    \   |            ^^^^ expected identifier, found keyword\n   |\nhelp: escape `move`\
    \ to use it as an identifier\n   |\n28 |         c2.r#move();\n   |          \
    \  ++\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n  -->\
    \ /tmp/tmp1im6zxjc.rs:13:18\n   |\n13 |     let mut c1 = Car::new(0, 0, 0);\n\
    \   |                  ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Car`\n  --> /tmp/tmp1im6zxjc.rs:14:18\n\
    \   |\n14 |     let mut c2 = Car::new(0, 0, 0);\n   |                  ^^^ use\
    \ of undeclared type `Car`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1im6zxjc.rs:33:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n33 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found `u64`\n   |\nhelp:\
    \ you can convert a `u64` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n33 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    let mut speed_left = n +\
    \ 1;\n    let mut speed_right = n - 1;\n    for left in 0..n {\n        for right\
    \ in 0..n {\n            let dist = speed_left + left + right + right;\n     \
    \       if dist == speed_left + left {\n                collisions += 1;\n   \
    \         } else if dist == speed_right + right {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpqjv8w6sj.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     let mut speed_left = n + 1;\n   |     --- unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    loop {\n        let\
    \ mut collision: Option<&str> = None;\n        for i in 0..n {\n            let\
    \ current_car = i as isize;\n            for j in 0..n {\n                if j\
    \ > i {\n                    continue;\n                }\n                let\
    \ other_car = j as isize;\n                let distance = get_distance(current_car,\
    \ other_car);\n                let speed = get_speed(current_car, other_car);\n\
    \                if distance.is_infinity && speed.is_infinity {\n            \
    \        collision = Some(format!(\"{:?} and {:?} are too far apart.\", current_car,\
    \ other_car));\n                    collisions += 1;\n                }\n    \
    \        }\n        }\n        if collision.is_some() {\n            break;\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_distance` in this scope\n  -->\
    \ /tmp/tmpcty7kz3g.rs:20:32\n   |\n20 |                 let distance = get_distance(current_car,\
    \ other_car);\n   |                                ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `get_speed` in this scope\n  -->\
    \ /tmp/tmpcty7kz3g.rs:21:29\n   |\n21 |                 let speed = get_speed(current_car,\
    \ other_car);\n   |                             ^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcty7kz3g.rs:23:38\n   |\n23 |\
    \                     collision = Some(format!(\"{:?} and {:?} are too far apart.\"\
    , current_car, other_car));\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ncollisions = 0\n    for a in 0..n {\n      \
    \  for b in a..n+1 {\n            /* a -> b */\n            let car1: Car = Car::new(a,\
    \ b);\n            /* b -> a */\n            let car2: Car = Car::new(b, a);\n\
    \            /* a -> a */\n            let car1_copy: Car = car1;\n          \
    \  /* a -> b */\n            let car2_copy: Car = car2;\n\n            if car1.is_collision_of(&car2_copy)\
    \ == false {\n                /* a -> b */\n                if car2.is_collision_of(&car1)\
    \ == false {\n                    /* b -> b */\n                    if car1.is_collision_of(&car2)\
    \ == false {\n                        /* a -> a */\n                        if\
    \ car2.is_collision_of(&car1) == false {\n                            /* a ->\
    \ b */\n                            if car1.is_collision_of(&car2) == false {\n\
    \                                /* b -> a */\n                              \
    \  if car2.is_collision_of(&car1) == false {\n                               \
    \     ncollisions += 1;\n                                }\n                 \
    \           }\n                        }\n                    }\n            \
    \    }\n            }\n        }\n    }\n    ncollisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp0ob2g4dd.rs:10:28\n\
    \   |\n10 |     let mut ncollisions = 0\n   |                            ^ help:\
    \ add `;` here\n11 |     for a in 0..n {\n   |     --- unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp0ob2g4dd.rs:14:29\n\
    \   |\n14 |             let car1: Car = Car::new(a, b);\n   |                \
    \             ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Car`\n  --> /tmp/tmp0ob2g4dd.rs:16:29\n   |\n16 |  \
    \           let car2: Car = Car::new(b, a);\n   |                            \
    \ ^^^ use of undeclared type `Car`\n\nerror[E0412]: cannot find type `Car` in\
    \ this scope\n  --> /tmp/tmp0ob2g4dd.rs:14:23\n   |\n14 |             let car1:\
    \ Car = Car::new(a, b);\n   |                       ^^^ not found in this scope\n\
    \nerror[E0412]: cannot find type `Car` in this scope\n  --> /tmp/tmp0ob2g4dd.rs:16:23\n\
    \   |\n16 |             let car2: Car = Car::new(b, a);\n   |                \
    \       ^^^ not found in this scope\n\nerror[E0412]: cannot find type `Car` in\
    \ this scope\n  --> /tmp/tmp0ob2g4dd.rs:18:28\n   |\n18 |             let car1_copy:\
    \ Car = car1;\n   |                            ^^^ not found in this scope\n\n\
    error[E0412]: cannot find type `Car` in this scope\n  --> /tmp/tmp0ob2g4dd.rs:20:28\n\
    \   |\n20 |             let car2_copy: Car = car2;\n   |                     \
    \       ^^^ not found in this scope\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_left = false;\n    let mut car_right = true;\n\
    \    let mut cars = Vec::with_capacity(n);\n    for _ in 0..n {\n        cars.push(0);\n\
    \    }\n    let mut collisions = 0;\n\n    for car as &[bool; 2] {\n        if\
    \ car_left && car_right {\n            collisions += 1;\n        }\n\n       \
    \ if car_left {\n            car[0] = !car[0];\n            car_left = false;\n\
    \        } else if car_right {\n            car[1] = !car[1];\n            car_right\
    \ = false;\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpamd7enle.rs:18:12\n  \
    \ |\n18 |     for car as &[bool; 2] {\n   |            ^ help: try adding `in`\
    \ here\n\nerror: expected expression, found keyword `as`\n  --> /tmp/tmpamd7enle.rs:18:13\n\
    \   |\n18 |     for car as &[bool; 2] {\n   |             ^^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpamd7enle.rs:12:39\n   |\n12 |\
    \     let mut cars = Vec::with_capacity(n);\n   |                            \
    \           ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n12\
    \ |     let mut cars = Vec::with_capacity(n.try_into().unwrap());\n   |      \
    \                                  ++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0 as usize;\n    for i in 0..n {\n      \
    \  if i != n - 1 {\n            c += car_collision(i, i + 1);\n        }\n   \
    \ }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpo1lz4dta.rs:13:18\n   |\n13 |             c += car_collision(i, i +\
    \ 1);\n   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo1lz4dta.rs:16:5\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                    ----- expected `isize`\
    \ because of return type\n...\n16 |     c\n   |     ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n16 |     c.try_into().unwrap()\n   |    \
    \  ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The collision detector is really simple.\n    // The\
    \ function cars_collide() returns a bool for each car.\n    // If cars_collide()\
    \ returns true, then we know that car i is colliding with car i+1.\n    // If\
    \ cars_collide() returns false, then we know that car i is not colliding with\
    \ car i+1.\n    // For each car, the number of collisions is 1 if the cars collide,\
    \ 2 if they do not,\n    // and so on.\n\n    // The collision detector function\n\
    \    // cars_collide returns true if car i is colliding with car i+1, and false\
    \ otherwise.\n    // The code below implements a similar function to cars_collide.\n\
    \    // It returns true if car i collides with car i+1, and false otherwise.\n\
    \    // If car i collides with car i+1, then we increment the counter \"collisions\"\
    \ by 1.\n    // If the cars do not collide, then we decrement the counter \"collisions\"\
    \ by 1.\n    // We do this for each car.\n    //\n    // The line \"if i == i\
    \ + 1\" will never be executed if the loop runs out of iterations.\n    // Therefore,\
    \ the loop will never increment the \"collisions\" counter.\n\n    // Initialize\
    \ the counters to 0.\n    let mut collisions = 0.;\n\n    // The loop will increment\
    \ the counter for each time car i collides with car i+1.\n    // The loop will\
    \ decrement the counter for each time car i does not collide with car i+1.\n \
    \   for i in 0..n {\n        if i == i + 1 {\n            collisions += 1;\n \
    \       } else {\n            collisions -= 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmppv_5q_hx.rs:35:24\n\
    \   |\n35 |             collisions += 1;\n   |                        ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0277]: cannot subtract-assign `{integer}`\
    \ from `{float}`\n  --> /tmp/tmppv_5q_hx.rs:37:24\n   |\n37 |             collisions\
    \ -= 1;\n   |                        ^^ no implementation for `{float} -= {integer}`\n\
    \   |\n   = help: the trait `SubAssign<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppv_5q_hx.rs:40:5\n   |\n9  | fn\
    \ car_race_collision(n: isize) -> isize {\n   |                              \
    \      ----- expected `isize` because of return type\n...\n40 |     collisions\n\
    \   |     ^^^^^^^^^^ expected `isize`, found floating-point number\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut car_1 = Vec::new();\n\
    \    let mut car_2 = Vec::new();\n\n    for _ in 0..n {\n        car_1.push(0);\n\
    \        car_2.push(0);\n    }\n\n    for _ in 0..n {\n        let mut collision_found\
    \ = false;\n        for car in &mut car_1 {\n            let mut collision_found\
    \ = false;\n            for car2 in &mut car_2 {\n                let collision\
    \ = car_collision(\n                    car,\n                    car2,\n    \
    \                car_1,\n                    car_2,\n                    false,\n\
    \                    false,\n                    false,\n                );\n\
    \                if collision {\n                    collision_found = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ collision_found {\n                break;\n            }\n        }\n      \
    \  if !collision_found {\n            collision_count += 1;\n        }\n    }\n\
    \n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpl5wxsm5p.rs:24:33\n   |\n24 |                 let collision = car_collision(\n\
    \   |                                 ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 1u64;\n    let mut num_collisions = 0;\n\
    \    while i <= n {\n        if n <= i {\n            break;\n        }\n    \
    \    let mut collisions = 1;\n        while i <= n {\n            if n-- == i\
    \ {\n                collisions += 1;\n                i = 1u64;\n           \
    \ }\n            i += 1;\n        }\n        num_collisions += collisions;\n \
    \   }\n    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `==`\n  --> /tmp/tmpofettu5w.rs:18:20\n\
    \   |\n18 |             if n-- == i {\n   |                    ^^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpofettu5w.rs:12:16\n   |\n12 |\
    \     while i <= n {\n   |                ^ expected `u64`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `u64` and panic if the converted value\
    \ doesn't fit\n   |\n12 |     while i <= n.try_into().unwrap() {\n   |       \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpofettu5w.rs:13:17\n\
    \   |\n13 |         if n <= i {\n   |                 ^ expected `isize`, found\
    \ `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n13 |         if n <= i.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpofettu5w.rs:17:20\n   |\n17 |         while i <= n {\n   |         \
    \           ^ expected `u64`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u64` and panic if the converted value doesn't fit\n   |\n17 |        \
    \ while i <= n.try_into().unwrap() {\n   |                     ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    for c1 in 0..n {\n\
    \        for c2 in 0..n {\n            let mut collide = false;\n\n          \
    \  // Left race.\n            if c1 > c2 {\n                for i in c1..c2 {\n\
    \                    if i > c2 {\n                        collide = true;\n  \
    \                      break;\n                    }\n                }\n\n  \
    \              if collide {\n                    collision_count += 1;\n     \
    \           }\n            }\n\n            // Right race.\n            else {\n\
    \                for i in c2..c1 {\n                    if i > c1 {\n        \
    \                collide = true;\n                        break;\n           \
    \         }\n                }\n\n                if collide {\n             \
    \       collision_count += 1;\n                }\n            }\n        }\n \
    \   }\n\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpm8jx4b6n.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    for (i, right) in n.iter().enumerate()\
    \ {\n        for (j, left) in n.iter().enumerate() {\n            if i != j {\n\
    \                if right > left {\n                    if left_and_right_collision(n[i..j\
    \ + 1], n[j..i + 1]) {\n                        collision_count = collision_count\
    \ + 1;\n                    }\n                }\n                else {\n   \
    \                 if right_and_left_collision(n[i..j + 1], n[j..i + 1]) {\n  \
    \                      collision_count = collision_count + 1;\n              \
    \      }\n                }\n            }\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `left_and_right_collision` in this scope\n\
    \  --> /tmp/tmpex1hzze5.rs:15:24\n   |\n15 |                     if left_and_right_collision(n[i..j\
    \ + 1], n[j..i + 1]) {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `right_and_left_collision`\
    \ in this scope\n  --> /tmp/tmpex1hzze5.rs:20:24\n   |\n20 |                 \
    \    if right_and_left_collision(n[i..j + 1], n[j..i + 1]) {\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmpex1hzze5.rs:11:25\n\
    \   |\n11 |     for (i, right) in n.iter().enumerate() {\n   |               \
    \          ^^^^ method not found in `isize`\n\nerror[E0599]: no method named `iter`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpex1hzze5.rs:12:28\n\
    \   |\n12 |         for (j, left) in n.iter().enumerate() {\n   |            \
    \                ^^^^ method not found in `isize`\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmpex1hzze5.rs:15:49\n   |\n15 |  \
    \                   if left_and_right_collision(n[i..j + 1], n[j..i + 1]) {\n\
    \   |                                                 ^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmpex1hzze5.rs:15:62\n\
    \   |\n15 |                     if left_and_right_collision(n[i..j + 1], n[j..i\
    \ + 1]) {\n   |                                                              ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpex1hzze5.rs:20:49\n\
    \   |\n20 |                     if right_and_left_collision(n[i..j + 1], n[j..i\
    \ + 1]) {\n   |                                                 ^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpex1hzze5.rs:20:62\n\
    \   |\n20 |                     if right_and_left_collision(n[i..j + 1], n[j..i\
    \ + 1]) {\n   |                                                              ^^^^^^^^^^^\n\
    \nerror: aborting due to 8 previous errors\n\nSome err"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: usize = 0;\n    let mut left = n\
    \ - 1;\n    let mut right = n;\n    while left >= 0 {\n        if right > n {\n\
    \            break;\n        }\n        if let Some(collision) = car_race(left,\
    \ right) {\n            collisions += 1;\n            right -= 1;\n        } else\
    \ {\n            right += 1;\n        }\n        left -= 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race` in this scope\n  --> /tmp/tmph6bftdql.rs:17:34\n\
    \   |\n17 |         if let Some(collision) = car_race(left, right) {\n   |   \
    \                               ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph6bftdql.rs:25:5\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                    ----- expected `isize`\
    \ because of return type\n...\n25 |     collisions\n   |     ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |     collisions.try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    let mut collision_matrix\
    \ = vec![vec![false; n + 1]; n + 1];\n\n    // The race starts at one edge of\
    \ the matrix.\n    collision_matrix[n - 1][n - 1] = !collision_matrix[n - 1][n\
    \ - 1];\n\n    let mut i = n - 1;\n    while i >= 0 {\n        let j = n - 1;\n\
    \        while j >= 0 {\n            if collision_matrix[i][j] {\n           \
    \     collision_count += 1;\n            }\n            j -= 1;\n        }\n \
    \       i -= 1;\n    }\n\n    collision_count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaedrc9m6.rs:12:49\n   |\n\
    12 |     let mut collision_matrix = vec![vec![false; n + 1]; n + 1];\n   |   \
    \                                              ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     let mut collision_matrix = vec![vec![false;\
    \ (n + 1).try_into().unwrap()]; n + 1];\n   |                                \
    \                 +     +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaedrc9m6.rs:12:57\n   |\n12 |     let mut collision_matrix = vec![vec![false;\
    \ n + 1]; n + 1];\n   |                                                      \
    \   ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut collision_matrix = vec![vec![false; n + 1]; (n + 1).try_into().unwrap()];\n\
    \   |                                                         +     +++++++++++++++++++++\n\
    \nerror[E0277]: the type `[Vec<bool>]` cannot be indexed by `isize`\n  --> /tmp/tmpaedrc9m6.rs:15:5\n\
    \   |\n15 |     collision_matrix[n - 1][n - 1] = !collision_matrix[n - 1][n -\
    \ 1];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<bool>]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<Vec<bool>>`\n\nerror[E0277]: the type `[Vec<bool>]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpaedrc9m6.rs:15:39\n   |\n15 |     collision_matrix[n\
    \ - 1][n - 1] = !collision_matrix[n - 1][n - 1];\n   |                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[Vec<bool>]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `I"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_speeds = vec![n];\n    car_speeds.push(1);\n\
    \    car_speeds.push(1);\n    for speed in car_speeds.iter_mut() {\n        speed\
    \ = 0;\n    }\n    car_speeds[n - 1] += 1;\n    let collisions = 0;\n    for speed\
    \ in car_speeds.iter_mut() {\n        if speed < 2 {\n            collisions +=\
    \ 1;\n        }\n        speed -= 2;\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpequ6rph4.rs:14:17\n   |\n\
    13 |     for speed in car_speeds.iter_mut() {\n   |         ----- expected due\
    \ to the type of this binding\n14 |         speed = 0;\n   |                 ^\
    \ expected `&mut isize`, found integer\n   |\nhelp: consider dereferencing here\
    \ to assign to the mutable borrowed piece of memory\n   |\n14 |         *speed\
    \ = 0;\n   |         +\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `isize`\n  --> /tmp/tmpequ6rph4.rs:16:5\n   |\n16 |     car_speeds[n - 1] +=\
    \ 1;\n   |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpequ6rph4.rs:19:20\n\
    \   |\n19 |         if speed < 2 {\n   |                    ^\n   |          \
    \          |\n   |                    expected `&mut isize`, found integer\n \
    \  |                    help: consider mutably borrowing here: `&mut 2`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&mut isize`\n  -->\
    \ /tmp/tmpequ6rph4.rs:22:9\n   |\n22 |         speed -= 2;\n   |         -----^^^^^\n\
    \   |         |\n   |         cannot use `-=` on type `&mut isize`\n   |\nhelp:\
    \ `-=` can be used on `isize`, you can dereference `speed`\n   |\n22 |       \
    \  *speed -= 2;\n   |         +\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0 as isize;\n\n    for k in 0..n {\n    \
    \    for j in 0..k {\n            c += 1;\n\n            /*\n             * We\
    \ know that any car that moves right to left will either hit a car\n         \
    \    * moving left to right or be colliding with a car moving left to right.\n\
    \             * But there may be other cars moving left to right.  To get their\
    \ speed\n             * to collide, we simply have to move them right to left\
    \ in the same\n             * direction.\n             * So we have two rules\
    \ to help us make the moves occur:\n             *  1. cars can move left to right\
    \ and right to left\n             *  2. the cars can move in the opposite direction\
    \ at the same time and\n             *      simultaneously\n             * We'll\
    \ choose the left-right rule and work backwards:\n             *  1. cars moving\
    \ left to right will always collide with cars moving right\n             *   \
    \   to left\n             *  2. cars can move left to right and right to left\
    \ at once\n             *      (ie: they can move either right or left at the\
    \ same time) but they\n             *      cannot move left or right at the same\
    \ time (ie: they cannot move\n             *      left and right at the same time)\
    \ because they would collide\n             */\n            match j {\n       \
    \         k => {\n                    if k == 0 {\n                        continue;\n\
    \                    }\n                    c\n                }\n           \
    \     _ => {\n                    c\n                }\n            }\n      \
    \  }\n    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0b5o2bwj.rs:39:21\n   |\n\
    34 | /             match j {\n35 | |                 k => {\n36 | |          \
    \           if k == 0 {\n37 | |                         continue;\n38 | |    \
    \                 }\n39 | |                     c\n   | |                    \
    \ ^ expected `()`, found `isize`\n...  |\n43 | |                 }\n44 | |   \
    \          }\n   | |_____________- expected this to be `()`\n   |\nhelp: you might\
    \ have meant to return this value\n   |\n39 |                     return c;\n\
    \   |                     ++++++  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0b5o2bwj.rs:42:21\n\
    \   |\n34 | /             match j {\n35 | |                 k => {\n36 | |   \
    \                  if k == 0 {\n37 | |                         continue;\n...\
    \  |\n42 | |                     c\n   | |                     ^ expected `()`,\
    \ found `isize`\n43 | |                 }\n44 | |             }\n   | |_____________-\
    \ expected this to be `()`\n   |\nhelp: you might have meant to return this value\n\
    \   |\n42 |                     return c;\n   |                     ++++++  +\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| i % 2).count() // how many cars are\
    \ in each set\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtlhsyoq.rs:10:23\n   |\n\
    10 |     (1..n).filter(|i| i % 2).count() // how many cars are in each set\n \
    \  |                       ^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphtlhsyoq.rs:10:5\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                    ----- expected `isize`\
    \ because of return type\n10 |     (1..n).filter(|i| i % 2).count() // how many\
    \ cars are in each set\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |     (1..n).filter(|i| i % 2).count().try_into().unwrap()\
    \ // how many cars are in each set\n   |                                     ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Compute the cars' starting positions.\n    // They\
    \ are equally spaced between one another.\n    let mut start_pos = (0..n)\n  \
    \      .map(|i| i * (2 * 1.1) + (2 * 0.1))\n        .collect::<Vec<_>>();\n\n\
    \    // Initialize a map of car states indexed by their position.\n    let mut\
    \ states = HashMap::with_capacity(n);\n    // The current position of each car.\n\
    \    let mut current = vec![0; n];\n\n    // Initialize the map to contain a collision\
    \ detector for each car.\n    let mut collisions = HashMap::with_capacity(n);\n\
    \n    // The two cars are initially colliding.\n    let mut collide = HashMap::with_capacity(n);\n\
    \n    // Set the initial state for each car based on the starting position.\n\
    \    for pos in start_pos.iter() {\n        states.insert(pos, CollisionDetector::new());\n\
    \        current.push(CollisionDetector::new());\n        collide[pos] = false;\n\
    \    }\n\n    // While there is still cars left to explore...\n    while current.len()\
    \ > 0 {\n        // Iterate over all of the cars.\n        for pos in current.iter().rev()\
    \ {\n            let mut state = states.get(&pos);\n            // If a collision\
    \ has occurred, return that number of collisions.\n            if let Some(detector)\
    \ = state {\n                collisions.entry(pos)\n                    .or_insert_with(||\
    \ CollisionDetector::new())\n                    .handle_collision(detector);\n\
    \            }\n\n            // Otherwise the car is still colliding.\n     \
    \       else {\n                collide[pos] = true;\n            }\n        }\n\
    \n        // Compute the next state.\n        let mut next = vec![0; n];\n   \
    \     let mut max_x = 0.0;\n        // Iterate over all of the cars.\n       \
    \ for pos in current.iter() {\n            let state = states.get(&pos);\n   \
    \         let mut detector = state;\n            // If this car has not yet collided,\
    \ update its current position.\n            if !collide[pos] {\n             \
    \   detector.update(&current);\n                next.push(pos);\n            \
    \    // Compute the new position for this car based on the current\n         \
    \       // position.\n                max_x = std::cmp::max(max_x, detector.x);\n\
    \            }\n        }\n\n        // If a collision has occurred for any car,\
    \ set the next state to be\n        // one with no collisions.\n        for pos\
    \ in next.iter() {\n            let state = states.get(&pos);\n            let\
    \ mut detector = state;\n            if !collide[pos] {\n                detector.update(&next);\n\
    \            }\n        }\n\n        // Set the current state to the new state.\n\
    \        states = next;\n        current = \n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxaepbmhe.rs:91:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n35 |     while current.len()\
    \ > 0 {\n   |                             - this delimiter might not be properly\
    \ closed...\n...\n82 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n91 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpxaepbmhe.rs:82:1\n\
    \   |\n82 | }\n   | ^ expected expression\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `CollisionDetector`\n  --> /tmp/tmpxaepbmhe.rs:29:28\n\
    \   |\n29 |         states.insert(pos, CollisionDetector::new());\n   |      \
    \                      ^^^^^^^^^^^^^^^^^ use of undeclared type `CollisionDetector`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `CollisionDetector`\n\
    \  --> /tmp/tmpxaepbmhe.rs:30:22\n   |\n30 |         current.push(CollisionDetector::new());\n\
    \   |                      ^^^^^^^^^^^^^^^^^ use of undeclared type `CollisionDetector`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `CollisionDetector`\n\
    \  --> /tmp/tmpxaepbmhe.rs:42:40\n   |\n42 |                     .or_insert_with(||\
    \ CollisionDetector::new())\n   |                                        ^^^^^^^^^^^^^^^^^\
    \ use of undeclared type `CollisionDetector`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxaepbmhe.rs:17:22\n   |\n17\
    \ |     let mut states = HashMap::with_capacity(n);\n   |                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpxaepbmhe.rs:22:26\n   |\n22\
    \ |     let mut collisions = HashMap::with_capacity(n);\n   |                \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpxaepbmhe.rs:25:23\n\
    \   |"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0\n    }\n    let mut collisions\
    \ = 0\n    for _ in 0..n {\n        for other in 1..n {\n            if !(car_race_collision(n\
    \ - 1) || car_race_collision(other)) {\n                collisions += 1;\n   \
    \         }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp_730naer.rs:13:27\n\
    \   |\n13 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n14 |     for _ in 0..n {\n   |     --- unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_730naer.rs:16:18\n   |\n16 |             if\
    \ !(car_race_collision(n - 1) || car_race_collision(other)) {\n   |          \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_730naer.rs:16:47\n   |\n16 |             if\
    \ !(car_race_collision(n - 1) || car_race_collision(other)) {\n   |          \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n)\n        .filter(|n| {\n            (0..n).all(|i|\
    \ car_race_collision_at(i)) &&\n            (0..n).all(|i| !car_race_collision_at(i\
    \ + 1))\n        })\n        .count() + 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_at` in this scope\n\
    \  --> /tmp/tmp76op0ht5.rs:12:28\n   |\n12 |             (0..n).all(|i| car_race_collision_at(i))\
    \ &&\n   |                            ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `car_race_collision_at` in this\
    \ scope\n  --> /tmp/tmp76op0ht5.rs:13:29\n   |\n13 |             (0..n).all(|i|\
    \ !car_race_collision_at(i + 1))\n   |                             ^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76op0ht5.rs:12:17\n\
    \   |\n12 |             (0..n).all(|i| car_race_collision_at(i)) &&\n   |    \
    \             ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n12 |             (0..*n).all(|i| car_race_collision_at(i))\
    \ &&\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76op0ht5.rs:13:17\n\
    \   |\n13 |             (0..n).all(|i| !car_race_collision_at(i + 1))\n   |  \
    \               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n13 |             (0..*n).all(|i| !car_race_collision_at(i\
    \ + 1))\n   |                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76op0ht5.rs:10:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 | /\
    \     (1..n)\n11 | |         .filter(|n| {\n12 | |             (0..n).all(|i|\
    \ car_race_collision_at(i)) &&\n13 | |             (0..n).all(|i| !car_race_collision_at(i\
    \ + 1))\n14 | |         })\n15 | |         .count() + 2\n   | |____________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 ~     ((1..n)\n\
    11 |         .filter(|n| {\n12 |             (0..n).all(|i| car_race_collision_at(i))\
    \ &&\n13 |             (0..n).all(|i| !car_race_collision_at(i + 1))\n14 |   \
    \      })\n15 ~         .count() + 2).try_into().unwrap()\n   |\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explana"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0; // Number of collisions.\n    let\
    \ mut moves: Vec<Direction> = vec![Direction::Left(0), Direction::Right(0)];\n\
    \    // Initialize moves.\n    for i in 0..n {\n        moves.push(i);\n    }\n\
    \    for i in 0..n {\n        if moves[i] > 0 {\n            for j in moves[i\
    \ - 1..i].iter() {\n                if j.collides_with(moves[i]) {\n         \
    \           count += 1;\n                    moves.swap(i, j);\n             \
    \       break;\n                }\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Direction`\n \
    \ --> /tmp/tmpcw2kj8u7.rs:11:42\n   |\n11 |     let mut moves: Vec<Direction>\
    \ = vec![Direction::Left(0), Direction::Right(0)];\n   |                     \
    \                     ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpcw2kj8u7.rs:11:62\n\
    \   |\n11 |     let mut moves: Vec<Direction> = vec![Direction::Left(0), Direction::Right(0)];\n\
    \   |                                                              ^^^^^^^^^ use\
    \ of undeclared type `Direction`\n\nerror[E0412]: cannot find type `Direction`\
    \ in this scope\n  --> /tmp/tmpcw2kj8u7.rs:11:24\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                      - help: you might be missing a\
    \ type parameter: `<Direction>`\n10 |     let mut count = 0; // Number of collisions.\n\
    11 |     let mut moves: Vec<Direction> = vec![Direction::Left(0), Direction::Right(0)];\n\
    \   |                        ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut c1: usize\
    \ = n;\n    let mut c2: usize = n;\n    while c1 > 0 && c2 > 0 {\n        if car_collision(c1,\
    \ c2) != 0 {\n            collisions += 1;\n        }\n        c1 -= 1;\n    \
    \    c2 -= 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmpagfrz7uh.rs:14:12\n   |\n14 |         if car_collision(c1, c2) != 0\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpagfrz7uh.rs:11:25\n   |\n11 |     let mut c1: usize = n;\n\
    \   |                 -----   ^ expected `usize`, found `isize`\n   |        \
    \         |\n   |                 expected due to this\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut c1: usize = n.try_into().unwrap();\n   |                    \
    \      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpagfrz7uh.rs:12:25\n\
    \   |\n12 |     let mut c2: usize = n;\n   |                 -----   ^ expected\
    \ `usize`, found `isize`\n   |                 |\n   |                 expected\
    \ due to this\n   |\nhelp: you can convert an `isize` to a `usize` and panic if\
    \ the converted value doesn't fit\n   |\n12 |     let mut c2: usize = n.try_into().unwrap();\n\
    \   |                          ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut c1: Vec<(isize, usize)>\
    \ = Vec::new();\n    let mut c2: Vec<(isize, usize)> = Vec::new();\n    for i\
    \ in 0..n {\n        let left = i as isize;\n        let right = left;\n     \
    \   c1.push((left, usize::max_value()));\n        c2.push((right, usize::max_value()));\n\
    \    }\n    for j in 0..n {\n        let left = j as isize;\n        let right\
    \ = j + 1;\n        for i in 0..n {\n            if i == j {\n               \
    \ continue;\n            }\n            let mut i1 = i as isize;\n           \
    \ let mut i2 = i1;\n            let mut i3 = i2;\n            while i1 < i3 {\n\
    \                i1 += 1;\n                i2 -= 1;\n                let mut i4\
    \ = i3;\n                while i2 < i4 {\n                    i2 += 1;\n     \
    \               i3 -= 1;\n                    let mut i5 = i4;\n             \
    \       while i3 < i5 {\n                        i3 += 1;\n                  \
    \      i4 -= 1;\n                        let mut i6 = i5;\n                  \
    \      while i4 < i6 {\n                            i4 += 1;\n               \
    \             i5 -= 1;\n                            let mut i7 = i6;\n       \
    \                     while i5 < i7 {\n                                i5 += 1;\n\
    \                                i6 -= 1;\n                                let\
    \ mut i8 = i7;\n                                while i6 < i8 {\n            \
    \                        i6 += 1;\n                                    i8 -= 1;\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \          if i1 == i2 {\n                continue;\n            }\n         \
    \   let mut i1 = i as isize;\n            let mut i2 = i1 + 1;\n            let\
    \ mut i3 = i2 + 1;\n            while i1 < i3 {\n                i1 += 1;\n  \
    \              i2 += 1;\n                let mut i4 = i3;\n                while\
    \ i2 < i4 {\n                    i2 += 1;\n                    i3 += 1;\n    \
    \                let mut i5 = i4;\n                    while i3 < i5 {\n     \
    \                   i3 += 1;\n                        i4 += 1;\n             \
    \           let mut i6 = i5;\n                        while i4 < i6 {\n      \
    \                      i4 += 1;\n                            i5 += 1;\n      \
    \                      let mut i7 = i6;\n                            while i5\
    \ < i7 {\n                                i5 += 1;\n                         \
    \       i6 += 1;\n                                let mut i8 = i7;\n         \
    \                       while i6 < i8 {\n                                    i6\
    \ += 1;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4vy0m_tu.rs:95:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n19 |     for j in 0..n {\n\
    \   |                   - unclosed delimiter\n...\n22 |         for i in 0..n\
    \ {\n   |                       - unclosed delimiter\n...\n64 |             while\
    \ i1 < i3 {\n   |                           - unclosed delimiter\n...\n68 |  \
    \               while i2 < i4 {\n   |                               - unclosed\
    \ delimiter\n...\n72 |                     while i3 < i5 {\n   |             \
    \                      - unclosed delimiter\n...\n76 |                       \
    \  while i4 < i6 {\n   |                                       - unclosed delimiter\n\
    ...\n80 |                             while i5 < i7 {\n   |                  \
    \                         - unclosed delimiter\n...\n84 |                    \
    \             while i6 < i8 {\n   |                                          \
    \     - this delimiter might not be properly closed...\n85 |                 \
    \                    i6 += 1;\n86 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n95 | }\n   |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4vy0m_tu.rs:19:5\n   |\n9  |   fn car_race_collision(n: isize)\
    \ -> isize {\n   |                                      ----- expected `isize`\
    \ because of return type\n...\n19 | /     for j in 0..n {\n20 | |         let\
    \ left = j as isize;\n21 | |         let right = j + 1;\n22 | |         for i\
    \ in 0..n {\n...  |\n94 | |     assert_eq!(candidate(10), 100);\n95 | | }\n  \
    \ | |__^ expected `isize`, found `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    // n is\
    \ the number of cars currently in the race.\n    // n starts at 0 because cars\
    \ are initially in the middle of the road.\n    let mut race_cars = [0; n];\n\n\
    \    // The next cars ID to assign to the cars.\n    let mut next_car = 1;\n\n\
    \    // A car is colliding when it hits a car currently in the race that's moving\n\
    \    // left or right toward the next car.\n    let mut collisions = 0;\n\n  \
    \  // The next car is moving right toward the next car.\n    let mut next_car_moving_right\
    \ = false;\n\n    // The next car is moving left toward the next car.\n    let\
    \ mut next_car_moving_left = false;\n\n    // The next car is moving up or down.\n\
    \    let mut next_car_moving_up = false;\n\n    // The next car is moving left\
    \ or right.\n    let mut next_car_moving_left = false;\n\n    // The next car\
    \ is moving up or down.\n    let mut next_car_moving_up = false;\n\n    // The\
    \ car that currently collides with the next car.\n    let mut collide_with = 0;\n\
    \n    // The index of the car currently collides with the next car.\n    let mut\
    \ collide_with_index = 0;\n\n    // The index of the last car that collided with\
    \ the next car.\n    let mut collide_with_last_index = 0;\n\n    // The next car\
    \ that collides with the last car.\n    let mut collide_with_next_car = 0;\n\n\
    \    // The last car that collides with the last car.\n    let mut collide_with_last_car\
    \ = 0;\n\n    // The index of the next car that collides with the last car.\n\
    \    let mut collide_with_next_car_index = 0;\n\n    // The index of the last\
    \ car that collides with the last car.\n    let mut collide_with_last_car_index\
    \ = 0;\n\n    // The car currently colliding with the last car.\n    let mut collide_with_last_car\
    \ = 0;\n\n    // Keep going until we run out of cars to race.\n    while next_car\
    \ < n {\n        // If the current car is already in the race, move on to the\
    \ next car.\n        if race_cars[next_car] == 1 {\n            next_car += 1;\n\
    \            continue;\n        }\n\n        // Update the car's position as if\
    \ they were moving right toward the next car.\n        race_cars[next_car] +=\
    \ 1;\n        if next_car_moving_right {\n            race_cars[next_car] += 1;\n\
    \        }\n\n        // Check each car in the race to see if it collide\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp58t2xnt_.rs:88:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n65 |     while next_car <\
    \ n {\n   |                        - this delimiter might not be properly closed...\n\
    ...\n79 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    88 | }\n   |   ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n\
    \  --> /tmp/tmp58t2xnt_.rs:16:29\n   |\n9  | fn car_race_collision(n: isize) ->\
    \ isize {\n   |                       - this would need to be a `const`\n...\n\
    16 |     let mut race_cars = [0; n];\n   |                             ^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp58t2xnt_.rs:9:36\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0435.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n\n    // We can't have\
    \ less than 2 cars running at any given time.\n    assert!((n as f64 / 2.0).is_integer());\n\
    \n    let mut car_position = (0..n)\n        .map(|i| i * 2.0_f64.sin(i))\n  \
    \      .collect::<Vec<f64>>();\n\n    // First set of cars collide with each other\
    \ at position 0.\n    collision_count += 0..n.min(2)\n        .filter(|i| car_position[i]\
    \ == 0.0_f64)\n        .count();\n\n    for mut position in car_position {\n \
    \       // Second set of cars collide with each other at position 1.\n       \
    \ collision_count += 0..n.min(2)\n            .filter(|i| car_position[i] == 1.0_f64)\n\
    \            .count();\n\n        // A third set of cars collide with each other\
    \ at position n.\n        collision_count += 0..n.min(2)\n            .filter(|i|\
    \ car_position[i] == 2.0_f64)\n            .count();\n\n        // The other positions\
    \ don't collide.\n        if position != 0.0_f64 {\n            collision_count\
    \ += 0..n.min(2)\n                .filter(|i| car_position[i] == position as f64)\n\
    \                .count();\n        }\n    }\n\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpaaqviz3s.rs:13:30\n   |\n13 |     assert!((n as\
    \ f64 / 2.0).is_integer());\n   |                              ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpaaqviz3s.rs:16:30\n    |\n16  |         .map(|i|\
    \ i * 2.0_f64.sin(i))\n    |                              ^^^ - supplied 1 argument\n\
    \    |                              |\n    |                              expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]:\
    \ cannot multiply `isize` by `f64`\n  --> /tmp/tmpaaqviz3s.rs:16:20\n   |\n16\
    \ |         .map(|i| i * 2.0_f64.sin(i))\n   |                    ^ no implementation\
    \ for `isize * f64`\n   |\n   = help: the trait `Mul<f64>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: `isize` is not an iterator\n  --> /tmp/tmpaaqviz3s.rs:21:10\n\
    \   |\n21 |         .filter(|i| car_position[i] == 0.0_f64)\n   |          ^^^^^^\
    \ `isize` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `isize: Iterator`\n           which is required by\
    \ `&mut isize: Iterator`\n\nerror[E0277]: cannot add-assign `std::ops::Range<{integer}>`\
    \ to `{integer}`\n  --> /tmp/tmpaaqviz3s.rs:20:21\n   |\n20 |     collision_count\
    \ += 0..n.min(2)\n   |                     ^^ no implementation for `{integer}\
    \ += std::ops::Range<{integer}>`\n   |\n   = help: the trait `AddAssign<std::ops::Range<{integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n    "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (0..n).count(move |i| {\n        collision_detect((i-1)\
    \ as usize, (i+1) as usize, n as usize)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `collision_detect` in this scope\n \
    \ --> /tmp/tmp2c0radip.rs:11:9\n   |\n11 |         collision_detect((i-1) as usize,\
    \ (i+1) as usize, n as usize)\n   |         ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp2c0radip.rs:10:12\n    |\n10  |       (0..n).count(move |i| {\n\
    \    |  ____________^^^^^_-\n    | |            |\n    | |            expected\
    \ 0 arguments\n11  | |         collision_detect((i-1) as usize, (i+1) as usize,\
    \ n as usize)\n12  | |     })\n    | |_____- supplied 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2c0radip.rs:10:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 | /\
    \     (0..n).count(move |i| {\n11 | |         collision_detect((i-1) as usize,\
    \ (i+1) as usize, n as usize)\n12 | |     })\n   | |______^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |     }).try_into().unwrap()\n\
    \   |       ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    // If there\
    \ are two cars in the same collision group,\n    // the two cars must move at\
    \ exactly the same speed.\n    let mut collision_count = 0;\n\n    let mut speeds\
    \ = [0.; n];\n    let mut positions = [0.; n];\n    let mut dirs = [0.; n];\n\
    \    let mut dirs_copy = [0.; n];\n\n    // Positions of the two cars.\n    let\
    \ mut pos1 = [10.; 10.];\n    let mut pos2 = [100.; 10.];\n\n    // Initial speeds.\n\
    \    let mut v1 = [20.; 20.];\n    let mut v2 = [120.; 20.];\n\n    let mut collide\
    \ = false;\n\n    // Initial positions.\n    let mut pos1_copy = [10.; 10.];\n\
    \    let mut pos2_copy = [100.; 10.];\n\n    let mut dir1_copy = [0.; n];\n  \
    \  let mut dir2_copy = [0.; n];\n\n    for _ in 0..(n * 2) {\n        // Set the\
    \ initial positions.\n        pos1 = pos1_copy;\n        pos2 = pos2_copy;\n\n\
    \        // Set the initial speeds.\n        v1 = v1;\n        v2 = v2;\n\n  \
    \      // Set the initial directions.\n        dir1 = dir1_copy;\n        dir2\
    \ = dir2_copy;\n\n        // Set the initial direction copy.\n        dirs_copy[0]\
    \ = dir1;\n        dirs_copy[n - 1] = dir2;\n\n        // Move the first car to\
    \ its initial position and speed.\n        move_car(&pos1, &v1, &dir1, &speeds[0]);\n\
    \n        // Move the second car to its initial position and speed.\n        move_car(&pos2,\
    \ &v2, &dir2, &speeds[1]);\n\n        // Copy dirs_copy to dirs so they can be\
    \ mutated below.\n        dirs_copy.copy_to_slice(&mut dirs);\n\n        // Copy\
    \ pos1 to pos1_copy so they can be mutated below.\n        pos1.copy_to_slice(&mut\
    \ pos1_copy);\n\n        // Copy pos2 to pos2_copy so they can be mutated below.\n\
    \        pos2.copy_to_slice(&mut pos2_copy);\n\n        // Copy v1 to v2 so they\
    \ can be mutated below.\n        v1.copy_to_slice(&mut v2);\n\n        // Move\
    \ both cars left and right.\n        move_car(&pos1, &v1, &dir1, &speeds[0]);\n\
    \        move_car(&pos2, &v2, &dir2, &speeds[1]);\n\n        // Set the initial\
    \ positions.\n        pos1 = pos1_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf29ifrmk.rs:89:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n39 |     for _ in 0..(n *\
    \ 2) {\n   |                         - this delimiter might not be properly closed...\n\
    ...\n80 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    89 | }\n   |   ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n\
    \  --> /tmp/tmpf29ifrmk.rs:17:27\n   |\n9  | fn car_race_collision(n: isize) ->\
    \ isize {\n   |                       - this would need to be a `const`\n...\n\
    17 |     let mut speeds = [0.; n];\n   |                           ^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmpf29ifrmk.rs:18:30\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - this would need to be a `const`\n...\n18 |     let mut positions = [0.;\
    \ n];\n   |                              ^\n\nerror[E0435]: attempt to use a non-constant\
    \ value in a constant\n  --> /tmp/tmpf29ifrmk.rs:19:25\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                       - this would need to be a `const`\n\
    ...\n19 |     let mut dirs = [0.; n];\n   |                         ^\n\nerror[E0435]:\
    \ attempt to use a non-constant value in a constant\n  --> /tmp/tmpf29ifrmk.rs:20:30\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \      - this would need to be a `const`\n...\n20 |     let mut dirs_copy = [0.;\
    \ n];\n   |                              ^\n\nerror[E0435]: attempt to use a non-constant\
    \ value in a constant\n  --> /tmp/tmpf29ifrmk.rs:36:30\n   |\n9  | fn car_race_collision(n:\
    \ isize) -> isize {\n   |                       - this would need to be a `const`\n\
    ...\n36 |     let mut dir1_copy = [0.; n];\n   |                             \
    \ ^\n\nerror[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpf29ifrmk.rs:37:30\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n..."
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).filter(|i| {\n        let i1 = i % 2;\n      \
    \  i % (2 * (i1 + 1))\n    }).count()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q4vfqis.rs:12:9\n   |\n\
    12 |         i % (2 * (i1 + 1))\n   |         ^^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q4vfqis.rs:10:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n10 | /\
    \     (1..n).filter(|i| {\n11 | |         let i1 = i % 2;\n12 | |         i %\
    \ (2 * (i1 + 1))\n13 | |     }).count()\n   | |______________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n13 |     }).count().try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n\n    // Compute the maximum\
    \ time for a collision\n    let max_time_collision = 2 * n;\n\n    // Iterate\
    \ through all cars\n    for (i, &(_, cx, cy)) in std::env::args_os().enumerate().zip(std::env::args_str().iter())\
    \ {\n        // If the ith car collides with the ith car, it's time to add another\
    \ collision\n        if i == 0 {\n            let (cx, cy) = cx.unwrap().split(',').collect::<Vec<&str>>().nth(2).unwrap();\n\
    \            collisions += 1;\n        } else if i == 1 {\n            let (cx,\
    \ cy) = cy.unwrap().split(',').collect::<Vec<&str>>().nth(2).unwrap();\n     \
    \       collisions += 1;\n        } else {\n            // Get distance of cars\
    \ i and i - 1 to the center\n            let dx = cx.unwrap().split(',').collect::<Vec<&str>>().nth(1).unwrap().parse().unwrap();\n\
    \            let dy = cy.unwrap().split(',').collect::<Vec<&str>>().nth(1).unwrap().parse().unwrap();\n\
    \n            // Get distance of cars i and i - 2 to the center\n            let\
    \ dx_i = cx.unwrap().split(',').collect::<Vec<&str>>().nth(2).unwrap().parse().unwrap();\n\
    \            let dy_i = cy.unwrap().split(',').collect::<Vec<&str>>().nth(2).unwrap().parse().unwrap();\n\
    \n            // Get the distance of cars i - 1 and i - 2 to the center\n    \
    \        let dx_i_1 = cx.unwrap().split(',').collect::<Vec<&str>>().nth(3).unwrap().parse().unwrap();\n\
    \            let dy_i_1 = cy.unwrap().split(',').collect::<Vec<&str>>().nth(3).unwrap().parse().unwrap();\n\
    \n            // Get the distance of cars i - 2 and i - 3 to the center\n    \
    \        let dx_i_2 = cx.unwrap().split(',').collect::<Vec<&str>>().nth(4).unwrap().parse().unwrap();\n\
    \            let dy_i_2 = cy.unwrap().split(',').collect::<Vec<&str>>().nth(4).unwrap().parse().unwrap();\n\
    \n            // Compute time\n            let time_collision = (dx + dy) - (dx_i\
    \ + dy_i) + (dx_i_1 + dy_i_1) - (dx_i_2 + dy_i_2);\n\n            // If the two\
    \ times are too close, it is time to add another collision\n            if time_collision\
    \ < 0.0 {\n                collisions += 1;\n            }\n\n            // If\
    \ the two times are too far, it is time to add another collision\n           \
    \ if time_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu_k2h44u.rs:60:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n16 |     for (i, &(_, cx,\
    \ cy)) in std::env::args_os().enumerate().zip(std::env::args_str().iter()) {\n\
    \   |                                                                        \
    \                       - unclosed delimiter\n...\n24 |         } else {\n   |\
    \                - this delimiter might not be properly closed...\n...\n51 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n60 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpu_k2h44u.rs:51:1\n\
    \   |\n50 |             if time_\n   |             -- this `if` expression has\
    \ a condition, but no block\n51 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot\
    \ find function `args_str` in module `std::env`\n  --> /tmp/tmpu_k2h44u.rs:16:76\n\
    \   |\n16 |     for (i, &(_, cx, cy)) in std::env::args_os().enumerate().zip(std::env::args_str().iter())\
    \ {\n   |                                                                    \
    \        ^^^^^^^^ not found in `std::env`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu_k2h44u.rs:18:17\n   |\n18 |         if i == 0 {\n   |       \
    \          ^ expected tuple, found integer\n   |\n   = note: expected tuple `(usize,\
    \ OsString)`\n               found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu_k2h44u.rs:21:24\n   |\n21 |         } else if i == 1\
    \ {\n   |                        ^ expected tuple, found integer\n   |\n   = note:\
    \ expected tuple `(usize, OsString)`\n               found type `{integer}`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu_k2h44u.rs:16:5\n   |\n9  |   fn\
    \ car_race_collision(n: isize) -> isize {\n   |                              \
    \        ----- expected `isize` because of return type\n...\n16 | /     for (i,\
    \ &(_, cx, cy)) in std::env::args_os().enumerate().zip(std::env::args_str().iter())\
    \ {\n17 | |         // If the ith car collides with the ith car, it's time to\
    \ add another collision\n18 | |         if i == 0 {\n19 |"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for i in 0..n {\n\
    \        let mut collision = n - i;\n        for j in 0..n {\n            if i\
    \ == j { continue; }\n            let mut speed = 5.0;\n            let new_pos\
    \ = (i + j) % n;\n            speed *= j;\n            let new_speed = speed *\
    \ 1.0;\n            let new_speed2 = speed * 2.0;\n            collision += (\n\
    \                collision_distance_2d(&(i - new_pos), &(new_pos - j)) +\n   \
    \             collision_distance_2d(&(j - new_pos), &(new_pos - i)) +\n      \
    \          collision_distance_2d(&(i - j), &(j - i)) +\n                collision_distance_2d(&(new_pos\
    \ - i), &(new_pos - j))\n            );\n            let dist = collision_distance_2d(&(i\
    \ - new_pos), &(new_pos - new_pos));\n            if dist < collision { collision\
    \ = dist; }\n            let dist2 = collision_distance_2d(&(i - new_pos), &(new_pos\
    \ - new_pos));\n            if dist2 < collision { collision = dist2; }\n    \
    \    }\n        if collision >= 1.5 { break; }\n    }\n    collisions\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `collision_distance_2d` in this scope\n\
    \  --> /tmp/tmpc2t1v10u.rs:21:17\n   |\n21 |                 collision_distance_2d(&(i\
    \ - new_pos), &(new_pos - j)) +\n   |                 ^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `collision_distance_2d`\
    \ in this scope\n  --> /tmp/tmpc2t1v10u.rs:22:17\n   |\n22 |                 collision_distance_2d(&(j\
    \ - new_pos), &(new_pos - i)) +\n   |                 ^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `collision_distance_2d`\
    \ in this scope\n  --> /tmp/tmpc2t1v10u.rs:23:17\n   |\n23 |                 collision_distance_2d(&(i\
    \ - j), &(j - i)) +\n   |                 ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `collision_distance_2d` in this\
    \ scope\n  --> /tmp/tmpc2t1v10u.rs:24:17\n   |\n24 |                 collision_distance_2d(&(new_pos\
    \ - i), &(new_pos - j))\n   |                 ^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `collision_distance_2d`\
    \ in this scope\n  --> /tmp/tmpc2t1v10u.rs:26:24\n   |\n26 |             let dist\
    \ = collision_distance_2d(&(i - new_pos), &(new_pos - new_pos));\n   |       \
    \                 ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `collision_distance_2d` in this scope\n  --> /tmp/tmpc2t1v10u.rs:28:25\n\
    \   |\n28 |             let dist2 = collision_distance_2d(&(i - new_pos), &(new_pos\
    \ - new_pos));\n   |                         ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nwarning: unnecessary parentheses around assigned value\n  -->\
    \ /tmp/tmpc2t1v10u.rs:20:26\n   |\n20 |               collision += (\n   |  __________________________^\n\
    21 | |                 collision_distance_2d(&(i - new_pos), &(new_pos - j)) +\n\
    \   | |________________^\n...\n24 |                   collision_distance_2d(&(new_pos\
    \ - i), &(new_pos - j))\n   |  ______________________________________________________________________^\n\
    25 | |             );\n   | |_____________^\n   |\n   = note: `#[warn(unu"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    let mut current_speed =\
    \ 5.0;\n    for _ in 0..n {\n        let speed = if current_speed > 4.0 { 4.0\
    \ } else { current_speed };\n        let direction = (1.0 * rand::random::<f64>()\
    \ - 0.5) as f64;\n        let offset = 2.0 * direction;\n        let collision\
    \ = (current_speed - speed) * direction < 0.0;\n        if collision {\n     \
    \       collisions += 1;\n        }\n        current_speed += speed;\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp32udmnbx.rs:14:32\n   |\n14 |         let direction = (1.0 * rand::random::<f64>()\
    \ - 0.5) as f64;\n   |                                ^^^^ use of undeclared crate\
    \ or module `rand`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Set up a data structure to store a record of positions\
    \ we've already seen\n    let mut seen = Vec::new();\n    let mut collision_count\
    \ = 0;\n\n    // The loop will run n + 2 times, since the first loop will run\
    \ the entire\n    // body of the race, and the last loop will run n times, since\
    \ the last car has\n    // already been moved n steps to the right.\n    for i\
    \ in 0..(n + 2) {\n        // Simulate the first car moving to the right\n   \
    \     let mut car_right = {\n            let mut car = Car::new();\n         \
    \   car.x = 100.0 as f32;\n            car.y = 200.0 as f32;\n            car.vx\
    \ = (-car.vx as f32) / 10.0 as f32;\n            car.vy = (-car.vy as f32) / 10.0\
    \ as f32;\n            car\n        };\n\n        // Simulate the second car moving\
    \ to the left\n        let mut car_left = {\n            let mut car = Car::new();\n\
    \            car.x = -100.0 as f32;\n            car.y = 200.0 as f32;\n     \
    \       car.vx = (car.vx as f32) / 10.0 as f32;\n            car.vy = (car.vy\
    \ as f32) / 10.0 as f32;\n            car\n        };\n\n        // Make a vector\
    \ of positions of all the cars.\n        // We need one position per car.\n  \
    \      let mut positions = vec![car_right.x, car_right.y, car_left.x, car_left.y];\n\
    \n        // Keep a record of the positions we've already seen\n        seen.extend(positions);\n\
    \n        // Check if any of the positions we've seen have collided.\n       \
    \ if positions.iter().all(|pos| seen\n            .iter()\n            .any(|seen|\
    \ seen\n                .iter()\n                .any(|seen| seen == pos))\n \
    \       ) {\n            collision_count = collision_count + 1;\n        }\n \
    \   }\n\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpodukt_k7.rs:20:27\n\
    \   |\n20 |             let mut car = Car::new();\n   |                      \
    \     ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Car`\n  --> /tmp/tmpodukt_k7.rs:30:27\n   |\n30 |      \
    \       let mut car = Car::new();\n   |                           ^^^ use of undeclared\
    \ type `Car`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    for _ in 0..n {\n\
    \        for _ in 0..n {\n            if car_race_collision_helper(n, &mut collisions)\
    \ {\n                break;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmp1lv87lk9.rs:13:16\n   |\n13 |             if car_race_collision_helper(n,\
    \ &mut collisions) {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut collision_limit\
    \ = 10;\n    // The distance traveled for each car must be greater than or equal\
    \ to\n    // the limit for a collision.\n    while collision_count < collision_limit\
    \ {\n        let collision_limit = collision_count + n;\n        // Create a vector\
    \ to hold the position of the car.\n        let mut position = (0, 0, 0);\n  \
    \      // Create a vector to hold the velocity of the car.\n        let mut velocity\
    \ = (0, 0, 0);\n        // Create a vector to hold the acceleration of the car.\n\
    \        let mut acceleration = (0, 0, 0);\n        // Create a vector to hold\
    \ the final position of the car.\n        let mut final_position = (0, 0, 0);\n\
    \        // Create a vector to hold the final velocity of the car.\n        let\
    \ mut final_velocity = (0, 0, 0);\n        // Create a vector to hold the final\
    \ acceleration of the car.\n        let mut final_acceleration = (0, 0, 0);\n\
    \        // A counter used to control the number of iterations.\n        let mut\
    \ iteration_count = 0;\n        // Create a list of cars to simulate the movement\
    \ of n cars.\n        let mut car_coordinates: Vec<(usize, usize, usize, usize)>\
    \ = Vec::new();\n        // Create a list of the cars currently in the simulation.\n\
    \        let mut cars_in_sim: Vec<usize> = Vec::new();\n        // Loop from 0\
    \ to n to simulate n moves.\n        for i in 0..n {\n            // Randomly\
    \ decide which car to move next.\n            let random_car_index = rand::random::<usize>();\n\
    \            // Randomly decide which direction to move the car in.\n        \
    \    let random_direction = rand::random::<usize>();\n            // Set the car's\
    \ initial position.\n            let initial_position = Vec::new();\n        \
    \    car_coordinates.push(initial_position);\n            cars_in_sim.push(i);\n\
    \            // Set the car's initial velocity.\n            let initial_velocity\
    \ = Vec::new();\n            car_coordinates.push(initial_velocity);\n       \
    \     cars_in_sim.push(i);\n            // Set the car's initial acceleration.\n\
    \            let initial_acceleration = Vec::new();\n            car_coordinates.push(initial_acceleration);\n\
    \            cars_in_sim.push(i);\n            // Set the car's final position.\n\
    \            let final_position = Vec::new();\n            car_coordinates.push(final_position);\n\
    \            cars_in_sim.push(i);\n            // Set the car's final velocity.\n\
    \            let final_velocity = Vec::new();\n            car_coordinates.push(final_velocity);\n\
    \            cars_in_sim.push(i);\n            // Set the car's final acceleration.\n\
    \            let final_acceleration = Vec::new();\n            car_coordinates.push(final_acceleration);\n\
    \            cars_in_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptns0anp8.rs:73:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n14 |     while collision_count\
    \ < collision_limit {\n   |                                             - unclosed\
    \ delimiter\n...\n35 |         for i in 0..n {\n   |                       - this\
    \ delimiter might not be properly closed...\n...\n64 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n73 | }\n   |   ^\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmptns0anp8.rs:37:36\n\
    \   |\n37 |             let random_car_index = rand::random::<usize>();\n   |\
    \                                    ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmptns0anp8.rs:39:36\n   |\n39 |             let random_direction\
    \ = rand::random::<usize>();\n   |                                    ^^^^ use\
    \ of undeclared crate or module `rand`\n\nerror[E0425]: cannot find value `cars_in_`\
    \ in this scope\n  --> /tmp/tmptns0anp8.rs:63:13\n   |\n63 |             cars_in_\n\
    \   |             ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptns0anp8.rs:42:34\n   |\n42 |             car_coordinates.push(initial_position);\n\
    \   |                                  ^^^^^^^^^^^^^^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected tuple `(usize, usize, usize, usize)`\n\
    \             found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptns0anp8.rs:43:30\n\
    \   |\n43 |             cars_in_sim.push(i);\n   |                           \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n43 |      \
    \       cars_in_sim.push(i.try_into().unwrap());\n   |                       \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptns0anp8.rs:46:34\n\
    \   |\n46 |             car_coordinates.push(initial_velocit"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut distance_from_left_to_right\
    \ = 2 * PI;\n\n    for _ in 0..n {\n        let angle = (PI * 2.) - distance_from_left_to_right;\n\
    \        let distance = distance_from_left_to_right + sin(angle);\n\n        if\
    \ distance_from_left_to_right > 2 * PI {\n            distance_from_left_to_right\
    \ -= PI;\n        } else {\n            distance_from_left_to_right += PI;\n \
    \       }\n\n        if distance(distance_from_left_to_right) < distance {\n \
    \           counter += 1;\n        }\n\n        distance_from_left_to_right +=\
    \ PI;\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `PI` in this scope\n  --> /tmp/tmpoaozxxss.rs:11:47\n\
    \   |\n11 |     let mut distance_from_left_to_right = 2 * PI;\n   |          \
    \                                     ^^ not found in this scope\n   |\nhelp:\
    \ consider importing one of these items\n   |\n1  | use std::f32::consts::PI;\n\
    \   |\n1  | use std::f64::consts::PI;\n   |\n\nerror[E0425]: cannot find value\
    \ `PI` in this scope\n  --> /tmp/tmpoaozxxss.rs:14:22\n   |\n14 |         let\
    \ angle = (PI * 2.) - distance_from_left_to_right;\n   |                     \
    \ ^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::f32::consts::PI;\n   |\n1  | use std::f64::consts::PI;\n\
    \   |\n\nerror[E0425]: cannot find function `sin` in this scope\n  --> /tmp/tmpoaozxxss.rs:15:54\n\
    \   |\n15 |         let distance = distance_from_left_to_right + sin(angle);\n\
    \   |                                                      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `PI` in this scope\n  --> /tmp/tmpoaozxxss.rs:17:46\n\
    \   |\n17 |         if distance_from_left_to_right > 2 * PI {\n   |          \
    \                                    ^^ not found in this scope\n   |\nhelp: consider\
    \ importing one of these items\n   |\n1  | use std::f32::consts::PI;\n   |\n1\
    \  | use std::f64::consts::PI;\n   |\n\nerror[E0425]: cannot find value `PI` in\
    \ this scope\n  --> /tmp/tmpoaozxxss.rs:18:44\n   |\n18 |             distance_from_left_to_right\
    \ -= PI;\n   |                                            ^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::f32::consts::PI;\n\
    \   |\n1  | use std::f64::consts::PI;\n   |\n\nerror[E0425]: cannot find value\
    \ `PI` in this scope\n  --> /tmp/tmpoaozxxss.rs:20:44\n   |\n20 |            \
    \ distance_from_left_to_right += PI;\n   |                                   \
    \         ^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::f32::consts::PI;\n   |\n1  | use std::f64::consts::PI;\n\
    \   |\n\nerror[E0425]: cannot find value `PI` in this scope\n  --> /tmp/tmpoaozxxss.rs:27:40\n\
    \   "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n_cars = n;\n    let mut collisions = 0;\n\n\
    \    // Initialize all cars to moving right to left.\n    let mut initial_speed\
    \ = 1;\n    for _ in 0..n_cars {\n        initial_speed *= 2;\n        collisions\
    \ += car_collision(initial_speed);\n    }\n\n    // At this point, the two sets\
    \ of cars are colliding.  We need to find which\n    // of them collide.\n   \
    \ while n_cars > 1 {\n        let mut new_speed = initial_speed;\n        while\
    \ new_speed >= 2 * collisions {\n            new_speed /= 2;\n            collisions\
    \ += car_collision(new_speed);\n        }\n        initial_speed = new_speed;\n\
    \        n_cars /= 2;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmp9lz95qvm.rs:17:23\n   |\n17 |         collisions += car_collision(initial_speed);\n\
    \   |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmp9lz95qvm.rs:26:27\n\
    \   |\n26 |             collisions += car_collision(new_speed);\n   |        \
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    // Initialize an array of\
    \ distances between each pair of cars.\n    let mut dist_arr: [isize; n + 1] =\
    \ Default::default();\n    for i in 0..n - 1 {\n        for j in (i + 1)..n {\n\
    \            let d = std::f64::hypot(car_dist_arr(i, j, n, n));\n            dist_arr[i\
    \ + j as usize] = d;\n        }\n    }\n\n    // Find the minimum distance between\
    \ two cars.\n    let mut min_dist = dist_arr[0];\n    for i in 1..n {\n      \
    \  if dist_arr[i] < min_dist {\n            min_dist = dist_arr[i];\n        }\n\
    \    }\n\n    // For each pair of cars, compare them against each other to see\
    \ if they collide.\n    for i in 0..n - 1 {\n        for j in (i + 1)..n {\n \
    \           let d = dist_arr[i + j as usize];\n            let a = car_dist_arr(i,\
    \ j, n, n);\n            let b = car_dist_arr(j, i, n, n);\n            if d <\
    \ min_dist {\n                let collision = is_collision(a, b);\n          \
    \      if collision {\n                    collisions += 1;\n                }\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpr1ooyk52.rs:12:31\n   |\n9  | fn car_race_collision(n: isize) -> isize\
    \ {\n   |                       - this would need to be a `const`\n...\n12 | \
    \    let mut dist_arr: [isize; n + 1] = Default::default();\n   |            \
    \                   ^\n\nerror[E0425]: cannot find function `hypot` in module\
    \ `std::f64`\n  --> /tmp/tmpr1ooyk52.rs:15:31\n   |\n15 |             let d =\
    \ std::f64::hypot(car_dist_arr(i, j, n, n));\n   |                           \
    \    ^^^^^ not found in `std::f64`\n\nerror[E0425]: cannot find function `car_dist_arr`\
    \ in this scope\n  --> /tmp/tmpr1ooyk52.rs:15:37\n   |\n15 |             let d\
    \ = std::f64::hypot(car_dist_arr(i, j, n, n));\n   |                         \
    \            ^^^^^^^^^^^^ help: a local variable with a similar name exists: `dist_arr`\n\
    \nerror[E0425]: cannot find function `car_dist_arr` in this scope\n  --> /tmp/tmpr1ooyk52.rs:32:21\n\
    \   |\n32 |             let a = car_dist_arr(i, j, n, n);\n   |              \
    \       ^^^^^^^^^^^^ help: a local variable with a similar name exists: `dist_arr`\n\
    \nerror[E0425]: cannot find function `car_dist_arr` in this scope\n  --> /tmp/tmpr1ooyk52.rs:33:21\n\
    \   |\n33 |             let b = car_dist_arr(j, i, n, n);\n   |              \
    \       ^^^^^^^^^^^^ help: a local variable with a similar name exists: `dist_arr`\n\
    \nerror[E0425]: cannot find function `is_collision` in this scope\n  --> /tmp/tmpr1ooyk52.rs:35:33\n\
    \   |\n35 |                 let collision = is_collision(a, b);\n   |        \
    \                         ^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `collisions`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr1ooyk52.rs:16:26\n\
    \   |\n16 |             dist_arr[i + j as usize] = d;\n   |                  \
    \        ^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot add\
    \ `usize` to `isize`\n  --> /tmp/tmpr1ooyk52.rs:16:24\n   |\n16 |            \
    \ dist_arr[i + j as usize] = d;\n   |                        ^ no implementation\
    \ for `isize + usize`\n   |\n   = help: the trait `Add<usize>` is not i"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions: isize = 0;\n    let mut speed: isize\
    \ = -1;\n    let mut prev_speed = -1;\n    let mut left_to_right = true;\n\n \
    \   fn update(car_speed: isize, prev_speed: isize) -> isize {\n        let mut\
    \ new_speed = prev_speed + car_speed;\n        prev_speed = new_speed;\n     \
    \   new_speed\n    }\n\n    for _ in range(n * (n - 1) / 2) {\n        if left_to_right\
    \ {\n            for _ in 0..n {\n                speed += 1;\n              \
    \  if speed > 1000 {\n                    collisions += 1;\n                 \
    \   speed = -1;\n                }\n                let new_speed = update(speed,\
    \ prev_speed);\n                if left_to_right == new_speed {\n            \
    \        left_to_right = false;\n                }\n            }\n        } else\
    \ {\n            for _ in 0..n {\n                speed += 1;\n              \
    \  if speed > 1000 {\n                    collisions += 1;\n                 \
    \   speed = -1;\n                }\n                let new_speed = update(speed,\
    \ prev_speed);\n                if left_to_right == new_speed {\n            \
    \        left_to_right = true;\n                }\n            }\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpz0kywjg8.rs:21:14\n\
    \   |\n21 |     for _ in range(n * (n - 1) / 2) {\n   |              ^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::slice::range;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz0kywjg8.rs:30:37\n\
    \   |\n30 |                 if left_to_right == new_speed {\n   |            \
    \                         ^^^^^^^^^ expected `bool`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz0kywjg8.rs:42:37\n   |\n42 |              \
    \   if left_to_right == new_speed {\n   |                                    \
    \ ^^^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_race_collisions = n as isize;\n    loop {\n\
    \        let mut collisions: Vec<&[Car]> = vec![vec![0; n] as &[Car]];\n     \
    \   for mut race in car_races {\n            for car_race in race {\n        \
    \        let mut collision = &mut collisions[car_race];\n                for mut\
    \ car in car_race {\n                    if car.position().x < car_race.position().x\
    \ {\n                        let collision_index = collision.len() - 1;\n    \
    \                    collision.insert((collision_index as usize), &[car]);\n \
    \                   } else if car_race.position().x > car.position().x {\n   \
    \                     let collision_index = collision.len() - 1;\n           \
    \             collision.insert((collision_index as usize), &[car]);\n        \
    \            }\n                }\n            }\n        }\n        for mut collision\
    \ in collisions {\n            if collision.len() > 1 {\n                car_race_collisions\
    \ += 1;\n            }\n        }\n    }\n    car_race_collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Car` in this scope\n  --> /tmp/tmph40ogcqa.rs:12:35\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \     - help: you might be missing a type parameter: `<Car>`\n...\n12 |      \
    \   let mut collisions: Vec<&[Car]> = vec![vec![0; n] as &[Car]];\n   |      \
    \                             ^^^ not found in this scope\n\nerror[E0412]: cannot\
    \ find type `Car` in this scope\n  --> /tmp/tmph40ogcqa.rs:12:64\n   |\n12 | \
    \        let mut collisions: Vec<&[Car]> = vec![vec![0; n] as &[Car]];\n   | \
    \                                                               ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `car_races` in this scope\n\
    \  --> /tmp/tmph40ogcqa.rs:13:25\n   |\n13 |         for mut race in car_races\
    \ {\n   |                         ^^^^^^^^^ not found in this scope\n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmph40ogcqa.rs:19:42\n\
    \   |\n19 |                         collision.insert((collision_index as usize),\
    \ &[car]);\n   |                                          ^                  \
    \      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n19 -                         collision.insert((collision_index\
    \ as usize), &[car]);\n19 +                         collision.insert(collision_index\
    \ as usize, &[car]);\n   | \n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmph40ogcqa.rs:22:42\n   |\n22 |                      \
    \   collision.insert((collision_index as usize), &[car]);\n   |              \
    \                            ^                        ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n22 -                         collision.insert((collision_index\
    \ as usize), &[car]);\n22 +                         collision.insert(collision_index\
    \ as usize, &[car]);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmph40ogcqa.rs:12:56\n\
    \   |\n12 |         let mut collisions: Vec<&[Car]> = vec![vec![0; n] as &[Car]];\n\
    \   |                                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you "
  stdout: ''
  timestamp: 1659977939
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n\n    let mut cars = vec![];\n\
    \    let mut cars_right = vec![];\n\n    // First we create cars moving left\n\
    \    for (i, direction) in DIRECTIONS.iter().enumerate() {\n        cars.push(Car::new(i,\
    \ direction));\n    }\n\n    // Now we create cars moving right\n    for (i, direction)\
    \ in DIRECTIONS.iter().rev() {\n        cars_right.push(Car::new(i, direction));\n\
    \    }\n\n    // The cars move left-to-right for n cycles while colliding.\n \
    \   for (i, direction) in DIRECTIONS.iter().enumerate() {\n        let mut c =\
    \ cars[i];\n\n        // Move and detect collisions\n        c.move();\n\n   \
    \     if c.is_colliding(&mut cars_right) {\n            collisions += 1;\n\n \
    \           c.set_direction(Direction::Right);\n        } else {\n           \
    \ cars_right.push(c);\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `move`\n  --> /tmp/tmpfq4i53dd.rs:30:11\n\
    \   |\n30 |         c.move();\n   |           ^^^^ expected identifier, found\
    \ keyword\n   |\nhelp: escape `move` to use it as an identifier\n   |\n30 |  \
    \       c.r#move();\n   |           ++\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Car`\n  --> /tmp/tmpfq4i53dd.rs:17:19\n   |\n17 |      \
    \   cars.push(Car::new(i, direction));\n   |                   ^^^ use of undeclared\
    \ type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n\
    \  --> /tmp/tmpfq4i53dd.rs:22:25\n   |\n22 |         cars_right.push(Car::new(i,\
    \ direction));\n   |                         ^^^ use of undeclared type `Car`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpfq4i53dd.rs:35:29\n\
    \   |\n35 |             c.set_direction(Direction::Right);\n   |             \
    \                ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0425]:\
    \ cannot find value `DIRECTIONS` in this scope\n  --> /tmp/tmpfq4i53dd.rs:16:27\n\
    \   |\n16 |     for (i, direction) in DIRECTIONS.iter().enumerate() {\n   |  \
    \                         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `DIRECTIONS` in this scope\n  --> /tmp/tmpfq4i53dd.rs:21:27\n\
    \   |\n21 |     for (i, direction) in DIRECTIONS.iter().rev() {\n   |        \
    \                   ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `DIRECTIONS` in this scope\n  --> /tmp/tmpfq4i53dd.rs:26:27\n   |\n\
    26 |     for (i, direction) in DIRECTIONS.iter().enumerate() {\n   |         \
    \                  ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 7 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The first \"racing\" set is identical to the \"collision\"\
    \ set.\n    let race_1 = make_racing(n);\n    // The second racing set is a subset\
    \ of \"collision\".\n    let race_2 = make_racing(n);\n    // The second racing\
    \ set has collisions removed from the collision set.\n    let race_2_1 = make_racing(n);\n\
    \n    let collision_count = race_1\n        .iter()\n        .rev()\n        .zip(race_2_1.iter().rev())\n\
    \        .count(|(a, b)| a.x == b.x && a.y == b.y);\n    collision_count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `make_racing` in this scope\n  --> /tmp/tmpk49hgqtl.rs:11:18\n\
    \   |\n11 |     let race_1 = make_racing(n);\n   |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `make_racing`\
    \ in this scope\n  --> /tmp/tmpk49hgqtl.rs:13:18\n   |\n13 |     let race_2 =\
    \ make_racing(n);\n   |                  ^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `make_racing` in this scope\n  --> /tmp/tmpk49hgqtl.rs:15:20\n\
    \   |\n15 |     let race_2_1 = make_racing(n);\n   |                    ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if i != j && car_collision(i, j) {\n          \
    \      collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp8cvj4k59.rs:10:27\n\
    \   |\n10 |     let mut collisions = 0\n   |                           ^ help:\
    \ add `;` here\n11 |     for i in 0..n {\n   |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find function `car_collision` in this scope\n  --> /tmp/tmp8cvj4k59.rs:13:26\n\
    \   |\n13 |             if i != j && car_collision(i, j) {\n   |             \
    \             ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n_cars_collide = 0;\n    // The starting point\
    \ is (0, 0)\n    let mut x = 0.;\n    let mut y = 0.;\n    // The destination\
    \ point is (0, 0)\n    let mut x_dest = 0.;\n    let mut y_dest = 0.;\n\n    //\
    \ The point (last_x, last_y) is the point that the last collision occurred.\n\
    \    let mut last_x = 0.;\n    let mut last_y = 0.;\n\n    // Set up the cars\n\
    \    for _ in 0..n {\n        let car_radius = 0.2;\n        // Get a random starting\
    \ point.\n        let mut x = get_random_float(-car_radius, car_radius);\n   \
    \     let mut y = get_random_float(-car_radius, car_radius);\n\n        // Get\
    \ a random destination point.\n        let mut x_dest = get_random_float(-car_radius,\
    \ car_radius);\n        let mut y_dest = get_random_float(-car_radius, car_radius);\n\
    \n        // Set up the car.\n        let car = Car::new(\n            Car::State::new(Position::new(x,\
    \ y, 0.)),\n            Car::State::new(Position::new(x_dest, y_dest, 0.)),\n\
    \        );\n        // Set the car's initial speed and acceleration.\n      \
    \  car.acceleration = 1.0;\n        car.speed = 1.0;\n        // Add it to the\
    \ list.\n        car_manager.add_car(car);\n        // Keep track of the last\
    \ collision.\n        last_x = x;\n        last_y = y;\n    }\n\n    // Simulate\
    \ the cars\n    for _ in 0..n {\n        // Get a random starting point.\n   \
    \     let mut x = get_random_float(-car_radius, car_radius);\n        let mut\
    \ y = get_random_float(-car_radius, car_radius);\n\n        // Get a random destination\
    \ point.\n        let mut x_dest = get_random_float(-car_radius, car_radius);\n\
    \        let mut y_dest = get_random_float(-car_radius, car_radius);\n\n     \
    \   // Update their position\n        if car_manager.cars.iter().any(|c| c.state\
    \ == Car::State::new(Position::new(x, y, 0.))) {\n            x = get_random_float(-car_radius,\
    \ car_radius);\n            y = get_random_float(-car_radius, car_radius);\n \
    \       }\n        if car_manager.cars.iter().any(|c| c.state == Car::State::new(Position::new(x_dest,\
    \ y_dest, 0.))) {\n            x_dest = get_random_float(-car_radius, car_radius);\n\
    \            y_dest = get_random_float(-car_radius, car_radius);\n        }\n\n\
    \        // Set up the car.\n        let car = Car::\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp17wqrt31.rs:79:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n49 |     for _ in 0..n {\n\
    \   |                   - this delimiter might not be properly closed...\n...\n\
    70 | }\n   | - ...as it matches this but it has different indentation\n...\n79\
    \ | }\n   |   ^\n\nerror: expected identifier, found `}`\n  --> /tmp/tmp17wqrt31.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Car`\n  --> /tmp/tmp17wqrt31.rs:34:19\n   |\n34 |  \
    \       let car = Car::new(\n   |                   ^^^ use of undeclared type\
    \ `Car`\n\nerror[E0433]: failed to resolve: use of undeclared type `Car`\n  -->\
    \ /tmp/tmp17wqrt31.rs:35:13\n   |\n35 |             Car::State::new(Position::new(x,\
    \ y, 0.)),\n   |             ^^^ use of undeclared type `Car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Position`\n  --> /tmp/tmp17wqrt31.rs:35:29\n\
    \   |\n35 |             Car::State::new(Position::new(x, y, 0.)),\n   |      \
    \                       ^^^^^^^^ use of undeclared type `Position`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp17wqrt31.rs:36:13\n\
    \   |\n36 |             Car::State::new(Position::new(x_dest, y_dest, 0.)),\n\
    \   |             ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Position`\n  --> /tmp/tmp17wqrt31.rs:36:29\n\
    \   |\n36 |             Car::State::new(Position::new(x_dest, y_dest, 0.)),\n\
    \   |                             ^^^^^^^^ use of undeclared type `Position`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmp17wqrt31.rs:59:55\n\
    \   |\n59 |         if car_manager.cars.iter().any(|c| c.state == Car::State::new(Position::new(x,\
    \ y, 0.))) {\n   |                                                       ^^^ use\
    \ of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Position`\n  --> /tmp/tmp17wqrt31.rs:59:71\n   |\n59 |         if car_manager.cars.iter()"
  stdout: ''
  timestamp: 1659977940
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n * (n - 1)) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpng6l2ozr.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n\n    // initialize left\
    \ and right neighbors\n    let mut left = 0;\n    let mut right = 0;\n    for\
    \ _ in 0..n {\n        if left == n {\n            left += 1;\n        } else\
    \ {\n            left += 1;\n        }\n        if right == n {\n            right\
    \ += 1;\n        } else {\n            right += 1;\n        }\n    }\n\n    //\
    \ calculate race length\n    let mut length = 0.;\n    for _ in 0..n {\n     \
    \   length += powf(100., (left - right) / 2.);\n        left += 1;\n        right\
    \ += 1;\n    }\n\n    // set starting position\n    let mut initial_position =\
    \ vec![vec!(0., 10.)];\n\n    // while there are still collisions\n    // for\
    \ _ in 0..n {\n    while length > 0.1 {\n        // get velocity in both directions\n\
    \        let mut velocity = initial_position\n            .iter_mut()\n      \
    \      .map(|x| x * 2.)\n            .collect::<Vec<_>>();\n\n        // for each\
    \ collision\n        for _ in 0..n {\n            // get new velocity after collision\n\
    \            let new_velocity = initial_position\n                .iter()\n  \
    \              .map(|x| x + velocity.map(|y| y / 4.))\n                .collect::<Vec<_>>();\n\
    \n            // if the new velocity is shorter than the old velocity\n      \
    \      // then the collision has occurred\n            if new_velocity.len() <\
    \ velocity.len() {\n                // increment count of collisions\n       \
    \         num_collisions += 1;\n                // set the new position\n    \
    \            initial_position = new_velocity;\n                // reset velocity\n\
    \                velocity = initial_position\n                    .iter_mut()\n\
    \                    .map(|x| x * 2.)\n                    .collect::<Vec<_>>();\n\
    \                // reset right and left\n                right = left;\n    \
    \            left = 0;\n                // decrement length\n                length\
    \ -= powf(100., (left - right) / 2.);\n            }\n        }\n    }\n\n   \
    \ // return the number of collisions\n    num_collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in this scope\n  --> /tmp/tmpc1ac0hwo.rs:31:19\n\
    \   |\n31 |         length += powf(100., (left - right) / 2.);\n   |         \
    \          ^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `powf` in this scope\n  --> /tmp/tmpc1ac0hwo.rs:72:27\n   |\n72 |          \
    \       length -= powf(100., (left - right) / 2.);\n   |                     \
    \      ^^^^ not found in this scope\n\nerror[E0277]: cannot divide `isize` by\
    \ `{float}`\n  --> /tmp/tmpc1ac0hwo.rs:31:45\n   |\n31 |         length += powf(100.,\
    \ (left - right) / 2.);\n   |                                             ^ no\
    \ implementation for `isize / {float}`\n   |\n   = help: the trait `Div<{float}>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n             <&'a f64\
    \ as Div<f64>>\n             <&'a i128 as Div<i128>>\n             <&'a i16 as\
    \ Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n\
    \             <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n  \
    \         and 54 others\n\nerror[E0369]: cannot multiply `&mut Vec<{float}>` by\
    \ `{float}`\n  --> /tmp/tmpc1ac0hwo.rs:45:24\n   |\n45 |             .map(|x|\
    \ x * 2.)\n   |                      - ^ -- {float}\n   |                    \
    \  |\n   |                      &mut Vec<{float}>\n\nerror[E0599]: `Vec<_>` is\
    \ not an iterator\n   --> /tmp/tmpc1ac0hwo.rs:53:39\n    |\n53  |            \
    \       .map(|x| x + velocity.map(|y| y / 4.))\n    |                        \
    \                 ^^^ `Vec<_>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n         \
    \   which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n\
    \            which is required by `&mut [_]: Iterator`\n\nerror[E0369]: cannot\
    \ multiply `&mut Vec<{float}>` by `{float}`\n  --> /tmp/tmpc1ac0hwo.rs:66:32\n\
    \   |\n66 |                     .map(|x| x * 2.)\n   |                       \
    \       - ^ -- {float}\n   |                              |\n   |           "
  stdout: ''
  timestamp: 1659977940
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    2 * n + (2 * n * (n - 1)) / 2\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmpuvm00vbb.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize n to 1.\n    // We want to count a collision\
    \ when there's at least two cars in the same\n    // position.  So, we only do\
    \ n += 1 when there's at least two cars going left.\n    // The other cars are\
    \ just going to get stuck between one another.\n    let mut count = 0;\n    for\
    \ _ in 0..n {\n        count += 1;\n    }\n\n    // Do n += 1 for each car.\n\
    \    for _ in 0..n {\n        count += 1;\n    }\n\n    // Do another n += 1 for\
    \ every car.\n    for _ in 0..n {\n        count += 1;\n    }\n\n    // Do n*(n+1)\
    \ += 1 for each car.\n    for _ in 0..n {\n        for _ in 0..n {\n         \
    \   count += 1;\n        }\n    }\n\n    // Do n*(n+1)*(n+2) += 1 for each car.\n\
    \    for _ in 0..n {\n        for _ in 0..n {\n            for _ in 0..n {\n \
    \               count += 1;\n            }\n        }\n    }\n\n    // Do n*(n+1)*(n+2)*(n+3)\
    \ += 1 for each car.\n    for _ in 0..n {\n        for _ in 0..n {\n         \
    \   for _ in 0..n {\n                for _ in 0..n {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n\n    count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `34`,\n right: `4`', /tmp/tmp_vst8dmd.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The next steps are based on some mathematical formulas\
    \ which can be found in\n    // the Wikipedia article [link](https://en.wikipedia.org/wiki/Collision_detection#Collision_detection_in_Stepik_Mathematics\n\
    \    // ).  In the case of the two cars above we have n = 3.  Therefore the formula\
    \ is:\n    // \n    //     C = (M * M) + (N * N)\n    //\n    // where M = M(n-1)\
    \ and N = N(n-1)\n    //\n    // The result is C = 3 * (3 * 3 + 1) / 2 = 9\n \
    \   //\n    // The next step is to find M and N.  We can do this by simply looking\
    \ at what happens\n    // when one car is moving left to right and another car\
    \ is moving right to left.  Since\n    // the cars continue to move in the same\
    \ direction, we can use the fact that they were\n    // originally moving left\
    \ to right to find the speed of the cars they just landed on to\n    // the right\
    \ of the starting car.\n    let mut car_speeds: Vec<_> = vec![0; n];\n    let\
    \ mut car_speed = car_speeds[0];\n    let mut car_speeds_right = vec![0; n];\n\
    \    let mut car_speeds_left = vec![0; n];\n\n    for car_left in 0..n {\n   \
    \     car_speeds[car_left] = car_left;\n        car_speeds_right[car_left] = car_left;\n\
    \    }\n\n    for car_right in 0..n {\n        car_speeds[car_right] = car_right;\n\
    \        car_speeds_left[car_right] = car_right;\n    }\n\n    for _ in 0..n {\n\
    \        let mut collisions = 0;\n        for car_left in 0..n {\n           \
    \ for car_right in 0..n {\n                if car_speeds[car_left] > car_speeds[car_right]\
    \ {\n                    if car_speed == car_speeds[car_left] {\n            \
    \            car_speed += 1;\n                        collisions += 1;\n     \
    \               }\n                } else {\n                    if car_speed\
    \ == car_speeds[car_right] {\n                        car_speed += 1;\n      \
    \                  collisions += 1;\n                    }\n                }\n\
    \            }\n        }\n\n        if collisions > 0 {\n            return collisions;\n\
    \        }\n    }\n\n    return 0;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnx4q02fi.rs:25:42\n   |\n\
    25 |     let mut car_speeds: Vec<_> = vec![0; n];\n   |                      \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    25 |     let mut car_speeds: Vec<_> = vec![0; n.try_into().unwrap()];\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnx4q02fi.rs:27:40\n   |\n27 |     let mut car_speeds_right\
    \ = vec![0; n];\n   |                                        ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |     let mut car_speeds_right\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnx4q02fi.rs:28:39\n\
    \   |\n28 |     let mut car_speeds_left = vec![0; n];\n   |                  \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    28 |     let mut car_speeds_left = vec![0; n.try_into().unwrap()];\n   |     \
    \                                   ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnx4q02fi.rs:31:9\n\
    \   |\n31 |         car_speeds[car_left] = car_left;\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `isize`\n  --> /tmp/tmpnx4q02fi.rs:32:9\n\
    \   |\n32 |         car_speeds_right[car_left] = car_left;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut sum = 0;\n\n    for _ in 0..n {\n        let\
    \ mut car_pos = vec![vec![1.0; CAR_POS_CHANNEL_DIM]; CAR_NUM_CHANNELS];\n\n  \
    \      for _ in 0..CAR_NUM_CHANNELS {\n            car_pos[_] = vec![];\n    \
    \    }\n\n        for _ in 0..CAR_NUM_CHANNELS {\n            car_pos[_].push(vec![vec![0.;\
    \ CAR_VELOCITY_CHANNEL_DIM]]);\n        }\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            car_pos[_].push(vec![vec![0.; CAR_ACCELERATION_CHANNEL_DIM]]);\n\
    \        }\n\n        let mut last_car_pos = vec![];\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            last_car_pos.push(vec![vec![0.; CAR_VELOCITY_CHANNEL_DIM]]);\n\
    \        }\n\n        let mut last_car_speed = vec![];\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            last_car_speed.push(vec![0.]);\n        }\n\n        for _ in\
    \ 0..CAR_NUM_CHANNELS {\n            last_car_speed.push(vec![0.]);\n        }\n\
    \n        let mut last_car_acc = vec![];\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            last_car_acc.push(vec![0.]);\n        }\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            last_car_acc.push(vec![0.]);\n        }\n\n        for _ in 0..CAR_NUM_CHANNELS\
    \ {\n            sum += car_race_collision_body(&mut car_pos, &mut last_car_pos,\
    \ &mut last_car_speed, &mut last_car_acc, &mut last_car_acc);\n        }\n   \
    \ }\n\n    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `CAR_POS_CHANNEL_DIM` in this scope\n \
    \ --> /tmp/tmp2yv6p0m8.rs:13:42\n   |\n13 |         let mut car_pos = vec![vec![1.0;\
    \ CAR_POS_CHANNEL_DIM]; CAR_NUM_CHANNELS];\n   |                             \
    \             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `CAR_NUM_CHANNELS` in this scope\n  --> /tmp/tmp2yv6p0m8.rs:13:64\n\
    \   |\n13 |         let mut car_pos = vec![vec![1.0; CAR_POS_CHANNEL_DIM]; CAR_NUM_CHANNELS];\n\
    \   |                                                                ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CAR_NUM_CHANNELS`\
    \ in this scope\n  --> /tmp/tmp2yv6p0m8.rs:15:21\n   |\n15 |         for _ in\
    \ 0..CAR_NUM_CHANNELS {\n   |                     ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `CAR_NUM_CHANNELS` in this scope\n\
    \  --> /tmp/tmp2yv6p0m8.rs:19:21\n   |\n19 |         for _ in 0..CAR_NUM_CHANNELS\
    \ {\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR_VELOCITY_CHANNEL_DIM` in this scope\n  --> /tmp/tmp2yv6p0m8.rs:20:43\n\
    \   |\n20 |             car_pos[_].push(vec![vec![0.; CAR_VELOCITY_CHANNEL_DIM]]);\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `CAR_NUM_CHANNELS` in this\
    \ scope\n  --> /tmp/tmp2yv6p0m8.rs:23:21\n   |\n23 |         for _ in 0..CAR_NUM_CHANNELS\
    \ {\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR_ACCELERATION_CHANNEL_DIM` in this scope\n  --> /tmp/tmp2yv6p0m8.rs:24:43\n\
    \   |\n24 |             car_pos[_].push(vec![vec![0.; CAR_ACCELERATION_CHANNEL_DIM]]);\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `CAR_NUM_CHANNELS` in\
    \ this scope\n  --> /tmp/tmp2yv6p0m8.rs:29:21\n   |\n29 |         for _ in 0..CAR_NUM_CHANNELS\
    \ {\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `CAR"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 1;\n    for &i in &[1..n] {\n  \
    \      for &j in &[1..n] {\n            if i != j && car_race_collision(n - i)\
    \ + car_race_collision(n - j) + 1 > collisions {\n                collisions =\
    \ car_race_collision(n - i) + car_race_collision(n - j) + 1;\n            }\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `std::ops::Range<isize>` from `isize`\n \
    \ --> /tmp/tmpmibef_89.rs:13:47\n   |\n13 |             if i != j && car_race_collision(n\
    \ - i) + car_race_collision(n - j) + 1 > collisions {\n   |                  \
    \                             ^ no implementation for `isize - std::ops::Range<isize>`\n\
    \   |\n   = help: the trait `Sub<std::ops::Range<isize>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: cannot subtract `std::ops::Range<isize>` from `isize`\n\
    \  --> /tmp/tmpmibef_89.rs:13:75\n   |\n13 |             if i != j && car_race_collision(n\
    \ - i) + car_race_collision(n - j) + 1 > collisions {\n   |                  \
    \                                                         ^ no implementation\
    \ for `isize - std::ops::Range<isize>`\n   |\n   = help: the trait `Sub<std::ops::Range<isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: cannot subtract `std::ops::Range<isize>`\
    \ from `isize`\n  --> /tmp/tmpmibef_89.rs:14:51\n   |\n14 |                 collisions\
    \ = car_race_collision(n - i) + car_race_collision(n - j) + 1;\n   |         \
    \                                          ^ no implementation for `isize - std::ops::Range<isize>`\n\
    \   |\n   = help: the trait `Sub<std::ops::Range<isize>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \  "
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut c = 0 as usize;\n\
    \    let mut d = n - 1;\n    while c < n && d >= 0 {\n        collision_count\
    \ += 1;\n        if c + d < n {\n            c += 1;\n            d -= 1;\n  \
    \      } else {\n            c += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5f7d9ct.rs:13:15\n   |\n\
    13 |     while c < n && d >= 0 {\n   |               ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |     while c < n.try_into().unwrap()\
    \ && d >= 0 {\n   |                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk5f7d9ct.rs:15:16\n   |\n15 |         if c + d < n {\n\
    \   |                ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmpk5f7d9ct.rs:15:14\n   |\n15 |        \
    \ if c + d < n {\n   |              ^ no implementation for `usize + isize`\n\
    \   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Add<Rhs>`:\n             <&'a\
    \ f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128\
    \ as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as\
    \ Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk5f7d9ct.rs:15:20\n   |\n15 |         if c +\
    \ d < n {\n   |                    ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         if c + d < n.try_into().unwrap() {\n   |           \
    \          ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut sum = 0;\n    let mut collisions = 0;\n    let\
    \ mut speed_left: i32 = 0;\n    let mut speed_right: i32 = 0;\n\n    for _ in\
    \ 0..n {\n        // Calculate the speed and direction of the car.\n        let\
    \ car_direction = if n % 2 == 0 {\n            1\n        } else {\n         \
    \   -1\n        };\n\n        let car_speed = if n % 2 == 0 {\n            1\n\
    \        } else {\n            -1\n        };\n\n        // Calculate the position\
    \ of the next car.\n        let car_x = speed_left * car_direction;\n        let\
    \ car_y = speed_right * car_direction;\n        let car_len = car_x * car_x +\
    \ car_y * car_y;\n        let car_speed = car_len / 2.0;\n        let car_direction\
    \ = car_x / car_speed;\n        let car_length = car_x / car_speed + car_y / car_speed;\n\
    \n        // Check if car_speed is greater than 0, meaning the car is moving right\n\
    \        // or left in the next iteration.\n        if car_speed > 0.0 {\n   \
    \         // If the cars are colliding, increment collisions.\n            if\
    \ car_x * speed_left > car_y * speed_right {\n                collisions += 1;\n\
    \            }\n            // If the cars are moving right to left, increment\
    \ speed_left to\n            // car_speed.  If the cars are moving left to right,\
    \ increment speed_right\n            // to car_speed.\n            speed_left\
    \ += car_speed;\n            speed_right += car_speed;\n        } else {\n   \
    \         // If the cars are colliding, increment collisions.\n            if\
    \ car_x * speed_right > car_y * speed_left {\n                collisions += 1;\n\
    \            }\n            // If the cars are moving left to right, increment\
    \ speed_right to\n            // car_speed.  If the cars are moving right to left,\
    \ increment speed_left\n            // to car_speed.\n            speed_left +=\
    \ car_speed;\n            speed_right += car_speed;\n        }\n\n        // Update\
    \ the position of the next car using the current speed.\n        speed_left +=\
    \ car_speed * car_direction;\n        speed_right += car_speed * car_direction;\n\
    \n        // Update the speed of the cars based on the current position of the\n\
    \        // cars.\n        speed_left += car_direction * car_length;\n       \
    \ speed_right += car_direction * car_length;\n\n        // Add current speed to\
    \ the sum.\n        sum += car_speed;\n    }\n\n    // Return the number of collisions.\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `i32` by `{float}`\n  --> /tmp/tmptfhqzeqp.rs:33:33\n\
    \   |\n33 |         let car_speed = car_len / 2.0;\n   |                     \
    \            ^ no implementation for `i32 / {float}`\n   |\n   = help: the trait\
    \ `Div<{float}>` is not implemented for `i32`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We use the following formulas to determine the number\
    \ of collisions:\n    // 1. collisions = min(n - 1, 2(n-1))\n    // 2. collisions\
    \ = min(collisions, collisions(n - 1) - 1)\n    // 3. collisions = min(collisions,\
    \ collisions(n - 2) - 2)\n    let mut collisions = 2 * n - 1;\n    while collisions\
    \ < 2 * n - 1 {\n        collisions = 2 * collisions;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpw4w5na2z.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    fn collision(rect1: Box<(u32, u32, u32, u32)>, rect2:\
    \ Box<(u32, u32, u32, u32)>) -> bool {\n        let mut x1 = rect1.0;\n      \
    \  let mut y1 = rect1.1;\n        let mut x2 = rect2.0;\n        let mut y2 =\
    \ rect2.1;\n\n        // first point\n        if x1 > x2 {\n            (y1, x1)\
    \ = (x1, y2);\n            (y2, x2) = (x2, y1);\n        }\n\n        // second\
    \ point\n        if y1 > y2 {\n            (y1, x1) = (x1, y2);\n            (y2,\
    \ x2) = (x2, y1);\n        }\n\n        // intersection\n        if x1 == x2 &&\
    \ y1 == y2 {\n            return true;\n        }\n\n        // collinear\n  \
    \      false\n    }\n\n    let mut count = 0;\n    let mut collisions = (0..n).map(|_|\
    \ Box::new(()));\n    for _ in 0..n {\n        let mut newcollisions = (0..n).map(|_|\
    \ Box::new(()));\n        for _ in 0..n {\n            if collisions(&collisions[..],\
    \ &collisions[_..]) {\n                newcollisions.push((collisions[_], collisions[_]));\n\
    \            }\n        }\n        count += newcollisions.len();\n        collisions\
    \ = newcollisions;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpz5twin4a.rs:42:56\n   |\n42 |             if collisions(&collisions[..],\
    \ &collisions[_..]) {\n   |                                                  \
    \      ^ `_` not allowed here\n\nerror: in expressions, `_` can only be used on\
    \ the left-hand side of an assignment\n  --> /tmp/tmpz5twin4a.rs:43:48\n   |\n\
    43 |                 newcollisions.push((collisions[_], collisions[_]));\n   |\
    \                                                ^ `_` not allowed here\n\nerror:\
    \ in expressions, `_` can only be used on the left-hand side of an assignment\n\
    \  --> /tmp/tmpz5twin4a.rs:43:63\n   |\n43 |                 newcollisions.push((collisions[_],\
    \ collisions[_]));\n   |                                                     \
    \          ^ `_` not allowed here\n\nerror[E0618]: expected function, found `Map<std::ops::Range<isize>,\
    \ [closure@/tmp/tmpz5twin4a.rs:38:37: 38:53]>`\n  --> /tmp/tmpz5twin4a.rs:42:16\n\
    \   |\n38 |     let mut collisions = (0..n).map(|_| Box::new(()));\n   |     \
    \    -------------- `collisions` has type `Map<std::ops::Range<isize>, [closure@/tmp/tmpz5twin4a.rs:38:37:\
    \ 38:53]>`\n...\n42 |             if collisions(&collisions[..], &collisions[_..])\
    \ {\n   |                ^^^^^^^^^^-----------------------------------\n   | \
    \               |\n   |                call expression requires function\n\nerror[E0608]:\
    \ cannot index into a value of type `Map<std::ops::Range<isize>, [closure@/tmp/tmpz5twin4a.rs:38:37:\
    \ 38:53]>`\n  --> /tmp/tmpz5twin4a.rs:42:28\n   |\n42 |             if collisions(&collisions[..],\
    \ &collisions[_..]) {\n   |                            ^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Map<std::ops::Range<isize>, [closure@/tmp/tmpz5twin4a.rs:38:37:\
    \ 38:53]>`\n  --> /tmp/tmpz5twin4a.rs:42:45\n   |\n42 |             if collisions(&collisions[..],\
    \ &collisions[_..]) {\n   |                                             ^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `push` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpz5twin4a.rs"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (n as usize) * (n as usize) + // Number of cars\n   \
    \ (n as usize) * ((n as usize) - 1) // Number of moving cars\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps_649ray.rs:10:5\n   |\n\
    9  |   fn car_race_collision(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n10 | /     (n\
    \ as usize) * (n as usize) + // Number of cars\n11 | |     (n as usize) * ((n\
    \ as usize) - 1) // Number of moving cars\n   | |_____________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 ~     ((n as\
    \ usize) * (n as usize) + // Number of cars\n11 ~     (n as usize) * ((n as usize)\
    \ - 1)).try_into().unwrap() // Number of moving cars\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).map(|i| {\n        let mut collision = 0;\n  \
    \      let mut c1 = car::new(i);\n        let mut c2 = car::new(i);\n        for\
    \ _ in 0..2 {\n            c1.update();\n            if c1.hits > 0 {\n      \
    \          collision += 1;\n            }\n            c2.update();\n        \
    \    if c2.hits > 0 {\n                collision += 1;\n            }\n      \
    \  }\n        collision\n    })\n    .max()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `car`\n\
    \  --> /tmp/tmps5nl0hcg.rs:12:22\n   |\n12 |         let mut c1 = car::new(i);\n\
    \   |                      ^^^ use of undeclared crate or module `car`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `car`\n  --> /tmp/tmps5nl0hcg.rs:13:22\n\
    \   |\n13 |         let mut c2 = car::new(i);\n   |                      ^^^ use\
    \ of undeclared crate or module `car`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps5nl0hcg.rs:10:5\n   |\n9  |   fn car_race_collision(n: isize) -> isize\
    \ {\n   |                                      ----- expected `isize` because\
    \ of return type\n10 | /     (1..n).map(|i| {\n11 | |         let mut collision\
    \ = 0;\n12 | |         let mut c1 = car::new(i);\n13 | |         let mut c2 =\
    \ car::new(i);\n...  |\n25 | |     })\n26 | |     .max()\n   | |__________^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<{integer}>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0isize;\n    let mut x = 0isize;\n\
    \    let mut y = 0isize;\n    let mut z = 0isize;\n\n    while y < n {\n     \
    \   x = 0;\n        z = y;\n        while x < n {\n            let a = x + 1;\n\
    \            let b = z;\n            let c = x - 1;\n            let d = z;\n\
    \            let e = x + n;\n            let f = x + n + n;\n            let g\
    \ = x;\n            let h = x - 1;\n            let i = x + 1;\n            let\
    \ j = x;\n            let k = x + n + 1;\n            let l = x + n + n;\n   \
    \         let m = z;\n            let n = z;\n            let o = x + n;\n\n \
    \           if a > n {\n                break;\n            }\n            if\
    \ b > n {\n                break;\n            }\n            if c > n {\n   \
    \             break;\n            }\n            if d > n {\n                break;\n\
    \            }\n            if e > n {\n                break;\n            }\n\
    \            if f > n {\n                break;\n            }\n            if\
    \ g > n {\n                break;\n            }\n            if h > n {\n   \
    \             break;\n            }\n            if i > n {\n                break;\n\
    \            }\n            if j > n {\n                break;\n            }\n\
    \            if k > n {\n                break;\n            }\n            if\
    \ l > n {\n                break;\n            }\n            if m > n {\n   \
    \             break;\n            }\n            if n > n {\n                break;\n\
    \            }\n            if o > n {\n                break;\n            }\n\
    \            if car_collision_with(car_a(x, y), car_b(z, y),\n               \
    \                    car_c(x, y), car_d(z, y),\n                             \
    \      car_e(x, y), car_f(z, y),\n                                   car_g(x,\
    \ y), car_h(z, y),\n                                   car_i(x, y), car_j(z, y),\n\
    \                                   car_k(x, y), car_l(z, y)) ||\n           \
    \     car_collision_with(car_b(x, y), car_a(z, y),\n                         \
    \          car_c(z, y), car_d(z, y),\n                                   car_e(z,\
    \ y), car_f(x, y),\n                                   car_g(z, y), car_h(x, y),\n\
    \                                   car_i(z, y), car_j(x, y),\n              \
    \                     car_k(z, y), car_l(z, y)) ||\n                car_collision_with(car_c(x,\
    \ y), car_a(z, y),\n                                   car_b(z, y), car_e(z, y),\n\
    \                                   car_f(z, y), car_g(x, y),\n              \
    \                     car_h(z, y), car_i(x, y),\n                            \
    \       car_j(x, y), car_k(z, y),\n                                   car_l(z,\
    \ y)) ||\n                car_collision_with(car_d(x, y), car_a(z, y),\n     \
    \                              car_b(z, \n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgm5ydba8.rs:109:3\n\
    \    |\n9   | fn car_race_collision(n: isize) -> isize {\n    |              \
    \                            - unclosed delimiter\n...\n15  |     while y < n\
    \ {\n    |                 - unclosed delimiter\n...\n18  |         while x <\
    \ n {\n    |                     - this delimiter might not be properly closed...\n\
    ...\n100 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n109 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpgm5ydba8.rs:100:1\n\
    \    |\n80  |             if car_collision_with(car_a(x, y), car_b(z, y),\n  \
    \  |             -- this `if` expression has a condition, but no block\n...\n\
    100 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmpgm5ydba8.rs:99:41\n    |\n9   | fn car_race_collision(n: isize)\
    \ -> isize {\n    |                                          - closing delimiter\
    \ possibly meant for this\n...\n99  |                                    car_b(z,\
    \ \n    |                                         ^ unclosed delimiter\n100 |\
    \ }\n    | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpgm5ydba8.rs:15:5\n    |\n9   |   fn car_race_collision(n: isize)\
    \ -> isize {\n    |                                      ----- expected `isize`\
    \ because of return type\n...\n15  | /     while y < n {\n16  | |         x =\
    \ 0;\n17  | |         z = y;\n18  | |         while x < n {\n...   |\n108 | |\
    \     assert_eq!(candidate(10), 100);\n109 | | }\n    | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut speeds = vec![n;\
    \ n];\n    let mut prev_speed = speeds[0];\n    for i in 0..n {\n        speeds[i]\
    \ = speeds[i] - prev_speed;\n        let next_speed = speeds[i] + 0.5;\n     \
    \   if speeds[i] < -prev_speed || speeds[i] > next_speed {\n            collision_count\
    \ += 1;\n        }\n        prev_speed = next_speed;\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpndq4y4in.rs:11:30\n   |\n\
    11 |     let mut speeds = vec![n; n];\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     let mut speeds\
    \ = vec![n; n.try_into().unwrap()];\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpndq4y4in.rs:14:9\n\
    \   |\n14 |         speeds[i] = speeds[i] - prev_speed;\n   |         ^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpndq4y4in.rs:14:21\n\
    \   |\n14 |         speeds[i] = speeds[i] - prev_speed;\n   |                \
    \     ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpndq4y4in.rs:15:26\n\
    \   |\n15 |         let next_speed = speeds[i] + 0.5;\n   |                  \
    \        ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpndq4y4in.rs:16:12\n\
    \   |\n16 |         if speeds[i] < -prev_speed || speeds[i] > next_speed {\n \
    \  |            ^^^^^^^^^ slice indices are of type `usize` or r"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut collision_distances\
    \ = vec![0; n];\n    let mut directions = vec![0; n];\n    let mut prev_collision_distances\
    \ = vec![0; n];\n\n    // initialize collision distances\n    for i in 0..n {\n\
    \        let mut collision_distance = std::f64::consts::FRAC_2;\n        if i\
    \ < n {\n            collision_distance = collision_distance * (i + 1.0);\n  \
    \      }\n        collision_distances[i] = collision_distance;\n    }\n\n    let\
    \ mut prev_collision_distance = std::f64::consts::FRAC_2;\n    for i in 0..n {\n\
    \        let mut prev_collision_distance = prev_collision_distance * (i + 1.0);\n\
    \        if i < n {\n            prev_collision_distance = prev_collision_distance\
    \ + ((collision_distances[i] - prev_collision_distance)\n                / (i\
    \ + 1.0));\n        }\n        prev_collision_distances[i] = prev_collision_distance;\n\
    \    }\n\n    // initialize directions\n    for i in 0..n {\n        if i < n\
    \ {\n            directions[i] = ((i + 1.0) - prev_collision_distances[i]) / (collision_distances[i]\
    \ + prev_collision_distances[i]);\n        }\n    }\n\n    // initialize collision\
    \ count\n    let mut prev_collisions = 1;\n\n    // race for collisions\n    for\
    \ i in 0..n {\n        collisions = 0;\n\n        // race for collisions\n   \
    \     for j in 0..n {\n            let mut is_colliding = false;\n           \
    \ let mut collision_distance_j = std::f64::consts::FRAC_2;\n            if j <\
    \ n {\n                collision_distance_j = collision_distances[j];\n      \
    \      }\n\n            if i == j {\n                is_colliding = true;\n  \
    \          }\n\n            if !is_colliding && (i - j) < n && j - i < n {\n \
    \               is_colliding = true;\n            }\n\n            if !is_colliding\
    \ {\n                // check to see if another car has collided with a car in\
    \ its path\n                let mut collide = false;\n                for m in\
    \ 0..n {\n                    if m != i && m != j && m != (i - j) && m != j -\
    \ i {\n                        if collision_distances[m] > collision_distance_j\
    \ {\n                            collide = true;\n                        }\n\
    \                    }\n                }\n\n                // check to see if\
    \ the two cars collided with each other in the right direction\n             \
    \   if collide {\n                    collisions++;\n                }\n     \
    \       }\n\n            if i == j {\n                // check to see if the two\
    \ cars collided with each other in the right direction\n                if collisions\
    \ > 0 {\n                    collisions++;\n                }\n            }\n\
    \n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpigf2mz_u.rs:97:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n45 |     for i in 0..n {\n\
    \   |                   - unclosed delimiter\n...\n49 |         for j in 0..n\
    \ {\n   |                       - this delimiter might not be properly closed...\n\
    ...\n88 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    97 | }\n   |   ^\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpigf2mz_u.rs:77:31\n\
    \   |\n77 |                     collisions++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    77 |                     { let tmp = collisions; collisions += 1; tmp };\n   |\
    \                     +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n77 -   \
    \                  collisions++;\n77 +                     collisions += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpigf2mz_u.rs:84:31\n\
    \   |\n84 |                     collisions++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    84 |                     { let tmp = collisions; collisions += 1; tmp };\n   |\
    \                     +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n84 -   \
    \                  collisions++;\n84 +                     collisions += 1;\n\
    \   | \n\nerror[E0425]: cannot find value `FRAC_2` in module `std::f64::consts`\n\
    \  --> /tmp/tmpigf2mz_u.rs:17:56\n   |\n17 |         let mut collision_distance\
    \ = std::f64::consts::FRAC_2;\n   |                                          \
    \              ^^^^^^ not found in `std::f64::consts`\n\nerror[E0425]: cannot\
    \ find value `FRAC_2` in module `std::f64::consts`\n  --> /tmp/tmpigf2mz_u.rs:24:57\n\
    \   |\n24 |     let mut prev_collision_distance = std::f64::consts::FRAC_2;\n\
    \   |                                                         ^^^^^^ not found\
    \ in `std::f64::consts`\n\nerror[E0425]: cannot find value `FRAC_2` in module\
    \ `std::f64::consts`\n  --> /tmp/tmpigf2mz_u.rs:51:62\n   |\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 1 {\n        return 0;\n    }\n    // Each car\
    \ collides with itself once.\n    if n == 2 {\n        return 1;\n    }\n    if\
    \ n < 2 {\n        return 0;\n    }\n    let mut collisions = 1;\n    for i in\
    \ 0..n {\n        collisions *= car_race_collision(n + i);\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp34fmqmel.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    while c < n {\n        let mut collisions\
    \ = 1;\n        let mut i = (n - 1) - c;\n        // check all possible pairs\
    \ of n cars\n        while i >= 0 {\n            let j = i - 1;\n            //\
    \ check all possible pairs of m cars\n            while j >= 0 {\n           \
    \     // if cars i and j are colliding\n                if i != j {\n        \
    \            // increment collisions by the number of times they collide\n   \
    \                 // let a = collisions + 1;\n                    // collisions\
    \ += car_collision(i, j);\n                    // c = collisions;\n          \
    \          collisions += car_collision(i, j);\n                }\n           \
    \     j -= 1;\n            }\n            i -= 1;\n        }\n        c += collisions;\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_collision` in this scope\n  -->\
    \ /tmp/tmprubq3zje.rs:25:35\n   |\n25 |                     collisions += car_collision(i,\
    \ j);\n   |                                   ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    fn collision(pos: Vec<f64>, dir: Vec<f64>) -> bool {\n\
    \        (dir.len() == 2) && pos[1].abs() < 0.1 &&\n            (pos[0].abs()\
    \ + pos[1].abs() < 0.1)\n    }\n\n    let mut collision_count: isize = 0;\n\n\
    \    // A set of n distinct cars, initially positioned at random\n    let mut\
    \ cars = (0..n).collect::<Vec<_>>();\n\n    // A set of n distinct cars, initially\
    \ positioned at random\n    let mut other_cars = (0..n).collect::<Vec<_>>();\n\
    \n    // The cars who collide with each other\n    let mut collided_with: Vec<isize>\
    \ = (0..n).collect::<Vec<_>>();\n\n    // A set of cars whose trajectories are\
    \ being compared to each other\n    let mut comparing = Vec::new();\n\n    //\
    \ A set of cars that have been assigned a unique ID\n    let mut uniques: Vec<usize>\
    \ = (0..n).collect::<Vec<_>>();\n\n    while cars.len() > 0 || other_cars.len()\
    \ > 0 {\n        let mut car = cars.remove(0);\n\n        // Find the cars who\
    \ should be compared to each other\n        let other_car = other_cars.remove(0);\n\
    \        if car == other_car {\n            continue;\n        }\n\n        //\
    \ Find the other cars who should collide with the current car\n        let other_cars_collision\
    \ = other_cars.iter().filter(|car_other_car| {\n            collision(\n     \
    \           &car_other_car,\n                car.clone().into_iter().zip(car_other_car.clone().into_iter()).collect::<Vec<_>>(),\n\
    \            )\n        }).count();\n\n        // A collision is counted if there\
    \ are two cars who are to collide\n        // and one of them is currently being\
    \ compared to the other\n        if other_cars_collision == 2 {\n            collision_count\
    \ += 1;\n            other_cars.push(other_car);\n            other_car.clone.iter().cloned().for_each(|car_other_car|\
    \ {\n                collision_count += 1;\n                cars.push(other_car);\n\
    \                car_other_car.clone.iter().cloned().for_each(|car| {\n      \
    \              cars.push(other_car);\n                    comparing.push(car);\n\
    \                });\n            });\n        }\n\n        // A collision is\
    \ counted if the cars are both being compared\n        if cars.iter().filter(|car_comparing|\
    \ {\n            collision(car, &car_comparing.clone().\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplcypymrk.rs:76:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n32 |     while cars.len()\
    \ > 0 || other_cars.len() > 0 {\n   |                                        \
    \          - unclosed delimiter\n...\n65 |         if cars.iter().filter(|car_comparing|\
    \ {\n   |                              - unclosed delimiter\n...\n76 | }\n   |\
    \   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmplcypymrk.rs:66:22\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - closing delimiter possibly meant for this\n...\n66\
    \ |             collision(car, &car_comparing.clone().\n   |                 \
    \     ^ unclosed delimiter\n67 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ unexpected token: `)`\n  --> /tmp/tmplcypymrk.rs:67:1\n   |\n67 | }\n   | ^\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \  --> /tmp/tmplcypymrk.rs:66:22\n   |\n66 |             collision(car, &car_comparing.clone().\n\
    \   |                      ^ unclosed delimiter\n67 | }\n   |  - help: `)` may\
    \ belong here\n68 | \n69 | fn main() {\n   | ^^\n\nerror: expected `{`, found\
    \ keyword `fn`\n  --> /tmp/tmplcypymrk.rs:69:1\n   |\n65 |         if cars.iter().filter(|car_comparing|\
    \ {\n   |         -- this `if` expression has a condition, but no block\n...\n\
    69 | fn main() {\n   | ^^ expected `{`\n   |\nhelp: try placing this code inside\
    \ a block\n   |\n69 ~ { fn main() {\n70 |     let candidate = car_race_collision;\n\
    71 |     assert_eq!(candidate(2), 4);\n72 |     assert_eq!(candidate(3), 9);\n\
    73 |     assert_eq!(candidate(4), 16);\n74 |     assert_eq!(candidate(8), 64);\n\
    \ ...\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplcypymrk.rs:30:35\n   |\n\
    30 |     let mut uniques: Vec<usize> = (0..n).collect::<Vec<_>>();\n   |     \
    \                 ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |                      |\n   |                      expected due\
    \ to this\n   |\n   = note: expe"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut j\
    \ = 0;\n    let mut i = 0;\n    while j < n {\n        let mut collision_count\
    \ = 0;\n        while i < n {\n            if car_collision(i + j, i + j + 1,\
    \ i + j + 2) || car_collision(i + j + 1, i + j, i + j + 2) || car_collision(i\
    \ + j, i + j + 1, i + j + 2) {\n                collision_count++;\n         \
    \   }\n            i += 4;\n        }\n        if collision_count == 0 {\n   \
    \         return j;\n        }\n        j += 1;\n    }\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpepytgxyw.rs:19:32\n\
    \   |\n19 |                 collision_count++;\n   |                         \
    \       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    19 |                 { let tmp = collision_count; collision_count += 1; tmp };\n\
    \   |                 +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    19 -                 collision_count++;\n19 +                 collision_count\
    \ += 1;\n   | \n\nerror[E0425]: cannot find function `car_collision` in this scope\n\
    \  --> /tmp/tmpepytgxyw.rs:18:16\n   |\n18 | ...   if car_collision(i + j, i +\
    \ j + 1, i + j + 2) || car_collision(i + j + 1, i + j, i + j + 2) || car_collision(i\
    \ + j, i + j + 1, i + ...\n   |          ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `car_collision` in this scope\n  --> /tmp/tmpepytgxyw.rs:18:62\n\
    \   |\n18 | ...   if car_collision(i + j, i + j + 1, i + j + 2) || car_collision(i\
    \ + j + 1, i + j, i + j + 2) || car_collision(i + j, i + j + 1, i + ...\n   |\
    \                                                        ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `car_collision` in this\
    \ scope\n  --> /tmp/tmpepytgxyw.rs:18:108\n   |\n18 | ...| car_collision(i + j\
    \ + 1, i + j, i + j + 2) || car_collision(i + j, i + j + 1, i + j + 2) {\n   |\
    \                                                    ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977940
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision_count = 0;\n    let mut current_time\
    \ = 0.0;\n    let mut current_x = 0.0;\n    let mut current_y = 0.0;\n    let\
    \ mut current_dir = 0.0;\n    let mut last_x = 0.0;\n    let mut last_y = 0.0;\n\
    \    let mut last_dir = 0.0;\n    let mut collide_x = 0.0;\n    let mut collide_y\
    \ = 0.0;\n    let mut collide_dir = 0.0;\n    let mut move_x = 0.0;\n    let mut\
    \ move_y = 0.0;\n    let mut move_dir = 0.0;\n\n    while current_time + 1.0 <\
    \ MAX_TIME_SECONDS {\n        // The car moving rightwards, collides with the\
    \ car moving leftwards.\n        let mut collide = false;\n        let mut collide_time\
    \ = 0.0;\n        if current_dir == 0.0 {\n            move_dir = -move_dir;\n\
    \        }\n        move_x = move_x + move_dir;\n        if move_x >= 0.0 && move_x\
    \ <= n / 2.0 + 1.0 {\n            if current_y >= 0.0 && move_y <= -n / 2.0 +\
    \ 1.0 {\n                move_dir = -move_dir;\n            }\n            move_y\
    \ = move_y + move_dir;\n            if move_y <= 0.0 {\n                move_dir\
    \ = -move_dir;\n                move_y = 0.0;\n            }\n        }\n    \
    \    if move_x == 0.0 && move_y == 0.0 {\n            current_x = 0.0;\n     \
    \       current_y = 0.0;\n        }\n\n        // The car moving leftwards, collides\
    \ with the car moving rightwards.\n        collide = false;\n        collide_time\
    \ = 0.0;\n        if current_dir == 0.0 {\n            move_dir = -move_dir;\n\
    \        }\n        move_x = move_x + move_dir;\n        if move_x <= n / 2.0\
    \ + 1.0 && move_x >= 0.0 - move_dir {\n            if current_y >= 0.0 && move_y\
    \ <= -n / 2.0 + 1.0 {\n                move_dir = -move_dir;\n            }\n\
    \            move_y = move_y + move_dir;\n            if move_y <= 0.0 {\n   \
    \             move_dir = -move_dir;\n                move_y = 0.0;\n         \
    \   }\n        }\n        if move_x == 0.0 {\n            current_x = 0.0;\n \
    \           current_y = 0.0;\n        }\n\n        // The car moving rightwards,\
    \ collides with the car moving leftwards.\n        collide = false;\n        collide_time\
    \ = 0.0;\n        if current_dir == 0.0 {\n            move_dir = -move_dir;\n\
    \        }\n        move_x = move_x + move_dir;\n        if move_x >= 0.0 && move_x\
    \ <= n / 2.0 + 1.0 {\n            if current_y >= 0.0 && move_\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqdzusxi3.rs:88:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n25 |     while current_time\
    \ + 1.0 < MAX_TIME_SECONDS {\n   |                                           \
    \      - unclosed delimiter\n...\n77 |         if move_x >= 0.0 && move_x <= n\
    \ / 2.0 + 1.0 {\n   |                                                     - this\
    \ delimiter might not be properly closed...\n78 |             if current_y >=\
    \ 0.0 && move_\n79 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n88 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpqdzusxi3.rs:79:1\n\
    \   |\n78 |             if current_y >= 0.0 && move_\n   |             -- this\
    \ `if` expression has a condition, but no block\n79 | }\n   | ^ expected `{`\n\
    \nerror[E0425]: cannot find value `MAX_TIME_SECONDS` in this scope\n  --> /tmp/tmpqdzusxi3.rs:25:32\n\
    \   |\n25 |     while current_time + 1.0 < MAX_TIME_SECONDS {\n   |          \
    \                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ cannot divide `isize` by `{float}`\n  --> /tmp/tmpqdzusxi3.rs:33:41\n   |\n\
    33 |         if move_x >= 0.0 && move_x <= n / 2.0 + 1.0 {\n   |             \
    \                            ^ no implementation for `isize / {float}`\n   |\n\
    \   = help: the trait `Div<{float}>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: cannot\
    \ divide `isize` by `{float}`\n  --> /tmp/tmpqdzusxi3.rs:34:49\n   |\n34 |   \
    \          if current_y >= 0.0 && move_y <= -n / 2.0 + 1.0 {\n   |           \
    \                                      ^ no implementation for `isize / {float}`\n\
    \   |\n   = help: the trait `Div<{float"
  stdout: ''
  timestamp: 1659977940
