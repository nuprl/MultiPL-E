language: rs
name: HumanEval_108_count_nums
results:
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppjppo3sm.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppjppo3sm.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    let mut digits = arr.iter().cloned().map(|x|\
    \ x.digits()).collect::<Vec<_>>();\n    while let Some(digit) = &digits.pop()\
    \ {\n        let digit = digit.unwrap();\n        if digit < 0 {\n           \
    \ digit *= -1;\n        }\n        if digit > 0 {\n            cnt += 1;\n   \
    \     }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpvn1s9hqo.rs:13:52\n   |\n13 |     let mut digits = arr.iter().cloned().map(|x|\
    \ x.digits()).collect::<Vec<_>>();\n   |                                     \
    \               ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&n| n > 0).count() + arr.iter().filter(|&n|\
    \ n < 0).count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5pir7tm.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&n| n > 0).count() + arr.iter().filter(|&n| n < 0).count()\n\
    \   |                                ^\n   |                                |\n\
    \   |                                expected `&isize`, found integer\n   |  \
    \                              help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp5pir7tm.rs:12:72\n   |\n12 |     arr.iter().filter(|&n|\
    \ n > 0).count() + arr.iter().filter(|&n| n < 0).count()\n   |               \
    \                                                         ^\n   |            \
    \                                                            |\n   |         \
    \                                                               expected `&isize`,\
    \ found integer\n   |                                                        \
    \                help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp5pir7tm.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|&n| n > 0).count() + arr.iter().filter(|&n|\
    \ n < 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (arr.iter().filter(|&n|\
    \ n > 0).count() + arr.iter().filter(|&n| n < 0).count()).try_into().unwrap()\n\
    \   |     +                                                                  \
    \           +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // if there are no elements in arr then return 0\n\
    \    if arr.is_empty() {\n        return 0;\n    }\n    let mut first_sign_digit\
    \ = -1;\n    for num in arr {\n        if num < 0 {\n            // if num has\
    \ negative sign then it is the smallest signed number with digits >0\n       \
    \     first_sign_digit = -1;\n            break;\n        }\n        first_sign_digit\
    \ = num;\n    }\n    let mut count = 0;\n    for num in arr {\n        // if num\
    \ is negative then num is not part of numbers with sum digits > 0,\n        //\
    \ but we need to sum its first signed digit\n        if num < 0 {\n          \
    \  continue;\n        }\n        // calculate number of digits in num (excluding\
    \ sign digit)\n        let mut digits = first_sign_digit;\n        while num >\
    \ 0 {\n            num %= 10;\n            digits++;\n        }\n        // if\
    \ sum of digits > 0 then add to count\n        if digits > 0 {\n            count\
    \ += digits;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmppafeljn0.rs:36:19\n\
    \   |\n36 |             digits++;\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |             { let tmp =\
    \ digits; digits += 1; tmp };\n   |             +++++++++++       ~~~~~~~~~~~~~~~~~~~~\n\
    36 -             digits++;\n36 +             digits += 1;\n   | \n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut res = 0;\n    for i in arr {\n        if\
    \ i >= 0 {\n            if i % 10 == 0 {\n                res++;\n           \
    \ }\n        }\n        else {\n            i -= i;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpo2y_0alg.rs:16:20\n\
    \   |\n16 |                 res++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |                 { let tmp\
    \ = res; res += 1; tmp };\n   |                 +++++++++++    ~~~~~~~~~~~~~~~~~\n\
    16 -                 res++;\n16 +                 res += 1;\n   | \n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr {\n        sum\
    \ += i;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmp5gqcu7jb.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for &n in arr.iter() {\n \
    \       cnt += n\n            .checked_mul(10)\n            .expect(\"Multiplying\
    \ by 10 should always succeed\");\n        cnt += n % 10;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-33`,\n right: `0`', /tmp/tmpjpq4zkb2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut nums = 0;\n    let mut min_digit = 0;\n\
    \    let mut max_digit = arr.len() - 1;\n    while max_digit > min_digit {\n \
    \       if arr[*min_digit] + arr[*max_digit] >= 10 && arr[*min_digit] + arr[*max_digit]\
    \ > 0 {\n            if min_digit >= 0 {\n                nums += 1;\n       \
    \     }\n            min_digit += 1;\n            max_digit -= 1;\n        } else\
    \ if arr[*min_digit] > 0 {\n            max_digit -= 1;\n        } else {\n  \
    \          min_digit -= 1;\n        }\n    }\n    nums\n}\n\nfn main() {\n   \
    \ let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp9clmgc1n.rs:16:16\n\
    \   |\n16 |         if arr[*min_digit] + arr[*max_digit] >= 10 && arr[*min_digit]\
    \ + arr[*max_digit] > 0 {\n   |                ^^^^^^^^^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmp9clmgc1n.rs:16:34\n   |\n16 |\
    \         if arr[*min_digit] + arr[*max_digit] >= 10 && arr[*min_digit] + arr[*max_digit]\
    \ > 0 {\n   |                                  ^^^^^^^^^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmp9clmgc1n.rs:16:59\n   |\n16 |\
    \         if arr[*min_digit] + arr[*max_digit] >= 10 && arr[*min_digit] + arr[*max_digit]\
    \ > 0 {\n   |                                                           ^^^^^^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp9clmgc1n.rs:16:77\n\
    \   |\n16 |         if arr[*min_digit] + arr[*max_digit] >= 10 && arr[*min_digit]\
    \ + arr[*max_digit] > 0 {\n   |                                              \
    \                               ^^^^^^^^^^\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp9clmgc1n.rs:22:23\n   |\n22 |         } else\
    \ if arr[*min_digit] > 0 {\n   |                       ^^^^^^^^^^\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut c = 0;\n    for x in arr {\n        if x > 0 {\n            c +=\
    \ x % 10;\n        }\n        x /= 10;\n    }\n    c += arr.len();\n    if c <\
    \ 0 {\n        c *= -1;\n    }\n    c\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeernc1wi.rs:22:10\n   |\n\
    22 |     c += arr.len();\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot add-assign `usize` to `isize`\n  --> /tmp/tmpeernc1wi.rs:22:7\n\
    \   |\n22 |     c += arr.len();\n   |       ^^ no implementation for `isize +=\
    \ usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for e in arr.iter() {\n  \
    \      if *e < 0 { break; }\n        sum += *e;\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpq87he1ry.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for num in arr {\n       \
    \ if num < 0 {\n            if num % 10 == 0 {\n                cnt += 1;\n  \
    \          }\n        } else {\n            cnt += 1;\n        }\n    }\n    cnt\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpnot9s_gk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut nums: usize = 0;\n    for v in arr.iter().cloned()\
    \ {\n        if *v < 0 {\n            num = -(*v);\n        } else {\n       \
    \     num = *v;\n        }\n\n        let last = num % 10;\n        let next =\
    \ num / (10 * 10);\n        if next > 0 {\n            nums += next;\n       \
    \ } else {\n            nums += 1;\n        }\n        if last > 0 {\n       \
    \     nums += 1;\n        }\n    }\n    nums\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `num` in this scope\n  --> /tmp/tmpua__u3nu.rs:15:13\n\
    \   |\n15 |             num = -(*v);\n   |             ^^^ help: a local variable\
    \ with a similar name exists: `nums`\n\nerror[E0425]: cannot find value `num`\
    \ in this scope\n  --> /tmp/tmpua__u3nu.rs:17:13\n   |\n17 |             num =\
    \ *v;\n   |             ^^^ help: a local variable with a similar name exists:\
    \ `nums`\n\nerror[E0425]: cannot find value `num` in this scope\n  --> /tmp/tmpua__u3nu.rs:20:20\n\
    \   |\n20 |         let last = num % 10;\n   |                    ^^^ help: a\
    \ local variable with a similar name exists: `nums`\n\nerror[E0425]: cannot find\
    \ value `num` in this scope\n  --> /tmp/tmpua__u3nu.rs:21:20\n   |\n21 |     \
    \    let next = num / (10 * 10);\n   |                    ^^^ help: a local variable\
    \ with a similar name exists: `nums`\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpua__u3nu.rs:14:12\n   |\n14 |         if *v < 0 {\n   |       \
    \     ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpua__u3nu.rs:15:20\n\
    \   |\n15 |             num = -(*v);\n   |                    ^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpua__u3nu.rs:17:19\n   |\n\
    17 |             num = *v;\n   |                   ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpua__u3nu.rs:31:5\n   |\n11 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n31 |     nums\n   |     ^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |     nums.try_into().unwrap()\n   |         ++++++++++++++++++++\n\
    \nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut n = 0;\n    let\
    \ mut j = 0;\n    for &i in arr.iter() {\n        j += i;\n        if j > 0 {\n\
    \            count += 1;\n            j = 0;\n        }\n    }\n    if n != arr.len()\
    \ {\n        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp2iyjd52o.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut ans = 0;\n    let mut i = 1;\n    let mut\
    \ sign = arr[0].signum();\n    for &x in arr {\n        let t = x;\n        if\
    \ sign != t {\n            ans += i;\n            i = 1;\n        }\n        i\
    \ += sign;\n        sign = t;\n    }\n    ans += i;\n    ans\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprclnt6to.rs:15:9\n   |\n\
    15 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    let mut cnt = 0;\n    for\
    \ &num in arr {\n        if num < 0 {\n            sum += -num;\n        } else\
    \ {\n            sum += num;\n        }\n        cnt += 1;\n    }\n    cnt\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa09ai40l.rs:14:9\n   |\n\
    14 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if\
    \ i >= 0 {\n            sum += i;\n        }\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp82x0rjil.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&n| n > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7adizn0.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&n| n > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_7adizn0.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&n| n > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&n|\
    \ n > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut nums = 0;\n    for num in arr {\n      \
    \  if num > 0 {\n            nums += num % 10 as isize;\n        }\n    }\n  \
    \  nums\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp6sbfuokf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut c = 0;\n    let mut sum = 0;\n    for &x\
    \ in arr {\n        if x < 0 {\n            c += x;\n        } else {\n      \
    \      sum += x;\n            c += 1;\n        }\n    }\n    c + sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bugcrq6.rs:14:9\n   |\n\
    14 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count: isize = 0;\n    let mut ndigits =\
    \ arr.len();\n\n    while ndigits > 0 {\n        if arr.contains(0) && arr.contains(1)\
    \ {\n            count += 1;\n        }\n        ndigits -= 2;\n        if ndigits\
    \ == 0 {\n            ndigits = arr.len();\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsymzrcne.rs:16:25\n   |\n\
    16 |         if arr.contains(0) && arr.contains(1) {\n   |                   \
    \      ^\n   |                         |\n   |                         expected\
    \ `&isize`, found integer\n   |                         help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsymzrcne.rs:16:44\n\
    \   |\n16 |         if arr.contains(0) && arr.contains(1) {\n   |            \
    \                                ^\n   |                                     \
    \       |\n   |                                            expected `&isize`,\
    \ found integer\n   |                                            help: consider\
    \ borrowing here: `&1`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num_digits = arr.len();\n    for &i in &arr\
    \ {\n        if i < 0 {\n            num_digits += count_nums(vec![i - 1isize]);\n\
    \        } else {\n            num_digits += 1;\n        }\n    }\n    num_digits\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpww8i86te.rs:15:27\n   |\n\
    15 |             num_digits += count_nums(vec![i - 1isize]);\n   |           \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpww8i86te.rs:15:24\n\
    \   |\n15 |             num_digits += count_nums(vec![i - 1isize]);\n   |    \
    \                    ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpww8i86te.rs:20:5\n   |\n11 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n20 |     num_digits\n   |     ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     num_digits.try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for (i, num) in arr.iter().enumerate()\
    \ {\n        if num > 0 {\n            if let Some(d) = i.checked_sub(1).unwrap()\
    \ {\n                sum += num - d + 1;\n            } else {\n             \
    \   sum += num - 1;\n            }\n        }\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_n5nuv5k.rs:14:18\n   |\n\
    14 |         if num > 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_n5nuv5k.rs:15:20\n   |\n15 |             if let Some(d) = i.checked_sub(1).unwrap()\
    \ {\n   |                    ^^^^^^^   ------------------------- this expression\
    \ has type `usize`\n   |                    |\n   |                    expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter_map(|&x| if x > 0 {\
    \ Some(x) } else { None })\n        .count() as isize\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmps7ri0qrw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&a| a > 0).count() + 1\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqcadxqno.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&a| a > 0).count() + 1\n   |                     \
    \           ^\n   |                                |\n   |                   \
    \             expected `&isize`, found integer\n   |                         \
    \       help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqcadxqno.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|&a| a > 0).count() + 1\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     (arr.iter().filter(|&a| a > 0).count() + 1).try_into().unwrap()\n\
    \   |     +                                         +++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    count_nums_impl(&arr, arr).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nums_impl` in this scope\n  -->\
    \ /tmp/tmphn6n4iog.rs:12:5\n   |\n12 |     count_nums_impl(&arr, arr).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut counts: Vec<usize> = arr.iter().cloned().collect();\n\
    \    for d in 0..(counts.len() - 1) {\n        if counts[d] > 0 {\n          \
    \  counts[d] -= 1\n        } else {\n            counts[d] -= 1;\n           \
    \ counts[d] += counts[d + 1]\n        }\n    }\n    counts.iter().cloned().sum()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<usize>` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmputz5ddl3.rs:12:54\n     |\n12\
    \   |     let mut counts: Vec<usize> = arr.iter().cloned().collect();\n     |\
    \                                                      ^^^^^^^ value of type `Vec<usize>`\
    \ cannot be built from `std::iter::Iterator<Item=isize>`\n     |\n     = help:\
    \ the trait `FromIterator<isize>` is not implemented for `Vec<usize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the trait bound `isize: Sum<usize>`\
    \ is not satisfied\n    --> /tmp/tmputz5ddl3.rs:21:28\n     |\n21   |     counts.iter().cloned().sum()\n\
    \     |                            ^^^ the trait `Sum<usize>` is not implemented\
    \ for `isize`\n     |\n     = help: the following other types implement trait\
    \ `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n\
    \               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n         \
    \      <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16\
    \ as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20 others\n\
    note: required by a bound in `std::iter::Iterator::sum`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr.iter() {\n\
    \        match i {\n            None => return 0,\n            Some(x) => if x\
    \ < 0 {\n                count += x as isize % 10;\n                count += 10\
    \ as isize % x;\n            } else {\n                count += x;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk4a0r1x7.rs:15:13\n   |\n\
    14 |         match i {\n   |               - this expression has type `&isize`\n\
    15 |             None => return 0,\n   |             ^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk4a0r1x7.rs:16:13\n\
    \   |\n14 |         match i {\n   |               - this expression has type `&isize`\n\
    15 |             None => return 0,\n16 |             Some(x) => if x < 0 {\n \
    \  |             ^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<_>`\n\nerror[E0277]:\
    \ can't compare `&_` with `{integer}`\n  --> /tmp/tmpk4a0r1x7.rs:16:29\n   |\n\
    16 |             Some(x) => if x < 0 {\n   |                             ^ no\
    \ implementation for `&_ < {integer}` and `&_ > {integer}`\n   |\n   = help: the\
    \ trait `PartialOrd<{integer}>` is not implemented for `&_`\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmpk4a0r1x7.rs:17:26\n   |\n17 |\
    \                 count += x as isize % 10;\n   |                          -^^^^^^^^^\n\
    \   |                          |\n   |                          cannot cast `&isize`\
    \ as `isize`\n   |                          help: dereference the expression:\
    \ `*x`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        0\n    } else {\n \
    \       match arr[0] {\n            -1 => count_nums(arr.split_off(1)).saturating_add(-2),\n\
    \            _ => count_nums(arr.split_off(1)).saturating_add(arr.iter().map(|&x|\
    \ x as isize).sum()),\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `arr` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_w9atk02.rs:16:30\n   |\n11 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n16 |             -1 => count_nums(arr.split_off(1)).saturating_add(-2),\n\
    \   |                              ^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `arr` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp_w9atk02.rs:17:29\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |               --- help: consider changing this to be mutable:\
    \ `mut arr`\n...\n17 |             _ => count_nums(arr.split_off(1)).saturating_add(arr.iter().map(|&x|\
    \ x as isize).sum()),\n   |                             ^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for (i, &d) in arr.iter().enumerate()\
    \ {\n        let mut neg = false;\n        if d < 0 {\n            neg = true;\n\
    \            d = -d;\n        }\n        sum += (d as isize) * (10 * (i + 1));\n\
    \    }\n    if sum < 0 {\n        sum *= -1;\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpffg3l4fh.rs:19:31\n   |\n\
    19 |         sum += (d as isize) * (10 * (i + 1));\n   |                     \
    \          ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ multiply `isize` by `usize`\n  --> /tmp/tmpffg3l4fh.rs:19:29\n   |\n19 |   \
    \      sum += (d as isize) * (10 * (i + 1));\n   |                           \
    \  ^ no implementation for `isize * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &i in arr.iter().rev()\
    \ {\n        if i != 0 {\n            sum += i;\n        }\n    }\n    if sum\
    \ < 0 {\n        sum *= -1;\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpma6_4xq8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter(|x| x > 0)\n       \
    \ .fold(0, |acc, _| acc + (*x % 10 as isize) % 10)\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `x` in this scope\n  --> /tmp/tmp8ihborj9.rs:14:35\n\
    \   |\n14 |         .fold(0, |acc, _| acc + (*x % 10 as isize) % 10)\n   |   \
    \                                ^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8ihborj9.rs:13:25\n   |\n13 |         .filter(|x| x > 0)\n\
    \   |                         ^ expected `&&isize`, found integer\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr.iter() {\n  \
    \      if i >= 0 {\n            if i % 10 != 0 {\n                sum += i;\n\
    \            }\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplwebh2fn.rs:14:17\n   |\n\
    14 |         if i >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = 0;\n    for n in arr {\n        if n\
    \ > 0 {\n            break;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpb9xohpdv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter(|x| *x >= 0)\n     \
    \   .filter(|x| *x > 0)\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzho07tve.rs:13:27\n   |\n\
    13 |         .filter(|x| *x >= 0)\n   |                           ^\n   |    \
    \                       |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzho07tve.rs:14:26\n   |\n14 |\
    \         .filter(|x| *x > 0)\n   |                          ^\n   |         \
    \                 |\n   |                          expected `&isize`, found integer\n\
    \   |                          help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzho07tve.rs:12:5\n   |\n11 |   fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                     ----- expected\
    \ `isize` because of return type\n12 | /     arr.iter()\n13 | |         .filter(|x|\
    \ *x >= 0)\n14 | |         .filter(|x| *x > 0)\n15 | |         .count()\n   |\
    \ |________________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    15 |         .count().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x < 0).count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp933ub0ps.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x < 0).count() as isize\n   |                 \
    \              ^ expected `&&isize`, found integer\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut total_nums = 0;\n    for a in &arr {\n \
    \       if a > 0 {\n            total_nums += a;\n        }\n    }\n    total_nums\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu0vwhhy9.rs:14:16\n   |\n\
    14 |         if a > 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n\
    \    let mut num_sum = 0;\n\n    for num in arr {\n        if num < 0 {\n    \
    \        num *= -1;\n        }\n\n        for d in num.digits() {\n          \
    \  if d > 0 {\n                num_sum += d;\n            }\n        }\n    }\n\
    \n    num_sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp29eb0ell.rs:23:22\n   |\n23 |         for d in num.digits()\
    \ {\n   |                      ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().fold(0, |acc, x| {\n        if x >= 0\
    \ {\n            acc + 1\n        } else {\n            -(*x).leading_signum().unwrap()\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu00qal6d.rs:13:17\n   |\n\
    13 |         if x >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror[E0599]: no method named `leading_signum`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpu00qal6d.rs:16:19\n\
    \   |\n16 |             -(*x).leading_signum().unwrap()\n   |                \
    \   ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `leading_ones`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&a| a >= 0).count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn1hy5sam.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&a| a >= 0).count() as isize\n   |               \
    \                  ^\n   |                                 |\n   |           \
    \                      expected `&isize`, found integer\n   |                \
    \                 help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumgo_fzw.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count()\n   |                         \
    \       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpumgo_fzw.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n   |                                  \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut digits = arr\n        .iter()\n        .map(|n|\
    \ match n {\n            -1 => 0,\n            _ => n,\n        })\n        .filter(|x|\
    \ x > 0)\n        .cloned()\n        .collect::<Vec<_>>();\n\n    let mut n =\
    \ 0;\n    while digits.len() > 0 {\n        if digits.iter().any(|&x| x > 0) {\n\
    \            digits.remove(0);\n        } else {\n            n += 1;\n      \
    \  }\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpsmneva5x.rs:16:18\n\
    \   |\n14 |           .map(|n| match n {\n   |  __________________-\n15 | |  \
    \           -1 => 0,\n   | |                   - this is found to be of type `{integer}`\n\
    16 | |             _ => n,\n   | |                  ^ expected integer, found\
    \ `&isize`\n17 | |         })\n   | |_________- `match` arms have incompatible\
    \ types\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |           \
    \  _ => *n,\n   |                  +\n\nerror[E0277]: can't compare `&_` with\
    \ `{integer}`\n  --> /tmp/tmpsmneva5x.rs:18:23\n   |\n18 |         .filter(|x|\
    \ x > 0)\n   |                       ^ no implementation for `&_ < {integer}`\
    \ and `&_ > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>` is\
    \ not implemented for `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = 0;\n    for &i in arr {\n        if\
    \ i > 0 {\n            if i >= 10 {\n                n += 1;\n            } else\
    \ {\n                n += i as isize - 10;\n            }\n        }\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpttfxcj2i.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().map(|e| e > 0).count(|e| e)\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh6skvqv.rs:12:28\n   |\n\
    12 |     arr.iter().map(|e| e > 0).count(|e| e)\n   |                        \
    \    ^\n   |                            |\n   |                            expected\
    \ `&isize`, found integer\n   |                            help: consider borrowing\
    \ here: `&0`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpuh6skvqv.rs:12:31\n    |\n12  |     arr.iter().map(|e|\
    \ e > 0).count(|e| e)\n    |                               ^^^^^ ----- supplied\
    \ 1 argument\n    |                               |\n    |                   \
    \            expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuh6skvqv.rs:12:5\n   |\n11 | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n12 |     arr.iter().map(|e|\
    \ e > 0).count(|e| e)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().map(|e|\
    \ e > 0).count(|e| e).try_into().unwrap()\n   |                              \
    \             ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    count_nums_inner(&arr)\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nums_inner` in this scope\n \
    \ --> /tmp/tmp448hey4l.rs:12:5\n   |\n12 |     count_nums_inner(&arr)\n   |  \
    \   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter(|i| i >= 0)\n      \
    \  .filter(|i| i % 10 == 0)\n        .count(|i| i >= 0)\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd239_11x.rs:13:26\n   |\n\
    13 |         .filter(|i| i >= 0)\n   |                          ^ expected `&&isize`,\
    \ found integer\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpd239_11x.rs:14:23\n\
    \   |\n14 |         .filter(|i| i % 10 == 0)\n   |                     - ^ --\
    \ {integer}\n   |                     |\n   |                     &&isize\n  \
    \ |\nhelp: `%` can be used on `isize`, you can dereference `i`\n   |\n14 |   \
    \      .filter(|i| *i % 10 == 0)\n   |                     +\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpd239_11x.rs:15:10\n\
    \    |\n15  |         .count(|i| i >= 0)\n    |          ^^^^^ ---------- supplied\
    \ 1 argument\n    |          |\n    |          expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd239_11x.rs:12:5\n\
    \   |\n11 |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n12 | /  \
    \   arr.iter()\n13 | |         .filter(|i| i >= 0)\n14 | |         .filter(|i|\
    \ i % 10 == 0)\n15 | |         .count(|i| i >= 0)\n   | |__________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .count(|i|\
    \ i >= 0).try_into().unwrap()\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr\n        .iter()\n        .filter(|i| i >= 0)\n\
    \        .filter(|i| i >= 0)\n        .filter(|i| i >= 0)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_xqesul.rs:14:26\n   |\n\
    14 |         .filter(|i| i >= 0)\n   |                          ^ expected `&&isize`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_xqesul.rs:15:26\n\
    \   |\n15 |         .filter(|i| i >= 0)\n   |                          ^ expected\
    \ `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_xqesul.rs:16:26\n\
    \   |\n16 |         .filter(|i| i >= 0)\n   |                          ^ expected\
    \ `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_xqesul.rs:12:5\n\
    \   |\n11 |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n12 | /  \
    \   arr\n13 | |         .iter()\n14 | |         .filter(|i| i >= 0)\n15 | |  \
    \       .filter(|i| i >= 0)\n16 | |         .filter(|i| i >= 0)\n17 | |      \
    \   .count()\n   | |________________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |         .count().try_into().unwrap()\n   |         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr\n        .iter()\n        .filter_map(|x|\n\
    \            if x % 10 < 0 {\n                let first_digit = x as i32 - x %\
    \ 10;\n                Some(first_digit as isize)\n            } else {\n    \
    \            None\n            }\n        )\n        .filter(|x| x.is_some())\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspvyvcv_.rs:16:46\n   |\n\
    16 |                 let first_digit = x as i32 - x % 10;\n   |              \
    \                                ^^^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `i32`\n  --> /tmp/tmpspvyvcv_.rs:16:44\n   |\n\
    16 |                 let first_digit = x as i32 - x % 10;\n   |              \
    \                              ^ no implementation for `i32 - isize`\n   |\n \
    \  = help: the trait `Sub<isize>` is not implemented for `i32`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]: no method\
    \ named `is_some` found for reference `&isize` in the current scope\n  --> /tmp/tmpspvyvcv_.rs:22:23\n\
    \   |\n22 |         .filter(|x| x.is_some())\n   |                       ^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpspvyvcv_.rs:12:5\n\
    \   |\n11 |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n12 | /  \
    \   arr\n13 | |         .iter()\n14 | |         .filter_map(|x|\n15 | |      \
    \       if x % 10 < 0 {\n...  |\n22 | |         .filter(|x| x.is_some())\n23 |\
    \ |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror[E0606]: casting `&isize` as `i32`\
    \ is invalid\n  --> /tmp/tmpspvyvcv_.rs:16:35\n   |\n16 |                 let\
    \ first_digit = x as i32 - x % 10;\n   |                                   -^^^^^^^\n\
    \   |                                   |\n   |                              \
    \     cannot cast `&isize` as `i32`\n   |   "
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| *x >= 0).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbgpqnju.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|x| *x >= 0).count()\n   |                        \
    \         ^\n   |                                 |\n   |                    \
    \             expected `&isize`, found integer\n   |                         \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppbgpqnju.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| *x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ *x >= 0).count().try_into().unwrap()\n   |                                 \
    \          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // find the first element whose sum is > 0.\n  \
    \  let mut n: isize = 0;\n    let mut sum = 0;\n    while n > 0 {\n        sum\
    \ += n % 10;\n        n /= 10;\n    }\n    if sum > 0 {\n        n = sum;\n  \
    \  }\n    arr.iter().filter(|&n| *n > 0).count() as isize\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpbongepqj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    if arr.len() <= 1 {\n        return arr.len();\n    }\n\n    let mut cnt\
    \ = 0;\n    let mut digits = Vec::new();\n\n    for num in arr {\n        if num\
    \ < 0 {\n            digits.push(-num);\n        }\n\n        if num >= 0 {\n\
    \            digits.push(num % 10);\n        }\n    }\n\n    let mut last_digit\
    \ = 0;\n    let mut index = 0;\n    let mut i = 1;\n\n    while i <= digits.len()\
    \ {\n        let digit = digits[i];\n\n        if digit == 0 && i == 1 {\n   \
    \         // If we started with a negative number, we must\n            // adjust\
    \ the sign of the digit before counting\n            // the sum.\n           \
    \ if digits[i - 1] >= 0 {\n                digits[i - 1] -= 1;\n            }\n\
    \        }\n\n        let digit = digits[i - 1] + digit;\n\n        if digit >\
    \ 0 {\n            cnt += i;\n        } else {\n            cnt += digit - 1;\n\
    \            last_digit = digit;\n            i += 1;\n        }\n    }\n\n  \
    \  cnt + last_digit\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf29txmlg.rs:17:16\n   |\n\
    11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n17 |         return\
    \ arr.len();\n   |                ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         return arr.len().try_into().unwrap();\n\
    \   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf29txmlg.rs:54:20\n   |\n54 |             cnt += digit\
    \ - 1;\n   |                    ^^^^^^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpf29txmlg.rs:54:17\n\
    \   |\n54 |             cnt += digit - 1;\n   |                 ^^ no implementation\
    \ for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf29txmlg.rs:60:11\n\
    \   |\n60 |     cnt + last_digit\n   |           ^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf29txmlg.rs:60:5\n\
    \   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n...\n60 |   \
    \  cnt + last_digit\n   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n60 |     (cnt + last_digit).try_into().unwrap()\n \
    \  |     +                +++++++++++++++++++++\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmpf29txmlg.rs:60:9\n   |\n60 |     cnt + las"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if\
    \ i >= 0 { sum += i } else { sum += -i; i *= -1; };\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmp4w2kk04v.rs:14:50\n\
    \   |\n14 |         if i >= 0 { sum += i } else { sum += -i; i *= -1; };\n   |\
    \                                                  ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmp4w2kk04v.rs:14:50\n\
    \   |\n13 |     for i in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n14 |         if i >= 0 { sum += i } else { sum += -i; i *= -1; };\n\
    \   |                                                  ^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    let mut res = 0;\n    let\
    \ mut sign = 1;\n    for &x in arr.iter().rev() {\n        res += x / 10;\n  \
    \      res %= 10;\n        if res > 0 {\n            cnt += 1;\n        } else\
    \ {\n            if *x >= 0 {\n                sign *= -1;\n            }\n  \
    \          if cnt > 0 {\n                break;\n            }\n        }\n  \
    \  }\n    res * sign\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpnweaes9b.rs:21:16\n\
    \   |\n21 |             if *x >= 0 {\n   |                ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    for n in arr {\n        if n\
    \ > 0 {\n            i += n as isize;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpvypbxi7t.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumgo_fzw.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count()\n   |                         \
    \       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpumgo_fzw.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n   |                                  \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num_sum: isize = 0;\n    for (i, &n) in\
    \ arr.iter().enumerate() {\n        if n >= 0 {\n            num_sum += n;\n \
    \       }\n    }\n    num_sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpoa2lbbw2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for el in arr.iter().rev()\
    \ {\n        sum += el;\n        if sum > 0 { break; }\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmp84cs5q2x.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppjppo3sm.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppjppo3sm.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if\
    \ i >= 0 { sum += i } else { sum += -i; }\n    }\n    sum\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpo4k0z25n.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter_map(|n| if *n >= 0 { Some(*n)\
    \ } else { None }).count()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprvda8xrc.rs:12:5\n   |\n\
    11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n12 |     arr.iter().filter_map(|n|\
    \ if *n >= 0 { Some(*n) } else { None }).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter_map(|n|\
    \ if *n >= 0 { Some(*n) } else { None }).count().try_into().unwrap()\n   |   \
    \                                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for v in arr.iter() {\n  \
    \      if v < 0 {\n            v = -v;\n        }\n        sum += v;\n    }\n\
    \    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9dibwkm.rs:14:16\n   |\n\
    14 |         if v < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9dibwkm.rs:15:17\n\
    \   |\n13 |     for v in arr.iter() {\n   |         - expected due to the type\
    \ of this binding\n14 |         if v < 0 {\n15 |             v = -v;\n   |   \
    \              ^^\n   |                 |\n   |                 expected `&isize`,\
    \ found `isize`\n   |                 help: consider borrowing here: `&-v`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &i in &arr {\n       \
    \ if i >= 0 {\n            sum += i;\n        }\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp47lzjs0i.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .map(|x| if x > 0 { x.abs()\
    \ } else { -x })\n        .filter(|x| x > 0)\n        .count() as isize\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_8d2p2a.rs:13:25\n   |\n\
    13 |         .map(|x| if x > 0 { x.abs() } else { -x })\n   |                \
    \         ^\n   |                         |\n   |                         expected\
    \ `&isize`, found integer\n   |                         help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_8d2p2a.rs:14:25\n\
    \   |\n14 |         .filter(|x| x > 0)\n   |                         ^\n   | \
    \                        |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&0`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &i in arr {\n        sum\
    \ += i as isize;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpta5o1ps7.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        0\n    } else {\n \
    \       let mut count = 0;\n        for &n in arr {\n            if n >= 0 {\n\
    \                count += std::cmp::max(n - std::i32::min_value(), 0);\n     \
    \       } else {\n                count += n;\n            }\n        }\n    \
    \    count\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_value` in module `std::i32`\n \
    \ --> /tmp/tmpqa9htejl.rs:18:54\n   |\n18 |                 count += std::cmp::max(n\
    \ - std::i32::min_value(), 0);\n   |                                         \
    \             ^^^^^^^^^ not found in `std::i32`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqa9htejl.rs:16:13\n   |\n16 |         for &n in arr {\n   |   \
    \          ^^    --- this expression has type `Option<isize>`\n   |          \
    \   |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut first_neg = false;\n    for &x in arr {\n\
    \        if x == 0 {\n            continue;\n        }\n        if x < 0 {\n \
    \           if first_neg {\n                count += x;\n            } else {\n\
    \                count += 1 + x;\n            }\n            continue;\n     \
    \   }\n        if first_neg {\n            first_neg = false;\n        } else\
    \ {\n            count += 1;\n        }\n        count += x;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg30la85v.rs:17:9\n   |\n\
    17 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&i| i >= 0).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9p9smzz.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&i| i >= 0).count()\n   |                        \
    \         ^\n   |                                 |\n   |                    \
    \             expected `&isize`, found integer\n   |                         \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt9p9smzz.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|&i| i >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&i|\
    \ i >= 0).count().try_into().unwrap()\n   |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut ret = 0;\n    for val in arr {\n       \
    \ if val < 0 {\n            assert!(ret < 0);\n            ret = -ret;\n     \
    \   }\n        ret += val % 10;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: ret < 0'', /tmp/tmpx15r07fb.rs:15:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumgo_fzw.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count()\n   |                         \
    \       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpumgo_fzw.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n   |                                  \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // First we get the number of positive elements.\n\
    \    let len = arr.len();\n    let mut counter = 0;\n    for i in 0 .. len {\n\
    \        if arr[i] > 0 {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpd7cnkvwt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // Start with 0\n    let mut count_nums: isize =\
    \ 0;\n    // Go through each element of the array in reverse order\n    for elt\
    \ in arr.iter().rev() {\n        // The sign of the number\n        let sign =\
    \ elt >= 0;\n        // Get the index of the first digit which is greater than\
    \ zero\n        let digit = elt / 10;\n        let remainder = elt % 10;\n   \
    \     // Add 1 to count if digit > 0 and is greater than 0\n        if sign &&\
    \ digit > 0 {\n            count_nums += 1;\n        }\n        // Add remainder\
    \ to count if digit > 0 and is greater than 0\n        if sign && digit > 0 &&\
    \ remainder > 0 {\n            count_nums += 1;\n        }\n    }\n    count_nums\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaj3gxbod.rs:17:27\n   |\n\
    17 |         let sign = elt >= 0;\n   |                           ^\n   |    \
    \                       |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&0`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt: isize = 0;\n    for val in arr.iter().rev()\
    \ {\n        if val < 0 {\n            cnt += 1;\n            continue;\n    \
    \    }\n        let d = val % 10;\n        if d == 0 {\n            continue;\n\
    \        }\n        cnt += d;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2q9qvqy.rs:14:18\n   |\n\
    14 |         if val < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in arr {\n     \
    \   if num < 0 {\n            count -= num;\n        } else {\n            count\
    \ += num;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmph4kx0g9_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut counts = arr.iter().cloned().map(|x| x.to_digit()).collect();\n\
    \    for digit in counts.iter().rev() {\n        if *digit < 0 {\n           \
    \ *digit = - *digit;\n        }\n    }\n    arr.iter().filter(|&x| x >= 0).count(|&x|\
    \ x > 0).unwrap()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp31q9rbop.rs:12:52\n   |\n12 |     let mut counts\
    \ = arr.iter().cloned().map(|x| x.to_digit()).collect();\n   |               \
    \                                     ^^^^^^^^ method not found in `isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp31q9rbop.rs:18:33\n   |\n18 |  \
    \   arr.iter().filter(|&x| x >= 0).count(|&x| x > 0).unwrap()\n   |          \
    \                       ^\n   |                                 |\n   |      \
    \                           expected `&isize`, found integer\n   |           \
    \                      help: consider borrowing here: `&0`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp31q9rbop.rs:18:36\n\
    \    |\n18  |     arr.iter().filter(|&x| x >= 0).count(|&x| x > 0).unwrap()\n\
    \    |                                    ^^^^^ ---------- supplied 1 argument\n\
    \    |                                    |\n    |                           \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp31q9rbop.rs:18:54\n   |\n18 |     arr.iter().filter(|&x|\
    \ x >= 0).count(|&x| x > 0).unwrap()\n   |                                   \
    \                   ^^^^^^ method not found in `usize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for n in arr {\n       \
    \ if n > 0 {\n            count += n % 10;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpxg66_s3e.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for x in arr.iter() {\n  \
    \      if x >= 0 {\n            cnt += x;\n        }\n        else {\n       \
    \     cnt += x * -1 + 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpymnctb4q.rs:14:17\n   |\n\
    14 |         if x >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpumgo_fzw.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count()\n   |                         \
    \       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpumgo_fzw.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count().try_into().unwrap()\n   |                                  \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr.iter() {\n  \
    \      if *i > 0 {\n            sum += *i;\n        }\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmpmglt1rsl.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut total = 0;\n    for i in arr {\n       \
    \ if i < 0 {\n            total += i;\n        } else if let Some(j) = (i / 10).floor()\
    \ {\n            total += j;\n        }\n    }\n    total\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `floor` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmplhhp3zgc.rs:16:42\n   |\n16 |         } else if let Some(j)\
    \ = (i / 10).floor() {\n   |                                          ^^^^^ help:\
    \ there is an associated function with a similar name: `div_floor`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count(|x| x >= 0)\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa2cw2xhi.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count(|x| x >= 0)\n   |               \
    \                 ^ expected `&&isize`, found integer\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpa2cw2xhi.rs:12:35\n\
    \    |\n12  |     arr.iter().filter(|x| x >= 0).count(|x| x >= 0)\n    |     \
    \                              ^^^^^ ---------- supplied 1 argument\n    |   \
    \                                |\n    |                                   expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa2cw2xhi.rs:12:5\n   |\n11 | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                   ----- expected\
    \ `isize` because of return type\n12 |     arr.iter().filter(|x| x >= 0).count(|x|\
    \ x >= 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x| x >=\
    \ 0).count(|x| x >= 0).try_into().unwrap()\n   |                             \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdzaztvj.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|n| n > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfdzaztvj.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|n| n > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n \
    \   let mut n = 0;\n    for i in arr.iter() {\n        if i > 0 {\n          \
    \  n += arr[i] - i;\n        } else {\n            n += 1;\n        }\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprokda1nf.rs:17:16\n   |\n\
    17 |         if i > 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0277]: the type `[isize]` cannot be indexed by\
    \ `&isize`\n  --> /tmp/tmprokda1nf.rs:18:18\n   |\n18 |             n += arr[i]\
    \ - i;\n   |                  ^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut ans = 0.0;\n    for &x in arr {\n      \
    \  if x % 10 == 0 && x > 0 {\n            ans += x;\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp04o6mcby.rs:13:9\n   |\n\
    13 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp04o6mcby.rs:18:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n18 |     ans\n   |     ^^^ expected `isize`, found floating-point\
    \ number\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .cloned()\n        .filter(|num|\
    \ num >= 0)\n        .filter(|num| num > 0)\n        .filter(|num| num % 10 !=\
    \ 0)\n        .count(|num| num != 0)\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmsshm6hu.rs:14:30\n   |\n\
    14 |         .filter(|num| num >= 0)\n   |                              ^\n  \
    \ |                              |\n   |                              expected\
    \ `&isize`, found integer\n   |                              help: consider borrowing\
    \ here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmsshm6hu.rs:15:29\n\
    \   |\n15 |         .filter(|num| num > 0)\n   |                             ^\n\
    \   |                             |\n   |                             expected\
    \ `&isize`, found integer\n   |                             help: consider borrowing\
    \ here: `&0`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpmsshm6hu.rs:17:10\n    |\n17  |         .count(|num|\
    \ num != 0)\n    |          ^^^^^ -------------- supplied 1 argument\n    |  \
    \        |\n    |          expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmsshm6hu.rs:12:5\n\
    \   |\n11 |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n12 | /  \
    \   arr.iter()\n13 | |         .cloned()\n14 | |         .filter(|num| num >=\
    \ 0)\n15 | |         .filter(|num| num > 0)\n16 | |         .filter(|num| num\
    \ % 10 != 0)\n17 | |         .count(|num| num != 0)\n   | |______________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |         .count(|num|\
    \ num != 0).try_into().unwrap()\n   |                               ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut count = 0;\n    for x in arr {\n        count += x % 10;\n      \
    \  x /= 10;\n    }\n\n    if count > 0 {\n        count += 1;\n    }\n\n    count\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `x` is never read\n  --> /tmp/tmpyydolaep.rs:19:9\n\
    \   |\n19 |         x /= 10;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `x`\n  --> /tmp/tmpyydolaep.rs:19:9\n\
    \   |\n17 |     for x in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `x`\n   |         help: consider making this binding mutable:\
    \ `mut x`\n18 |         count += x % 10;\n19 |         x /= 10;\n   |        \
    \ ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut nums = vec![vec![0; 10]];\n    let mut digit = 0;\n    let mut sum\
    \ = 0;\n    for i in arr.iter() {\n        sum += i;\n        let mut c = nums[digit].as_mut();\n\
    \        if *c > 0 {\n            *c -= i;\n        } else {\n            *c +=\
    \ i;\n        }\n        digit += 1;\n    }\n    if sum > 0 {\n        nums[0][0]\
    \ = 1;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed for `&mut T`\n  --> /tmp/tmpc9jh4pp8.rs:20:33\n\
    \   |\n20 |         let mut c = nums[digit].as_mut();\n   |             -----\
    \               ^^^^^^ cannot infer type for type parameter `T` declared on the\
    \ trait `AsMut`\n   |             |\n   |             consider giving `c` the\
    \ explicit type `&mut T`, where the type parameter `T` is specified\n   |\n  \
    \ = note: multiple `impl`s satisfying `Vec<i32>: AsMut<_>` found in the `alloc`\
    \ crate:\n           - impl<T, A> AsMut<Vec<T, A>> for Vec<T, A>\n           \
    \  where A: Allocator;\n           - impl<T, A> AsMut<[T]> for Vec<T, A>\n   \
    \          where A: Allocator;\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0283`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().rev().peekable().filter(|x| x > 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnlgdyz58.rs:12:48\n   |\n\
    12 |     arr.iter().rev().peekable().filter(|x| x > 0).count()\n   |         \
    \                                       ^ expected `&&isize`, found integer\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnlgdyz58.rs:12:5\n   |\n11 | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n12 |     arr.iter().rev().peekable().filter(|x|\
    \ x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().rev().peekable().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppjppo3sm.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppjppo3sm.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num_digits = arr.len();\n    if num_digits\
    \ == 0 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut digits\
    \ = vec![0; num_digits];\n\n    for &n in arr {\n        let mut i = 0;\n    \
    \    while i < num_digits {\n            let d = n % 10;\n            if d > 0\
    \ {\n                digits[i] = d;\n                i += 1;\n            } else\
    \ {\n                if i >= num_digits - 1 {\n                    break;\n  \
    \              }\n                digits[i] = digits[i - 1];\n               \
    \ i += 1;\n            }\n        }\n        if i == num_digits {\n          \
    \  break;\n        }\n        let m = std::cmp::max(digits[..i].iter().sum(),\
    \ 0);\n        if m > 0 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0m3wryze.rs:20:9\n   |\n\
    20 |     for &n in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x >= 0 {\n            count += count_nums(vec![i as isize, x +\
    \ 1]);\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpa_ccbq03.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x > 0)\n        .map(|(i, x)| {\n            let mut s = x;\n          \
    \  let mut digit = 0;\n            while (s > 0) {\n                s = s / 10;\n\
    \                digit += 1;\n            }\n            if i == 0 {\n       \
    \         digit * -1\n            } else {\n                digit\n          \
    \  }\n        })\n        .sum()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqiei9h9i.rs:18:19\n\
    \   |\n18 |             while (s > 0) {\n   |                   ^     ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -             while (s > 0) {\n18 +             while s > 0 {\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqiei9h9i.rs:14:30\n   |\n\
    14 |         .filter(|(_, x)| x > 0)\n   |                              ^ expected\
    \ `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqiei9h9i.rs:18:24\n\
    \   |\n18 |             while (s > 0) {\n   |                        ^\n   | \
    \                       |\n   |                        expected `&isize`, found\
    \ integer\n   |                        help: consider borrowing here: `&0`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqiei9h9i.rs:19:21\n   |\n16 |  \
    \           let mut s = x;\n   |                         - expected due to this\
    \ value\n...\n19 |                 s = s / 10;\n   |                     ^^^^^^\n\
    \   |                     |\n   |                     expected `&isize`, found\
    \ `isize`\n   |                     help: consider borrowing here: `&(s / 10)`\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut res = 0;\n    for n in arr {\n        if\
    \ n > 0 {\n            res += n%10;\n        }\n        n /= 10;\n    }\n    if\
    \ res > 0 {\n        -1\n    } else {\n        0\n    }\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `n` is never read\n  --> /tmp/tmp30wse9u5.rs:17:9\n\
    \   |\n17 |         n /= 10;\n   |         ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `n`\n  --> /tmp/tmp30wse9u5.rs:17:9\n\
    \   |\n13 |     for n in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `n`\n   |         help: consider making this binding mutable:\
    \ `mut n`\n...\n17 |         n /= 10;\n   |         ^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut sum = 0;\n    let mut i = 0;\n    for num in arr.iter() {\n     \
    \   sum += num;\n        // use i to keep the sign\n        if sum > 0 {\n   \
    \         i += 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpwdya3o0h.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|n| n > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfdzaztvj.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|n| n > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfdzaztvj.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|n| n > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|n|\
    \ n > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut prev_sign = false;\n\
    \    for v in arr.iter() {\n        if *v < 0 {\n            count += !prev_sign;\n\
    \            *v = -(*v);\n            prev_sign = true;\n        } else {\n  \
    \          prev_sign = false;\n        }\n        count += *v as isize;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `bool` to `{integer}`\n  --> /tmp/tmp_y585myp.rs:16:19\n\
    \   |\n16 |             count += !prev_sign;\n   |                   ^^ no implementation\
    \ for `{integer} += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &i in arr.iter() {\n \
    \       if i >= 0 {\n            sum += i;\n        } else {\n            sum\
    \ += -i;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmp46srj_mb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = 0;\n    let mut carry = 0;\n\n    for\
    \ i in arr {\n        n += *i as isize - carry;\n        carry = *i as isize -\
    \ *i as isize - 1;\n    }\n    n += carry;\n    n\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpsmqqi4gw.rs:16:14\n\
    \   |\n16 |         n += *i as isize - carry;\n   |              ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpsmqqi4gw.rs:17:17\n   |\n\
    17 |         carry = *i as isize - *i as isize - 1;\n   |                 ^^\n\
    \nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpsmqqi4gw.rs:17:31\n\
    \   |\n17 |         carry = *i as isize - *i as isize - 1;\n   |             \
    \                  ^^\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut ret = 0;\n    for i in arr.iter() {\n  \
    \      ret += i / 10;\n        ret -= i % 10;\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpu4c_bo_d.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count().unwrap()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf0l15t0.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count().unwrap()\n   |                \
    \                ^\n   |                                |\n   |              \
    \                  expected `&isize`, found integer\n   |                    \
    \            help: consider borrowing here: `&0`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpzf0l15t0.rs:12:43\n\
    \   |\n12 |     arr.iter().filter(|&x| x > 0).count().unwrap()\n   |         \
    \                                  ^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n\
    \    let mut carry = 0;\n\n    for x in arr.iter().rev() {\n        let mut v\
    \ = x;\n        while v >= 10 {\n            v -= 10;\n            carry += 1;\n\
    \        }\n\n        arr.remove(0);\n        arr.append(v + carry);\n    }\n\n\
    \    arr.iter().filter(|x| *x > 0).sum()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2jf8bri2.rs:20:20\n   |\n\
    20 |         while v >= 10 {\n   |                    ^^\n   |               \
    \     |\n   |                    expected `&isize`, found integer\n   |      \
    \              help: consider borrowing here: `&10`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmp2jf8bri2.rs:21:13\n\
    \   |\n21 |             v -= 10;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `v`\n   |\n21 |             *v -= 10;\n   |\
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2jf8bri2.rs:26:20\n\
    \   |\n26 |         arr.append(v + carry);\n   |                    ^^^^^^^^^\
    \ expected `&mut Vec<isize>`, found `isize`\n   |\n   = note: expected mutable\
    \ reference `&mut Vec<isize>`\n                           found type `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2jf8bri2.rs:29:32\n   |\n29 |\
    \     arr.iter().filter(|x| *x > 0).sum()\n   |                              \
    \  ^\n   |                                |\n   |                            \
    \    expected `&isize`, found integer\n   |                                help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|num| num > 0).count()\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n1x3_f7.rs:12:35\n   |\n\
    12 |     arr.iter().filter(|num| num > 0).count()\n   |                      \
    \             ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9n1x3_f7.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>)\
    \ -> isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|num| num > 0).count()\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     arr.iter().filter(|num| num > 0).count().try_into().unwrap()\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .enumerate()\n        .filter(|(_,\
    \ elem)| elem > 0)\n        .count()\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkquewiv.rs:14:36\n   |\n\
    14 |         .filter(|(_, elem)| elem > 0)\n   |                             \
    \       ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphkquewiv.rs:12:5\n   |\n11 |   fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                     ----- expected `isize` because\
    \ of return type\n12 | /     arr.iter()\n13 | |         .enumerate()\n14 | | \
    \        .filter(|(_, elem)| elem > 0)\n15 | |         .count()\n   | |________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut result = 0;\n    for i in arr {\n      \
    \  result += (i * 10);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-30`,\n right: `0`', /tmp/tmp6z012_jv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x >= 0).count();\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5thf7z0i.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&x| x >= 0).count();\n   |                       \
    \          ^\n   |                                 |\n   |                   \
    \              expected `&isize`, found integer\n   |                        \
    \         help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5thf7z0i.rs:11:35\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |    ----------                     ^^^^^ expected `isize`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    let mut negative = arr[0].is_negative();\n\
    \    for &n in &arr {\n        if n.is_negative() {\n            negative = !negative;\n\
    \        }\n        sum += if n.is_positive() {\n            n - 1\n        }\
    \ else {\n            n - 2\n        };\n    }\n    sum + negative as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpdc1guv5_.rs:13:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut nums = arr.iter().map(|x| x as isize).collect::<Vec<_>>();\n    let\
    \ mut num_negatives = 0;\n    loop {\n        let mut i = arr.len() - 1;\n   \
    \     if nums[i].is_negative() {\n            num_negatives += 1;\n          \
    \  for i in &mut [0; num_negatives] {\n                nums[i] = -nums[i];\n \
    \           }\n        }\n        if num_negatives > 0 && nums[i] as isize % 10\
    \ == 0 {\n            i += 1;\n        }\n        if i >= 0 {\n            break;\n\
    \        }\n        nums = nums.iter().cloned().collect::<Vec<_>>();\n       \
    \ num_negatives = 0;\n    }\n    arr.len() - num_negatives\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpfbr161ug.rs:22:31\n   |\n17 |     let mut num_negatives = 0;\n   | \
    \    --------------------- help: consider using `const` instead of `let`: `const\
    \ num_negatives`\n...\n22 |             for i in &mut [0; num_negatives] {\n \
    \  |                               ^^^^^^^^^^^^^ non-constant value\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfbr161ug.rs:35:5\n   |\n11 | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                   ----- expected\
    \ `isize` because of return type\n...\n35 |     arr.len() - num_negatives\n  \
    \ |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |     (arr.len() - num_negatives).try_into().unwrap()\n   |  \
    \   +                         +++++++++++++++++++++\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpfbr161ug.rs:16:39\n   |\n16 |     let mut\
    \ nums = arr.iter().map(|x| x as isize).collect::<Vec<_>>();\n   |           \
    \                            -^^^^^^^^^\n   |                                \
    \       |\n   |                                       cannot cast `&isize` as\
    \ `isize`\n   |                                       help: dereference the expression:\
    \ `*x`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0435, E0606.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n \
    \   let mut sum: isize = 0;\n    let mut last_sign: isize = 0;\n    let mut max_neg:\
    \ isize = 0;\n    let mut min_neg: isize = 0;\n    for i in arr.iter().rev() {\n\
    \        sum += i;\n        last_sign = i;\n        if i as isize < 0 {\n    \
    \        min_neg += i as isize;\n        } else {\n            max_neg += i as\
    \ isize;\n        }\n        if sum > 0 {\n            break;\n        }\n   \
    \ }\n    if sum > 0 {\n        return sum as isize - last_sign;\n    }\n    //\
    \ For negative numbers we reverse the digits in order to count them backwards.\n\
    \    if arr.len() > 0 {\n        let mut arr2 = arr;\n        arr2.reverse();\n\
    \        for mut i in arr2 {\n            sum -= i;\n            last_sign = -i;\n\
    \            if sum > 0 {\n                return sum as isize - last_sign;\n\
    \            }\n        }\n    }\n    if min_neg < max_neg {\n        max_neg\n\
    \    } else {\n        min_neg\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `isize`,\
    \ not a comparison\n  --> /tmp/tmpw8994zz2.rs:22:23\n   |\n22 |         if i as\
    \ isize < 0 {\n   |                       ^ --- interpreted as generic arguments\n\
    \   |                       |\n   |                       not interpreted as comparison\n\
    \   |\nhelp: try comparing the cast value\n   |\n22 |         if (i as isize)\
    \ < 0 {\n   |            +          +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw8994zz2.rs:21:21\n   |\n16 |     let mut last_sign: isize = 0;\n  \
    \ |                        ----- expected due to this type\n...\n21 |        \
    \ last_sign = i;\n   |                     ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |         last_sign =\
    \ *i;\n   |                     +\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpw8994zz2.rs:22:12\n   |\n22 |         if i as isize\
    \ < 0 {\n   |            -^^^^^^^^^\n   |            |\n   |            cannot\
    \ cast `&isize` as `isize`\n   |            help: dereference the expression:\
    \ `*i`\n\nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpw8994zz2.rs:23:24\n\
    \   |\n23 |             min_neg += i as isize;\n   |                        -^^^^^^^^^\n\
    \   |                        |\n   |                        cannot cast `&isize`\
    \ as `isize`\n   |                        help: dereference the expression: `*i`\n\
    \nerror[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpw8994zz2.rs:25:24\n\
    \   |\n25 |             max_neg += i as isize;\n   |                        -^^^^^^^^^\n\
    \   |                        |\n   |                        cannot cast `&isize`\
    \ as `isize`\n   |                        help: dereference the expression: `*i`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&i| i >= 0).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9p9smzz.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&i| i >= 0).count()\n   |                        \
    \         ^\n   |                                 |\n   |                    \
    \             expected `&isize`, found integer\n   |                         \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt9p9smzz.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|&i| i >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&i|\
    \ i >= 0).count().try_into().unwrap()\n   |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count_nums = arr.iter().filter(|n| *n >\
    \ 0).count();\n    if count_nums < 0 {\n        count_nums *= -1;\n    }\n   \
    \ count_nums\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp398mqx6r.rs:12:53\n   |\n\
    12 |     let mut count_nums = arr.iter().filter(|n| *n > 0).count();\n   |   \
    \                                                  ^\n   |                   \
    \                                  |\n   |                                   \
    \                  expected `&isize`, found integer\n   |                    \
    \                                 help: consider borrowing here: `&0`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp398mqx6r.rs:14:23\n\
    \   |\n14 |         count_nums *= -1;\n   |                       ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp398mqx6r.rs:16:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n16 |     count_nums\n   |     ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     count_nums.try_into().unwrap()\n\
    \   |               ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for &num in arr {\n      \
    \  if num >= 0 {\n            cnt += 1;\n        } else {\n            cnt +=\
    \ ((num % 10) as isize) + 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59j9x2ar.rs:13:9\n   |\n\
    13 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for &n in arr {\n        cnt\
    \ += count_digits(n);\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_digits` in this scope\n  -->\
    \ /tmp/tmp025aq87_.rs:14:16\n   |\n14 |         cnt += count_digits(n);\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp025aq87_.rs:13:9\n   |\n13 |     for &n in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // find the first negative number (or if no negative,\
    \ any number not starting with 0)\n    let mut neg_idx = arr.iter().position(|&x|\
    \ x < 0).unwrap_or(0);\n\n    // count the number of elements with digits in range\
    \ [0, 10] greater than 0\n    let mut nums = 0;\n    for &x in arr.iter().skip(neg_idx)\
    \ {\n        if x >= 10 { nums += x - 10 } else { nums += 1 }\n    }\n    nums\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpr_6jdyah.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n\
    \    if arr[0] < 0 {\n        let mut result = 1;\n        for &i in arr {\n \
    \           if i >= 0 {\n                result *= i::abs_sub(i);\n          \
    \  }\n        }\n        return result;\n    }\n\n    let mut result = 1;\n  \
    \  for &i in arr {\n        let mut j = i;\n        while j > 0 {\n          \
    \  if j % 10 == 0 {\n                result += 1;\n            }\n           \
    \ j /= 10;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `i`\n\
    \  --> /tmp/tmph2cbxln3.rs:20:27\n   |\n20 |                 result *= i::abs_sub(i);\n\
    \   |                           ^ use of undeclared crate or module `i`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph2cbxln3.rs:18:13\n   |\n18 |         for &i\
    \ in arr {\n   |             ^^    --- this expression has type `Option<isize>`\n\
    \   |             |\n   |             expected `isize`, found reference\n   |\
    \             help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph2cbxln3.rs:27:9\n   |\n27 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    let mut neg = false;\n   \
    \ for i in arr {\n        if i < 0 {\n            neg = true;\n            i -=\
    \ 10;\n        }\n        if i >= 10 {\n            cnt += 1;\n        }\n   \
    \     if neg {\n            i += 10;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmp5w2frgmv.rs:23:13\n\
    \   |\n23 |             i += 10;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmp5w2frgmv.rs:17:13\n\
    \   |\n14 |     for i in arr {\n   |         -\n   |         |\n   |         first\
    \ assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n...\n17 |             i -= 10;\n   |             ^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `i`\n  --> /tmp/tmp5w2frgmv.rs:23:13\n   |\n14 |     for i in arr {\n\
    \   |         -\n   |         |\n   |         first assignment to `i`\n   |  \
    \       help: consider making this binding mutable: `mut i`\n...\n23 |       \
    \      i += 10;\n   |             ^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count_nums = 0;\n    for num in arr {\n\
    \        if num > 0 {\n            count_nums += 1;\n        } else if num < 0\
    \ {\n            count_nums += std::mem::swap(num as u32, -num as u32);\n    \
    \    }\n    }\n    count_nums\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7m4kciaa.rs:17:42\n   |\n\
    17 |             count_nums += std::mem::swap(num as u32, -num as u32);\n   |\
    \                                          ^^^^^^^^^^\n   |                  \
    \                        |\n   |                                          expected\
    \ `&mut _`, found `u32`\n   |                                          help: consider\
    \ mutably borrowing here: `&mut (num as u32)`\n   |\n   = note: expected mutable\
    \ reference `&mut _`\n                           found type `u32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7m4kciaa.rs:17:54\n   |\n17 |             count_nums\
    \ += std::mem::swap(num as u32, -num as u32);\n   |                          \
    \                            ^^^^^^^^^^^\n   |                               \
    \                       |\n   |                                              \
    \        expected `&mut _`, found `u32`\n   |                                \
    \                      help: consider mutably borrowing here: `&mut (-num as u32)`\n\
    \   |\n   = note: expected mutable reference `&mut _`\n                      \
    \     found type `u32`\n\nerror[E0277]: cannot add-assign `()` to `{integer}`\n\
    \  --> /tmp/tmp7m4kciaa.rs:17:24\n   |\n17 |             count_nums += std::mem::swap(num\
    \ as u32, -num as u32);\n   |                        ^^ no implementation for\
    \ `{integer} += ()`\n   |\n   = help: the trait `AddAssign<()>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for v in arr.iter() {\n  \
    \      sum += v;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpc1k79bbp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x >= 0).count() + count_digits(arr)\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_digits` in this scope\n  -->\
    \ /tmp/tmpr_rt28ug.rs:12:46\n   |\n12 |     arr.iter().filter(|&x| x >= 0).count()\
    \ + count_digits(arr)\n   |                                              ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr_rt28ug.rs:12:33\n\
    \   |\n12 |     arr.iter().filter(|&x| x >= 0).count() + count_digits(arr)\n \
    \  |                                 ^\n   |                                 |\n\
    \   |                                 expected `&isize`, found integer\n   | \
    \                                help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr_rt28ug.rs:12:5\n   |\n11 | fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                   ----- expected\
    \ `isize` because of return type\n12 |     arr.iter().filter(|&x| x >= 0).count()\
    \ + count_digits(arr)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (arr.iter().filter(|&x|\
    \ x >= 0).count() + count_digits(arr)).try_into().unwrap()\n   |     +       \
    \                                                   +++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut total_digits = 0;\n    for num in arr {\n\
    \        if num < 0 {\n            total_digits += num;\n        } else {\n  \
    \          total_digits += num % 10;\n        }\n    }\n    total_digits\n}\n\n\
    fn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmptpr8hxfb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = arr\n        .iter()\n        .cloned()\n\
    \        .filter(|i| i != 0)\n        .count();\n    for &i in n {\n        if\
    \ *i < 0 {\n            *i -= 1;\n        }\n    }\n    n\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_93bf8zx.rs:15:23\n\
    \   |\n15 |         .filter(|i| i != 0)\n   |                       ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: `usize` is not an iterator\n\
    \  --> /tmp/tmp_93bf8zx.rs:17:15\n   |\n17 |     for &i in n {\n   |         \
    \      ^ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `usize`\n   = note: if you want to iterate between `start`\
    \ until a value `end`, use the exclusive range syntax `start..end` or the inclusive\
    \ range syntax `start..=end`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_93bf8zx.rs:22:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n...\n22 |     n\n   |     ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |     n.try_into().unwrap()\n   |      ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    // Initialize counter\n    let mut cnt = 0;\n\n\
    \    // Iterate over all elements\n    for (i, &d) in arr.iter().enumerate() {\n\
    \        // If element is non-negative then add it to counter\n        if d >=\
    \ 0 {\n            cnt += 1;\n        }\n\n        // Otherwise check if first\
    \ digit is negative\n        else {\n            if d < 0 {\n                cnt\
    \ += 1;\n            }\n        }\n    }\n\n    // Return counter\n    cnt\n}\n\
    \nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmp9d3x5kwy.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    for n in arr {\n        i +=\
    \ if n > 0 { n } else { -n };\n    }\n    i\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `0`', /tmp/tmpm5kgth7u.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|n| n < 0).count().unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz2ncv725.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|n| n < 0).count().unwrap_or(0)\n   |             \
    \                  ^ expected `&&isize`, found integer\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for type `usize` in the current scope\n  --> /tmp/tmpz2ncv725.rs:12:42\n\
    \   |\n12 |     arr.iter().filter(|n| n < 0).count().unwrap_or(0)\n   |      \
    \                                    ^^^^^^^^^ method not found in `usize`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2iqbhfur.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count() as isize\n   |                \
    \                ^\n   |                                |\n   |              \
    \                  expected `&isize`, found integer\n   |                    \
    \            help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| *x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx4fzq9h7.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| *x > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx4fzq9h7.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|x| *x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ *x > 0).count().try_into().unwrap()\n   |                                  \
    \        ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter(|&x| x > 0)\n      \
    \  .filter(|&x| x % 10 != 0)\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykphyneq.rs:13:26\n   |\n\
    13 |         .filter(|&x| x > 0)\n   |                          ^\n   |      \
    \                    |\n   |                          expected `&isize`, found\
    \ integer\n   |                          help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpykphyneq.rs:12:5\n   |\n11 | \
    \  fn count_nums(arr: Vec<isize>) -> isize {\n   |                           \
    \          ----- expected `isize` because of return type\n12 | /     arr.iter()\n\
    13 | |         .filter(|&x| x > 0)\n14 | |         .filter(|&x| x % 10 != 0)\n\
    15 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt: isize = 0;\n    for n in arr {\n  \
    \      cnt += n >= 0;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `bool` to `isize`\n  --> /tmp/tmpmwon6mms.rs:14:13\n\
    \   |\n14 |         cnt += n >= 0;\n   |             ^^ no implementation for\
    \ `isize += bool`\n   |\n   = help: the trait `AddAssign<bool>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = 0;\n    for num in arr.iter() {\n  \
    \      if num < 0 {\n            n += (-num) as isize;\n        } else {\n   \
    \         n += num as isize;\n        }\n    }\n    n\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp05qw8g4x.rs:14:18\n   |\n\
    14 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmp05qw8g4x.rs:17:18\n   |\n17 |             n += num\
    \ as isize;\n   |                  ---^^^^^^^^^\n   |                  |\n   |\
    \                  cannot cast `&isize` as `isize`\n   |                  help:\
    \ dereference the expression: `*num`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in arr.iter() {\n\
    \        if num < 0 {\n            if let Some(digit) = num.leading_sign() {\n\
    \                count += digit as isize;\n            }\n            continue;\n\
    \        }\n        count += num as isize;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpct9znyzv.rs:14:18\n   |\n\
    14 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0599]: no method named `leading_sign`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpct9znyzv.rs:15:38\n\
    \   |\n15 |             if let Some(digit) = num.leading_sign() {\n   |      \
    \                                ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `leading_ones`\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmpct9znyzv.rs:20:18\n   |\n20 |         count += num\
    \ as isize;\n   |                  ---^^^^^^^^^\n   |                  |\n   |\
    \                  cannot cast `&isize` as `isize`\n   |                  help:\
    \ dereference the expression: `*num`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count();\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp18kn832i.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count();\n   |                        \
    \        ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp18kn832i.rs:11:35\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |    ----------                     ^^^^^ expected `isize`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr\n        .iter()\n        .filter(|i| i > 0)\n\
    \        .filter(|i| i > 0)\n        .filter(|i| i % 10 != 0)\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp809x5vp6.rs:14:25\n   |\n\
    14 |         .filter(|i| i > 0)\n   |                         ^ expected `&&isize`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp809x5vp6.rs:15:25\n\
    \   |\n15 |         .filter(|i| i > 0)\n   |                         ^ expected\
    \ `&&isize`, found integer\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmp809x5vp6.rs:16:23\n   |\n16 |         .filter(|i| i % 10 != 0)\n\
    \   |                     - ^ -- {integer}\n   |                     |\n   | \
    \                    &&isize\n   |\nhelp: `%` can be used on `isize`, you can\
    \ dereference `i`\n   |\n16 |         .filter(|i| *i % 10 != 0)\n   |        \
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp809x5vp6.rs:12:5\n\
    \   |\n11 |   fn count_nums(arr: Vec<isize>) -> isize {\n   |                \
    \                     ----- expected `isize` because of return type\n12 | /  \
    \   arr\n13 | |         .iter()\n14 | |         .filter(|i| i > 0)\n15 | |   \
    \      .filter(|i| i > 0)\n16 | |         .filter(|i| i % 10 != 0)\n17 | |   \
    \      .count()\n   | |________________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n17 |         .count().try_into().unwrap()\n   |         \
    \        ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num = 0;\n    for digit in arr {\n     \
    \   if digit > 0 {\n            num += 1\n        }\n    }\n    num\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpjx1rmmph.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x >= 0).count().unwrap()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo2yknb3c.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&x| x >= 0).count().unwrap()\n   |               \
    \                  ^\n   |                                 |\n   |           \
    \                      expected `&isize`, found integer\n   |                \
    \                 help: consider borrowing here: `&0`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmpo2yknb3c.rs:12:44\n\
    \   |\n12 |     arr.iter().filter(|&x| x >= 0).count().unwrap()\n   |        \
    \                                    ^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    count_nums_impl(arr, vec![], 0)\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nums_impl` in this scope\n  -->\
    \ /tmp/tmpt2pxsyo5.rs:12:5\n   |\n12 |     count_nums_impl(arr, vec![], 0)\n \
    \  |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr.iter() {\n  \
    \      sum += i as isize;\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmpv9t9e3jn.rs:14:16\n\
    \   |\n14 |         sum += i as isize;\n   |                -^^^^^^^^^\n   | \
    \               |\n   |                cannot cast `&isize` as `isize`\n   | \
    \               help: dereference the expression: `*i`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for x in arr {\n        sum\
    \ += x;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpyh5pog05.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().cloned().filter(|&x| x > 0).count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfx83_trq.rs:12:5\n   |\n\
    11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n12 |     arr.iter().cloned().filter(|&x|\
    \ x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().cloned().filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \                ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for x in arr.iter() {\n  \
    \      if x > 0 {\n            cnt += x;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuy8pfo5u.rs:14:16\n   |\n\
    14 |         if x > 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut count = 1;\n    let mut last_positive = false;\n    let mut arr =\
    \ arr.iter().cloned().collect::<Vec<_>>();\n    if arr.len() > 0 && arr[0] < 0\
    \ {\n        arr.swap(0, 1);\n        last_positive = true;\n    }\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        // skip leading zeros (since count_nums\
    \ will count these too)\n        if i > 0 {\n            if n % 10 == 0 {\n  \
    \              continue;\n            }\n            if last_positive {\n    \
    \            count -= 1;\n            }\n            if n < 0 {\n            \
    \    count += 1;\n            }\n        }\n        last_positive = n < 0;\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnw1yv29e.rs:32:20\n   |\n\
    32 |             if n < 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnw1yv29e.rs:36:29\n   |\n36 |         last_positive = n < 0;\n\
    \   |                             ^\n   |                             |\n   |\
    \                             expected `&isize`, found integer\n   |         \
    \                    help: consider borrowing here: `&0`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    for i in &arr {\n        if *i >= 0 {\n         \
    \   i += 10;\n        }\n        for d in &i {\n            if *d > 0 {\n    \
    \            *d -= 1;\n                count += 1;\n                break;\n \
    \           }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&isize`\n  --> /tmp/tmpmdtrdaz_.rs:18:13\n   |\n18 |             i += 10;\n\
    \   |             -^^^^^^\n   |             |\n   |             cannot use `+=`\
    \ on type `&isize`\n   |\nhelp: `+=` can be used on `isize`, you can dereference\
    \ `i`\n   |\n18 |             *i += 10;\n   |             +\n\nerror[E0277]: `&&isize`\
    \ is not an iterator\n  --> /tmp/tmpmdtrdaz_.rs:20:18\n   |\n20 |         for\
    \ d in &i {\n   |                  ^^ `&&isize` is not an iterator\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&&isize`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&&isize`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0368.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for &a in arr {\n      \
    \  if a < 0 {\n            a *= -1;\n        }\n        if a > 9 {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9dt5o75v.rs:13:9\n   |\n\
    13 |     for &a in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `a`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for x in arr {\n        if\
    \ x < 0 {\n            cnt += x;\n        } else {\n            cnt += 1 if x\
    \ > 9 { cnt += 10; } { cnt += 1; }\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmph9k6_jfb.rs:17:22\n   |\n17 |             cnt += 1 if x\
    \ > 9 { cnt += 10; } { cnt += 1; }\n   |                      ^^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num_count = 0;\n    for num in arr {\n \
    \       if num < 0 {\n            num *= -1;\n        }\n        let d = &num\
    \ as i32 - 1;\n        if d > 0 {\n            d %= 10;\n        }\n        num_count\
    \ += *d as usize;\n    }\n    num_count\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `i32` cannot be dereferenced\n  --> /tmp/tmp6ypepgau.rs:21:22\n\
    \   |\n21 |         num_count += *d as usize;\n   |                      ^^\n\n\
    error[E0606]: casting `&isize` as `i32` is invalid\n  --> /tmp/tmp6ypepgau.rs:17:17\n\
    \   |\n17 |         let d = &num as i32 - 1;\n   |                 ----^^^^^^^\n\
    \   |                 |\n   |                 cannot cast `&isize` as `i32`\n\
    \   |                 help: dereference the expression: `*&num`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0606, E0614.\n\
    For more information about an error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n \
    \   let mut sum: isize = 0;\n    let mut min_val = arr.iter().min();\n    for\
    \ n in arr.iter().skip(1) {\n        sum += (n*10 as usize - min_val*10 + 1).wrapping_mul(n\
    \ as usize);\n        min_val = n;\n    }\n    sum\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu5m4km2o.rs:18:19\n   |\n\
    18 |         sum += (n*10 as usize - min_val*10 + 1).wrapping_mul(n as usize);\n\
    \   |                   ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot multiply `&isize` by `usize`\n  --> /tmp/tmpu5m4km2o.rs:18:18\n   |\n\
    18 |         sum += (n*10 as usize - min_val*10 + 1).wrapping_mul(n as usize);\n\
    \   |                  ^ no implementation for `&isize * usize`\n   |\n   = help:\
    \ the trait `Mul<usize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0369]: cannot\
    \ multiply `Option<&isize>` by `{integer}`\n  --> /tmp/tmpu5m4km2o.rs:18:40\n\
    \   |\n18 |         sum += (n*10 as usize - min_val*10 + 1).wrapping_mul(n as\
    \ usize);\n   |                                 -------^-- {integer}\n   |   \
    \                              |\n   |                                 Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu5m4km2o.rs:18:62\n   |\n18 |\
    \         sum += (n*10 as usize - min_val*10 + 1).wrapping_mul(n as usize);\n\
    \   |                                                              ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |         sum\
    \ += (n*10 as usize - min_val*10 + 1).wrapping_mul((n as usize).try_into().unwrap());\n\
    \   |                                                              +         \
    \ +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu5m4km2o.rs:19:19\n\
    \   |\n16 |     let mut min_val = arr.iter().min();\n   |                    \
    \   ---------------- expected due to this value\n...\n19 |         min_val = n;\n\
    \   |                   ^ expected enum `Option`, found `&i"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        0\n    } else {\n \
    \       let mut n = 0;\n        let mut m = arr[0].to_digits();\n        let mut\
    \ x = 1;\n        while *m.len() > 0 {\n            n += x;\n            x /=\
    \ 10;\n            m -= 1;\n        }\n        n\n    }\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp07fbv4jb.rs:16:28\n   |\n16 |         let mut m\
    \ = arr[0].to_digits();\n   |                            ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut res = 0;\n    for &i in arr {\n        if\
    \ i < 0 {\n            i += 10;\n        }\n        res += i % 10;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2tmt7ls.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut counter = 0;\n    for val in arr {\n   \
    \     if val < 0 {\n            val %= 10;\n            if val >= 0 {\n      \
    \          counter = 1 + counter;\n            }\n        } else {\n         \
    \   val %= 10;\n            if val >= 0 {\n                counter = counter +\
    \ val;\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `val`\n  --> /tmp/tmpoc36ziml.rs:15:13\n\
    \   |\n13 |     for val in arr {\n   |         ---\n   |         |\n   |     \
    \    first assignment to `val`\n   |         help: consider making this binding\
    \ mutable: `mut val`\n14 |         if val < 0 {\n15 |             val %= 10;\n\
    \   |             ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `val`\n  --> /tmp/tmpoc36ziml.rs:20:13\n\
    \   |\n13 |     for val in arr {\n   |         ---\n   |         |\n   |     \
    \    first assignment to `val`\n   |         help: consider making this binding\
    \ mutable: `mut val`\n...\n20 |             val %= 10;\n   |             ^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter(|i| i > 0isize)\n  \
    \      .count();\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13ylz_s0.rs:13:25\n   |\n\
    13 |         .filter(|i| i > 0isize)\n   |                         ^^^^^^ expected\
    \ `&&isize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13ylz_s0.rs:11:35\n\
    \   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |    ----------    \
    \                 ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for i in arr {\n        if\
    \ i < 0 {\n            sum += i;\n        } else {\n            sum += i * i;\n\
    \        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpy1d5m2t0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n\n\
    \    let mut nums = arr.clone();\n    let mut sum = 0;\n\n    while nums.len()\
    \ > 0 {\n        let first = nums.first().unwrap();\n        let mut digit = first\
    \ % 10;\n        if digit > 0 {\n            sum += digit;\n        }\n      \
    \  nums.remove(0);\n    }\n\n    nums.reverse();\n    nums.reverse();\n\n    sum\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `6`', /tmp/tmp9rq_pf_2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    for &num in arr {\n        i\
    \ += if num < 0 {\n            -num\n        } else {\n            num\n     \
    \   };\n    }\n    i\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq832ry6y.rs:13:9\n   |\n\
    13 |     for &num in arr {\n   |         ^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&i| i != 0).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp7oaa5cwf.rs:12:30\n\
    \   |\n12 |     arr.iter().filter(|&i| i != 0).count()\n   |                 \
    \             ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7oaa5cwf.rs:12:5\n   |\n11 | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n12 |     arr.iter().filter(|&i|\
    \ i != 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&i| i\
    \ != 0).count().try_into().unwrap()\n   |                                    \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut n = 0;\n    for &i in arr {\n        n += if i >= 0 { 1 } else {\
    \ -1 };\n    }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdeooe5kv.rs:17:9\n   |\n\
    17 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppjppo3sm.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppjppo3sm.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for &i in arr {\n        if\
    \ i > 0 {\n            sum += i as isize;\n        }\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxloeh056.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut num: usize = 0;\n    for elt in arr {\n        if elt > 0 {\n   \
    \         let mut nums: usize = 0;\n            while elt >= 10 {\n          \
    \      elt /= 10;\n                nums += 1;\n            }\n            num\
    \ += nums as usize;\n        }\n    }\n    num\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1fh10oka.rs:26:5\n   |\n\
    11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n26 |     num\n\
    \   |     ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     num.try_into().unwrap()\n\
    \   |        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut result = vec![];\n\n    for n in arr {\n\
    \        if n < 0 {\n            n = -n as isize;\n        }\n        let digits\
    \ = &[...(n as isize)].chars().take(4);\n        let digit = digits.iter().sum();\n\
    \        result.push(digit as isize);\n    }\n\n    if result.is_empty() {\n \
    \       return 0;\n    }\n\n    let mut n = 0.;\n    let mut d = 0.;\n    for\
    \ d in result {\n        n += d;\n        if n == 100 {\n            return d;\n\
    \        }\n    }\n    n -= 100;\n    if n < 0 {\n        n += 100;\n    }\n \
    \   n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmp5d1m6pdu.rs:18:24\n   |\n\
    18 |         let digits = &[...(n as isize)].chars().take(4);\n   |          \
    \              ^^^\n   |\nhelp: use `..` for an exclusive range\n   |\n18 |  \
    \       let digits = &[..(n as isize)].chars().take(4);\n   |                \
    \        ~~\nhelp: or `..=` for an inclusive range\n   |\n18 |         let digits\
    \ = &[..=(n as isize)].chars().take(4);\n   |                        ~~~\n\nerror[E0599]:\
    \ no method named `chars` found for array `[RangeToInclusive<isize>; 1]` in the\
    \ current scope\n  --> /tmp/tmp5d1m6pdu.rs:18:41\n   |\n18 |         let digits\
    \ = &[...(n as isize)].chars().take(4);\n   |                                \
    \         ^^^^^ method not found in `[RangeToInclusive<isize>; 1]`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `{float}`\n  --> /tmp/tmp5d1m6pdu.rs:30:11\n  \
    \ |\n30 |         n += d;\n   |           ^^ no implementation for `{float} +=\
    \ isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented for\
    \ `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: can't compare `{float}` with `{integer}`\n  --> /tmp/tmp5d1m6pdu.rs:31:14\n\
    \   |\n31 |         if n == 100 {\n   |              ^^ no implementation for\
    \ `{float} == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5d1m6pdu.rs:31:17\n   |\n31 |         if n == 100 {\n   |          \
    \       ^^^ expected floating-point number, found integer\n\nerro"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&n| n > 0).count();\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphq_crwzh.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&n| n > 0).count();\n   |                        \
    \        ^\n   |                                |\n   |                      \
    \          expected `&isize`, found integer\n   |                            \
    \    help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmphq_crwzh.rs:11:35\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |    ----------                     ^^^^^ expected `isize`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().rev().fold(0, |acc, i| acc + if i < *i\
    \ { 1 } else { 0 })\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_jys3rr7.rs:12:52\n   |\n\
    12 |     arr.iter().rev().fold(0, |acc, i| acc + if i < *i { 1 } else { 0 })\n\
    \   |                                                    ^^\n   |            \
    \                                        |\n   |                             \
    \                       expected `&isize`, found `isize`\n   |               \
    \                                     help: consider borrowing here: `&*i`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut counts = vec![0];\n\n    for &d in arr.iter().cloned()\
    \ {\n        if d < 0 {\n            d += 10;\n        }\n\n        counts[d -\
    \ 10] += 1;\n    }\n\n    counts.iter().sum()\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzzegcb4t.rs:14:9\n   |\n\
    14 |     for &d in arr.iter().cloned() {\n   |         ^^    -------------------\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `d`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut digit_sum = 0;\n    for num in arr.iter()\
    \ {\n        if num < 0 {\n            num = -num;\n        }\n        let digits\
    \ = num / 10;\n        if digits > 0 {\n            digit_sum += digits;\n   \
    \     }\n    }\n    digit_sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlhg5ctb.rs:14:18\n   |\n\
    14 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprlhg5ctb.rs:15:19\n   |\n13 |     for num in arr.iter() {\n   |    \
    \     --- expected due to the type of this binding\n14 |         if num < 0 {\n\
    15 |             num = -num;\n   |                   ^^^^\n   |              \
    \     |\n   |                   expected `&isize`, found `isize`\n   |       \
    \            help: consider borrowing here: `&-num`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().fold(0, |sum, i| if sum < 0 { -(*i).abs()\
    \ + 1 } else { 1 })\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp3wkobz0p.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut nums = arr.clone();\n    let mut sum = 0;\n\
    \    for n in nums.iter() {\n        sum += n;\n        if sum < 0 {\n       \
    \     sum -= n;\n        }\n    }\n    nums.len() - sum\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp141yf7j9.rs:20:18\n   |\n\
    20 |     nums.len() - sum\n   |                  ^^^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp141yf7j9.rs:20:5\n   |\n11 | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n...\n20 |     nums.len() -\
    \ sum\n   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     (nums.len() - sum).try_into().unwrap()\n   |     +     \
    \           +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmp141yf7j9.rs:20:16\n   |\n20 |     nums.len() - sum\n\
    \   |                ^ no implementation for `usize - isize`\n   |\n   = help:\
    \ the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x >= 0).count(|x| x % 10 !=\
    \ 0)\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqyngq7x.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|x| x >= 0).count(|x| x % 10 != 0)\n   |          \
    \                      ^ expected `&&isize`, found integer\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppqyngq7x.rs:12:35\n\
    \    |\n12  |     arr.iter().filter(|x| x >= 0).count(|x| x % 10 != 0)\n    |\
    \                                   ^^^^^ --------------- supplied 1 argument\n\
    \    |                                   |\n    |                            \
    \       expected 0 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppqyngq7x.rs:12:5\n   |\n11 | fn\
    \ count_nums(arr: Vec<isize>) -> isize {\n   |                               \
    \    ----- expected `isize` because of return type\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count(|x| x % 10 != 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x >= 0).count(|x| x % 10 != 0).try_into().unwrap()\n   |                   \
    \                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut total_nums: isize = 0;\n    for num in arr.iter()\
    \ {\n        total_nums += (digits(num).len() * num_digits(num));\n    }\n   \
    \ total_nums\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digits` in this scope\n  --> /tmp/tmpiaglby2e.rs:14:24\n\
    \   |\n14 |         total_nums += (digits(num).len() * num_digits(num));\n   |\
    \                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `num_digits` in this scope\n  --> /tmp/tmpiaglby2e.rs:14:44\n\
    \   |\n14 |         total_nums += (digits(num).len() * num_digits(num));\n   |\
    \                                            ^^^^^^^^^^ not found in this scope\n\
    \nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmpiaglby2e.rs:14:23\n\
    \   |\n14 |         total_nums += (digits(num).len() * num_digits(num));\n   |\
    \                       ^                                   ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    14 -         total_nums += (digits(num).len() * num_digits(num));\n14 +      \
    \   total_nums += digits(num).len() * num_digits(num);\n   | \n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&n| n > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7adizn0.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&n| n > 0).count()\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         expected `&isize`, found integer\n   |                             \
    \   help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_7adizn0.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize\
    \ {\n   |                                   ----- expected `isize` because of\
    \ return type\n12 |     arr.iter().filter(|&n| n > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&n|\
    \ n > 0).count().try_into().unwrap()\n   |                                   \
    \       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in arr {\n       \
    \ sum += num;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `0`', /tmp/tmpyu4sakw2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x < 0).count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphzqcibr3.rs:12:32\n   |\n\
    12 |     arr.iter().filter(|&x| x < 0).count() as isize\n   |                \
    \                ^\n   |                                |\n   |              \
    \                  expected `&isize`, found integer\n   |                    \
    \            help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut res = 0;\n    for i in arr {\n        res\
    \ += i + i + i;\n    }\n    res\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-9`,\n right: `0`', /tmp/tmpzxt4yocj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&i| i >= 0).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9p9smzz.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&i| i >= 0).count()\n   |                        \
    \         ^\n   |                                 |\n   |                    \
    \             expected `&isize`, found integer\n   |                         \
    \        help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt9p9smzz.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|&i| i >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|&i|\
    \ i >= 0).count().try_into().unwrap()\n   |                                  \
    \         ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut i = 0;\n    while i < arr.len() {\n    \
    \    if arr[i] - arr[i] == 0 {\n            i += 1;\n        } else {\n      \
    \      break;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_sa_237b.rs:20:5\n   |\n\
    11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                         \
    \          ----- expected `isize` because of return type\n...\n20 |     i\n  \
    \ |     ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n20 |     i.try_into().unwrap()\n\
    \   |      ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut sum = 0;\n    let mut count = 0;\n\n    for i in arr.iter() {\n \
    \       if i >= 0 {\n            sum += i;\n        } else {\n            count\
    \ += i;\n        }\n    }\n\n    count - sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbov6_u8b.rs:20:17\n   |\n\
    20 |         if i >= 0 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut n = 0;\n    for el in arr.iter().rev() {\n\
    \        n += el as isize % 10;\n        n += el as isize / 10 as isize;\n   \
    \ }\n    n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `isize` is invalid\n  --> /tmp/tmp1pf2d1lg.rs:14:14\n\
    \   |\n14 |         n += el as isize % 10;\n   |              --^^^^^^^^^\n  \
    \ |              |\n   |              cannot cast `&isize` as `isize`\n   |  \
    \            help: dereference the expression: `*el`\n\nerror[E0606]: casting\
    \ `&isize` as `isize` is invalid\n  --> /tmp/tmp1pf2d1lg.rs:15:14\n   |\n15 |\
    \         n += el as isize / 10 as isize;\n   |              --^^^^^^^^^\n   |\
    \              |\n   |              cannot cast `&isize` as `isize`\n   |    \
    \          help: dereference the expression: `*el`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut num = 0;\n    for &x in arr {\n        if\
    \ x > 0 {\n            num += (x % 10).unwrap();\n        } else {\n         \
    \   num += (-x % 10).unwrap();\n        }\n    }\n    num\n}\n\nfn main() {\n\
    \    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7xq6oixo.rs:13:9\n   |\n\
    13 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    let mut max_digit = 0;\n \
    \   for i in arr {\n        if i.is_negative() {\n            let sign = -i as\
    \ isize;\n            cnt += sign;\n            max_digit = sign;\n        } else\
    \ {\n            cnt += i;\n            max_digit = i;\n        }\n    }\n   \
    \ cnt + (max_digit > 0 ? 1 : 0)\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `1`\n\
    \  --> /tmp/tmp6zb74hwj.rs:24:28\n   |\n24 |     cnt + (max_digit > 0 ? 1 : 0)\n\
    \   |                            ^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \nerror: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `...`, `.`, `;`, `<`,\
    \ `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`,\
    \ `}`, `~`, an operator, lifetime, or path, found `0`\n  --> /tmp/tmp6zb74hwj.rs:24:32\n\
    \   |\n24 |     cnt + (max_digit > 0 ? 1 : 0)\n   |                          \
    \      ^ expected one of 26 possible tokens\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().map(|x| x if x > 0 as isize % 10 == 0\
    \ as isize % 10).sum()\n}\n\nfn main() {\n    let candidate = count_nums;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmph39luti6.rs:12:31\n\
    \   |\n12 |     arr.iter().map(|x| x if x > 0 as isize % 10 == 0 as isize % 10).sum()\n\
    \   |                               ^                 ^^\n   |\nhelp: parenthesize\
    \ the comparison\n   |\n12 |     arr.iter().map(|x| x if (x > 0 as isize % 10)\
    \ == 0 as isize % 10).sum()\n   |                             +              \
    \     +\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmph39luti6.rs:12:26\n   |\n12 |     arr.iter().map(|x|\
    \ x if x > 0 as isize % 10 == 0 as isize % 10).sum()\n   |                   \
    \       ^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph39luti6.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().map(|x| x if x > 0 as isize % 10 == 0 as\
    \ isize % 10).sum()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Map`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmph39luti6.rs:12:20:\
    \ 12:25]>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for num in arr.iter() {\n\
    \        if num < 0 {\n            sum += num as isize\n        } else {\n   \
    \         sum += num as isize * 10 + (num % 10) as isize;\n        }\n    }\n\
    \    sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9b3cghtt.rs:14:18\n   |\n\
    14 |         if num < 0 {\n   |                  ^\n   |                  |\n\
    \   |                  expected `&isize`, found integer\n   |                \
    \  help: consider borrowing here: `&0`\n\nerror[E0606]: casting `&isize` as `isize`\
    \ is invalid\n  --> /tmp/tmp9b3cghtt.rs:15:20\n   |\n15 |             sum += num\
    \ as isize\n   |                    ---^^^^^^^^^\n   |                    |\n\
    \   |                    cannot cast `&isize` as `isize`\n   |               \
    \     help: dereference the expression: `*num`\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmp9b3cghtt.rs:17:20\n   |\n17 |         \
    \    sum += num as isize * 10 + (num % 10) as isize;\n   |                   \
    \ ---^^^^^^^^^\n   |                    |\n   |                    cannot cast\
    \ `&isize` as `isize`\n   |                    help: dereference the expression:\
    \ `*num`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0606.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0\n    }\n \
    \   if arr.iter().any(|&x| x < 0) {\n        return -1\n    }\n    let mut n =\
    \ 0\n    for &x in arr {\n        n += x + count_nums(&x.digits());\n    }\n \
    \   n\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp2bnqnm5a.rs:18:18\n\
    \   |\n18 |     let mut n = 0\n   |                  ^ help: add `;` here\n19\
    \ |     for &x in arr {\n   |     --- unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2bnqnm5a.rs:19:9\n   |\n19 |     for &x in arr {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().cloned().filter(|&x| x > 0).count() as\
    \ isize\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp9lvkv5ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .map(|i| {\n            if i\
    \ < 0 {\n                (-i).abs() as isize\n            } else {\n         \
    \       i as isize\n            }\n        })\n        .filter(|i| i > 0)\n  \
    \      .count() as isize\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtf6n0lq.rs:14:20\n   |\n\
    14 |             if i < 0 {\n   |                    ^\n   |                 \
    \   |\n   |                    expected `&isize`, found integer\n   |        \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphtf6n0lq.rs:20:25\n   |\n20 |         .filter(|i| i > 0)\n   |\
    \                         ^\n   |                         |\n   |            \
    \             expected `&isize`, found integer\n   |                         help:\
    \ consider borrowing here: `&0`\n\nerror[E0606]: casting `&isize` as `isize` is\
    \ invalid\n  --> /tmp/tmphtf6n0lq.rs:17:17\n   |\n17 |                 i as isize\n\
    \   |                 -^^^^^^^^^\n   |                 |\n   |               \
    \  cannot cast `&isize` as `isize`\n   |                 help: dereference the\
    \ expression: `*i`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0606.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut sum = 0;\n    for\
    \ i in arr.iter() {\n        if i < 0 {\n            count += 1;\n           \
    \ sum += i;\n        } else {\n            sum += i;\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = count_nums;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbqlww9qj.rs:15:16\n   |\n\
    15 |         if i < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    for x in arr {\n       \
    \ if x >= 0 {\n            count += 1;\n        }\n        else {\n          \
    \  count += count_nums(-x)\n        }\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0b00ia6r.rs:18:33\n   |\n\
    18 |             count += count_nums(-x)\n   |                               \
    \  ^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut cnt = 0;\n    for &i in arr {\n        if\
    \ i >= 0 {\n            cnt += 1;\n        } else if i < 0 {\n            cnt\
    \ += 1;\n            i -= 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n  \
    \  let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwli1ajy.rs:13:9\n   |\n\
    13 |     for &i in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut ret: isize = 0;\n    let mut digits = 0;\n\
    \n    for &x in arr {\n        let x = unsafe { std::mem::transmute(x) };\n  \
    \      if x > 0 {\n            digits += 1;\n        }\n        else {\n     \
    \       digits -= 1;\n        }\n        ret += if digits == 0 {\n           \
    \ 1\n        } else {\n            x\n        };\n    }\n\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbksslqi.rs:15:9\n   |\n\
    15 |     for &x in arr {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut acc = 0;\n    let mut digit = arr[0];\n    for i in arr.iter().rev()\
    \ {\n        if i < 0 {\n            digit -= 1;\n        }\n        if digit\
    \ < 0 {\n            break;\n        }\n        acc += 1;\n        digit = i;\n\
    \    }\n    acc\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzx50k3j6.rs:18:16\n   |\n\
    18 |         if i < 0 {\n   |                ^\n   |                |\n   |  \
    \              expected `&isize`, found integer\n   |                help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzx50k3j6.rs:25:17\n\
    \   |\n16 |     let mut digit = arr[0];\n   |                     ------ expected\
    \ due to this value\n...\n25 |         digit = i;\n   |                 ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    25 |         digit = *i;\n   |                 +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut num_elems = 1;\n    let mut last_sign = 1;\n    for i in arr.iter().rev()\
    \ {\n        let n = if *i > 0 { -(*i) } else { 0 };\n        (*last_sign) * (*i)\
    \ + n * num_elems;\n        num_elems *= 10;\n        last_sign = n;\n    }\n\
    \    num_elems / 10\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmprkfgozhs.rs:19:9\n\
    \   |\n19 |         (*last_sign) * (*i) + n * num_elems;\n   |         ^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut nums = arr.iter();\n    let mut counter\
    \ = 0;\n    while nums.any(|&x| x > 0) {\n        let x = nums.next().unwrap();\n\
    \        nums = nums.chain(vec![x]);\n        if x >= 0 {\n            counter++;\n\
    \        }\n    }\n    counter as usize\n}\n\nfn main() {\n    let candidate =\
    \ count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpqlqb7ec0.rs:18:20\n\
    \   |\n18 |             counter++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp =\
    \ counter; counter += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             counter++;\n18 +             counter += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqlqb7ec0.rs:16:16\n   |\n12 |     let mut nums\
    \ = arr.iter();\n   |                    ---------- expected due to this value\n\
    ...\n16 |         nums = nums.chain(vec![x]);\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `std::slice::Iter`, found struct `std::iter::Chain`\n   |\n\
    \   = note: expected struct `std::slice::Iter<'_, _>`\n              found struct\
    \ `std::iter::Chain<std::slice::Iter<'_, _>, std::vec::IntoIter<&isize>>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpqlqb7ec0.rs:17:17\n   |\n17 |  \
    \       if x >= 0 {\n   |                 ^\n   |                 |\n   |    \
    \             expected `&isize`, found integer\n   |                 help: consider\
    \ borrowing here: `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlqb7ec0.rs:21:5\n\
    \   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n...\n21 |   \
    \  counter as usize\n   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     (counter as usize).try_into().unwrap()\n \
    \  |     +                +++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x < 0).count() + arr.iter().filter(|x|\
    \ x >= 0).count()\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ptgv53p.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x < 0).count() + arr.iter().filter(|x| x >= 0).count()\n\
    \   |                               ^ expected `&&isize`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8ptgv53p.rs:12:71\n   |\n12 |     arr.iter().filter(|x|\
    \ x < 0).count() + arr.iter().filter(|x| x >= 0).count()\n   |               \
    \                                                        ^ expected `&&isize`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ptgv53p.rs:12:5\n\
    \   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                  \
    \                 ----- expected `isize` because of return type\n12 |     arr.iter().filter(|x|\
    \ x < 0).count() + arr.iter().filter(|x| x >= 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (arr.iter().filter(|x|\
    \ x < 0).count() + arr.iter().filter(|x| x >= 0).count()).try_into().unwrap()\n\
    \   |     +                                                                  \
    \          +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|&x| x >= 0).count().unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu7qz61xr.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|&x| x >= 0).count().unwrap_or(0)\n   |           \
    \                      ^\n   |                                 |\n   |       \
    \                          expected `&isize`, found integer\n   |            \
    \                     help: consider borrowing here: `&0`\n\nerror[E0599]: no\
    \ method named `unwrap_or` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpu7qz61xr.rs:12:44\n   |\n12 |     arr.iter().filter(|&x| x >= 0).count().unwrap_or(0)\n\
    \   |                                            ^^^^^^^^^ method not found in\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|n| n < 0).count() * -1 + (arr.iter().filter(|n|\
    \ n < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count() - 1) as isize)\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6j1hydps.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|n| n < 0).count() * -1 + (arr.iter().filter(|n| n\
    \ < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count() - 1) as...\n   |  \
    \                             ^ expected `&&isize`, found integer\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp6j1hydps.rs:12:44\n\
    \   |\n12 |     arr.iter().filter(|n| n < 0).count() * -1 + (arr.iter().filter(|n|\
    \ n < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count() - 1) as...\n   |\
    \                                            ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6j1hydps.rs:12:76\n\
    \   |\n12 |     arr.iter().filter(|n| n < 0).count() * -1 + (arr.iter().filter(|n|\
    \ n < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count() - 1) as...\n   |\
    \                                                                            ^\
    \ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6j1hydps.rs:12:120\n\
    \   |\n12 | ... n < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count() - 1)\
    \ as isize)\n   |                                                     ^ expected\
    \ `&&isize`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6j1hydps.rs:12:93\n\
    \   |\n12 | ...|n| n < 0).count() * 1 - (arr.iter().filter(|n| n < 0).count()\
    \ - 1) as isize)\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmp6j1hydps.rs:12:91\n   |\n12 |     arr.iter().filter(|n|\
    \ n < 0).count() * -1 + (arr.iter().filter(|n| n < 0).count() * 1 - (arr.iter().filter(|n|\
    \ n < 0).count() - 1) as...\n   |                                            \
    \                                               ^ no im"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter()\n        .filter_map(|x| if x > 0 { Some(x\
    \ - 1) } else { None })\n        .filter(|x| x.is_some())\n        .count()\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpggddzbr_.rs:13:32\n   |\n\
    13 |         .filter_map(|x| if x > 0 { Some(x - 1) } else { None })\n   |   \
    \                             ^\n   |                                |\n   | \
    \                               expected `&isize`, found integer\n   |       \
    \                         help: consider borrowing here: `&0`\n\nerror[E0599]:\
    \ no method named `is_some` found for reference `&isize` in the current scope\n\
    \  --> /tmp/tmpggddzbr_.rs:14:23\n   |\n14 |         .filter(|x| x.is_some())\n\
    \   |                       ^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpggddzbr_.rs:12:5\n   |\n11 |   fn count_nums(arr:\
    \ Vec<isize>) -> isize {\n   |                                     ----- expected\
    \ `isize` because of return type\n12 | /     arr.iter()\n13 | |         .filter_map(|x|\
    \ if x > 0 { Some(x - 1) } else { None })\n14 | |         .filter(|x| x.is_some())\n\
    15 | |         .count()\n   | |________________^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n15 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut neg_count = 1;\n\
    \    for i in arr {\n        if i < 0 {\n            count -= 1;\n        } else\
    \ {\n            count += 1;\n        }\n        if i == 0 {\n            continue;\n\
    \        }\n        if count < neg_count {\n            return neg_count;\n  \
    \      }\n        neg_count -= 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n\
    \    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpu5gmi3sd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 101
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    let mut sum = 0;\n    for (i, &n) in arr.iter().enumerate()\
    \ {\n        if n >= 0 {\n            sum += n;\n        } else {\n          \
    \  sum += n * 10;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1,\
    \ -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n  \
    \  assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1,\
    \ 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56,\
    \ 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-30`,\n right: `0`', /tmp/tmps8a327ix.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976129
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|x| x > 0).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtc_6p96.rs:12:31\n   |\n\
    12 |     arr.iter().filter(|x| x > 0).count()\n   |                          \
    \     ^ expected `&&isize`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtc_6p96.rs:12:5\n   |\n11 | fn count_nums(arr: Vec<isize>) ->\
    \ isize {\n   |                                   ----- expected `isize` because\
    \ of return type\n12 |     arr.iter().filter(|x| x > 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     arr.iter().filter(|x|\
    \ x > 0).count().try_into().unwrap()\n   |                                   \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976128
- exit_code: 1
  program: "/// Write a function count_nums which takes a vector of integers and returns\n\
    /// the number of elements which has a sum of digits > 0.\n/// If a number is\
    \ negative, then its first signed digit will be negative:\n/// e.g. -123 has signed\
    \ digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1,\
    \ 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr:\
    \ Vec<isize>) -> isize {\n    arr.iter().filter(|n| *n >= 0).count() as isize\n\
    }\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
    \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
    \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
    \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
    \ 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptseu7vu6.rs:12:33\n   |\n\
    12 |     arr.iter().filter(|n| *n >= 0).count() as isize\n   |               \
    \                  ^\n   |                                 |\n   |           \
    \                      expected `&isize`, found integer\n   |                \
    \                 help: consider borrowing here: `&0`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976129
