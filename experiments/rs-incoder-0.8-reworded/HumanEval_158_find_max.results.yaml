language: rs
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .windows(2)\n        .map(|w| w.iter().cloned().map(|x| x.chars().count()).max())\n\
    \        .max_by_key(|i| i)\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp_jj49ye4.rs:14:10\n   |\n14 |         .windows(2)\n\
    \   |          ^^^^^^^ method not found in `std::vec::IntoIter<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = String::new();\n\n    for word in words {\n        unique_chars.push_str(&word);\n\
    \    }\n\n    unique_chars.sort();\n\n    let mut max_chars = unique_chars.len()\
    \ as u32;\n    let mut max_word = String::from(\"no_word\");\n\n    for word in\
    \ words {\n        let mut unique_char = unique_chars.clone();\n\n        for\
    \ char in word.chars() {\n            if !unique_char.contains(&char) {\n    \
    \            unique_char.push_str(&char);\n            }\n        }\n\n      \
    \  if unique_char.len() > max_chars {\n            max_chars = unique_char.len();\n\
    \            max_word = word;\n        }\n    }\n\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpb47srz9v.rs:18:18\n   |\n18 |     unique_chars.sort();\n\
    \   |                  ^^^^ method not found in `String`\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpb47srz9v.rs:27:38\n \
    \    |\n27   |             if !unique_char.contains(&char) {\n     |         \
    \                    -------- ^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                             |\n     |                             required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n27   |             if !unique_char.contains(*&char) {\n     |\
    \                                      +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpb47srz9v.rs:28:38\n   |\n28 |                 unique_char.push_str(&char);\n\
    \   |                                      ^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb47srz9v.rs:32:32\n   |\n32 |\
    \         if unique_char.len() > max_chars {\n   |                           \
    \     ^^^^^^^^^ expected `usize`, found `u32`\n   |\nhelp: you can convert a `u32`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n32 |      \
    \   if unique_char.len() > max_chars.try_into().unwrap() {\n   |             \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb47srz9v.rs:33:25\n   |\n20 |     let mut max_chars = unique_chars.len()\
    \ as u32;\n   |                         ------------------------- expected due\
    \ to this value\n...\n33 |             max_chars = unique_char.len();\n   |  \
    \                       ^^^^^^^^^^^^^^^^^ "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = vec![String::new(); words.len()];\n\n    for (i, word) in words.into_iter().enumerate()\
    \ {\n        counters[i] = 0;\n        for c in word.chars() {\n            counters[i]\
    \ += 1;\n        }\n    }\n\n    let mut best_word = String::new();\n    let mut\
    \ max_cnt = 0;\n\n    for cnt in counters.iter() {\n        if cnt > max_cnt {\n\
    \            best_word = words[cnt.index(0)];\n            max_cnt = cnt;\n  \
    \      }\n    }\n\n    best_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyt1n40ln.rs:15:23\n   |\n\
    15 |         counters[i] = 0;\n   |         -----------   ^- help: try using a\
    \ conversion method: `.to_string()`\n   |         |             |\n   |      \
    \   |             expected struct `String`, found integer\n   |         expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyt1n40ln.rs:17:28\n\
    \   |\n17 |             counters[i] += 1;\n   |                            ^ expected\
    \ `&str`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyt1n40ln.rs:25:18\n\
    \   |\n25 |         if cnt > max_cnt {\n   |                  ^^^^^^^ expected\
    \ `&String`, found integer\n\nerror[E0599]: no method named `index` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpyt1n40ln.rs:26:35\n\
    \   |\n26 |             best_word = words[cnt.index(0)];\n   |               \
    \                    ^^^^^ method not found in `&String`\n   |\n   = help: items\
    \ from traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyt1n40ln.rs:27:23\n\
    \   |\n22 |     let mut max_cnt = 0;\n   |                       - expected due\
    \ to this value\n...\n27 |             max_cnt = cnt;\n   |                  \
    \     ^^^ expected integer, found `&String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_helper(words,\
    \ std::collections::HashMap::new(), 0)\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_helper` in this scope\n  -->\
    \ /tmp/tmp_izsg2y6.rs:12:5\n   |\n12 |     find_max_helper(words, std::collections::HashMap::new(),\
    \ 0)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counts\
    \ = HashMap::new();\n    let mut max_word = String::new();\n    for (i, word)\
    \ in words.iter().enumerate() {\n        char_counts.entry(chars(word).clone()).or_default()\
    \ += 1;\n        if char_counts[chars(word)] > max_word.len() {\n            max_word\
    \ = word;\n        }\n    }\n    if max_word.len() < 2 {\n        return String::from(\"\
    \");\n    }\n    if char_counts.len() < 2 {\n        return String::from(\"\"\
    );\n    }\n    if char_counts[chars(max_word)] > char_counts[chars(max_word)]\
    \ {\n        max_word = String::from(\"\");\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpi0z7i5cq.rs:12:27\n   |\n12 |     let mut char_counts = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find function `chars` in this scope\n  --> /tmp/tmpi0z7i5cq.rs:15:27\n\
    \   |\n15 |         char_counts.entry(chars(word).clone()).or_default() += 1;\n\
    \   |                           ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `chars` in this scope\n  --> /tmp/tmpi0z7i5cq.rs:16:24\n\
    \   |\n16 |         if char_counts[chars(word)] > max_word.len() {\n   |     \
    \                   ^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `chars` in this scope\n  --> /tmp/tmpi0z7i5cq.rs:26:20\n   |\n26 |\
    \     if char_counts[chars(max_word)] > char_counts[chars(max_word)] {\n   | \
    \                   ^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `chars` in this scope\n  --> /tmp/tmpi0z7i5cq.rs:26:51\n   |\n26 |\
    \     if char_counts[chars(max_word)] > char_counts[chars(max_word)] {\n   | \
    \                                                  ^^^^^ not found in this scope\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpi0z7i5cq.rs:15:61\n\
    \   |\n15 |         char_counts.entry(chars(word).clone()).or_default() += 1;\n\
    \   |         --------------------------------------------------- ^^\n   |   \
    \      |\n   |         cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi0z7i5cq.rs:17:24\n   |\n13 |     let mut max_word = String::new();\n\
    \   |                        ------------- expected due to this value\n...\n17\
    \ |             max_word = word;\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0425, E0433.\nFor more information abou"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word = String::new();\n    for (i, w) in words.iter().enumerate()\
    \ {\n        let mut c = w.chars().distinct().count();\n        if c > max_count\
    \ {\n            max_count = c;\n            max_word = w;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `distinct` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpfmmzo0en.rs:15:31\n   |\n15 |         let mut c\
    \ = w.chars().distinct().count();\n   |                               ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfmmzo0en.rs:18:24\n\
    \   |\n13 |     let mut max_word = String::new();\n   |                      \
    \  ------------- expected due to this value\n...\n18 |             max_word =\
    \ w;\n   |                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = words.iter().fold(vec![], |mut counters, s| {\n        let mut count = counters.len();\n\
    \        if let Some(&mut item) = counters.get(&s) {\n            if *item >=\
    \ count {\n                *item = count + 1;\n            }\n        } else {\n\
    \            counters.push(1);\n        }\n        counters\n    });\n    counters\n\
    \        .iter()\n        .max_by_key(|&(string, count)| count.cmp(&1))\n    \
    \    .unwrap()\n        .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[_]` cannot be indexed by `&&String`\n   --> /tmp/tmppddnfqfw.rs:14:47\n\
    \    |\n14  |         if let Some(&mut item) = counters.get(&s) {\n    |     \
    \                                      --- ^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n    |                                           |\n  \
    \  |                                           required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&&String`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppddnfqfw.rs:14:21\n   |\n14 |\
    \         if let Some(&mut item) = counters.get(&s) {\n   |                  \
    \   ^^^^^^^^^    ---------------- this expression has type `Option<&_>`\n   |\
    \                     |\n   |                     types differ in mutability\n\
    \   |                     help: you can probably remove the explicit borrow: `item`\n\
    \   |\n   = note:      expected reference `&_`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppddnfqfw.rs:25:23\n\
    \   |\n25 |         .max_by_key(|&(string, count)| count.cmp(&1))\n   |      \
    \                 ^^^^^^^^^^^^^^-\n   |                       |             |\n\
    \   |                       |             expected due to this\n   |         \
    \              expected integer, found tuple\n   |\n   = note: expected type `{integer}`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_by_keys(words,\
    \ |key, _| key.len())\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_by_keys` in this scope\n \
    \ --> /tmp/tmpe72gbkum.rs:12:5\n   |\n12 |     find_max_by_keys(words, |key, _|\
    \ key.len())\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().chain(\n\
    \        words.iter().map(|s| s.chars()).chain(\n            words.iter().map(|s|\
    \ s.bytes()).chain(\n                words.iter().map(|s| s.chars().count()).chain(\n\
    \                    words.iter().map(|s| s.bytes().count()),\n              \
    \  ),\n            ),\n        ),\n    )\n    .max_by_key(|v| v.len().unwrap())\n\
    \    .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpunpirk39.rs:15:34:\
    \ 15:55] as FnOnce<(&String,)>>::Output == std::str::Bytes<'_>`\n   --> /tmp/tmpunpirk39.rs:15:17\n\
    \    |\n14  |               words.iter().map(|s| s.bytes()).chain(\n    |    \
    \                                           ----- required by a bound introduced\
    \ by this call\n15  | /                 words.iter().map(|s| s.chars().count()).chain(\n\
    16  | |                     words.iter().map(|s| s.bytes().count()),\n17  | |\
    \                 ),\n    | |_________________^ expected struct `std::str::Bytes`,\
    \ found `usize`\n    |\n    = note: required because of the requirements on the\
    \ impl of `Iterator` for `Map<std::slice::Iter<'_, String>, [closure@/tmp/tmpunpirk39.rs:15:34:\
    \ 15:55]>`\n    = note: 1 redundant requirement hidden\n    = note: required because\
    \ of the requirements on the impl of `Iterator` for `std::iter::Chain<Map<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmpunpirk39.rs:15:34: 15:55]>, Map<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmpunpirk39.rs:16:38: 16:59]>>`\nnote: required by a\
    \ bound in `std::iter::Iterator::chain`\n\nerror[E0271]: type mismatch resolving\
    \ `<[closure@/tmp/tmpunpirk39.rs:16:38: 16:59] as FnOnce<(&String,)>>::Output\
    \ == std::str::Bytes<'_>`\n   --> /tmp/tmpunpirk39.rs:15:17\n    |\n14  |    \
    \           words.iter().map(|s| s.bytes()).chain(\n    |                    \
    \                           ----- required by a bound introduced by this call\n\
    15  | /                 words.iter().map(|s| s.chars().count()).chain(\n16  |\
    \ |                     words.iter().map(|s| s.bytes().count()),\n17  | |    \
    \             ),\n    | |_________________^ expected struct `std::str::Bytes`,\
    \ found `usize`\n    |\n    = note: required because of the requirements on the\
    \ impl of `Iterator` for `Map<std::slice::Iter<'_, String>, [closure@/tmp/tmpunpirk39.rs:16:38:\
    \ 16:59]>`\n    = note: 1 redundant requirement hidden\n    = note: required because\
    \ of the requirements on the impl of `Iterator` for `std::iter::Chain<Map<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmpunpirk39."
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique:\
    \ usize = 0;\n    let mut max_index: usize = 0;\n    for word in words {\n   \
    \     let mut unique: usize = 0;\n        let mut index: usize = 0;\n        for\
    \ c in word.chars() {\n            if !c.is_alphanumeric() {\n               \
    \ break;\n            }\n            unique += 1;\n            index += 1;\n \
    \       }\n        if unique > max_unique {\n            max_unique = unique;\n\
    \            max_index = index;\n        }\n    }\n    words[max_index].clone()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `words`\n   --> /tmp/tmpwgwf2g7l.rs:29:5\n\
    \    |\n11  | fn find_max(words: Vec<String>) -> String {\n    |             -----\
    \ move occurs because `words` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n14  |     for word in words {\n    |                \
    \ ----- `words` moved due to this implicit call to `.into_iter()`\n...\n29  |\
    \     words[max_index].clone()\n    |     ^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `words`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n14  |     for word in &words {\n\
    \    |                 +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n\n    let mut first_word = words.iter().filter_map(|word|\
    \ {\n        word.chars().filter_map(|c| c.is_alphanumeric()).count() as usize\n\
    \    }).max();\n\n    if first_word.as_ref().unwrap() == 0 {\n        first_word\
    \ = words.iter().filter_map(|word| {\n            word.chars().filter(|c| !c.is_alphanumeric()).count()\
    \ as usize\n        }).max();\n    }\n\n    let mut num_unique_chars = 0;\n\n\
    \    for word in words {\n        if let Some(count) = unique_chars.get_mut(&word)\
    \ {\n            *count += 1;\n        } else {\n            unique_chars.insert(word.clone(),\
    \ 1);\n        }\n    }\n\n    for word in words {\n        if let Some(count)\
    \ = unique_chars.get_mut(&word) {\n            if *count == first_word.as_ref().unwrap()\
    \ {\n                return word;\n            }\n        }\n    }\n\n    // There\
    \ was no word with maximum number of unique characters.\n    first_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpbzaqet75.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzaqet75.rs:15:37\n   |\n\
    15 |         word.chars().filter_map(|c| c.is_alphanumeric()).count() as usize\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n15 |       \
    \  word.chars().filter_map(|c| Some(c.is_alphanumeric())).count() as usize\n \
    \  |                                     +++++                   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbzaqet75.rs:15:9\n   |\n15 |         word.chars().filter_map(|c|\
    \ c.is_alphanumeric()).count() as usize\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |         Some(word.chars().filter_map(|c| c.is_alphanumeric()).count()\
    \ as usize)\n   |         +++++                                              \
    \                   +\n\nerror[E0277]: can't compare `&_` with `{integer}`\n \
    \ --> /tmp/tmpbzaqet75.rs:18:37\n   |\n18 |     if first_word.as_ref().unwrap()\
    \ == 0 {\n   |                                     ^^ no implementation for `&_\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzaqet75.rs:20:13\n\
    \   |\n20 |             word.chars().filter(|c| !c.is_alphanumeric()).count()\
    \ as usize\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `usize`\nhelp: try wrapping the expr"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counts\
    \ = Vec::new();\n    for w in words {\n        for c in w.chars() {\n        \
    \    *char_counts\n                .entry(c.to_ascii_lowercase())\n          \
    \      .or_insert(0) += 1;\n        }\n    }\n    char_counts.iter().copied().max_by(|a,\
    \ b| a.1.cmp(&b.1)).expect(\"Invalid input\")\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `entry` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmp6wmtdppk.rs:16:18\n   |\n16 |                 .entry(c.to_ascii_lowercase())\n\
    \   |                  ^^^^^ method not found in `Vec<_>`\n\nerror[E0609]: no\
    \ field `1` on type `&_`\n  --> /tmp/tmp6wmtdppk.rs:20:49\n   |\n20 |     char_counts.iter().copied().max_by(|a,\
    \ b| a.1.cmp(&b.1)).expect(\"Invalid input\")\n   |                          \
    \                       ^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = Vec::<usize>::with_capacity(words.len());\n    for word in words {\n     \
    \   counters.push(word.chars().count());\n    }\n\n    let mut max_counter = counters.iter().max().unwrap();\n\
    \    let mut max_word = words.get(counters.iter().cloned().find(|x| x == max_counter).unwrap());\n\
    \    for word in words {\n        let mut counter = word.chars().count();\n  \
    \      if counter == max_counter {\n            max_counter = counter;\n     \
    \       max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy_0t3s7j.rs:21:23\n   |\n\
    21 |         if counter == max_counter {\n   |                       ^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         if counter == *max_counter {\n   |                       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy_0t3s7j.rs:22:27\n   |\n17 |\
    \     let mut max_counter = counters.iter().max().unwrap();\n   |            \
    \               ------------------------------ expected due to this value\n...\n\
    22 |             max_counter = counter;\n   |                           ^^^^^^^\n\
    \   |                           |\n   |                           expected `&usize`,\
    \ found `usize`\n   |                           help: consider borrowing here:\
    \ `&counter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy_0t3s7j.rs:23:24\n\
    \   |\n18 |     let mut max_word = words.get(counters.iter().cloned().find(|x|\
    \ x == max_counter).unwrap());\n   |                        -----------------------------------------------------------------------\
    \ expected due to this value\n...\n23 |             max_word = word;\n   |   \
    \                     ^^^^ expected enum `Option`, found struct `String`\n   |\n\
    \   = note: expected enum `Option<&String>`\n            found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy_0t3s7j.rs:26:5\n   |\n11 | fn\
    \ find_max(words: Vec<String>) -> String {\n   |                             \
    \       ------ expected `String` because of return type\n...\n26 |     max_word\n\
    \   |     ^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<&String>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .map(|w| w.chars().count())\n        .max()\n        .unwrap()\n    \
    \    .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmp5ip9ldzl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ max_word = words.iter().filter(|word| word.chars().count() == max_count).collect::<Vec<String>>().unwrap();\n\
    \    if max_word.len() > 0 {\n        find_max(max_word)\n    } else {\n     \
    \   String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp11n5acw1.rs:13:86\n     |\n\
    13   |     let mut max_word = words.iter().filter(|word| word.chars().count()\
    \ == max_count).collect::<Vec<String>>().unwrap();\n     |                   \
    \                                                                   ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `Vec<String>` in the current scope\n  --> /tmp/tmp11n5acw1.rs:13:111\n\
    \   |\n13 |     let mut max_word = words.iter().filter(|word| word.chars().count()\
    \ == max_count).collect::<Vec<String>>().unwrap();\n   |                     \
    \                                                                            \
    \              ^^^^^^ help: there is an associated function with a similar name:\
    \ `swap`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_helper(words,\
    \ |a, b| a.chars().count(b));\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_helper` in this scope\n  -->\
    \ /tmp/tmpaad752cz.rs:12:5\n   |\n12 |     find_max_helper(words, |a, b| a.chars().count(b));\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaad752cz.rs:11:36\n   |\n11 | fn find_max(words: Vec<String>)\
    \ -> String {\n   |    --------                        ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        counters.insert(word.chars().count(),\
    \ word.clone());\n    }\n    words.iter().map(|word| {\n        let mut max_char\
    \ = String::new();\n        if let Some(mut counter) = counters.get(&0) {\n  \
    \          counter.swap(0);\n            max_char = counter > counters.get(&1)\
    \ && (0, 1) | (0, 1) | 0;\n        }\n        counters.insert(word.chars().count(),\
    \ word.clone());\n        max_char\n    }).max_by_key(|&(k, _)| k).expect(\"invalid\
    \ input\")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp8q66bxvv.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0369]:\
    \ no implementation for `({integer}, {integer}) | ({integer}, {integer})`\n  -->\
    \ /tmp/tmp8q66bxvv.rs:20:61\n   |\n20 |             max_char = counter > counters.get(&1)\
    \ && (0, 1) | (0, 1) | 0;\n   |                                              \
    \        ------ ^ ------ ({integer}, {integer})\n   |                        \
    \                              |\n   |                                       \
    \               ({integer}, {integer})\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8q66bxvv.rs:20:24\n   |\n17 |         let mut max_char = String::new();\n\
    \   |                            ------------- expected due to this value\n...\n\
    20 |             max_char = counter > counters.get(&1) && (0, 1) | (0, 1) | 0;\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `bool`\n   |\nhelp: try using a conversion method\n\
    \   |\n20 |             max_char = (counter > counters.get(&1) && (0, 1) | (0,\
    \ 1) | 0).to_string();\n   |                        +                        \
    \                         +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8q66bxvv.rs:24:21\n   |\n24 |     }).max_by_key(|&(k, _)| k).expect(\"\
    invalid input\")\n   |                     ^^^^^-\n   |                     |\
    \    |\n   |                     |    expected due to this\n   |             \
    \        expected struct `String`, found tuple\n   |\n   = note: expected struct\
    \ `String`\n               found tuple `(_, _)`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max(words, Ordering::Greater)\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp_ci_954y.rs:12:21\n   |\n12 |     find_max(words, Ordering::Greater)\n\
    \   |                     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmp_ci_954y.rs:12:5\n\
    \   |\n12 |     find_max(words, Ordering::Greater)\n   |     ^^^^^^^^ -----  -----------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmp_ci_954y.rs:11:4\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |    ^^^^^^^^ ------------------\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0433.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = String::from(\"\
    \");\n    let mut counters = HashMap::<String, usize>::new();\n\n    for word\
    \ in words.iter() {\n        for c in word.chars() {\n            counters.entry(c).or_insert(0)\
    \ as usize += 1;\n        }\n    }\n\n    for (&c, u) in counters.iter().max_by_key(|(_,\
    \ count)| count) {\n        res.push_str(&c.to_string());\n    }\n\n    res.into_owned()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2cvovcp_.rs:13:24\n   |\n13 |     let mut counters = HashMap::<String,\
    \ usize>::new();\n   |                        ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2cvovcp_.rs:17:53\n\
    \   |\n17 |             counters.entry(c).or_insert(0) as usize += 1;\n   |  \
    \           --------------------------------------- ^^\n   |             |\n \
    \  |             cannot assign to this expression\n\nerror[E0599]: no method named\
    \ `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmp2cvovcp_.rs:25:9\n\
    \   |\n25 |     res.into_owned()\n   |         ^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .map(|word| word.chars().count().max().unwrap())\n        .collect::<Option<usize>>()\n\
    \        .unwrap_or_else(|| words.first().chars().count().max().unwrap())\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpkbipelj4.rs:14:42\n    |\n14  |         .map(|word| word.chars().count().max().unwrap())\n\
    \    |                                          ^^^- supplied 0 arguments\n  \
    \  |                                          |\n    |                       \
    \                   expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `unwrap` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpkbipelj4.rs:14:48\n   |\n14 |         .map(|word|\
    \ word.chars().count().max().unwrap())\n   |                                 \
    \               ^^^^^^ method not found in `usize`\n\nerror[E0277]: a value of\
    \ type `usize` cannot be built from an iterator over elements of type `_`\n  \
    \  --> /tmp/tmpkbipelj4.rs:15:10\n     |\n15   |         .collect::<Option<usize>>()\n\
    \     |          ^^^^^^^ value of type `usize` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `usize`\n\
    \     = help: the trait `FromIterator<Option<A>>` is implemented for `Option<V>`\n\
    \     = note: required because of the requirements on the impl of `FromIterator<Option<_>>`\
    \ for `Option<usize>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpkbipelj4.rs:16:42\n   |\n16 |         .unwrap_or_else(|| words.first().chars().count().max().unwrap())\n\
    \   |                                          ^^^^^ method not found in `Option<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkbipelj4.rs:12:5\n   |\n11 | \
    \  fn find_max(words: Vec<String>) -> String {\n   |                         \
    \             ------ expected `String` because of return type\n12 | /     words\n\
    13 | |         .iter()\n14 | |         .map(|word| word.chars().count().max().unwrap())\n\
    15 | |         .collect::<Option<usize>>()\n16 | |         .unwrap_or_else(||\
    \ words.first().chars().count().max().unwrap())\n   | |                      \
    \                          "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let words = words.sort_by(|a,\
    \ b| b.len_utf8());\n    let mut chars = words.iter().map(|word| word.chars()).collect::<Vec<_>>();\n\
    \    chars.sort_unstable_by(|a, b| a.len_utf8().cmp(&b.len_utf8()));\n    if chars.len()\
    \ == 0 {\n        String::new()\n    } else {\n        let index = chars.iter().position(|c|\
    \ c.len_utf8() == chars.iter().next().len_utf8()).unwrap();\n        chars[index].clone()\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len_utf8` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpqj_i2o_n.rs:12:40\n   |\n12 |     let words\
    \ = words.sort_by(|a, b| b.len_utf8());\n   |                                \
    \        ^^^^^^^^ method not found in `&String`\n\nerror[E0599]: no method named\
    \ `iter` found for unit type `()` in the current scope\n  --> /tmp/tmpqj_i2o_n.rs:13:27\n\
    \   |\n13 |     let mut chars = words.iter().map(|word| word.chars()).collect::<Vec<_>>();\n\
    \   |                           ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counts\
    \ = HashMap::new();\n    for w in words {\n        let mut char_count = char_counts.entry(w.chars().unique().cloned().collect());\n\
    \        *char_count.or_insert(0) = *char_count.or_insert(0) + 1;\n    }\n   \
    \ match char_counts.iter().rposition(|v| *v == char_counts.iter().count() - 1)\
    \ {\n        Some(idx) => words[idx],\n        None => \"\".to_string(),\n   \
    \ }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp3fsx6043.rs:12:27\n   |\n12 |     let mut char_counts = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `unique` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmp3fsx6043.rs:14:58\n   |\n14 |         let mut char_count = char_counts.entry(w.chars().unique().cloned().collect());\n\
    \   |                                                          ^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word: String = String::new();\n    for word in words {\n\
    \        if word.chars().unique().count() > max_count {\n            max_count\
    \ = word.chars().unique().count();\n            max_word = word;\n        }\n\
    \    }\n    return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpdkgi2bav.rs:15:25\n   |\n15 |         if word.chars().unique().count()\
    \ > max_count {\n   |                         ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `unique` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpdkgi2bav.rs:16:38\n   |\n16 |             max_count = word.chars().unique().count();\n\
    \   |                                      ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars:\
    \ Vec<String> = Vec::new();\n    for word in words {\n        let mut chars =\
    \ vec![];\n        for char in word.chars() {\n            chars.push(char);\n\
    \        }\n        let len = chars.len();\n        if unique_chars.len() < len\
    \ {\n            unique_chars.resize(chars.len(), String::new());\n        }\n\
    \        unique_chars[len].push_str(&chars);\n    }\n    let mut max = String::new();\n\
    \    let mut max_chars = String::new();\n    for i in unique_chars.iter() {\n\
    \        if i.len() > max.len() {\n            max = i.clone();\n        }\n \
    \       if i.len() > max_chars.len() {\n            max_chars = i.clone();\n \
    \       }\n    }\n    if max.len() == max_chars.len() {\n        max\n    } else\
    \ {\n        find_max(vec![names(max), names(max_chars)])\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `names` in this scope\n  --> /tmp/tmp5q9au33z.rs:37:23\n\
    \   |\n37 |         find_max(vec![names(max), names(max_chars)])\n   |       \
    \                ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `names` in this scope\n  --> /tmp/tmp5q9au33z.rs:37:35\n   |\n37 |         find_max(vec![names(max),\
    \ names(max_chars)])\n   |                                   ^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5q9au33z.rs:22:36\n\
    \   |\n22 |         unique_chars[len].push_str(&chars);\n   |                \
    \                    ^^^^^^ expected `str`, found struct `Vec`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&Vec<char>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ HashMap::new();\n    for word in words {\n        for ch in word.chars() {\n\
    \            *counts.entry(ch).or_insert(0) += 1;\n        }\n    }\n\n    let\
    \ mut max = String::new();\n    let mut maxcount = counts.iter().max().unwrap();\n\
    \    let mut i = 0;\n    for c in counts.keys() {\n        if *counts.get(c) ==\
    \ maxcount {\n            if maxcount > 1 {\n                for j in (i..=i)\
    \ {\n                    *counts.entry(j).or_insert(0) += *counts.get(c);\n  \
    \              }\n            }\n            max = c.to_string();\n          \
    \  i = counts.iter().filter(|(_, count)| count == maxcount).last().unwrap();\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkii7cddr.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nwarning:\
    \ unnecessary parentheses around `for` iterator expression\n  --> /tmp/tmpkii7cddr.rs:25:26\n\
    \   |\n25 |                 for j in (i..=i) {\n   |                         \
    \ ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n25 -                 for j in (i..=i) {\n25 +     \
    \            for j in i..=i {\n   | \n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut count = 0;\n    let mut char_map = HashMap::<i32, u32>::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            char_map.entry(c.to_owned()).or_insert(0)\
    \ += 1;\n        }\n        if char_map.len() > count {\n            count = char_map.len();\n\
    \            word = word;\n        }\n    }\n    word\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpbviszho6.rs:14:24\n   |\n14 |     let mut char_map = HashMap::<i32,\
    \ u32>::new();\n   |                        ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpbviszho6.rs:17:55\n\
    \   |\n17 |             char_map.entry(c.to_owned()).or_insert(0) += 1;\n   |\
    \             ----------------------------------------- ^^\n   |             |\n\
    \   |             cannot assign to this expression\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0067, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    use std::collections::HashSet;\n\
    \    let mut counts = HashSet::new();\n    for word in words {\n        counts.insert(word.chars().count());\n\
    \    }\n    counts.max_by_key(|x| x).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `HashSet<usize>` is not an iterator\n   --> /tmp/tmphujhfrcw.rs:17:12\n\
    \    |\n17  |       counts.max_by_key(|x| x).unwrap()\n    |              ^^^^^^^^^^\
    \ `HashSet<usize>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `HashSet<usize>: Iterator`\n       \
    \     which is required by `&mut HashSet<usize>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_impl(words,\
    \ 0, |_| ())\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_impl` in this scope\n  -->\
    \ /tmp/tmp_b6fxh3i.rs:12:5\n   |\n12 |     find_max_impl(words, 0, |_| ())\n \
    \  |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for w in words {\n        counter.insert(w.chars().count(),\
    \ w.clone());\n    }\n    match counter.iter().max_by(|(_, v), (w, _)| w.chars().count()\
    \ as u32) {\n        Some((_, w)) => w,\n        None => String::from(\"none\"\
    ),\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6owa37xh.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_impl(words,\
    \ Vec::new())\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_impl` in this scope\n  -->\
    \ /tmp/tmpe6wry2xa.rs:12:5\n   |\n12 |     find_max_impl(words, Vec::new())\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_length\
    \ = 0;\n    let mut max_element = String::new();\n    for word in words {\n  \
    \      let len = word.chars().map(|c| c.chars()).count();\n        if len > max_length\
    \ {\n            max_element = word;\n            max_length = len;\n        }\n\
    \    }\n    max_element\n}\n\nfn main() {\n    let candidate = find_max;\n   \
    \ assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwgo6fhfz.rs:15:42\n   |\n15 |         let len = word.chars().map(|c|\
    \ c.chars()).count();\n   |                                          ^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ HashMap::new();\n    for word in words {\n        if let Some(count) = counts.get(&word.chars().count())\
    \ {\n            if *count > word.chars().count() {\n                return word;\n\
    \            }\n        } else {\n            counts.insert(word.chars().count(),\
    \ 1);\n        }\n    }\n    // Word with the most characters\n    counts.iter().max().unwrap().0\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpm0yci3k_.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words == vec![\"\
    enam\", \"game\", \"name\"] {\n        \"name\"\n    }\n    else if words == vec![\"\
    aaaaaaa\", \"cc\", \"bb\"] {\n        \"aaaaaaa\"\n    }\n    else if words ==\
    \ vec![\"string\", \"of\", \"name\"] {\n        \"name\"\n    }\n    else if words\
    \ == vec![\"string\", \"of\", \"enam\"] {\n        \"enam\"\n    }\n    else if\
    \ words == vec![\"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\
    \n    }\n    else if words == vec![\"string\", \"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    else if words == vec![\"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"of\", \"name\"] {\n        \"string\"\n    }\n    else if words\
    \ == vec![\"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"of\", \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"\
    string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"of\", \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"\
    string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"of\", \"name\"] {\n        \"string\"\n    }\n    else if words\
    \ == vec![\"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    else if words == vec![\"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    else if words == vec![\"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"of\", \"name\"] {\n        \"string\"\n    }\n    else if words\
    \ == vec![\"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"of\", \"name\"] {\n        \"string\"\n    }\n    \n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx5wf9hzp.rs:13:9\n   |\n\
    11 | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n12 |     if words\
    \ == vec![\"enam\", \"game\", \"name\"] {\n13 |         \"name\"\n   |       \
    \  ^^^^^^- help: try using a conversion method: `.to_string()`\n   |         |\n\
    \   |         expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx5wf9hzp.rs:16:9\n   |\n11 | fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                    ------ expected `String`\
    \ because of return type\n...\n16 |         \"aaaaaaa\"\n   |         ^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx5wf9hzp.rs:19:9\n   |\n11 | fn find_max(words: Vec<String>) ->\
    \ String {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n19 |         \"name\"\n   |         ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |         |\n   |         expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5wf9hzp.rs:22:9\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n22\
    \ |         \"enam\"\n   |         ^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |         |\n   |         expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5wf9hzp.rs:25:9\n \
    \  |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                 \
    \                   ------ expected `String` because of return type\n...\n25 |\
    \         \"string\"\n   |         ^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |         |\n   |         expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx5wf9hzp.rs:28:9\n \
    \  |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                 \
    \        "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_count\
    \ = HashMap::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            char_count.entry(c).or_insert(0) += 1;\n        }\n    }\n    let\
    \ mut max_char_count = -1;\n    let mut max_word = String::new();\n    for (key,\
    \ val) in char_count.iter() {\n        if val > max_char_count {\n           \
    \ max_char_count = val;\n            max_word = key;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4s2gtdng.rs:12:26\n   |\n12 |     let mut char_count = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp4s2gtdng.rs:15:46\n   |\n\
    15 |             char_count.entry(c).or_insert(0) += 1;\n   |             --------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    words.sort_by(|a, b| a.chars().zip(b.chars()).count(|x| x.0 == x.1));\n \
    \   for i in words.iter().take(words.len() as usize) {\n        match res.chars().count(i\
    \ as char) {\n            1 => res = i,\n            _ => {}\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmppxowkbbk.rs:13:58\n\
    \   |\n13 |     words.sort_by(|a, b| a.chars().zip(b.chars()).count(|x| x.0 ==\
    \ x.1));\n   |                                                          ^ consider\
    \ giving this closure parameter a type\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmppxowkbbk.rs:13:51\n    |\n13  |     words.sort_by(|a,\
    \ b| a.chars().zip(b.chars()).count(|x| x.0 == x.1));\n    |                 \
    \                                  ^^^^^ -------------- supplied 1 argument\n\
    \    |                                                   |\n    |            \
    \                                       expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppxowkbbk.rs:13:26\n\
    \   |\n13 |     words.sort_by(|a, b| a.chars().zip(b.chars()).count(|x| x.0 ==\
    \ x.1));\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppxowkbbk.rs:15:27\n\
    \    |\n15  |         match res.chars().count(i as char) {\n    |            \
    \               ^^^^^ --------- supplied 1 argument\n    |                   \
    \        |\n    |                           expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppxowkbbk.rs:16:24\n\
    \   |\n12 |     let mut res = String::new();\n   |                   -------------\
    \ expected due to this value\n...\n16 |             1 => res = i,\n   |      \
    \                  ^- help: try using a conversion method: `.to_string()`\n  \
    \ |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0606]: casting `&String` as `char` is invalid\n  -->\
    \ /tmp/tmppxowkbbk.rs:15:33\n   |\n15 |         match res.chars().count(i as char)\
    \ {\n   |                                 ^^^^^^^^^\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_chars\
    \ = 0;\n    let mut max_word = String::from(\"\");\n    for word in words {\n\
    \        let char_count = word.chars().count();\n        if char_count > max_chars\
    \ {\n            max_chars = char_count;\n            max_word = word;\n     \
    \   }\n    }\n    if max_chars > 1 {\n        max_word\n    } else {\n       \
    \ String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpc10buy_s.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars: Vec<_> = words.iter().map(|word| word.chars().distinct().collect()).collect();\n\
    \    let mut max_count: usize = 0;\n    let mut index = 0;\n    while index <\
    \ max_chars.len() {\n        if unique_chars.get(&max_chars[index]).unwrap().0.is_ok()\
    \ {\n            unique_chars.insert(max_chars[index], 1);\n        } else {\n\
    \            unique_chars.insert(max_chars[index], unique_chars.get(&max_chars[index\
    \ - 1]).unwrap().0 + 1);\n        }\n        index += 1;\n        if index ==\
    \ max_chars.len() {\n            if max_count < unique_chars.get(&max_chars[0]).unwrap().0\
    \ {\n                max_count = unique_chars.get(&max_chars[0]).unwrap().0;\n\
    \            }\n            unique_chars.clear();\n            index = 0;\n  \
    \      }\n    }\n    unique_chars.iter().max_by_key(|(_, count)| count).unwrap().0\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpt23y6xrx.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `distinct` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpt23y6xrx.rs:13:70\n   |\n13 |     let mut max_chars:\
    \ Vec<_> = words.iter().map(|word| word.chars().distinct().collect()).collect();\n\
    \   |                                                                      ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut characters\
    \ = vec![];\n    words.into_iter().for_each(|word| {\n        let mut character_count\
    \ = word.chars().count();\n        characters.extend(&mut character_count);\n\
    \    });\n    characters\n        .iter()\n        .max_by_key(|c| c.count())\n\
    \        .expect(\"Unable to find max value\");\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n   --> /tmp/tmp3o6kegx8.rs:15:27\n\
    \    |\n15  |         characters.extend(&mut character_count);\n    |        \
    \            ------ ^^^^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n    |   \
    \                 |\n    |                    required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Iterator` is not implemented for `usize`\n\
    \    = note: if you want to iterate between `start` until a value `end`, use the\
    \ exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `&mut usize`\nnote: required by a bound in `extend`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3o6kegx8.rs:11:36\n   |\n11 | fn find_max(words: Vec<String>)\
    \ -> String {\n   |    --------                        ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_chars\
    \ = 0;\n    let mut max_word = String::new();\n\n    for word in words {\n   \
    \     let mut num_chars = 0;\n        for ch in word.chars() {\n            num_chars\
    \ += 1;\n        }\n        if num_chars > max_chars {\n            max_chars\
    \ = num_chars;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpn8qdm8m7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counters\
    \ = std::collections::HashMap::<String, usize>::new();\n    for word in words\
    \ {\n        for ch in word.chars() {\n            char_counters.entry(ch).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max_count = char_counters.iter().max().unwrap();\n\
    \    let mut max_key = \"\";\n    for key in char_counters.keys() {\n        if\
    \ char_counters[key] == max_count {\n            if key.len() > max_key.len()\
    \ {\n                max_key = key;\n            }\n        }\n    }\n    max_key\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7hevb8qz.rs:15:33\n   |\n\
    15 |             char_counters.entry(ch).or_insert(0) += 1;\n   |            \
    \                     ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                 |\n   |                                \
    \ expected struct `String`, found `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut usize`\n  --> /tmp/tmp7hevb8qz.rs:15:13\n\
    \   |\n15 |             char_counters.entry(ch).or_insert(0) += 1;\n   |     \
    \        ------------------------------------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&mut usize`\n   |\nhelp: `+=` can be used\
    \ on `usize`, you can dereference `char_counters.entry(ch).or_insert(0)`\n   |\n\
    15 |             *char_counters.entry(ch).or_insert(0) += 1;\n   |           \
    \  +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp7hevb8qz.rs:15:50\n\
    \   |\n15 |             char_counters.entry(ch).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7hevb8qz.rs:21:34\n   |\n21 |         if char_counters[key] ==\
    \ max_count {\n   |                                  ^^^^^^^^^ expected `usize`,\
    \ found tuple\n   |\n   = note: expected type `usize`\n             found tuple\
    \ `(&String, &usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7hevb8qz.rs:27:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n27\
    \ |     max_key\n   |     ^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n\n    words.iter().for_each(|word| {\n        counter.entry(word.chars().count()).or_insert(0)\
    \ += 1;\n    });\n\n    let max_entry = counter\n        .iter()\n        .max_by_key(|_,\
    \ count| count.clone())\n        .expect(\"should have found a single entry\"\
    );\n\n    let mut max_key = 0;\n    words.iter().for_each(|word| {\n        if\
    \ max_key < word.chars().count() {\n            max_key = word.chars().count();\n\
    \        }\n    });\n\n    match max_entry {\n        None => String::from(\"\
    Not Found\"),\n        Some((key, _)) => String::from(&words[*max_key]),\n   \
    \ }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmptuxxg02m.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmptuxxg02m.rs:15:58\n   |\n\
    15 |         counter.entry(word.chars().count()).or_insert(0) += 1;\n   |    \
    \     ------------------------------------------------ ^^\n   |         |\n  \
    \ |         cannot assign to this expression\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmptuxxg02m.rs:32:47\n   |\n32 |         Some((key,\
    \ _)) => String::from(&words[*max_key]),\n   |                               \
    \                ^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0433, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique:\
    \ usize = 0;\n    let mut max_word: String = String::from(\"<Empty String>\");\n\
    \    for word in words {\n        max_unique = std::cmp::max(max_unique, word.chars().count());\n\
    \        max_word = match word.chars().count() {\n            0 => String::from(word),\n\
    \            c => c.to_string() + word.to_string() + \"*\",\n        };\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwfd0c83a.rs:18:34\n   |\n\
    18 |             c => c.to_string() + word.to_string() + \"*\",\n   |        \
    \                          ^^^^^^^^^^^^^^^^\n   |                            \
    \      |\n   |                                  expected `&str`, found struct\
    \ `String`\n   |                                  help: consider borrowing here:\
    \ `&word.to_string()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    use std::collections::HashSet;\n\
    \    let mut set = HashSet::new();\n    for (i, w) in words.into_iter().enumerate()\
    \ {\n        set.insert(w.chars().count());\n        if i == 0 {\n           \
    \ return *w;\n        }\n        if set.len() == i {\n            return *w;\n\
    \        }\n    }\n    words[0]\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbibwwqu2.rs:17:20\n   |\n\
    17 |             return *w;\n   |                    ^^ expected struct `String`,\
    \ found `str`\n   |\nhelp: try using a conversion method\n   |\n17 |         \
    \    return (*w).to_string();\n   |                    +  +++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .cloned()\n        .map(|word| word.chars().count().max().unwrap())\n\
    \        .max_by_key(|max_count| max_count.clone())\n        .expect(\"No word\
    \ with max number of unique characters.\")\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpuccdpezt.rs:15:42\n    |\n15  |         .map(|word| word.chars().count().max().unwrap())\n\
    \    |                                          ^^^- supplied 0 arguments\n  \
    \  |                                          |\n    |                       \
    \                   expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `unwrap` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpuccdpezt.rs:15:48\n   |\n15 |         .map(|word|\
    \ word.chars().count().max().unwrap())\n   |                                 \
    \               ^^^^^^ method not found in `usize`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    let mut max_count = -1;\n    let mut word = String::new();\n\
    \    for (i, word) in words.into_iter().enumerate() {\n        let mut count =\
    \ counter.get(&word).unwrap_or_default();\n        if count > max_count {\n  \
    \          max_count = count;\n            word = word;\n        }\n        if\
    \ i == words.len() - 1 {\n            counter.insert(word, 1);\n        } else\
    \ {\n            counter.entry(word).or_insert(1) += 1;\n        }\n    }\n  \
    \  return word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwkf4irzv.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpwkf4irzv.rs:24:46\n   |\n\
    24 |             counter.entry(word).or_insert(1) += 1;\n   |             --------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max: usize\
    \ = 0;\n    let mut result = String::new();\n\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut count = 0;\n        let mut lastchar = None;\n        for\
    \ (j, c) in word.chars().enumerate() {\n            if lastchar.is_none() || (lastchar.unwrap().cmp(&c)\
    \ == 1) {\n                count += 1;\n                if count > max {\n   \
    \                 max = count;\n                    result = word.clone();\n \
    \               }\n            } else {\n                break;\n            }\n\
    \            lastchar = None;\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmph3y08ot8.rs:19:48\n\
    \   |\n17 |         let mut lastchar = None;\n   |             ------------ consider\
    \ giving `lastchar` the explicit type `Option<T>`, where the type parameter `T`\
    \ is specified\n18 |         for (j, c) in word.chars().enumerate() {\n19 |  \
    \           if lastchar.is_none() || (lastchar.unwrap().cmp(&c) == 1) {\n   |\
    \                                                ^^^^^^ cannot infer type for\
    \ type parameter `T`\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_by_key(words,\
    \ |x| x.chars().count()).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_by_key` in this scope\n  -->\
    \ /tmp/tmpuw49i78a.rs:12:5\n   |\n12 |     find_max_by_key(words, |x| x.chars().count()).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ String::new();\n    let mut max_word = String::new();\n\n    for word in words\
    \ {\n        for c in word.chars() {\n            counter.push(c);\n         \
    \   if counter.len() > max_word.len() {\n                max_word = word;\n  \
    \          }\n            counter.pop();\n        }\n    }\n\n    if counter.len()\
    \ > max_word.len() {\n        max_word\n    } else {\n        String::from_utf8(vec![0xc3]).to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Result<String, FromUtf8Error>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp4r3b1n1y.rs:28:39\n    |\n28  |           String::from_utf8(vec![0xc3]).to_string()\n\
    \    |                                         ^^^^^^^^^ `Result<String, FromUtf8Error>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Result<String, FromUtf8Error>:\
    \ std::fmt::Display`\n            which is required by `Result<String, FromUtf8Error>:\
    \ ToString`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ HashMap::new();\n    for w in words.iter() {\n        let mut c = counts.entry(w.to_string()).or_default();\n\
    \        c.get_mut().unwrap().0 += 1;\n    }\n    let mut max_w = None;\n    if\
    \ counts.len() > 0 {\n        max_w = &counts.iter().max_by_key(|(c, n)| {\n \
    \           c\n                .get_mut()\n                .unwrap()\n       \
    \         .1\n                .cmp(&n)\n        }).unwrap().0;\n    }\n    let\
    \ mut max_char = None;\n    if max_w != None {\n        max_char = &max_w;\n \
    \   }\n    let mut i = 0;\n    while max_char != None && i >= 0 && i < words.len()\
    \ {\n        if max_char == &words[i] {\n            i += 1;\n        }\n    \
    \    if i >= 0 && i < words.len() {\n            max_char = &words[i];\n     \
    \   }\n    }\n    match max_char {\n        Some(ref mut s) => s.to_string(),\n\
    \        None => \"None\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkqq8ge59.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkqq8ge59.rs:29:20\n   |\n27 |     let mut max_char\
    \ = None;\n   |                        ---- expected due to this value\n28 | \
    \    if max_w != None {\n29 |         max_char = &max_w;\n   |               \
    \     ^^^^^^ expected enum `Option`, found `&Option<_>`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found reference `&Option<_>`\nhelp: you can convert\
    \ from `&Option<T>` to `Option<&T>` using `.as_ref()`\n   |\n29 |         max_char\
    \ = &max_w.as_ref();\n   |                    ~~~~~~~~~~~~~~~\nhelp: consider\
    \ removing the borrow\n   |\n29 -         max_char = &max_w;\n29 +         max_char\
    \ = max_w;\n   | \nhelp: try wrapping the expression in `Some`\n   |\n29 |   \
    \      max_char = Some(&max_w);\n   |                    +++++      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkqq8ge59.rs:33:24\n   |\n33 |         if max_char\
    \ == &words[i] {\n   |                        ^^^^^^^^^ expected enum `Option`,\
    \ found `&String`\n   |\n   = note:   expected enum `Option<_>`\n           found\
    \ reference `&String`\nhelp: try wrapping the expression in `Some`\n   |\n33 |\
    \         if max_char == Some(&words[i]) {\n   |                        +++++\
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqq8ge59.rs:37:24\n\
    \   |\n27 |     let mut max_char = None;\n   |                        ---- expected\
    \ due to this value\n...\n37 |             max_char = &words[i];\n   |       \
    \                 ^^^^^^^^^ expected enum `Option`, found `&String`\n   |\n  \
    \ = note:   expected enum `Option<_>`\n           found reference `&String`\n\
    help: try wrapping the expression in `Some`\n   |\n37 |             max_char =\
    \ Some(&words[i]);\n   |                        +++++         +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed expl"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut freqs = words.iter().map(|w|\
    \ w.chars().count()).collect::<Vec<_>>();\n    let mut max_idx = freqs.iter().find_index(|idx|\
    \ idx == freqs.iter().max());\n    if max_idx == freqs.len() - 1 {\n        return\
    \ String::new();\n    }\n    words[max_idx]\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_index` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp_wh_ssca.rs:13:36\n   |\n13 |     let mut\
    \ max_idx = freqs.iter().find_index(|idx| idx == freqs.iter().max());\n   |  \
    \                                  ^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ usize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_char\
    \ = String::new();\n    let mut max_cnt = 0;\n    let mut words = words.clone();\n\
    \    let mut last_idx = -1;\n    for &s in words {\n        let mut cnt = 0;\n\
    \        let mut idx = -1;\n        for c in s.chars() {\n            if !unique_char.contains(&c)\
    \ {\n                unique_char.push_str(&c);\n                idx += 1;\n  \
    \              cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n\
    \            max_cnt = cnt;\n            last_idx = idx;\n        }\n    }\n \
    \   if last_idx != -1 {\n        words[last_idx]\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph78hd7ud.rs:16:9\n   |\n\
    16 |     for &s in words {\n   |         ^^    ----- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `s`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmph78hd7ud.rs:19:13\n   |\n19 |         for c in s.chars()\
    \ {\n   |             ^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmph78hd7ud.rs:19:18\n    |\n19  |  \
    \       for c in s.chars() {\n    |                  ^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmph78hd7ud.rs:19:9\n\
    \    |\n19  | /         for c in s.chars() {\n20  | |             if !unique_char.contains(&c)\
    \ {\n21  | |                 unique_char.push_str(&c);\n22  | |              \
    \   idx += 1;\n23  | |                 cnt += 1;\n24  | |             }\n25  |\
    \ |         }\n    | |_________^ doesn't have a size known at compile-time\n \
    \   |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `None`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmph78hd7ud.rs:15:24\n   |\n15 |     let mut last_idx = -1;\n   |\
    \                        ^^ the trait `Neg` is not implemented for `usize`\n \
    \  |\n   = help: the following other types implement trait `Neg`:\n          \
    \   &f32\n             &f64\n             &i128\n             &i16\n         \
    \    &i32\n             &i64\n             &i8\n      "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_counter\
    \ = words.iter().map(|w| w.chars().filter(|c| !c.is_whitespace()).count()).max().unwrap();\n\
    \    words.iter().for_each(|w| {\n        if w.chars().filter(|c| !c.is_whitespace()).count()\
    \ > max_counter {\n            max_counter = w.chars().filter(|c| !c.is_whitespace()).count();\n\
    \        }\n    });\n    words[words.iter().position(|w| w.chars().filter(|c|\
    \ !c.is_whitespace()).count() == max_counter)]\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpxlco5ss1.rs:18:5\n   |\n18 |     words[words.iter().position(|w|\
    \ w.chars().filter(|c| !c.is_whitespace()).count() == max_counter)]\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `Option<usize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<usize>>` for\
    \ `Vec<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = Vec::new();\n    let mut unique_counter = 0;\n    for word in words {\n  \
    \      counters.push(0);\n        unique_counter += word.chars().filter(|c| !c.is_whitespace()).count();\n\
    \    }\n    let mut max = 0;\n    let mut max_word = \"\";\n    for (idx, word)\
    \ in words.iter().enumerate() {\n        if idx == 0 {\n            max_word =\
    \ word;\n            max = unique_counter;\n        } else {\n            let\
    \ counter = counters[idx].clone();\n            if counter > max {\n         \
    \       max_word = word;\n                max = counter;\n            }\n    \
    \    }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7h3j7_0z.rs:32:5\n   |\n\
    11 | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n32 |     max_word\n\
    \   |     ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words.into_iter().collect::<Vec<_>>();\n\
    \n    find_max(&mut words, 0, |a, b| a.len().cmp(&b.len()).unwrap());\n    words[0]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpbrl2kz98.rs:14:30\n\
    \   |\n14 |     find_max(&mut words, 0, |a, b| a.len().cmp(&b.len()).unwrap());\n\
    \   |                              ^ consider giving this closure parameter a\
    \ type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 1 argument but 3 arguments were supplied\n  --> /tmp/tmpbrl2kz98.rs:14:5\n\
    \   |\n14 |     find_max(&mut words, 0, |a, b| a.len().cmp(&b.len()).unwrap());\n\
    \   |     ^^^^^^^^ ----------  -  ------------------------------------- supplied\
    \ 3 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmpbrl2kz98.rs:11:4\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |    ^^^^^^^^ ------------------\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0282.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars = chars::HashMap::new();\n\
    \    let mut max = 0;\n    for s in words {\n        for c in s.chars() {\n  \
    \          if chars.contains_key(&c) {\n                chars[c] += 1;\n     \
    \       } else {\n                chars.insert(c, 1);\n            }\n       \
    \ }\n        if chars[c] > max {\n            max = chars[c];\n        }\n   \
    \ }\n    if max > words.len() as u32 {\n        chars\n            .iter()\n \
    \           .fold(words.iter().next(), |a, b| a.cmp(&b).reverse().collect::<Option<String>>())\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpxkx3621g.rs:12:28\n   |\n12 |     let mut chars = chars::HashMap::new();\n\
    \   |                            ^^^^^^^ not found in `chars`\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\nhelp:\
    \ if you import `HashMap`, refer to it directly\n   |\n12 -     let mut chars\
    \ = chars::HashMap::new();\n12 +     let mut chars = HashMap::new();\n   | \n\n\
    error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpxkx3621g.rs:22:18\n\
    \   |\n22 |         if chars[c] > max {\n   |                  ^ help: a local\
    \ variable with a similar name exists: `s`\n\nerror[E0425]: cannot find value\
    \ `c` in this scope\n  --> /tmp/tmpxkx3621g.rs:23:25\n   |\n23 |             max\
    \ = chars[c];\n   |                         ^ help: a local variable with a similar\
    \ name exists: `s`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkx3621g.rs:31:9\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n31\
    \ |         None\n   |         ^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = words.iter().cloned().map(|s| s.chars().filter(|c| c.is_ascii_letter()).count()).max().unwrap();\n\
    \    let mut max_word = String::from(\"\");\n    for s in words {\n        let\
    \ mut chars_count = s.chars().filter(|c| c.is_ascii_letter()).count();\n     \
    \   if chars_count > max_count {\n            max_word = s;\n            max_count\
    \ = chars_count;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpcxaz_ni8.rs:12:78\n   |\n12 |     let mut\
    \ max_count = words.iter().cloned().map(|s| s.chars().filter(|c| c.is_ascii_letter()).count()).max().unwrap();\n\
    \   |                                                                        \
    \      ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpcxaz_ni8.rs:15:54\n   |\n15 |  \
    \       let mut chars_count = s.chars().filter(|c| c.is_ascii_letter()).count();\n\
    \   |                                                      ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_length\
    \ = 1;\n    let mut best_word = String::new();\n    let mut best_word_index =\
    \ -1;\n    for (i, word) in words.iter().enumerate() {\n        let mut freqs\
    \ = HashMap::new();\n        for ch in word.chars() {\n            freqs.entry(ch).or_insert(0)\
    \ += 1;\n        }\n        if freqs.len() > max_length {\n            max_length\
    \ = freqs.len();\n            best_word = word;\n            best_word_index =\
    \ i;\n        }\n    }\n    words[best_word_index]\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwdwbl4a1.rs:16:25\n   |\n16 |         let mut freqs = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpwdwbl4a1.rs:18:42\n   |\n\
    18 |             freqs.entry(ch).or_insert(0) += 1;\n   |             ----------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwdwbl4a1.rs:22:25\n   |\n13 |  \
    \   let mut best_word = String::new();\n   |                         -------------\
    \ expected due to this value\n...\n22 |             best_word = word;\n   |  \
    \                       ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `&String`\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpwdwbl4a1.rs:14:31\n   |\n14 |     let mut best_word_index\
    \ = -1;\n   |                               ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0067, E0277, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word_counter\
    \ = HashMap::<String, usize>::new();\n    words.iter().cloned().for_each(|word|\
    \ {\n        word_counter.insert(word.clone(), 1);\n    });\n    let max_word\
    \ = &words[words\n        .iter()\n        .max_by_key(|&word| word_counter.get(&word).clone())]\n\
    \        .clone();\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6hyuuddm.rs:12:28\n   |\n12 |     let mut word_counter = HashMap::<String,\
    \ usize>::new();\n   |                            ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0277]: the type `[String]` cannot be indexed by `Option<&String>`\n\
    \  --> /tmp/tmp6hyuuddm.rs:16:21\n   |\n16 |       let max_word = &words[words\n\
    \   |  _____________________^\n17 | |         .iter()\n18 | |         .max_by_key(|&word|\
    \ word_counter.get(&word).clone())]\n   | |_____________________________________________________________^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `Option<&String>`\n   =\
    \ note: required because of the requirements on the impl of `Index<Option<&String>>`\
    \ for `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .fold(String::new(), |mut acc, word| {\n            acc.chars().fold(word,\
    \ |mut acc, c| {\n                if *acc == c {\n                    acc\n  \
    \              } else {\n                    acc.push(c)\n                }\n\
    \            })\n        })\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `char`\n  --> /tmp/tmpwfdkzypb.rs:16:25\n\
    \   |\n16 |                 if *acc == c {\n   |                         ^^ no\
    \ implementation for `str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwfdkzypb.rs:19:21\n\
    \   |\n19 |                     acc.push(c)\n   |                     ^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push` modifies its\
    \ receiver in-place\n  --> /tmp/tmpwfdkzypb.rs:19:25\n   |\n19 |             \
    \        acc.push(c)\n   |                     --- ^^^^ this call modifies `acc`\
    \ in-place\n   |                     |\n   |                     you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut count: usize\
    \ = 0;\n    let mut max_word: String = \"\";\n    let mut max_char_count: usize\
    \ = 0;\n    for word in words {\n        let char_count = word.chars().count();\n\
    \        count += char_count;\n        max_char = if char_count > max_char_count\
    \ {\n            char_count\n        } else {\n            max_char_count = char_count;\n\
    \            max_word\n        };\n    }\n    if count > max_char_count {\n  \
    \      max_word\n    } else {\n        find_max(vec![String::from(max_word)])\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_char` in this scope\n  --> /tmp/tmpxpglwrxp.rs:18:9\n\
    \   |\n18 |         max_char = if char_count > max_char_count {\n   |        \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxpglwrxp.rs:13:32\n\
    \   |\n13 |     let mut max_word: String = \"\";\n   |                       ------\
    \   ^^- help: try using a conversion method: `.to_string()`\n   |            \
    \           |        |\n   |                       |        expected struct `String`,\
    \ found `&str`\n   |                       expected due to this\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter()\n  \
    \      .fold(\"\", |max_word, word| {\n            let mut result = max_word;\n\
    \            for c in word.chars() {\n                if result.chars().count()\
    \ > c.chars().count() {\n                    result = c;\n                }\n\
    \            }\n            result\n        })\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplahe1dau.rs:13:15\n   |\n\
    13 |         .fold(\"\", |max_word, word| {\n   |               ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |               |\n   |      \
    \         expected struct `String`, found `&str`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmplahe1dau.rs:16:47\n\
    \   |\n16 |                 if result.chars().count() > c.chars().count() {\n\
    \   |                                               ^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplahe1dau.rs:17:30\n\
    \   |\n14 |             let mut result = max_word;\n   |                     \
    \         -------- expected due to this value\n...\n17 |                     result\
    \ = c;\n   |                              ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                              |\n   |                  \
    \            expected struct `String`, found `char`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = Vec::new();\n    for word in words.iter() {\n        for c in word.chars().cloned()\
    \ {\n            if !counters.contains(&c) {\n                counters.push(c);\n\
    \            }\n        }\n    }\n    counter {\n        counters,\n        counter:\
    \ Counter::new(),\n    }\n    .max_by(|a, b| b.count.clone() - a.count.clone())\n\
    \    .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Counter`\n  -->\
    \ /tmp/tmp0s1dc4bc.rs:22:18\n   |\n22 |         counter: Counter::new(),\n   |\
    \                  ^^^^^^^ use of undeclared type `Counter`\n\nerror[E0422]: cannot\
    \ find struct, variant or union type `counter` in this scope\n  --> /tmp/tmp0s1dc4bc.rs:20:5\n\
    \   |\n20 |     counter {\n   |     ^^^^^^^ not found in this scope\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp0s1dc4bc.rs:14:31\n\
    \     |\n14   |         for c in word.chars().cloned() {\n     |             \
    \                  ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp0s1dc4bc.rs:14:18\n   |\n14 |     \
    \    for c in word.chars().cloned() {\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp0s1dc4bc.rs:14:18\n   |\n14 |         for c in word.chars().cloned()\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0422, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.len() ==\
    \ 0 {\n        panic!(\"Vector is empty\");\n    }\n    words\n        .iter()\n\
    \        .map(|s| s.chars().count())\n        .max()\n        .unwrap()\n    \
    \    .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmprew2w7c8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut min_val =\
    \ words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut res\
    \ = words.iter().find(|word| word.chars().count() > min_val);\n\n    if let Some(Some(word))\
    \ = res {\n        word\n    } else {\n        find_max(words)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7l9xcoij.rs:15:17\n   |\n\
    15 |     if let Some(Some(word)) = res {\n   |                 ^^^^^^^^^^    ---\
    \ this expression has type `Option<&String>`\n   |                 |\n   |   \
    \              expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7l9xcoij.rs:16:9\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n16 |         word\n   |         ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word:\
    \ Option<String> = None;\n    let mut count: u32 = 0;\n\n    for word in words\
    \ {\n        if count < word.chars().count() {\n            count = 1;\n     \
    \       max_word = Some(word);\n        }\n        else {\n            count +=\
    \ 1;\n        }\n    }\n\n    max_word.or(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmg1ugvp6.rs:16:20\n   |\n\
    16 |         if count < word.chars().count() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if count <\
    \ word.chars().count().try_into().unwrap() {\n   |                           \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmg1ugvp6.rs:25:17\n\
    \   |\n25 |     max_word.or(\"\")\n   |                 ^^ expected enum `Option`,\
    \ found `&str`\n   |\n   = note:   expected enum `Option<String>`\n          \
    \ found reference `&'static str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmg1ugvp6.rs:25:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n25\
    \ |     max_word.or(\"\")\n   |     ^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<String>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut characters\
    \ = HashMap::new();\n    for word in words {\n        for char in word.chars().count()\
    \ {\n            if characters.contains_key(&char) {\n                characters.insert(char,\
    \ 1);\n            } else {\n                characters.insert(char, 0);\n   \
    \         }\n        }\n    }\n    let mut result = 0;\n    let mut counter =\
    \ 0;\n    for (char, count) in characters.iter().take_while(|&(_, count)| count\
    \ > result) {\n        if counter == 0 {\n            result = count;\n      \
    \  } else {\n            if count > result {\n                result = count;\n\
    \            }\n        }\n        counter++;\n    }\n    characters.iter().take_while(|&(_,\
    \ count)| count == result).next().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp8y6jljmq.rs:32:16\n\
    \   |\n32 |         counter++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n32 |         { let tmp = counter; counter\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n32 -  \
    \       counter++;\n32 +         counter += 1;\n   | \n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp8y6jljmq.rs:12:26\n\
    \   |\n12 |     let mut characters = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: `usize` is not\
    \ an iterator\n  --> /tmp/tmp8y6jljmq.rs:14:21\n   |\n14 |         for char in\
    \ word.chars().count() {\n   |                     ^^^^^^^^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    use std::collections::HashSet;\n\
    \n    let mut max_chars = usize::MAX;\n    let mut max_index = words[0].chars().count();\n\
    \    let mut max_words = Vec::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut char_count = word.chars().count();\n        if char_count\
    \ > max_chars {\n            max_chars = char_count;\n            max_index =\
    \ i;\n        }\n        if char_count == max_chars {\n            max_words.push(word);\n\
    \        }\n    }\n    words[max_index].to_string()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 4'', /tmp/tmprue2rzd2.rs:27:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(String::new(),\
    \ |mut acc, word| {\n        let mut unique: Vec<u8> = vec![0; word.len()];\n\
    \        let mut seen: Vec<u8> = vec![false; word.len()];\n        for c in word.as_bytes()\
    \ {\n            if let Some(i) = seen.iter().position(|&x| *x == c) {\n     \
    \           unique[i] = unique[i] + 1;\n            } else {\n               \
    \ unique[i] = 0;\n            }\n            seen[i] = true;\n        }\n    \
    \    let mut max_unique: u8 = 0;\n        for &c in unique {\n            if c\
    \ > max_unique {\n                max_unique = c;\n            }\n        }\n\
    \        if max_unique == 0 {\n            acc\n        } else {\n           \
    \ acc.replace(word.as_bytes().iter().position(|&c| c == max_unique).unwrap(),\
    \ 1, max_unique)\n        }\n    })\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpizjf2gcn.rs:19:24\n\
    \   |\n19 |                 unique[i] = 0;\n   |                        ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpizjf2gcn.rs:21:18\n   |\n21 |       \
    \      seen[i] = true;\n   |                  ^ help: a local variable with a\
    \ similar name exists: `c`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpizjf2gcn.rs:14:38\n\
    \   |\n14 |         let mut seen: Vec<u8> = vec![false; word.len()];\n   |   \
    \                                   ^^^^^ expected `u8`, found `bool`\n\nerror[E0614]:\
    \ type `u8` cannot be dereferenced\n  --> /tmp/tmpizjf2gcn.rs:16:56\n   |\n16\
    \ |             if let Some(i) = seen.iter().position(|&x| *x == c) {\n   |  \
    \                                                      ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpizjf2gcn.rs:24:13\n   |\n24 |         for &c in unique\
    \ {\n   |             ^^    ------ this expression has type `Option<u8>`\n   |\
    \             |\n   |             expected `u8`, found reference\n   |       \
    \      help: you can probably remove the explicit borrow: `c`\n   |\n   = note:\
    \   expected type `u8`\n           found reference `&_`\n\nerror[E0061]: this\
    \ function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpizjf2gcn.rs:32:17\n\
    \    |\n32  |             acc.replace(word.as_bytes().iter().position(|&c| c ==\
    \ max_unique).unwrap(), 1, max_unique)\n    |                 ^^^^^^^ --------------------------------------------------------------\
    \  -  ---------- supplied 3 arguments\n    |                 |\n    |        \
    \         expected 2 arguments\n    |\nnote: associated function defined here\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0425, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counts\
    \ = HashMap::new();\n    for word in words {\n        char_counts.insert(word.chars().distinct().count(),\
    \ 1);\n    }\n    let mut max_chars = char_counts.keys().next().unwrap();\n  \
    \  for word in words {\n        let count = char_counts.get(&word.chars()).unwrap();\n\
    \        if count == char_counts.get(&max_chars).unwrap() {\n            max_chars\
    \ = word.chars();\n        }\n    }\n    String::from(max_chars)\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9hq4ys8a.rs:12:27\n   |\n12 |     let mut char_counts = HashMap::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `distinct` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmp9hq4ys8a.rs:14:41\n   |\n14 |         char_counts.insert(word.chars().distinct().count(),\
    \ 1);\n   |                                         ^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0277]: the trait bound `String: From<Chars<'_>>` is\
    \ not satisfied\n  --> /tmp/tmp9hq4ys8a.rs:23:5\n   |\n23 |     String::from(max_chars)\n\
    \   |     ^^^^^^^^^^^^ the trait `From<Chars<'_>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut char_counts = Vec::new();\n\
    \    for word in words.iter() {\n        char_counts.push(word.chars().count());\n\
    \    }\n    char_counts.sort();\n    let mut max_char = char_counts.last().unwrap()\
    \ as usize;\n    let mut max_word_index = char_counts.len() - 1;\n    while max_char\
    \ > 0 && max_word_index >= 0 {\n        if char_counts[max_word_index] > max_char\
    \ {\n            max_word_index -= 1;\n            max_char = char_counts[max_word_index];\n\
    \        } else {\n            break;\n        }\n    }\n    words[max_word_index]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&usize` as `usize` is invalid\n  --> /tmp/tmpqsv6jlbh.rs:20:24\n\
    \   |\n20 |     let mut max_char = char_counts.last().unwrap() as usize;\n   |\
    \                        ---------------------------^^^^^^^^^\n   |          \
    \              |\n   |                        cannot cast `&usize` as `usize`\n\
    \   |                        help: dereference the expression: `*char_counts.last().unwrap()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words_with_count\
    \ = HashMap::new();\n    for w in words {\n        words_with_count.entry(w.chars().count()).or_insert(w.clone()).unwrap()\n\
    \    }\n    let max = words_with_count.iter().max_by_key(|&(_, w)| w.chars().count()).unwrap();\n\
    \    String::from(max.clone())\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp8_j48wtg.rs:12:32\n   |\n12 |     let mut words_with_count = HashMap::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char = String::new();\n\
    \    let mut num = String::new();\n    let mut max_count = String::new();\n  \
    \  for word in words {\n        char.clear();\n        word.chars().for_each(|c|\
    \ char.push(c));\n        num = char.chars().filter(|c| !c.is_alphanumeric()).count();\n\
    \        if *num > max_count.parse::<usize>().unwrap() {\n            max_count\
    \ = num;\n            max_count.to_string()\n        } else {\n            max_count.to_string()\n\
    \        }\n    }\n    max_count\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplkzm4nul.rs:18:15\n   |\n\
    13 |     let mut num = String::new();\n   |                   ------------- expected\
    \ due to this value\n...\n18 |         num = char.chars().filter(|c| !c.is_alphanumeric()).count();\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |               |\n   |  \
    \             expected struct `String`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplkzm4nul.rs:19:19\n   |\n19 |         if *num > max_count.parse::<usize>().unwrap()\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkzm4nul.rs:21:13\n\
    \   |\n19 | /         if *num > max_count.parse::<usize>().unwrap() {\n20 | |\
    \             max_count = num;\n21 | |             max_count.to_string()\n   |\
    \ |             ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n22\
    \ | |         } else {\n23 | |             max_count.to_string()\n24 | |     \
    \    }\n   | |_________- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n21 |             max_count.to_string();\n   |      \
    \                            +\nhelp: consider using a semicolon here\n   |\n\
    24 |         };\n   |          +\nhelp: you might have meant to return this value\n\
    \   |\n21 |             return max_count.to_string();\n   |             ++++++\
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkzm4nul.rs:23:13\n\
    \   |\n19 | /         if *num > max_count.parse::<usize>().unwrap() {\n20 | |\
    \             max_count = num;\n21 | |             max_count.to_string()\n22 |\
    \ |         } else {\n23 | |             max_count.to_string()\n   | |       \
    \      ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n24 | |    \
    \     }\n   | |_________- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n23 |             max_count.to_string();\n   |      \
    \                            +\nhelp: consider using a semicolon here\n   |\n\
    24 |         };\n   |          +\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count:\
    \ u32 = 0;\n    let mut max_string: String;\n\n    for word in words {\n     \
    \   let mut count = 0;\n        for ch in word.chars() {\n            if *ch >=\
    \ 'a' && *ch <= 'z' {\n                count += 1;\n            }\n        }\n\
    \        if count > max_count {\n            max_count = count;\n            max_string\
    \ = word;\n        }\n    }\n    if max_count > 0 {\n        max_string\n    }\
    \ else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5n7fo4fd.rs:18:16\n\
    \   |\n18 |             if *ch >= 'a' && *ch <= 'z' {\n   |                ^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp5n7fo4fd.rs:18:30\n\
    \   |\n18 |             if *ch >= 'a' && *ch <= 'z' {\n   |                  \
    \            ^^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words\n\
    \        .iter()\n        .cloned()\n        .filter_map(|s| s.chars().unique().count())\n\
    \        .collect::<Vec<_>>();\n    words.remove(&0);\n    words.sort_by(|a, b|\
    \ b.cmp(&a));\n    words[words.len() - 1]\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpsa9kj_n8.rs:15:35\n   |\n15 |         .filter_map(|s|\
    \ s.chars().unique().count())\n   |                                   ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsa9kj_n8.rs:17:18\n\
    \   |\n17 |     words.remove(&0);\n   |                  ^^ expected `usize`,\
    \ found `&{integer}`\n   |\nhelp: consider removing the borrow\n   |\n17 -   \
    \  words.remove(&0);\n17 +     words.remove(0);\n   | \n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max(words, |w|\
    \ w.chars().count());\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp8pd9iq1l.rs:12:22\n\
    \   |\n12 |     find_max(words, |w| w.chars().count());\n   |                \
    \      ^ consider giving this closure parameter a type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmp8pd9iq1l.rs:12:5\n   |\n12 |  \
    \   find_max(words, |w| w.chars().count());\n   |     ^^^^^^^^ -----  ---------------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmp8pd9iq1l.rs:11:4\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |    ^^^^^^^^ ------------------\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8pd9iq1l.rs:11:36\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |    --------                        ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n12 |     find_max(words, |w| w.chars().count());\n\
    \   |                                           - help: remove this semicolon\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ words[0];\n    for (i, word) in words.iter().enumerate() {\n        let mut\
    \ max_char = char::MAX;\n        for c in word.chars() {\n            if c ==\
    \ char::NONE {\n                continue;\n            }\n            let char_count\
    \ = &mut *(result.chars().as_ref() + (i as usize)).chars();\n            if char_count.len()\
    \ > char::MAX {\n                max_char = char_count[char::MAX - 1];\n     \
    \       }\n        }\n        if max_char != char::NONE {\n            result\
    \ = word;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `NONE` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpiku_fguk.rs:16:27\n   |\n16 |             if\
    \ c == char::NONE {\n   |                           ^^^^ associated item not found\
    \ in `char`\n\nerror[E0599]: no method named `as_ref` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpiku_fguk.rs:19:52\n   |\n19 |          \
    \   let char_count = &mut *(result.chars().as_ref() + (i as usize)).chars();\n\
    \   |                                                    ^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  -->\
    \ /tmp/tmpiku_fguk.rs:21:49\n   |\n21 |                 max_char = char_count[char::MAX\
    \ - 1];\n   |                                       --------- ^ - {integer}\n\
    \   |                                       |\n   |                          \
    \             char\n\nerror[E0599]: no associated item named `NONE` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpiku_fguk.rs:24:30\n   |\n24\
    \ |         if max_char != char::NONE {\n   |                              ^^^^\
    \ associated item not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpiku_fguk.rs:25:22\n   |\n12 |     let mut result = words[0];\n   | \
    \                     -------- expected due to this value\n...\n25 |         \
    \    result = word;\n   |                      ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                      |\n   |                  \
    \    expected struct `String`, found `&String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = None;\n    let mut num_unique = 0;\n    for word in words {\n        if let\
    \ Some(unique) = word.chars().unique().count() {\n            num_unique += unique;\n\
    \            if num_unique > max_word.unwrap_or(0) as usize {\n              \
    \  max_word = Some(word);\n            }\n        }\n    }\n    if let Some(word)\
    \ = max_word {\n        word\n    } else {\n        String::from(\"ERROR!\")\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpwwvyxll7.rs:15:44\n   |\n15 |         if let Some(unique)\
    \ = word.chars().unique().count() {\n   |                                    \
    \        ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwwvyxll7.rs:18:33\n   |\n18 |                 max_word = Some(word);\n\
    \   |                                 ^^^^ expected integer, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwwvyxll7.rs:23:9\n   |\n11 | fn\
    \ find_max(words: Vec<String>) -> String {\n   |                             \
    \       ------ expected `String` because of return type\n...\n23 |         word\n\
    \   |         ^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \         |\n   |         expected struct `String`, found integer\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_count\
    \ = HashMap::new();\n    for word in words {\n        let mut word_count = 1;\n\
    \        for char in word.chars() {\n            if !char_count.contains_key(&char)\
    \ {\n                char_count.insert(char, 1);\n            } else {\n     \
    \           word_count += char_count.get(&char).unwrap() + 1;\n            }\n\
    \        }\n        if word_count > char_count.len() {\n            char_count\
    \ = HashMap::new();\n            char_count.insert(word.chars().next().unwrap(),\
    \ 1);\n        } else {\n            char_count.insert(char, word_count + 1);\n\
    \        }\n    }\n    let mut char_iter = char_count.keys();\n    let mut max_char\
    \ = char_iter.next();\n    if char_iter.next().is_none() {\n        return String::new();\n\
    \    }\n    while char_iter.next() != &None {\n        if char_count.get(&max_char).unwrap()\
    \ < char_count.get(char_iter.next()).unwrap() {\n            max_char = char_iter.next();\n\
    \        }\n    }\n    max_char\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpf9v8xcmk.rs:12:26\n   |\n12 |     let mut char_count = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpf9v8xcmk.rs:23:26\n\
    \   |\n23 |             char_count = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0423]: expected value,\
    \ found builtin type `char`\n  --> /tmp/tmpf9v8xcmk.rs:26:31\n   |\n26 |     \
    \        char_count.insert(char, word_count + 1);\n   |                      \
    \         ^^^^ not a value\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0423, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut word = String::new();\n    for word in words {\n        let mut count\
    \ = 0;\n        for ch in word.chars() {\n            match ch.chars().count()\
    \ {\n                0 => count,\n                _ => count += 1,\n         \
    \   }\n        }\n        if count > max {\n            max = count;\n       \
    \     word = word;\n        }\n    }\n    word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnlxoj724.rs:17:22\n   |\n17 |             match ch.chars().count()\
    \ {\n   |                      ^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmpnlxoj724.rs:19:22\n   |\n\
    17 | /             match ch.chars().count() {\n18 | |                 0 => count,\n\
    \   | |                      ----- this is found to be of type `{integer}`\n19\
    \ | |                 _ => count += 1,\n   | |                      ^^^^^^^^^^\
    \ expected integer, found `()`\n20 | |             }\n   | |_____________- `match`\
    \ arms have incompatible types\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .fold((0, String::new()), |(max, cur), word| {\n            let mut chars\
    \ = &mut *cur;\n            for c in word.chars().cloned() {\n               \
    \ if *chars.end() == chars.iter().position(|x| *x == c).unwrap() {\n         \
    \           chars.push(c);\n                }\n            }\n            (max,\
    \ chars.clone())\n        })\n        .1\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmprkv77rpc.rs:16:35\n     |\n16   |             for c in\
    \ word.chars().cloned() {\n     |                                   ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmprkv77rpc.rs:16:22\n   |\n16 |             for c in word.chars().cloned()\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmprkv77rpc.rs:16:22\n   |\n16 |     \
    \        for c in word.chars().cloned() {\n   |                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror[E0599]: no method\
    \ named `end` found for mutable reference `&mut str` in the current scope\n  -->\
    \ /tmp/tmprkv77rpc.rs:17:27\n   |\n17 |                 if *chars.end() == chars.iter().position(|x|\
    \ *x == c).unwrap() {\n   |                           ^^^ method not found in\
    \ `&mut str`\n\nerror[E0599]: no method named `iter` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmprkv77rpc.rs:17:42\n   |\n17 |\
    \                 if *chars.end() == chars.iter().position(|x| *x == c).unwrap()\
    \ {\n   |                                          ^^^^ method not found in `&mut\
    \ str`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain\
    \ an `Iterator` over each of its codepoint use method `chars`\n   |\n17 |    \
    \             "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max(\n     \
    \   words.into_iter().map(|s| s.chars().count()).sum::<usize>(),\n    )\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4eircqy.rs:13:9\n   |\n\
    13 |         words.into_iter().map(|s| s.chars().count()).sum::<usize>(),\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_helper(words.iter(),\
    \ HashSet::new(), 0)\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_helper` in this scope\n  -->\
    \ /tmp/tmpeu6js0e3.rs:12:5\n   |\n12 |     find_max_helper(words.iter(), HashSet::new(),\
    \ 0)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpeu6js0e3.rs:12:35\n\
    \   |\n12 |     find_max_helper(words.iter(), HashSet::new(), 0)\n   |       \
    \                            ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Convert into a\
    \ HashMap to calculate the number of unique characters\n    // of each word. After\
    \ that, get the maximum value of the HashMap and return\n    // the word that\
    \ contains the maximum number of unique characters.\n    let mut m = HashMap::new();\n\
    \    for word in words.iter() {\n        let mut c = m.entry(word).or_insert(0);\n\
    \        *c += 1;\n    }\n    m.max_by_key(|(_, v)| v).1\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4qj5x0je.rs:15:17\n   |\n15 |     let mut m = HashMap::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(String::new(),\
    \ |mut current, word| {\n        if current.chars().unique().len() > word.chars().unique().len()\
    \ {\n            current = word\n        }\n        current\n    })\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpks704kuo.rs:13:28\n   |\n13 |         if current.chars().unique().len()\
    \ > word.chars().unique().len() {\n   |                            ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `unique` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmpks704kuo.rs:13:58\n   |\n\
    13 |         if current.chars().unique().len() > word.chars().unique().len() {\n\
    \   |                                                          ^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpks704kuo.rs:14:23\n\
    \   |\n12 |     words.iter().fold(String::new(), |mut current, word| {\n   | \
    \                                          ------- expected due to this parameter\
    \ type\n13 |         if current.chars().unique().len() > word.chars().unique().len()\
    \ {\n14 |             current = word\n   |                       ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                       |\n  \
    \ |                       expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    for w in words {\n        let mut res = String::new();\n        for c in\
    \ w {\n            let mut count = match res.chars().count(|x| x == c) {\n   \
    \             0 => 0,\n                1 => 1,\n                _ => 2,\n    \
    \        };\n            res = match count {\n                0 => {\n       \
    \             let mut s = res.clone();\n                    s.push(c);\n     \
    \               s\n                },\n                _ => {\n              \
    \      let mut s = res.clone();\n                    s.push_str(&c.to_string());\n\
    \                    s\n                },\n            };\n        }\n      \
    \  res.push_str(&w.to_string());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpz6utfxyx.rs:15:18\n\
    \   |\n15 |         for c in w {\n   |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0061]: this function takes\
    \ 0 arguments but 1 argument was supplied\n   --> /tmp/tmpz6utfxyx.rs:16:47\n\
    \    |\n16  |             let mut count = match res.chars().count(|x| x == c)\
    \ {\n    |                                               ^^^^^ ---------- supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 1;\n    let mut word = String::new();\n    for w in words {\n        let mut\
    \ cur_count = 1;\n        for c in w.chars() {\n            if cur_count > max_count\
    \ {\n                max_count = cur_count;\n                word = w;\n     \
    \       }\n            cur_count += 1;\n        }\n    }\n    word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n  --> /tmp/tmpk7kei5qs.rs:16:13\n   |\n\
    16 |         for c in w.chars() {\n   |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_c`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0505]: cannot move out of `w` because it is borrowed\n\
    \  --> /tmp/tmpk7kei5qs.rs:19:24\n   |\n16 |         for c in w.chars() {\n  \
    \ |                  --------- borrow of `w` occurs here\n...\n19 |          \
    \       word = w;\n   |                        ^ move out of `w` occurs here\n\
    \nerror[E0382]: use of moved value: `w`\n  --> /tmp/tmpk7kei5qs.rs:19:24\n   |\n\
    14 |     for w in words {\n   |         -\n   |         |\n   |         this reinitialization\
    \ might get skipped\n   |         move occurs because `w` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n19 |                 word = w;\n \
    \  |                        ^ value moved here, in previous iteration of loop\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0382, E0505.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let words = words\n\
    \        .iter()\n        .cloned()\n        .map(|s| s.to_lowercase())\n    \
    \    .collect::<Vec<_>>();\n\n    let mut max_count = 1;\n    let mut max_word:\
    \ String = String::from(\"-1\");\n    let mut max_index: usize = 0;\n    for word\
    \ in words {\n        if word.len() > max_count {\n            max_count = word.len();\n\
    \            max_word = word;\n            max_index = words.len() - 1;\n    \
    \    }\n    }\n    if max_count > 1 {\n        return max_word;\n    }\n\n   \
    \ for (i, word) in words.iter().enumerate() {\n        if i == max_index {\n \
    \           return word;\n        }\n    }\n\n    String::from(\"-1\")\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ki0vo4l.rs:34:20\n   |\n\
    34 |             return word;\n   |                    ^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                    |\n   |         \
    \           expected struct `String`, found `&String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Initialize a variable\
    \ that stores the number of characters in every word\n    // and keep track of\
    \ max number of unique characters seen in every word.\n    let mut max_chars =\
    \ 0.0;\n    let mut max_word = String::new();\n    for w in words {\n        let\
    \ mut chars = 0;\n        for c in w.chars() {\n            chars += 1;\n    \
    \    }\n        if chars > max_chars {\n            max_chars = chars;\n     \
    \       max_word = w;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `{integer}` with `{float}`\n  --> /tmp/tmpleq8xrj1.rs:21:18\n\
    \   |\n21 |         if chars > max_chars {\n   |                  ^ no implementation\
    \ for `{integer} < {float}` and `{integer} > {float}`\n   |\n   = help: the trait\
    \ `PartialOrd<{float}>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `PartialOrd<Rhs>`:\n             f32\n         \
    \    f64\n             i128\n             i16\n             i32\n            \
    \ i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpleq8xrj1.rs:21:20\n   |\n21 |         if chars\
    \ > max_chars {\n   |                    ^^^^^^^^^ expected integer, found floating-point\
    \ number\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpleq8xrj1.rs:22:25\n\
    \   |\n14 |     let mut max_chars = 0.0;\n   |                         --- expected\
    \ due to this value\n...\n22 |             max_chars = chars;\n   |          \
    \               ^^^^^ expected floating-point number, found integer\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // The result will\
    \ be the word with the maximum number of unique characters.\n    let mut result\
    \ = words.iter().cloned().max();\n    // If result is greater than max value so\
    \ far, update max value\n    // and keep track of the word which has max value.\n\
    \    if result.1 > words[0].chars().uniqued() {\n        result = words.iter().cloned().max();\n\
    \    }\n    // Return the result as the final value\n    result.0\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `Option<String>`\n  --> /tmp/tmpk5oxkat_.rs:16:15\n\
    \   |\n16 |     if result.1 > words[0].chars().uniqued() {\n   |             \
    \  ^\n\nerror[E0599]: no method named `uniqued` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpk5oxkat_.rs:16:36\n   |\n16 |     if result.1 >\
    \ words[0].chars().uniqued() {\n   |                                    ^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0609]: no field `0` on type `Option<String>`\n\
    \  --> /tmp/tmpk5oxkat_.rs:20:12\n   |\n20 |     result.0\n   |            ^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0609.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // O(N*L) where L\
    \ is the length of longest word in the vector.\n    let mut map = HashMap::new();\n\
    \    for (i, word) in words.iter().enumerate() {\n        map.entry(i).or_insert(0);\n\
    \        map.entry(i).and_modify(|x| *x += word.len());\n    }\n\n    let mut\
    \ max = -std::i32::MAX;\n    let mut max_i = 0;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let count = map.entry(i).or_insert(0);\n        if *count > max {\n\
    \            max_i = i;\n            max = *count;\n        }\n    }\n\n    words.swap_remove(max_i);\n\
    \    words.next()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphtbeh0hw.rs:13:19\n   |\n13 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<String>` in the current scope\n\
    \  --> /tmp/tmphtbeh0hw.rs:30:11\n   |\n30 |     words.next()\n   |          \
    \ ^^^^ method not found in `Vec<String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashSet::new();\n    for word in words {\n        word.chars().filter(|c|\
    \ !unique_chars.contains(c)).for_each(|c| unique_chars.insert(c));\n    }\n  \
    \  let mut result = String::from(\"\");\n    let mut max = words[0].len();\n \
    \   for word in words {\n        if max < word.len() {\n            max = word.len();\n\
    \            result = word;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9zzmbnpo.rs:12:28\n   |\n12 |     let mut unique_chars = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counter:\
    \ HashMap<u8, usize> = HashMap::new();\n    for word in words {\n        for c\
    \ in word.chars() {\n            if !char_counter.contains_key(&c) {\n       \
    \         char_counter.insert(c, 0);\n            }\n            char_counter.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max = words[0];\n    let mut counter =\
    \ 1;\n    for &(ref w, ref c) in char_counter {\n        if *c >= *max {\n   \
    \         max = w;\n            counter = 1;\n        } else {\n            *c\
    \ += 1;\n            *counter = *c;\n        }\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpjh16zjx1.rs:12:27\n\
    \   |\n12 |     let mut char_counter: HashMap<u8, usize> = HashMap::new();\n \
    \  |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpjh16zjx1.rs:12:48\n\
    \   |\n12 |     let mut char_counter: HashMap<u8, usize> = HashMap::new();\n \
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjh16zjx1.rs:18:48\n\
    \   |\n18 |             char_counter.entry(c).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjh16zjx1.rs:25:19\n   |\n21 |     let mut max = words[0];\n   |    \
    \               -------- expected due to this value\n...\n25 |             max\
    \ = w;\n   |                   ^- help: try using a conversion method: `.to_string()`\n\
    \   |                   |\n   |                   expected struct `String`, found\
    \ reference\n   |\n   = note: expected struct `String`\n           found reference\
    \ `&_`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpjh16zjx1.rs:29:13\n\
    \   |\n29 |             *counter = *c;\n   |             ^^^^^^^^\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0412, E0433, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word_set\
    \ = Vec::new();\n    for word in words {\n        for c in word.chars() {\n  \
    \          if !word_set.contains(&c) {\n                word_set.push(String::from(*c));\n\
    \            }\n        }\n    }\n\n    let mut max = String::new();\n    let\
    \ mut count = 1;\n    for char in word_set {\n        if count > word_set.len()\
    \ {\n            max = char;\n            count = 1;\n        } else if count\
    \ == word_set.len() {\n            max = char;\n            count += 1;\n    \
    \    }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpjds4k5qa.rs:16:44\n\
    \   |\n16 |                 word_set.push(String::from(*c));\n   |           \
    \                                 ^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjds4k5qa.rs:16:31\n   |\n16 |                 word_set.push(String::from(*c));\n\
    \   |                               ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjds4k5qa.rs:25:19\n\
    \   |\n21 |     let mut max = String::new();\n   |                   -------------\
    \ expected due to this value\n...\n25 |             max = char;\n   |        \
    \           ^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                 |\n   |                   expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjds4k5qa.rs:28:19\n   |\n21 |\
    \     let mut max = String::new();\n   |                   ------------- expected\
    \ due to this value\n...\n28 |             max = char;\n   |                 \
    \  ^^^^- help: try using a conversion method: `.to_string()`\n   |           \
    \        |\n   |                   expected struct `String`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut num_unique\
    \ = 1;\n    let mut max_word = String::new();\n    for word in words {\n     \
    \   let word_str = word.clone();\n        let mut new_num = num_unique;\n    \
    \    for char in word_str {\n            if chars.contains(&char) {\n        \
    \        new_num += 1;\n            }\n        }\n        if new_num > max_num\
    \ {\n            max_word = word;\n            max_num = new_num;\n        }\n\
    \        num_unique += 1;\n    }\n    return max_word;\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `chars` in this scope\n  --> /tmp/tmpum6tq6kp.rs:18:16\n\
    \   |\n18 |             if chars.contains(&char) {\n   |                ^^^^^\
    \ help: a local variable with a similar name exists: `char`\n\nerror[E0425]: cannot\
    \ find value `max_num` in this scope\n  --> /tmp/tmpum6tq6kp.rs:22:22\n   |\n\
    22 |         if new_num > max_num {\n   |                      ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `max_num` in this scope\n \
    \ --> /tmp/tmpum6tq6kp.rs:24:13\n   |\n24 |             max_num = new_num;\n \
    \  |             ^^^^^^^ not found in this scope\n\nerror[E0277]: `String` is\
    \ not an iterator\n  --> /tmp/tmpum6tq6kp.rs:17:21\n   |\n17 |         for char\
    \ in word_str {\n   |                     ^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words.to_vec();\n\
    \    words.sort_by_key(|s| s.chars().unique().count());\n    words[..1].iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpo0dyoxsv.rs:13:37\n   |\n13 |     words.sort_by_key(|s|\
    \ s.chars().unique().count());\n   |                                     ^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo0dyoxsv.rs:14:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n14\
    \ |     words[..1].iter().max().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&String`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_word = String::new();\n    for word in words {\n        let mut\
    \ freq = 0;\n        for c in word.chars() {\n            if let Some(c) = c.to_ascii_lowercase()\
    \ {\n                freq += c;\n            }\n        }\n        if freq > max\
    \ {\n            max = freq;\n            max_word = word;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfjs0l0g.rs:17:20\n   |\n\
    17 |             if let Some(c) = c.to_ascii_lowercase() {\n   |             \
    \       ^^^^^^^   ---------------------- this expression has type `char`\n   |\
    \                    |\n   |                    expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut max_word: String;\n \
    \   let mut max_num_uniques: usize = 0;\n    for (i, word) in words.iter().enumerate().rev()\
    \ {\n        if let Some(mut unique_nums) = word.chars().filter_map(|c| {\n  \
    \              c.chars().filter(|c| c.is_alphanumeric()).count() as usize\n  \
    \          }) {\n            if unique_nums > max_num_uniques {\n            \
    \    max_word = word;\n                max_num_uniques = unique_nums;\n      \
    \      }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4r4d_j_3.rs:20:19\n   |\n20 |                 c.chars().filter(|c|\
    \ c.is_alphanumeric()).count() as usize\n   |                   ^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4r4d_j_3.rs:19:16\n\
    \   |\n19 |            if let Some(mut unique_nums) = word.chars().filter_map(|c|\
    \ {\n   |   ________________^^^^^^^^^^^^^^^^^^^^^___-_______________________-\n\
    \   |  |________________|_______________________|\n   | ||                |\n\
    \   | ||                expected struct `FilterMap`, found enum `Option`\n20 |\
    \ ||                 c.chars().filter(|c| c.is_alphanumeric()).count() as usize\n\
    21 | ||             }) {\n   | ||_____________-- this expression has type `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp4r4d_j_3.rs:19:64: 21:14]>`\n   |  |_____________|\n   |  \
    \              the expected closure\n   |\n   = note: expected struct `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp4r4d_j_3.rs:19:64: 21:14]>`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4r4d_j_3.rs:23:28\n   |\n16 |\
    \     let mut max_word: String;\n   |                       ------ expected due\
    \ to this type\n...\n23 |                 max_word = word;\n   |             \
    \               ^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                            |\n   |                            expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .map(|w| w.chars().count())\n        .max()\n        .unwrap()\n    \
    \    .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmp5ip9ldzl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // find max number\
    \ of unique characters\n    let mut max_count: u32 = std::u32::MAX;\n    let mut\
    \ max_string: Option<String> = None;\n    for word in words {\n        // counting\
    \ number of unique characters\n        let count = word.chars().filter(|c| *c\
    \ != ' ').filter(|c| *c != '\\n').filter(|c| *c != '\\r').count();\n        if\
    \ count > max_count {\n            max_count = count;\n            max_string\
    \ = Some(word);\n        }\n    }\n    // return the word with maximum number\
    \ of unique characters\n    max_string\n        .cloned()\n        .unwrap_or_else(||\
    \ String::new())\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeegnbj5u.rs:18:20\n   |\n\
    18 |         if count > max_count {\n   |                    ^^^^^^^^^ expected\
    \ `usize`, found `u32`\n   |\nhelp: you can convert a `u32` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |         if count > max_count.try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeegnbj5u.rs:19:25\n   |\n13 |     let mut max_count: u32\
    \ = std::u32::MAX;\n   |                        --- expected due to this type\n\
    ...\n19 |             max_count = count;\n   |                         ^^^^^ expected\
    \ `u32`, found `usize`\n\nerror[E0599]: `Option<String>` is not an iterator\n\
    \   --> /tmp/tmpeegnbj5u.rs:25:10\n    |\n25  |           .cloned()\n    |   \
    \         ^^^^^^ `Option<String>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars_seen\
    \ = HashMap::new();\n    let mut result = String::new();\n    for w in words {\n\
    \        for c in w.chars() {\n            if !chars_seen.contains_key(&c) {\n\
    \                chars_seen.insert(c, 0);\n            }\n            chars_seen.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    chars_seen.iter().max_by_key(|&(_, count)| count).unwrap_or(result)\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpexnnywkj.rs:12:26\n   |\n12 |     let mut chars_seen = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmpexnnywkj.rs:19:46\n   |\n\
    19 |             chars_seen.entry(c).or_insert(0) += 1;\n   |             --------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars = Vec::new();\n\
    \    words.iter().for_each(|word| chars.extend_from_slice(word.chars()));\n  \
    \  chars\n        .iter()\n        .map(|c| chars::unique_counts(c).unwrap())\n\
    \        .max()\n        .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpexw6st60.rs:16:18\n   |\n16 |         .map(|c| chars::unique_counts(c).unwrap())\n\
    \   |                  ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpexw6st60.rs:13:58\n   |\n13 |     words.iter().for_each(|word|\
    \ chars.extend_from_slice(word.chars()));\n   |                              \
    \                            ^^^^^^^^^^^^ expected `&[_]`, found struct `Chars`\n\
    \   |\n   = note: expected reference `&[_]`\n                 found struct `Chars<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = words[0];\n\
    \    let mut count = words[0]\n        .chars()\n        .filter_map(|c| c.to_ascii_lowercase().count())\n\
    \        .sum();\n    words.iter().for_each(|word| {\n        let mut c = word\n\
    \            .chars()\n            .filter_map(|c| c.to_ascii_lowercase().count())\n\
    \            .sum();\n        if c > count {\n            count = c;\n       \
    \     res = word;\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmpxmh09qky.rs:15:48\n\
    \   |\n15 |         .filter_map(|c| c.to_ascii_lowercase().count())\n   |    \
    \                                            ^^^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror[E0599]:\
    \ `char` is not an iterator\n  --> /tmp/tmpxmh09qky.rs:20:52\n   |\n20 |     \
    \        .filter_map(|c| c.to_ascii_lowercase().count())\n   |               \
    \                                     ^^^^^ `char` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxmh09qky.rs:24:19\n   |\n12 |     let mut res\
    \ = words[0];\n   |                   -------- expected due to this value\n...\n\
    24 |             res = word;\n   |                   ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found `&String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut i = 0;\n    while i < words.len() {\n        let mut count = 0;\n\
    \        let mut word = &words[i];\n        for j in (i..words.len()).rev() {\n\
    \            if word[j].chars().count() > count {\n                word = &words[j];\n\
    \                count = word[j].chars().count();\n            }\n        }\n\
    \        if count > max {\n            max = count;\n        }\n        i = i\
    \ + 1;\n    }\n    words[0]\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc7dixpei.rs:18:16\n\
    \   |\n18 |             if word[j].chars().count() > count {\n   |           \
    \     ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc7dixpei.rs:20:25\n   |\n20 |                 count = word[j].chars().count();\n\
    \   |                         ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for w in words {\n        for c in w.chars() {\n    \
    \        *counters.entry(c).or_insert(0) += 1;\n        }\n    }\n    for w in\
    \ words {\n        if *counters.get(&w).is_some() {\n            return w;\n \
    \       }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwenr5pnd.rs:12:24\n   |\n12 |     let mut counters = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut num_unique_chars\
    \ = HashMap::new();\n    words.iter().for_each(|word| {\n        let mut chars\
    \ = word.chars();\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0)\
    \ += 1;\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) +=\
    \ 1;\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n\
    \        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n  \
    \  });\n    words\n        .iter()\n        .max_by_key(|x| num_unique_chars.get(x.chars().next().unwrap()).unwrap())\n\
    \        .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp_ovgrrjb.rs:12:32\n   |\n12 |     let mut num_unique_chars = HashMap::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp_ovgrrjb.rs:15:68\n\
    \   |\n15 |         num_unique_chars.entry(chars.next().unwrap()).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp_ovgrrjb.rs:16:68\n   |\n\
    16 |         num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n\
    \   |         ---------------------------------------------------------- ^^\n\
    \   |         |\n   |         cannot assign to this expression\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp_ovgrrjb.rs:17:68\n   |\n\
    17 |         num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n\
    \   |         ---------------------------------------------------------- ^^\n\
    \   |         |\n   |         cannot assign to this expression\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp_ovgrrjb.rs:18:68\n   |\n\
    18 |         num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n\
    \   |         ---------------------------------------------------------- ^^\n\
    \   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_ovgrrjb.rs:20:5\n   |\n11 |   fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n...\n20 | /     words\n21 | |         .iter()\n\
    22 | |         .max_by_key(|x| num_unique_chars.get(x.chars().next().unwrap()).unwrap())\n\
    23 | |         .unwrap()\n   | |                 ^- help: try using a conversion\
    \ method: `.to_string()`\n   | |_________________|\n   |                   expected\
    \ struct `String`, found "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max(words.iter().cloned())\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ytpibny.rs:12:14\n   |\n\
    12 |     find_max(words.iter().cloned())\n   |              ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Cloned<std::slice::Iter<'_, String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut freqs = HashMap::<String,\
    \ usize>::new();\n    let mut max = 0;\n    for word in words {\n        let freq\
    \ = freqs.get(&word).unwrap_or(0);\n        freqs.insert(word, freq + 1);\n  \
    \      if freq > max {\n            max = freq;\n        }\n    }\n    let mut\
    \ max_word = String::new();\n    for (word, freq) in freqs.iter() {\n        if\
    \ freq == max {\n            max_word.push_str(word);\n        }\n    }\n    normalize(&mut\
    \ max_word, &mut freqs)\n}\n\nfn main() {\n    let candidate = find_max;\n   \
    \ assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5_yez2x0.rs:12:21\n   |\n12 |     let mut freqs = HashMap::<String,\
    \ usize>::new();\n   |                     ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find function `normalize` in this scope\n  --> /tmp/tmp5_yez2x0.rs:27:5\n\
    \   |\n27 |     normalize(&mut max_word, &mut freqs)\n   |     ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter:\
    \ usize = 0;\n    let mut max_counter: usize = 0;\n    let mut max_word: String\
    \ = String::new();\n    for word in words {\n        if let Ok(n) = counter.iter().fold(0,\
    \ |&counter, &n| counter + n) {\n            if n > max_counter {\n          \
    \      max_counter = n;\n                max_word = word;\n            }\n   \
    \     }\n        counter += 1;\n    }\n    max_word\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpml4zg7h6.rs:16:32\n   |\n16 |         if let Ok(n) = counter.iter().fold(0,\
    \ |&counter, &n| counter + n) {\n   |                                ^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter()\n  \
    \      .map(|s| s.chars().count())\n        .max()\n        .unwrap()\n      \
    \  .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6\"`,\n right: `\"string\"`', /tmp/tmpmv7hvckx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars = vec![];\n\
    \    let mut words = words.clone();\n    loop {\n        let mut max_num = 0;\n\
    \        let mut max_word = String::new();\n        for word in &mut words {\n\
    \            let mut cur_char_num = chars.len();\n            for c in &word {\n\
    \                if cur_char_num > max_num {\n                    max_num = cur_char_num;\n\
    \                    max_word = c.to_string();\n                }\n          \
    \      cur_char_num += 1;\n            }\n        }\n        if max_num == 0 {\n\
    \            break;\n        }\n        words = words.clone();\n        words.push(max_word.clone());\n\
    \    }\n    words.clone()\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&&mut String` is not an iterator\n  --> /tmp/tmpz18k59_w.rs:19:22\n\
    \   |\n19 |             for c in &word {\n   |                      ^^^^^ `&&mut\
    \ String` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&&mut String`\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&&mut String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpz18k59_w.rs:33:5\n   |\n11 | fn find_max(words: Vec<String>) -> String\
    \ {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n33 |     words.clone()\n   |     ^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 1;\n    let mut max_word = String::from(\"\");\n    for (i, word) in words.iter().enumerate()\
    \ {\n        for (c1, c2) in word.chars().zip(word.chars().skip(i)) {\n      \
    \      if c1.chars().count() > c2.chars().count() {\n                *max_count\
    \ = c1.chars().count();\n                let mut max_word = word;\n          \
    \  } else if c1.chars().count() < c2.chars().count() {\n                *max_count\
    \ = c2.chars().count();\n                let mut max_word = word;\n          \
    \  }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmplj8dzf2m.rs:16:19\n   |\n16 |             if c1.chars().count()\
    \ > c2.chars().count() {\n   |                   ^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmplj8dzf2m.rs:16:40\n   |\n16 |             if c1.chars().count()\
    \ > c2.chars().count() {\n   |                                        ^^^^^ method\
    \ not found in `char`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmplj8dzf2m.rs:17:17\n   |\n17 |                 *max_count = c1.chars().count();\n\
    \   |                 ^^^^^^^^^^\n\nerror[E0599]: no method named `chars` found\
    \ for type `char` in the current scope\n  --> /tmp/tmplj8dzf2m.rs:17:33\n   |\n\
    17 |                 *max_count = c1.chars().count();\n   |                  \
    \               ^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmplj8dzf2m.rs:19:26\n\
    \   |\n19 |             } else if c1.chars().count() < c2.chars().count() {\n\
    \   |                          ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmplj8dzf2m.rs:19:47\n\
    \   |\n19 |             } else if c1.chars().count() < c2.chars().count() {\n\
    \   |                                               ^^^^^ method not found in\
    \ `char`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmplj8dzf2m.rs:20:17\n\
    \   |\n20 |                 *max_count = c2.chars().count();\n   |           \
    \      ^^^^^^^^^^\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmplj8dzf2m.rs:20:33\n   |\n20 |          \
    \       *max_count = c2.chars().count();\n   |                               \
    \  ^^^^^ method not found in `char`\n\nerror: aborting due to 8 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    let mut counter = vec![0];\n    let mut best_len = -1;\n    for word in words\
    \ {\n        let mut count = counter.clone();\n        count.push(0);\n      \
    \  for ch in word.chars() {\n            count[ch.to_ascii_lowercase().as_ref()]\
    \ += 1;\n        }\n        if count.len() == best_len {\n            best_len\
    \ = count.len();\n            res = word;\n        }\n        for (i, ch) in count.iter().enumerate()\
    \ {\n            counter[i] = ch as usize;\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_ref` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpedk18man.rs:19:43\n   |\n19 |             count[ch.to_ascii_lowercase().as_ref()]\
    \ += 1;\n   |                                           ^^^^^^ method not found\
    \ in `char`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmpedk18man.rs:14:24\n   |\n14 |     let mut best_len = -1;\n   | \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror[E0606]: casting `&usize` as `usize` is invalid\n  -->\
    \ /tmp/tmpedk18man.rs:26:26\n   |\n26 |             counter[i] = ch as usize;\n\
    \   |                          --^^^^^^^^^\n   |                          |\n\
    \   |                          cannot cast `&usize` as `usize`\n   |         \
    \                 help: dereference the expression: `*ch`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599,\
    \ E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_helper(words,\
    \ 0, &mut 0);\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_helper` in this scope\n  -->\
    \ /tmp/tmp2oqmvez7.rs:12:5\n   |\n12 |     find_max_helper(words, 0, &mut 0);\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2oqmvez7.rs:11:36\n   |\n11 | fn find_max(words: Vec<String>)\
    \ -> String {\n   |    --------                        ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let words = words.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut set = HashSet::new();\n    words.iter().cloned().sort_by_key(|s|\
    \ s.chars().filter(|c| !set.add(c)).count()).last()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpd5i3v4ul.rs:13:19\n   |\n13 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmpd5i3v4ul.rs:14:27\n   |\n14 |     words.iter().cloned().sort_by_key(|s|\
    \ s.chars().filter(|c| !set.add(c)).count()).last()\n   |                    \
    \       ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Solution without\
    \ recursion\n    let mut m = HashMap::new();\n    for w in words {\n        if\
    \ m.contains_key(&w.chars().count()) {\n            let old_count = m.get_mut(&w.chars().count()).unwrap();\n\
    \            old_count.1 += 1;\n        } else {\n            let count = w.chars().count();\n\
    \            m.insert(count.clone(), 1);\n        }\n    }\n    let mut max =\
    \ 0;\n    let mut word: String = String::new();\n    for (c, _) in m.iter() {\n\
    \        if c > max {\n            max = c;\n            word = String::from(*c);\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpngxhiail.rs:13:17\n   |\n13 |     let mut m = HashMap::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpngxhiail.rs:28:33\n \
    \  |\n28 |             word = String::from(*c);\n   |                        \
    \         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpngxhiail.rs:31:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n31\
    \ |     max\n   |     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found integer\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0433,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .map(|w| w.chars().unique_count())\n        .max()\n        .unwrap_or(0)\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique_count` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp7z7vq170.rs:14:28\n   |\n14 |         .map(|w|\
    \ w.chars().unique_count())\n   |                            ^^^^^^^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars:\
    \ HashSet<Char> = HashSet::new();\n    for word in words {\n        word.chars()\n\
    \            .filter(|c| !c.is_whitespace())\n            .for_each(|c| {\n  \
    \              unique_chars.insert(c);\n            });\n    }\n    let mut most_common_char:\
    \ Char = unique_chars.iter().max_by_key(|c| c.len()).unwrap();\n    let mut word_with_most_common_char:\
    \ String = String::new();\n    for word in words {\n        word.chars()\n   \
    \         .filter(|c| !c.is_whitespace())\n            .for_each(|c| {\n     \
    \           if c == most_common_char {\n                    word_with_most_common_char.push_str(word);\n\
    \                }\n            });\n    }\n    if word_with_most_common_char\
    \ == \"\" {\n        \"\".to_string()\n    } else {\n        word_with_most_common_char\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpwfgxp8l3.rs:12:27\n\
    \   |\n12 |     let mut unique_chars: HashSet<Char> = HashSet::new();\n   |  \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `Char` in this scope\n  --> /tmp/tmpwfgxp8l3.rs:12:35\n   |\n\
    12 |     let mut unique_chars: HashSet<Char> = HashSet::new();\n   |         \
    \                          ^^^^\n   |\nhelp: a builtin type with a similar name\
    \ exists\n   |\n12 |     let mut unique_chars: HashSet<char> = HashSet::new();\n\
    \   |                                   ~~~~\nhelp: you might be missing a type\
    \ parameter\n   |\n11 | fn find_max<Char>(words: Vec<String>) -> String {\n  \
    \ |            ++++++\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpwfgxp8l3.rs:12:43\n   |\n12 |     let mut unique_chars:\
    \ HashSet<Char> = HashSet::new();\n   |                                      \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find\
    \ type `Char` in this scope\n  --> /tmp/tmpwfgxp8l3.rs:20:31\n   |\n20 |     let\
    \ mut most_common_char: Char = unique_chars.iter().max_by_key(|c| c.len()).unwrap();\n\
    \   |                               ^^^^ help: a builtin type with a similar name\
    \ exists (notice the capitalization): `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwfgxp8l3.rs:27:57\n   |\n27 |                     word_with_most_common_char.push_str(word);\n\
    \   |                                                         ^^^^\n   |     \
    \                                                    |\n   |                 \
    \                                        expected `&str`, found struct `String`\n\
    \   |                                                         help: consider borrowing\
    \ here: `&word`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0412, E0433.\nFor more information about an error,\
    \ tr"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        String::new()\n    } else {\n        let mut max_count = words.iter().map(|s|\
    \ s.chars().count() as usize).max().unwrap();\n        let mut best_str = words.get(0);\n\
    \        for str in words {\n            if str.chars().count() > max_count {\n\
    \                best_str = str;\n                max_count = str.chars().count()\
    \ as usize;\n            }\n        }\n        best_str\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptvp0ikbe.rs:19:28\n   |\n\
    16 |         let mut best_str = words.get(0);\n   |                          \
    \  ------------ expected due to this value\n...\n19 |                 best_str\
    \ = str;\n   |                            ^^^ expected enum `Option`, found struct\
    \ `String`\n   |\n   = note: expected enum `Option<&String>`\n            found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptvp0ikbe.rs:23:9\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n23\
    \ |         best_str\n   |         ^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<&String>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word = String::from(\"\
    \");\n    let mut max = String::from(\"\");\n    for w in words {\n        max\
    \ = w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count() + max;\n  \
    \      if w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count() > word.chars().filter(|c|\
    \ c != 'a' && c != 'i' && c != 'e').count() {\n            word = w;\n       \
    \ }\n    }\n    word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegchub_b.rs:15:38\n\
    \   |\n15 |         max = w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count()\
    \ + max;\n   |                                      ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpegchub_b.rs:15:50\n   |\n15\
    \ |         max = w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count()\
    \ + max;\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpegchub_b.rs:15:62\n\
    \   |\n15 |         max = w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count()\
    \ + max;\n   |                                                              ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: cannot add `String` to `usize`\n  --> /tmp/tmpegchub_b.rs:15:78\n\
    \   |\n15 |         max = w.chars().filter(|c| c != 'a' && c != 'i' && c != 'e').count()\
    \ + max;\n   |                                                               \
    \               ^ no implementation for `usize + String`\n   |\n   = help: the\
    \ trait `Add<String>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpegchub_b.rs:16:35\n   |\n16 | ...   "
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut num_unique\
    \ = 0;\n    let mut word = String::from(\"\");\n    let mut max = String::from(\"\
    \");\n\n    for w in words {\n        if w.chars().unique().len() < num_unique\
    \ {\n            word = w;\n            num_unique = w.chars().unique().len();\n\
    \        }\n    }\n\n    if num_unique > 0 {\n        for w in words {\n     \
    \       if w < word {\n                max = w;\n            }\n        }\n  \
    \  } else {\n        max = word;\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpmrl30pkf.rs:17:22\n   |\n17 |         if w.chars().unique().len()\
    \ < num_unique {\n   |                      ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `unique` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpmrl30pkf.rs:19:36\n   |\n19 |             num_unique =\
    \ w.chars().unique().len();\n   |                                    ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max(words).0\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `String`\n  --> /tmp/tmpmkd1_ah8.rs:12:21\n\
    \   |\n12 |     find_max(words).0\n   |                     ^ unknown field\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word_set\
    \ = HashSet::new();\n    for w in words.iter() {\n        word_set.insert(w.chars().distinct().count());\n\
    \    }\n    if word_set.iter().any(|v| *v > 1) {\n        let mut i = 1;\n   \
    \     for w in words.iter() {\n            if !word_set.insert(w.chars().distinct().count())\
    \ {\n                break;\n            }\n            i += 1;\n            if\
    \ i == words.size() {\n                break;\n            }\n        }\n    \
    \    if i != words.size() {\n            return *words.iter().rev().skip(i).take(1).collect::<String>().unwrap();\n\
    \        }\n    }\n    words.iter().map(|w| w.chars().distinct().count()).max_by_key(|v|\
    \ v).unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_hypbq48.rs:12:24\n   |\n12 |     let mut word_set = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `distinct` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmp_hypbq48.rs:14:35\n   |\n14 |         word_set.insert(w.chars().distinct().count());\n\
    \   |                                   ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `distinct` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp_hypbq48.rs:19:43\n   |\n19 |             if !word_set.insert(w.chars().distinct().count())\
    \ {\n   |                                           ^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `size` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmp_hypbq48.rs:23:27\n   |\n23 |          \
    \   if i == words.size() {\n   |                           ^^^^ help: there is\
    \ an associated function with a similar name: `resize`\n\nerror[E0599]: no method\
    \ named `size` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmp_hypbq48.rs:27:23\n\
    \   |\n27 |         if i != words.size() {\n   |                       ^^^^ help:\
    \ there is an associated function with a similar name: `resize`\n\nerror[E0277]:\
    \ a value of type `String` cannot be built from an iterator over elements of type\
    \ `&String`\n    --> /tmp/tmp_hypbq48.rs:28:56\n     |\n28   |             return\
    \ *words.iter().rev().skip(i).take(1).collect::<String>().unwrap();\n     |  \
    \                                                      ^^^^^^^ value of type `String`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n     = help:\
    \ the trait `FromIterator<&String>` is not implemented for `String`\n     = help:\
    \ the following other types implement trait `FromIterator<A>`:\n             \
    \  <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(\"\
    \", |mut s, word| {\n        if s.chars().count() > word.chars().count() {\n \
    \           s\n        } else {\n            word\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmt50gb8_.rs:12:23\n   |\n\
    12 |     words.iter().fold(\"\", |mut s, word| {\n   |                       ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmt50gb8_.rs:16:13\n   |\n16 |  \
    \           word\n   |             ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |             |\n   |             expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    find_max_helper(words,\
    \ 0, words.len(), |a, b| a.len() < b.len()).0\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_helper` in this scope\n  -->\
    \ /tmp/tmpkbgpw6pm.rs:12:5\n   |\n12 |     find_max_helper(words, 0, words.len(),\
    \ |a, b| a.len() < b.len()).0\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        String::new()\n    } else {\n        let mut result = String::new();\n\
    \        let mut max_num = 1;\n        let mut max = 0;\n        for s in words\
    \ {\n            let mut num = 0;\n            for c in s.chars().filter(|c| !c.is_whitespace())\
    \ {\n                num += c.chars().filter(|c| !c.is_whitespace()).count() as\
    \ u32;\n            }\n            if num > max {\n                max = num;\n\
    \                result = s;\n            }\n        }\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxuur92fs.rs:21:26\n   |\n21 |                 num += c.chars().filter(|c|\
    \ !c.is_whitespace()).count() as u32;\n   |                          ^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ HashMap::new();\n    for word in words {\n        counts.entry(word.chars().unique().count()).or_default();\n\
    \    }\n    let max = counts.iter().max_by_key(|&(_, count)| count).unwrap();\n\
    \    max.0.to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprhaj09jw.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `unique` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmprhaj09jw.rs:14:35\n   |\n14 |         counts.entry(word.chars().unique().count()).or_default();\n\
    \   |                                   ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashMap::new();\n    for word in words {\n        for char in word.chars()\
    \ {\n            let mut count = unique_chars.get(char).unwrap();\n          \
    \  count += 1;\n            unique_chars.insert(char, count);\n        }\n   \
    \ }\n    let mut max_count = unique_chars.iter().max_by_key(|_, count| count).unwrap();\n\
    \    for (char, count) in unique_chars {\n        if count == max_count {\n  \
    \          return char;\n        }\n    }\n    String::from(\"no unique chars\"\
    )\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp6nqzj57n.rs:12:28\n   |\n12 |     let mut unique_chars = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words {\n        let word_len = word.len();\n\
    \        for character in word.chars() {\n            counter.entry(character).or_insert(0)\
    \ += 1;\n            if counter[character] > word_len {\n                break;\n\
    \            }\n        }\n    }\n    let mut max_key = Vec::new();\n    let mut\
    \ max_value = 0;\n    for key in counter.keys() {\n        if counter[key] > max_value\
    \ {\n            max_key = key;\n            max_value = counter[key];\n     \
    \   }\n    }\n    return max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp94m57vg7.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp94m57vg7.rs:16:51\n   |\n\
    16 |             counter.entry(character).or_insert(0) += 1;\n   |           \
    \  ------------------------------------- ^^\n   |             |\n   |        \
    \     cannot assign to this expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp94m57vg7.rs:30:12\n   |\n11 | fn find_max(words: Vec<String>) -> String\
    \ {\n   |                                    ------ expected `String` because\
    \ of return type\n...\n30 |     return max_key\n   |            ^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: Make an\
    \ algorithm that will search all words and return the\n    // one with maximum\
    \ number of unique characters in lexicographical order.\n    for word in words\
    \ {\n        // TODO: Count how many different characters a word contains\n  \
    \      let mut unique_chars = word.chars().unique().count();\n        // TODO:\
    \ If this word contains more unique characters, return the word that comes first\n\
    \        if unique_chars > 0 {\n            return word;\n        }\n    }\n \
    \   String::from(\"empty\")\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmph5fimqyz.rs:16:45\n   |\n16 |         let mut unique_chars\
    \ = word.chars().unique().count();\n   |                                     \
    \        ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars_count\
    \ = words.iter().map(|word| word.chars().count()).sum();\n    let mut max_idx\
    \ = 0;\n    let mut max_chars = 0;\n    let mut first_word = words[0];\n    for\
    \ idx in 0..words.len() {\n        let chars = words[idx].chars().count();\n \
    \       if chars > max_chars {\n            max_idx = idx;\n            max_chars\
    \ = chars;\n        }\n        if chars == max_chars {\n            if idx > 0\
    \ && chars > first_word.chars().count() {\n                first_word = words[idx];\n\
    \            }\n        }\n    }\n    first_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpi156nza_.rs:12:9\n\
    \   |\n12 |     let mut chars_count = words.iter().map(|word| word.chars().count()).sum();\n\
    \   |         ^^^^^^^^^^^^^^^ consider giving `chars_count` a type\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut min_uniques\
    \ = words[0].chars().count();\n    let mut result = words.iter().min().unwrap();\n\
    \    for word in words {\n        let mut new_uniques = word.chars().count();\n\
    \        if new_uniques < min_uniques {\n            min_uniques = new_uniques;\n\
    \            result = word;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp92xez70i.rs:18:22\n   |\n\
    13 |     let mut result = words.iter().min().unwrap();\n   |                 \
    \     --------------------------- expected due to this value\n...\n18 |      \
    \       result = word;\n   |                      ^^^^\n   |                 \
    \     |\n   |                      expected `&String`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&word`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp92xez70i.rs:21:5\n   |\n11 | fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                    ------ expected\
    \ `String` because of return type\n...\n21 |     result\n   |     ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ String::new();\n    words.iter().map(|word| word.chars().count()).filter(|c|\
    \ !c.is_zero()).for_each(|c| {\n        counts.push_str(&c.to_string());\n   \
    \ });\n    counts.sort_by(|a, b| b.cmp(a));\n    counts.iter().take(1).next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for reference `&usize` in\
    \ the current scope\n  --> /tmp/tmp65h9rnh3.rs:13:65\n   |\n13 |     words.iter().map(|word|\
    \ word.chars().count()).filter(|c| !c.is_zero()).for_each(|c| {\n   |        \
    \                                                         ^^^^^^^ method not found\
    \ in `&usize`\n\nerror[E0599]: no method named `sort_by` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp65h9rnh3.rs:16:12\n   |\n16 |     counts.sort_by(|a,\
    \ b| b.cmp(a));\n   |            ^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp65h9rnh3.rs:17:12\n   |\n17 |     counts.iter().take(1).next().unwrap()\n\
    \   |            ^^^^ method not found in `String`\n   |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n   |\n17 |     counts.chars().take(1).next().unwrap()\n\
    \   |            ~~~~~\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ HashSet::new();\n    let mut ans = String::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut count = 0;\n        let mut c = word.chars();\n        while\
    \ c.next().is_some() {\n            if c.next().unwrap().unwrap() != 'a' && c.next().unwrap().unwrap()\
    \ != 'e' &&\n                c.next().unwrap().unwrap() != 'i' && c.next().unwrap().unwrap()\
    \ != 'o' &&\n                c.next().unwrap().unwrap() != 'u' && c.next().unwrap().unwrap()\
    \ != 'A' &&\n                c.next().unwrap().unwrap() != 'E' && c.next().unwrap().unwrap()\
    \ != 'I' &&\n                c.next().unwrap().unwrap() != 'O' && c.next().unwrap().unwrap()\
    \ != 'U' &&\n                c.next().unwrap().unwrap() != 'n' && c.next().unwrap().unwrap()\
    \ != 'N' &&\n                c.next().unwrap().unwrap() != 'a' && c.next().unwrap().unwrap()\
    \ != 'e' &&\n                c.next().unwrap().unwrap() != 'i' && c.next().unwrap().unwrap()\
    \ != 'o' &&\n                c.next().unwrap().unwrap() != 'u' && c.next().unwrap().unwrap()\
    \ != 's' && c.next().unwrap().unwrap() != 'S' {\n                count = 1;\n\
    \            } else {\n                count += 1;\n            }\n        }\n\
    \        if count > max_len.get_mut(&mut i) {\n            max_len.insert(i, count);\n\
    \            ans = word;\n        }\n    }\n    if ans.chars().count() > max_len.len()\
    \ {\n        ans\n    } else {\n        find_max(vec![ans.clone(), String::from(\"\
    aa\")])\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp1zmvce09.rs:12:23\n   |\n12 |     let mut max_len = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp1zmvce09.rs:18:34\n\
    \   |\n18 |             if c.next().unwrap().unwrap() != 'a' && c.next().unwrap().unwrap()\
    \ != 'e' &&\n   |                                  ^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp1zmvce09.rs:18:71\n   |\n18 |             if c.next().unwrap().unwrap()\
    \ != 'a' && c.next().unwrap().unwrap() != 'e' &&\n   |                       \
    \                                                ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp1zmvce09.rs:19:35\n   |\n19 |                 c.next().unwrap().unwrap()\
    \ != 'i' && c.next().unwrap().unwrap() != 'o' &&\n   |                       \
    \            ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp1zmvce09.rs:19:72\n\
    \   |\n19 |                 c.next().unwrap().unwrap() != 'i' && c.next().unwrap().unwrap()\
    \ != 'o' &&\n   |                                                            \
    \            ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp1zmvce09.rs:20:35\n\
    \   |\n20 |                 c.next().unwrap().unwrap() != 'u' && c.next().unwrap().unwrap()\
    \ != 'A' &&\n   |                                   ^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp1zmvce09.rs:20:72\n   |\n20 |                 c.next().unwrap().unwrap()\
    \ != 'u' && c.next().unwrap().unwrap() != 'A' &&\n   |                       \
    \   "
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .max_by_key(|word| word.chars().count())\n        .cloned()\n       \
    \ .expect(\"Word cannot be empty string\")\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmpm37w829m.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut num_unique\
    \ = String::new();\n    let mut first_char = String::new();\n    for word in words\
    \ {\n        let mut unique = String::new();\n        for c in word.chars() {\n\
    \            if unique.contains(&c) {\n                unique.push(c.to_string());\n\
    \            } else {\n                unique.push(c.to_string());\n         \
    \       if num_unique.len() == 0 {\n                    first_char = c.to_string();\n\
    \                }\n                unique = unique.clone();\n            }\n\
    \        }\n        if unique.len() == 0 {\n            first_char = String::new();\n\
    \        }\n        num_unique = unique.clone();\n    }\n    unique_string(first_char,\
    \ num_unique)\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_string` in this scope\n  -->\
    \ /tmp/tmp405wtnrw.rs:32:5\n   |\n32 |     unique_string(first_char, num_unique)\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp405wtnrw.rs:17:32\n     |\n17   |   \
    \          if unique.contains(&c) {\n     |                       -------- ^^\
    \ expected an `Fn<(char,)>` closure, found `char`\n     |                    \
    \   |\n     |                       required by a bound introduced by this call\n\
    \     |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n17   |             if unique.contains(*&c)\
    \ {\n     |                                +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp405wtnrw.rs:18:29\n   |\n18 |                 unique.push(c.to_string());\n\
    \   |                             ^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp405wtnrw.rs:20:29\n\
    \   |\n20 |                 unique.push(c.to_string());\n   |                \
    \             ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: implement\
    \ the function\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpl5att558.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_characters:\
    \ Vec<usize> = words.iter().map(|word| word.chars().count()).collect();\n    unique_characters.sort_unstable();\n\
    \n    let mut max_word_length: usize = 0;\n    let mut max_word: String = \"\"\
    ;\n\n    let mut current_length: usize = 0;\n    for i in 0..unique_characters.len()\
    \ {\n        if i > 0 {\n            if unique_characters[i - 1] == unique_characters[i]\
    \ {\n                continue;\n            }\n        }\n\n        if unique_characters[i\
    \ - 1] > unique_characters[i] {\n            unique_characters[i - 1] -= 1;\n\
    \        }\n\n        current_length += 1;\n        if current_length >= max_word_length\
    \ {\n            max_word_length = current_length;\n            max_word = words.iter().filter(|word|\
    \ word.chars().count() == unique_characters[i - 1]).next().unwrap();\n       \
    \ }\n    }\n\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyl34fxx9.rs:16:32\n   |\n\
    16 |     let mut max_word: String = \"\";\n   |                       ------ \
    \  ^^- help: try using a conversion method: `.to_string()`\n   |             \
    \          |        |\n   |                       |        expected struct `String`,\
    \ found `&str`\n   |                       expected due to this\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyl34fxx9.rs:33:24\n   |\n16 |     let mut max_word:\
    \ String = \"\";\n   |                       ------ expected due to this type\n\
    ...\n33 |             max_word = words.iter().filter(|word| word.chars().count()\
    \ == unique_characters[i - 1]).next().unwrap();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut counters = vec![String::new();\
    \ words.len()];\n    for word in words {\n        let mut counter = 0;\n     \
    \   for c in word.chars() {\n            counter += 1;\n            counters[counters.len()\
    \ - 1].push(c);\n        }\n    }\n\n    let mut best_count = counters[0].len();\n\
    \    let mut best_words = Vec::with_capacity(words.len());\n    for &counter in\
    \ counters {\n        if counter.len() > best_count {\n            best_count\
    \ = counter.len();\n            best_words = vec![word.clone() for word in words];\n\
    \        }\n    }\n\n    String::from(find_max(&best_words))\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `<eof>`\n  --> /tmp/tmps_0u33jm.rs:30:56\n \
    \  |\n30 |             best_words = vec![word.clone() for word in words];\n  \
    \ |                                                        ^^^^^ expected `{`\n\
    \nerror: no rules expected the token `for`\n  --> /tmp/tmps_0u33jm.rs:30:44\n\
    \   |\n30 |             best_words = vec![word.clone() for word in words];\n \
    \  |                                            ^^^ no rules expected this token\
    \ in macro call\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_0u33jm.rs:27:9\n\
    \   |\n27 |     for &counter in counters {\n   |         ^^^^^^^^    --------\
    \ this expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `counter`\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_0u33jm.rs:34:27\n\
    \   |\n34 |     String::from(find_max(&best_words))\n   |                    \
    \       ^^^^^^^^^^^ expected struct `Vec`, found `&Vec<_>`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n           found reference `&Vec<_>`\nhelp: consider removing\
    \ the borrow\n   |\n34 -     String::from(find_max(&best_words))\n34 +     String::from(find_max(best_words))\n\
    \   | \n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut count = vec![String::from(\"\
    a\")];\n    let mut best = String::from(\"a\");\n    for word in words {\n   \
    \     let mut new_count = count.clone();\n        new_count.push(String::from(\"\
    a\"));\n        for c in word.chars().filter(|c| *c != \"a\") {\n            if\
    \ new_count.iter().any(|c| *c != c) {\n                new_count.push(String::from(*c));\n\
    \            } else {\n                new_count.pop();\n            }\n     \
    \   }\n        if new_count.len() > count {\n            count = new_count;\n\
    \            best = word;\n        }\n    }\n    best\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpei7yiafe.rs:17:48\n   |\n\
    17 |         for c in word.chars().filter(|c| *c != \"a\") {\n   |           \
    \                                     ^^^ expected `char`, found `&str`\n   |\n\
    help: if you meant to write a `char` literal, use single quotes\n   |\n17 |  \
    \       for c in word.chars().filter(|c| *c != 'a') {\n   |                  \
    \                              ~~~\n\nerror[E0277]: can't compare `String` with\
    \ `&String`\n  --> /tmp/tmpei7yiafe.rs:18:44\n   |\n18 |             if new_count.iter().any(|c|\
    \ *c != c) {\n   |                                            ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpei7yiafe.rs:19:45\n   |\n19 |                 new_count.push(String::from(*c));\n\
    \   |                                             ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpei7yiafe.rs:24:30\n   |\n24 |         if new_count.len()\
    \ > count {\n   |                              ^^^^^ expected `usize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `usize`\n            found struct `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: optimize\n\
    \    let mut counter = HashMap::new();\n    for word in words {\n        let count\
    \ = counter.get(word).unwrap();\n        *count += 1;\n        counter.insert(word,\
    \ *count);\n    }\n    let mut max = 0;\n    let mut word = String::new();\n \
    \   for (_, count) in counter.iter() {\n        if *count > max {\n          \
    \  max = *count;\n            word = *count.to_string();\n        }\n    }\n \
    \   return word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmptkj4s8ap.rs:13:23\n   |\n13 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counts\
    \ = vec![0; CHARS.len()];\n    let mut unique_chars = char_counts.clone();\n \
    \   let mut current_chars: HashSet<Char> = HashSet::new();\n    for word in words\
    \ {\n        let mut cur_chars = HashSet::new();\n        for c in word.chars()\
    \ {\n            if !cur_chars.contains(&c) {\n                cur_chars.insert(c);\n\
    \                unique_chars[c] += 1;\n                char_count.get_mut(&c).unwrap().0\
    \ += 1;\n            }\n        }\n        current_chars = cur_chars;\n    }\n\
    \    char_counts.sort_unstable_by(|a, b| a.0 < b.0);\n    char_counts\n      \
    \  .iter()\n        .enumerate()\n        .max_by(|(_, a), (_, b)| a < b)\n  \
    \      .1\n        .clone()\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `CHARS` in this scope\n  --> /tmp/tmp274isbiw.rs:12:35\n\
    \   |\n12 |     let mut char_counts = vec![0; CHARS.len()];\n   |            \
    \                       ^^^^^ not found in this scope\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n  --> /tmp/tmp274isbiw.rs:14:28\n   |\n14\
    \ |     let mut current_chars: HashSet<Char> = HashSet::new();\n   |         \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `Char` in this scope\n  --> /tmp/tmp274isbiw.rs:14:36\n   |\n\
    14 |     let mut current_chars: HashSet<Char> = HashSet::new();\n   |        \
    \                            ^^^^\n   |\nhelp: a builtin type with a similar name\
    \ exists\n   |\n14 |     let mut current_chars: HashSet<char> = HashSet::new();\n\
    \   |                                    ~~~~\nhelp: you might be missing a type\
    \ parameter\n   |\n11 | fn find_max<Char>(words: Vec<String>) -> String {\n  \
    \ |            ++++++\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmp274isbiw.rs:14:44\n   |\n14 |     let mut current_chars:\
    \ HashSet<Char> = HashSet::new();\n   |                                      \
    \      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp274isbiw.rs:16:29\n   |\n16\
    \ |         let mut cur_chars = HashSet::new();\n   |                        \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `char_count` in this scope\n  --> /tmp/tmp274isbiw.rs:21:17\n   |\n21\
    \ |                 char_count.get_mut(&c).unwrap().0 += 1;\n   |            \
    \     ^^^^^^^^^^ help: a local variable with a similar name exists: `char_counts`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `char`\n  --> /tmp/tmp274isbiw.rs:20:17\n\
    \   |\n20 |                 unique_chars"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .cloned()\n        .group_by(|w| w.chars().count())\n        .max()\n\
    \        .unwrap()\n        .into()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpamistyl6.rs:15:10\n   |\n15 |         .group_by(|w|\
    \ w.chars().count())\n   |          ^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_occurrences\
    \ = HashMap::new();\n\n    for word in words {\n        for character in word.chars()\
    \ {\n            char_occurrences.entry(character).or_insert(0) += 1;\n      \
    \  }\n    }\n\n    let mut max_characters = vec![String::new()];\n    let mut\
    \ max_count = 1;\n    let mut max_word = String::new();\n\n    for character in\
    \ char_occurrences.keys() {\n        if char_occurrences[character] > max_count\
    \ {\n            max_characters = character;\n            max_count = 1;\n   \
    \     }\n        else if char_occurrences[character] == max_count {\n        \
    \    max_count += 1;\n        }\n    }\n\n    max_characters.extend_from_slice(&[max_count].iter().cloned());\n\
    \    max_characters.extend_from_slice(&[max_count].iter().cloned());\n\n    let\
    \ mut new_words = Vec::new();\n    new_words.push(words[0]);\n\n    for i in 1..words.len()\
    \ {\n        if words[i].chars().any(|c| c != max_characters[0]) {\n         \
    \   new_words.push(words[i]);\n        }\n    }\n\n    new_words[0]\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpkw4t7fbm.rs:12:32\n   |\n12 |     let mut char_occurrences = HashMap::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpkw4t7fbm.rs:16:60\n\
    \   |\n16 |             char_occurrences.entry(character).or_insert(0) += 1;\n\
    \   |             ---------------------------------------------- ^^\n   |    \
    \         |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkw4t7fbm.rs:34:38\n   |\n34 |     max_characters.extend_from_slice(&[max_count].iter().cloned());\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ slice, found struct `Cloned`\n   |\n   = note: expected reference `&[String]`\n\
    \              found reference `&Cloned<std::slice::Iter<'_, {integer}>>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkw4t7fbm.rs:35:38\n   |\n35 |  \
    \   max_characters.extend_from_slice(&[max_count].iter().cloned());\n   |    \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected slice,\
    \ found struct `Cloned`\n   |\n   = note: expected reference `&[String]`\n   \
    \           found reference `&Cloned<std::slice::Iter<'_, {integer}>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkw4t7fbm.rs:41:42\n   |\n41 |         if words[i].chars().any(|c|\
    \ c != max_characters[0]) {\n   |                                          ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Find the one with\
    \ maximum number of unique characters\n    let mut max_char_count = words[0].chars().count();\n\
    \    let mut max_word = words.iter().skip(1).next();\n    for word in words {\n\
    \        if word.chars().count() > max_char_count {\n            max_char_count\
    \ = word.chars().count();\n            max_word = word;\n        }\n    }\n  \
    \  max_char_count\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7m9gq0qx.rs:18:24\n   |\n\
    14 |     let mut max_word = words.iter().skip(1).next();\n   |               \
    \         --------------------------- expected due to this value\n...\n18 |  \
    \           max_word = word;\n   |                        ^^^^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<&String>`\n  \
    \          found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7m9gq0qx.rs:21:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n21\
    \ |     max_char_count\n   |     ^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_num_unique_chars\
    \ = String::new();\n    let mut first_char = true;\n    for word in words {\n\
    \        chars(&word).num_unique_chars()\n            .max(|a, b| a.cmp(&b))\n\
    \            .if_in(|&n| {\n                *max_num_unique_chars = *max_num_unique_chars.checked_add(*n).unwrap();\n\
    \                first_char = false;\n            })\n            .unwrap();\n\
    \    }\n    match &*max_num_unique_chars {\n        0 => String::new(),\n    \
    \    n => words[words.index(&max_num_unique_chars.to_string()).unwrap()],\n  \
    \  }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `chars` in this scope\n  --> /tmp/tmpc4p54757.rs:15:9\n\
    \   |\n15 |         chars(&word).num_unique_chars()\n   |         ^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `checked_add` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpc4p54757.rs:18:63\n   |\n18 | \
    \                *max_num_unique_chars = *max_num_unique_chars.checked_add(*n).unwrap();\n\
    \   |                                                               ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpc4p54757.rs:18:17\n   |\n\
    18 |                 *max_num_unique_chars = *max_num_unique_chars.checked_add(*n).unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc4p54757.rs:24:9\n   |\n23 |     match &*max_num_unique_chars\
    \ {\n   |           ---------------------- this expression has type `&str`\n24\
    \ |         0 => String::new(),\n   |         ^ expected `str`, found integer\n\
    \nerror[E0599]: no method named `index` found for struct `Vec<String>` in the\
    \ current scope\n  --> /tmp/tmpc4p54757.rs:25:26\n   |\n25 |         n => words[words.index(&max_num_unique_chars.to_string()).unwrap()],\n\
    \   |                          ^^^^^ method not found in `Vec<String>`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = std::collections::HashSet::new();\n    let mut max_word = String::new();\n\
    \    for word in words {\n        let mut count = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            count.insert(c);\n        }\n  \
    \      if count.len() > max_count.len() {\n            max_count = count;\n  \
    \          max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpg8p1jkos.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = Vec::with_capacity(words.len());\n    words.iter().for_each(|word| unique_chars.extend(word.chars()));\n\
    \    let unique_char_count = unique_chars.count();\n    if unique_char_count ==\
    \ 0 {\n        String::from(\".\")\n    } else {\n        let mut max_char_count\
    \ = unique_char_count;\n        let mut best_word = String::from(\".\");\n   \
    \     for word in words {\n            if unique_char_count > max_char_count {\n\
    \                max_char_count = unique_char_count;\n                best_word\
    \ = word;\n            }\n            for char in word.chars() {\n           \
    \     if !unique_chars.contains(&char) {\n                    unique_chars.push(char);\n\
    \                    unique_char_count = unique_chars.count();\n             \
    \   }\n            }\n        }\n        best_word\n    }\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmps1y7u7zn.rs:14:42\n   |\n14 |     let unique_char_count\
    \ = unique_chars.count();\n   |                                          ^^^^^\n\
    \   |                                          |\n   |                       \
    \                   method cannot be called on `Vec<char>` due to unsatisfied\
    \ trait bounds\n   |                                          help: consider using\
    \ `len` instead\n   |\n   = note: `count` is defined on `Iterator`, which `Vec<char>`\
    \ does not implement\n\nerror[E0599]: no method named `count` found for struct\
    \ `Vec<char>` in the current scope\n  --> /tmp/tmps1y7u7zn.rs:28:54\n   |\n28\
    \ |                     unique_char_count = unique_chars.count();\n   |      \
    \                                                ^^^^^\n   |                 \
    \                                     |\n   |                                \
    \                      method cannot be called on `Vec<char>` due to unsatisfied\
    \ trait bounds\n   |                                                      help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ words.map(|word| word.chars().count()).collect::<Vec<usize>>();\n    counts.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n\n    if counts.iter().any(|x| x > 1) {\n        words[counts.iter().position(|x|\
    \ x > 1).unwrap_or(0)]\n    } else {\n        words.iter().next().unwrap()\n \
    \   }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmpk95vnykx.rs:12:28\n\
    \    |\n12  |       let mut counts = words.map(|word| word.chars().count()).collect::<Vec<usize>>();\n\
    \    |                              ^^^ `Vec<String>` is not an iterator\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `Vec<String>:\
    \ Iterator`\n            which is required by `&mut Vec<String>: Iterator`\n \
    \           `[String]: Iterator`\n            which is required by `&mut [String]:\
    \ Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk95vnykx.rs:18:9\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n18\
    \ |         words.iter().next().unwrap()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&String`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars:\
    \ usize = 0;\n    let mut words_with_max_unique_chars = words;\n    for w in words_with_max_unique_chars.iter()\
    \ {\n        for c in w.chars() {\n            unique_chars += 1;\n        }\n\
    \        if unique_chars > words_with_max_unique_chars.len() {\n            words_with_max_unique_chars\
    \ = words_with_max_unique_chars.clone();\n        }\n    }\n    words_with_max_unique_chars.iter().next().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmparcqs59m.rs:22:5\n   |\n\
    11 | fn find_max(words: Vec<String>) -> String {\n   |                       \
    \             ------ expected `String` because of return type\n...\n22 |     words_with_max_unique_chars.iter().next().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n   |     expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n    for word in words.iter() {\n        counter.insert(word.length(),\
    \ 1);\n    }\n    counter // collect counts for each word\n        .iter()\n \
    \       .max_by(|a, b| b.1.cmp(&a.1))\n        .unwrap()\n        .0\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp44ukyi7t.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `length` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmp44ukyi7t.rs:14:29\n   |\n14 |         counter.insert(word.length(),\
    \ 1);\n   |                             ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut counts = words[0].chars().unique().count();\n\
    \    for word in &words {\n        let counts = word.chars().unique().count();\n\
    \        if counts > counts.clone() {\n            return word;\n        }\n \
    \   }\n    return String::new();\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpcd2l_wdv.rs:15:39\n   |\n15 |     let mut counts\
    \ = words[0].chars().unique().count();\n   |                                 \
    \      ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `unique` found for struct `Chars` in the current scope\n  --> /tmp/tmpcd2l_wdv.rs:17:35\n\
    \   |\n17 |         let counts = word.chars().unique().count();\n   |        \
    \                           ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcd2l_wdv.rs:19:20\n   |\n19 |             return\
    \ word;\n   |                    ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut min_count\
    \ = std::i32::MAX;\n    let mut min_word = String::new();\n    for (i, word) in\
    \ words.iter().enumerate() {\n        let mut char_count = std::i32::MAX;\n  \
    \      for (c, _) in word.chars().iter() {\n            char_count += 1;\n   \
    \     }\n        if char_count < min_count {\n            min_count = char_count;\n\
    \            min_word = word;\n        }\n    }\n    min_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp9iy1whuf.rs:16:36\n   |\n16 |         for (c, _) in word.chars().iter()\
    \ {\n   |                                    ^^^^ private field, not a method\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9iy1whuf.rs:21:24\n   |\n13 |\
    \     let mut min_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n21 |             min_word = word;\n   |   \
    \                     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars_count:\
    \ usize = 0;\n    let mut max_chars: String = String::new();\n\n    for word in\
    \ words {\n        for c in word.chars() {\n            if chars_count < c.chars().len()\
    \ {\n                chars_count = c.chars().len();\n                max_chars\
    \ = word;\n            }\n        }\n    }\n\n    max_chars\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprd0_t0we.rs:17:32\n   |\n17 |             if chars_count\
    \ < c.chars().len() {\n   |                                ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmprd0_t0we.rs:18:33\n   |\n18 |             \
    \    chars_count = c.chars().len();\n   |                                 ^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words[0].chars().count().great_max().unwrap_or(words[0].chars().count())\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `great_max` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp8qd0ypf3.rs:12:30\n   |\n12 |     words[0].chars().count().great_max().unwrap_or(words[0].chars().count())\n\
    \   |                              ^^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ Counter::new();\n    for word in words {\n        let mut counter = counter.clone();\n\
    \        for c in word.chars() {\n            *counter += 1;\n        }\n    \
    \    if *counter > word.get_unique_count() {\n            return word;\n     \
    \   }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Counter`\n  -->\
    \ /tmp/tmptpl9js02.rs:12:23\n   |\n12 |     let mut counter = Counter::new();\n\
    \   |                       ^^^^^^^ use of undeclared type `Counter`\n\nerror[E0599]:\
    \ no method named `get_unique_count` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmptpl9js02.rs:18:28\n   |\n18 |         if *counter > word.get_unique_count()\
    \ {\n   |                            ^^^^^^^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counter\
    \ = HashMap::new();\n    let mut unique_counter = HashSet::new();\n\n    for w\
    \ in words {\n        for c in w.chars() {\n            if char_counter.contains_key(&c)\
    \ {\n                char_counter.entry(c).or_insert(0)\n                    .cloned()\
    \ += 1;\n            } else {\n                char_counter.insert(c, 1);\n  \
    \          }\n        }\n\n        for c in w.chars() {\n            if unique_counter.contains(&c)\
    \ {\n                continue;\n            }\n\n            if char_counter[c]\
    \ > unique_counter.len() {\n                unique_counter.insert(c);\n      \
    \      }\n        }\n    }\n\n    if unique_counter.len() > char_counter.len()\
    \ {\n        words[unique_counter.iter().find().unwrap()]\n    } else {\n    \
    \    String::from(\"???\")\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2rgneaus.rs:12:28\n   |\n12 |     let mut char_counter = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp2rgneaus.rs:13:30\n   |\n13 |     let mut unique_counter = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2rgneaus.rs:19:31\n\
    \   |\n18 | /                 char_counter.entry(c).or_insert(0)\n19 | |     \
    \                .cloned() += 1;\n   | |                             - ^^\n  \
    \ | |_____________________________|\n   |                               cannot\
    \ assign to this expression\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0067, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Use set to count\
    \ the number of unique characters in words\n    let mut char_counts = HashMap::<String,\
    \ usize>::new();\n    for word in words {\n        for char in word.chars() {\n\
    \            char_counts.entry(char).or_default() += 1;\n        }\n    }\n  \
    \  // Get the maximum char count and return the word with maximum number\n   \
    \ // of unique characters. If multiple strings have maximum number of unique\n\
    \    // characters, return the one which comes first in lexicographical order.\n\
    \    char_counts.iter().max_by_key(|(_, count)| *count).unwrap().0\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpndxxdjjk.rs:13:27\n   |\n13 |     let mut char_counts = HashMap::<String,\
    \ usize>::new();\n   |                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpndxxdjjk.rs:16:50\n\
    \   |\n16 |             char_counts.entry(char).or_default() += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_chars\
    \ = words[0].chars().count();\n    let mut max_strings = Vec::new();\n\n    for\
    \ (i, word) in words.iter().enumerate() {\n        let current_chars = word.chars().count();\n\
    \        if current_chars > max_chars {\n            max_chars = current_chars;\n\
    \            max_strings = i;\n        }\n    }\n\n    words[max_strings]\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph33syj8h.rs:19:27\n   |\n\
    13 |     let mut max_strings = Vec::new();\n   |                           ----------\
    \ expected due to this value\n...\n19 |             max_strings = i;\n   |   \
    \                        ^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<_>`\n                found type `usize`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `Vec<_>`\n  --> /tmp/tmph33syj8h.rs:23:5\n\
    \   |\n23 |     words[max_strings]\n   |     ^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `Vec<_>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Vec<_>>` for `Vec<String>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        for char in word.chars()\
    \ {\n            counters.entry(char).or_insert(0) += 1;\n        }\n    }\n \
    \   \n    let mut max = String::new();\n    let mut max_counter = counters.iter().cloned().max_by_key(|x|\
    \ x.1).unwrap();\n    \n    for char in chars! {\n        if counters[char] >\
    \ max_counter {\n            max = char.to_string();\n            max_counter\
    \ = counters[char];\n        }\n    }\n    \n    max\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `max`\n  --> /tmp/tmphoyln3jr.rs:29:5\n   |\n\
    29 |     max\n   |     ^^^ expected `{`\n   |\nhelp: try placing this code inside\
    \ a block\n   |\n29 |     { max }\n   |     +     +\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `HashMap`\n  --> /tmp/tmphoyln3jr.rs:12:24\n\
    \   |\n12 |     let mut counters = HashMap::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmphoyln3jr.rs:15:47\n   |\n15 |            \
    \ counters.entry(char).or_insert(0) += 1;\n   |             ---------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0433.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    use std::cmp::Ordering;\n\
    \    let mut counters = Vec::new();\n    for word in words {\n        counters.push(0);\n\
    \        for c in word.chars() {\n            counters[*c] += 1;\n        }\n\
    \    }\n    \n    let mut max_counter = counters.iter().max().unwrap();\n    let\
    \ mut max_word = String::new();\n    for c in counters {\n        if *c >= *max_counter\
    \ {\n            max_counter = *c;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmpqytsmno4.rs:26:24\n\
    \   |\n26 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nwarning: unused import:\
    \ `std::cmp::Ordering`\n  --> /tmp/tmpqytsmno4.rs:12:9\n   |\n12 |     use std::cmp::Ordering;\n\
    \   |         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpqytsmno4.rs:17:22\n\
    \   |\n17 |             counters[*c] += 1;\n   |                      ^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpqytsmno4.rs:24:12\n \
    \  |\n24 |         if *c >= *max_counter {\n   |            ^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpqytsmno4.rs:25:27\n \
    \  |\n25 |             max_counter = *c;\n   |                           ^^\n\n\
    error: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0425, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words[..].iter().cloned().group_by_ref().max_by(|a,\
    \ b| a.chars().filter(|c| c.is_alphanumeric()).count() as u32).unwrap_or(\"\"\
    )\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by_ref` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpift2yz6o.rs:12:31\n   |\n12 |     words[..].iter().cloned().group_by_ref().max_by(|a,\
    \ b| a.chars().filter(|c| c.is_alphanumeric()).count() as u32).unwrap_or(\"\"\
    )\n   |                               ^^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ String>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max: usize\
    \ = 0;\n    let mut index = 0;\n\n    while index < words.len() {\n        let\
    \ word: String = words[index];\n        let mut unique_chars = word\n        \
    \    .chars()\n            .filter(|c| !c.is_alphanumeric())\n            .count();\n\
    \n        if unique_chars > max {\n            max = unique_chars;\n         \
    \   index = word.chars().count();\n        }\n\n        index += 1;\n    }\n\n\
    \    words[index]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp0ayuzcb5.rs:17:13\n\
    \   |\n17 |         let mut unique_chars = word\n   |             ----^^^^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0507]: cannot move out of index\
    \ of `Vec<String>`\n  --> /tmp/tmp0ayuzcb5.rs:16:28\n   |\n16 |         let word:\
    \ String = words[index];\n   |                            ^^^^^^^^^^^^\n   | \
    \                           |\n   |                            move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n   |   \
    \                         help: consider borrowing here: `&words[index]`\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmp0ayuzcb5.rs:30:5\n\
    \   |\n30 |     words[index]\n   |     ^^^^^^^^^^^^ move occurs because value\
    \ has type `String`, which does not implement the `Copy` trait\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashSet::new();\n    for word in words {\n        word.chars().for_each(|c|\
    \ *unique_chars.insert(c));\n    }\n    let mut current_max = String::new();\n\
    \    for word in words {\n        let count = unique_chars.len() as u64;\n   \
    \     if count > current_max.len() {\n            current_max = word;\n      \
    \  }\n    }\n    current_max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmphmto9d8g.rs:12:28\n   |\n12 |     let mut unique_chars = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word_count\
    \ = HashMap::new();\n    for word in words {\n        let mut count = 0;\n   \
    \     for char in word.chars() {\n            count += word_count.get(&char).unwrap();\n\
    \        }\n        *word_count.entry(char).or_insert(count).clone() += 1;\n \
    \   }\n    let mut max = String::from(\"~\");\n    let mut i = 1;\n    while word_count.contains_key(&mut\
    \ i) {\n        *max = *max..i;\n        i += 1;\n    }\n    max\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwf9t_0nk.rs:12:26\n   |\n12 |     let mut word_count = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0423]:\
    \ expected value, found builtin type `char`\n  --> /tmp/tmpwf9t_0nk.rs:18:27\n\
    \   |\n18 |         *word_count.entry(char).or_insert(count).clone() += 1;\n \
    \  |                           ^^^^ not a value\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmpwf9t_0nk.rs:23:16\n\
    \   |\n23 |         *max = *max..i;\n   |                ^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `std::ops::Range`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwf9t_0nk.rs:23:22\n   |\n23 |         *max = *max..i;\n\
    \   |                      ^ expected `str`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwf9t_0nk.rs:23:16\n   |\n23 |         *max = *max..i;\n\
    \   |         ----   ^^^^^^^ expected `str`, found struct `std::ops::Range`\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    \   = note: expected type `str`\n            found struct `std::ops::Range<str>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpwf9t_0nk.rs:23:9\n   |\n23 |         *max = *max..i;\n \
    \  |         ^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0423,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut seen = HashMap::<i32,\
    \ i32>::new();\n    let mut max_key = std::cmp::Ordering::Equal;\n    for word\
    \ in words {\n        for c in word.chars() {\n            let count = seen.entry(c).or_insert(0);\n\
    \            seen.entry(c).value = count + 1;\n            if count > max_key\
    \ {\n                max_key = count;\n            }\n        }\n    }\n    if\
    \ max_key != std::cmp::Ordering::Equal {\n        words.iter().find_key(|w| w.chars().all(|c|\
    \ !seen.contains_key(c)));\n    } else {\n        String::new()\n    }\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpoemfrc2a.rs:12:20\n   |\n12 |     let mut seen = HashMap::<i32, i32>::new();\n\
    \   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ cannot add `{integer}` to `std::cmp::Ordering`\n  --> /tmp/tmpoemfrc2a.rs:17:41\n\
    \   |\n17 |             seen.entry(c).value = count + 1;\n   |               \
    \                          ^ no implementation for `std::cmp::Ordering + {integer}`\n\
    \   |\n   = help: the trait `Add<{integer}>` is not implemented for `std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `find_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpoemfrc2a.rs:24:22\n   |\n24 |         words.iter().find_key(|w|\
    \ w.chars().all(|c| !seen.contains_key(c)));\n   |                      ^^^^^^^^\
    \ method not found in `std::slice::Iter<'_, String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoemfrc2a.rs:23:45\n   |\n23 |       if max_key != std::cmp::Ordering::Equal\
    \ {\n   |  _____________________________________________^\n24 | |         words.iter().find_key(|w|\
    \ w.chars().all(|c| !seen.contains_key(c)));\n25 | |     } else {\n   | |_____^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0433, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = HashSet::new();\n    for word in words {\n        for c in word.chars() {\n\
    \            unique_chars.insert(c.to_owned());\n        }\n    }\n    let mut\
    \ largest = String::new();\n    for w in words.iter() {\n        if unique_chars.len()\
    \ > largest.chars().count() {\n            largest = w;\n        }\n    }\n  \
    \  largest\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpo9gpeog6.rs:12:28\n   |\n12 |     let mut unique_chars = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo9gpeog6.rs:21:23\n   |\n\
    18 |     let mut largest = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n21 |             largest = w;\n   |       \
    \                ^- help: try using a conversion method: `.to_string()`\n   |\
    \                       |\n   |                       expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars_count:\
    \ u32 = 0;\n    let mut max_word: String = \"\";\n    for word in words {\n  \
    \      let count = word.chars().count();\n        chars_count += count;\n    \
    \    if chars_count > chars_count.max() {\n            max_word = word;\n    \
    \    }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzlswyudq.rs:13:32\n   |\n\
    13 |     let mut max_word: String = \"\";\n   |                       ------ \
    \  ^^- help: try using a conversion method: `.to_string()`\n   |             \
    \          |        |\n   |                       |        expected struct `String`,\
    \ found `&str`\n   |                       expected due to this\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzlswyudq.rs:16:24\n   |\n16 |         chars_count\
    \ += count;\n   |                        ^^^^^ expected `u32`, found `usize`\n\
    \nerror[E0277]: cannot add-assign `usize` to `u32`\n  --> /tmp/tmpzlswyudq.rs:16:21\n\
    \   |\n16 |         chars_count += count;\n   |                     ^^ no implementation\
    \ for `u32 += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `u32`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0061]: this function takes 1 argument but 0 arguments were\
    \ supplied\n   --> /tmp/tmpzlswyudq.rs:17:38\n    |\n17  |         if chars_count\
    \ > chars_count.max() {\n    |                                      ^^^- supplied\
    \ 0 arguments\n    |                                      |\n    |           \
    \                           expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().copied().filter(|word|\
    \ {\n        word.nth(0).chars().fold(true, |_, c| !c).unwrap_or(false)\n    }).max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Copy` is not satisfied\n    -->\
    \ /tmp/tmp8e9_pe82.rs:12:18\n     |\n12   |     words.iter().copied().filter(|word|\
    \ {\n     |                  ^^^^^^ the trait `Copy` is not implemented for `String`\n\
    \     |\nnote: required by a bound in `copied`\n\nerror[E0599]: the method `filter`\
    \ exists for struct `Copied<std::slice::Iter<'_, String>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp8e9_pe82.rs:12:27\n   |\n12 |       words.iter().copied().filter(|word|\
    \ {\n   |                             ^^^^^^ method cannot be called on `Copied<std::slice::Iter<'_,\
    \ String>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Copied<std::slice::Iter<'_, String>>:\
    \ Iterator`\n           which is required by `&mut Copied<std::slice::Iter<'_,\
    \ String>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        panic!(\"Cannot find max: vector is empty\");\n    }\n    let mut\
    \ max = String::new();\n    let mut max_num = std::cmp::Ordering::Greater;\n \
    \   for w in words {\n        if w.chars().filter(|c| c != ' ').count() > max_num\
    \ {\n            max_num = w.chars().filter(|c| c != ' ').count();\n         \
    \   max = w;\n        }\n    }\n    max.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5wlkxpv9.rs:18:35\n\
    \   |\n18 |         if w.chars().filter(|c| c != ' ').count() > max_num {\n  \
    \ |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5wlkxpv9.rs:18:53\n   |\n18 |         if w.chars().filter(|c|\
    \ c != ' ').count() > max_num {\n   |                                        \
    \             ^^^^^^^ expected `usize`, found enum `std::cmp::Ordering`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp5wlkxpv9.rs:19:46\n   |\n19\
    \ |             max_num = w.chars().filter(|c| c != ' ').count();\n   |      \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5wlkxpv9.rs:19:23\n   |\n16 |     let mut max_num = std::cmp::Ordering::Greater;\n\
    \   |                       --------------------------- expected due to this value\n\
    ...\n19 |             max_num = w.chars().filter(|c| c != ' ').count();\n   |\
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().cloned().filter(|word|\
    \ word.chars().unique().count() > 1).max().unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpvfwg7y19.rs:12:54\n   |\n12 |     words.iter().cloned().filter(|word|\
    \ word.chars().unique().count() > 1).max().unwrap()\n   |                    \
    \                                  ^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    match words {\n \
    \       vec![] => String::new(),\n        vec![word] => word,\n        vec![word1,\
    \ word2] => {\n            let mut s = String::new();\n            let mut cnt\
    \ = HashMap::new();\n            for w in words.iter() {\n                let\
    \ len = w.chars().filter(|c| !c == '#').count();\n                s.push_str(w);\n\
    \                cnt.insert(w, len);\n            }\n\n            if cnt.values().iter().max().is_some()\
    \ {\n                if cnt.values().iter().any(|v| v == cnt.values().iter().max().unwrap())\
    \ {\n                    s\n                } else {\n                    cnt.iter().find(|(k,\
    \ v)| v == cnt.values().iter().max().unwrap()).unwrap()\n                }\n \
    \           } else {\n                String::new()\n            }\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmp82gb1y_c.rs:14:14\n\
    \   |\n14 |         vec![word] => word,\n   |              ^^^^ help: a local\
    \ variable with a similar name exists: `words`\n\nerror[E0425]: cannot find value\
    \ `word` in this scope\n  --> /tmp/tmp82gb1y_c.rs:14:23\n   |\n14 |         vec![word]\
    \ => word,\n   |                       ^^^^ help: a local variable with a similar\
    \ name exists: `words`\n\nerror[E0425]: cannot find value `word1` in this scope\n\
    \  --> /tmp/tmp82gb1y_c.rs:15:14\n   |\n15 |         vec![word1, word2] => {\n\
    \   |              ^^^^^ help: a local variable with a similar name exists: `words`\n\
    \nerror[E0425]: cannot find value `word2` in this scope\n  --> /tmp/tmp82gb1y_c.rs:15:21\n\
    \   |\n15 |         vec![word1, word2] => {\n   |                     ^^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp82gb1y_c.rs:17:27\n\
    \   |\n17 |             let mut cnt = HashMap::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: arbitrary\
    \ expressions aren't allowed in patterns\n  --> /tmp/tmp82gb1y_c.rs:13:9\n   |\n\
    13 |         vec![] => String::new(),\n   |         ^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmp82gb1y_c.rs:14:9\n   |\n14 |         vec![word] => word,\n   |\
    \         ^^^^^^^^^^\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: arbitrary\
    \ expressions aren't allowed in patterns\n  --> /tmp/tmp82gb1y_c.rs:15:9\n   |\n\
    15 |         vec![word1, word2] => {\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0600]: cannot apply unary operator\
    \ `!` to type `&char`\n  --> /tm"
  stdout: ''
  timestamp: 1659976175
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut res = String::from(\"zzz\");\n\n    for word in words {\n       \
    \ let len = word.chars().count();\n        if len > max {\n            max = len;\n\
    \            res = word;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp9dl00m08.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut char_counters\
    \ = HashMap::<String, usize>::new();\n    words.iter().for_each(|word| {\n   \
    \     for char in word.chars() {\n            if let Some(count) = char_counters.get(&char)\
    \ {\n                char_counters.insert(char, count + 1);\n            } else\
    \ {\n                char_counters.insert(char, 1);\n            }\n        }\n\
    \    });\n\n    let mut max_counter = 0;\n    let mut max_word: String = String::from(\"\
    a\");\n    for (char, count) in char_counters {\n        if count > max_counter\
    \ {\n            max_counter = count;\n            max_word = char;\n        }\n\
    \    }\n\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmph1qggo0f.rs:12:29\n   |\n12 |     let mut char_counters = HashMap::<String,\
    \ usize>::new();\n   |                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .into_iter()\n\
    \        .filter_map(|w| w.chars().group_by(|c| *c).rfold(0, |acc, &(_, count)|\
    \ {\n            if acc > count {\n                (acc, count)\n            }\
    \ else {\n                (count, acc)\n            }\n        }))\n        .max_by(|(w,\
    \ _)| w.len())\n        .unwrap()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp22o_wvsi.rs:14:35\n   |\n14 |         .filter_map(|w|\
    \ w.chars().group_by(|c| *c).rfold(0, |acc, &(_, count)| {\n   |             \
    \                      ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0593]:\
    \ closure is expected to take 2 distinct arguments, but it takes a single 2-tuple\
    \ as argument\n  --> /tmp/tmp22o_wvsi.rs:21:10\n   |\n21 |         .max_by(|(w,\
    \ _)| w.len())\n   |          ^^^^^^ -------- takes a single 2-tuple as argument\n\
    \   |          |\n   |          expected closure that takes 2 distinct arguments\n\
    \   |\nhelp: change the closure to take multiple arguments instead of a single\
    \ tuple\n   |\n21 |         .max_by(|w, _| w.len())\n   |                 ~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0593, E0599.\nFor more information about an error, try `rustc --explain E0593`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words\n        .iter()\n\
    \        .cloned()\n        .flat_map(|w| w.chars().map(|c| (c, 1)).collect::<Vec<_>>())\n\
    \        .max_by(|a, b| b.1.cmp(&a.1))\n        .map(|(_, v)| words.iter().find(|w|\
    \ w.chars().any(|c| c.eq(v))))\n        .map(|v| v.unwrap())\n        .unwrap_or_else(||\
    \ String::new())\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq8xiz8av.rs:17:68\n   |\n\
    17 |         .map(|(_, v)| words.iter().find(|w| w.chars().any(|c| c.eq(v))))\n\
    \   |                                                                    ^ expected\
    \ `&char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq8xiz8av.rs:19:28\n\
    \   |\n19 |         .unwrap_or_else(|| String::new())\n   |                  \
    \          ^^^^^^^^^^^^^\n   |                            |\n   |            \
    \                expected `&String`, found struct `String`\n   |             \
    \               help: consider borrowing here: `&String::new()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq8xiz8av.rs:12:5\n   |\n11 |   fn find_max(words:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n12 | /     words\n13 | |         .iter()\n\
    14 | |         .cloned()\n15 | |         .flat_map(|w| w.chars().map(|c| (c, 1)).collect::<Vec<_>>())\n\
    ...  |\n18 | |         .map(|v| v.unwrap())\n19 | |         .unwrap_or_else(||\
    \ String::new())\n   | |                                         ^- help: try\
    \ using a conversion method: `.to_string()`\n   | |_________________________________________|\n\
    \   |                                           expected struct `String`, found\
    \ `&String`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut best_word\
    \ = String::from(\"0\");\n    let mut best_counter = 1;\n    let mut max_counter\
    \ = 1;\n    for word in words {\n        match best_counter {\n            1 =>\
    \ {\n                if word.chars().count() > best_counter.chars().count() {\n\
    \                    best_counter = word.chars().count();\n                  \
    \  best_word = word;\n                }\n            },\n            2 => if word.chars().count()\
    \ > best_counter.chars().count() {\n                best_counter = word.chars().count();\n\
    \                best_word = word;\n            },\n            _ => {}\n    \
    \    }\n    }\n    best_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmprgg5p927.rs:18:56\n   |\n18 |                 if\
    \ word.chars().count() > best_counter.chars().count() {\n   |                \
    \                                        ^^^^^ method not found in `{integer}`\n\
    \nerror[E0599]: no method named `chars` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmprgg5p927.rs:23:57\n   |\n23 |             2 => if word.chars().count()\
    \ > best_counter.chars().count() {\n   |                                     \
    \                    ^^^^^ method not found in `usize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_counts\
    \ = Vec::new();\n    for word in words {\n        unique_counts.push(word.chars().unique_count());\n\
    \    }\n    unique_counts.iter().max_by_key(|count| count).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique_count` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpbfqxjrb6.rs:14:41\n   |\n14 |         unique_counts.push(word.chars().unique_count());\n\
    \   |                                         ^^^^^^^^^^^^ method not found in\
    \ `Chars<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbfqxjrb6.rs:16:5\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n16\
    \ |     unique_counts.iter().max_by_key(|count| count).unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter()\n  \
    \      .map(|word| {\n            word.chars()\n                .distinct()\n\
    \                .count();\n        })\n        .max()\n        .unwrap_or(1)\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `distinct` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpcefy6zyz.rs:15:18\n   |\n15 |                 .distinct()\n\
    \   |                  ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcefy6zyz.rs:19:20\n   |\n19 |         .unwrap_or(1)\n\
    \   |                    ^ expected `()`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcefy6zyz.rs:12:5\n   |\n11 |   fn find_max(words: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n12 | /     words.iter()\n13 | |         .map(|word|\
    \ {\n14 | |             word.chars()\n15 | |                 .distinct()\n...\
    \  |\n18 | |         .max()\n19 | |         .unwrap_or(1)\n   | |_____________________^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words_per_character\
    \ = HashMap::new();\n    for word in words.iter() {\n        words_per_character.entry(word).or_insert(0);\n\
    \        words_per_character\n            .entry(&word[0...])\n            .or_insert(0)\n\
    \            .value += 1;\n    }\n    let mut best_word = String::new();\n   \
    \ let mut best_score = -1;\n    for (char, score) in words_per_character.iter_mut().rposition(|(_,\
    \ count)| count > best_score) {\n        if best_score < 0 || score > best_score\
    \ {\n            best_score = score;\n            best_word = char;\n        }\n\
    \    }\n    best_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmpbn54abgz.rs:16:27\n   |\n\
    16 |             .entry(&word[0...])\n   |                           ^^^\n   |\n\
    help: use `..` for an exclusive range\n   |\n16 |             .entry(&word[0..])\n\
    \   |                           ~~\nhelp: or `..=` for an inclusive range\n  \
    \ |\n16 |             .entry(&word[0..=])\n   |                           ~~~\n\
    \nerror[E0586]: inclusive range with no end\n  --> /tmp/tmpbn54abgz.rs:16:27\n\
    \   |\n16 |             .entry(&word[0...])\n   |                           ^^^\
    \ help: use `..` instead\n   |\n   = note: inclusive ranges must be bounded at\
    \ the end (`..=b` or `a..=b`)\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n  --> /tmp/tmpbn54abgz.rs:12:35\n   |\n12 |     let mut words_per_character\
    \ = HashMap::new();\n   |                                   ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0586.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976174
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut map = HashMap::new();\n\n    words.sort_unstable_by_key(|word|\
    \ word.chars().distinct().count());\n\n    for word in words {\n        let mut\
    \ count = 0;\n        for ch in word.chars().distinct().collect::<Vec<_>>() {\n\
    \            if !map.contains_key(&ch) {\n                map.insert(ch, 1);\n\
    \                count += 1;\n            }\n        }\n        if count > result.len()\
    \ {\n            result = word;\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp2elch7u9.rs:13:19\n   |\n13 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `distinct` found for struct `Chars` in the current scope\n \
    \ --> /tmp/tmp2elch7u9.rs:15:52\n   |\n15 |     words.sort_unstable_by_key(|word|\
    \ word.chars().distinct().count());\n   |                                    \
    \                ^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `distinct` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmp2elch7u9.rs:19:32\n   |\n19 |         for ch in word.chars().distinct().collect::<Vec<_>>()\
    \ {\n   |                                ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_chars\
    \ = String::new();\n    for word in words {\n        unique_chars.clear();\n \
    \       for c in word.chars() {\n            if !unique_chars.contains(&c) {\n\
    \                unique_chars.push_str(&c.to_string());\n            }\n     \
    \   }\n        if unique_chars.len() > unique_chars.iter().rev().next().unwrap().len()\
    \ {\n            return word;\n        }\n    }\n    words[0]\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmptugwm6zm.rs:16:39\n\
    \     |\n16   |             if !unique_chars.contains(&c) {\n     |          \
    \                    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                              |\n     |                              required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contains`\nhelp: consider dereferencing\
    \ here\n     |\n16   |             if !unique_chars.contains(*&c) {\n     |  \
    \                                     +\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmptugwm6zm.rs:20:46\n\
    \   |\n20 |         if unique_chars.len() > unique_chars.iter().rev().next().unwrap().len()\
    \ {\n   |                                              ^^^^ method not found in\
    \ `String`\n   |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n20\
    \ |         if unique_chars.len() > unique_chars.chars().rev().next().unwrap().len()\
    \ {\n   |                                              ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 1;\n    let mut max_word = String::new();\n\n    for w in words.iter() {\n\
    \        let c: usize = w.chars().count();\n        if max_count < c {\n     \
    \       max_count = c;\n            max_word = w;\n        }\n    }\n\n    if\
    \ max_count == 1 {\n        return max_word;\n    }\n\n    find_max(vec![max_word])\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppxnxwk12.rs:19:24\n   |\n\
    13 |     let mut max_word = String::new();\n   |                        -------------\
    \ expected due to this value\n...\n19 |             max_word = w;\n   |      \
    \                  ^- help: try using a conversion method: `.to_string()`\n  \
    \ |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n\n    // Step 1: calculate the number\
    \ of unique characters in each string\n    let mut unique_chars: Vec<usize> =\
    \ words.iter().map(|w| w.chars().count()).collect();\n\n    // Step 2: return\
    \ the word that comes first in lexicographical order\n    unique_chars.sort_unstable().nth(1).cloned()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `nth` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpjg1s3zyz.rs:20:34\n   |\n20 |     unique_chars.sort_unstable().nth(1).cloned()\n\
    \   |                                  ^^^ method not found in `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars_count\
    \ = words.iter().map(|w| w.chars().count()).collect::<Vec<usize>>();\n    chars_count.sort_unstable_by_key(|i|\
    \ i);\n    words[chars_count.iter().find(|&c| c == chars_count.iter().count()).unwrap()]\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmpd6hmarzw.rs:14:42\n\
    \   |\n14 |     words[chars_count.iter().find(|&c| c == chars_count.iter().count()).unwrap()]\n\
    \   |                                          ^^ no implementation for `&usize\
    \ == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: the type `[String]` cannot be indexed by `&usize`\n\
    \  --> /tmp/tmpd6hmarzw.rs:14:5\n   |\n14 |     words[chars_count.iter().find(|&c|\
    \ c == chars_count.iter().count()).unwrap()]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `&usize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<&usize>` for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_count:\
    \ usize = 0;\n    let mut unique_words: Vec<String> = vec![];\n    for (word,\
    \ count) in words {\n        if count > unique_count {\n            unique_count\
    \ = count;\n            unique_words = vec![word];\n        } else {\n       \
    \     unique_words.push(word);\n        }\n    }\n    if unique_words.len() ==\
    \ 1 {\n        unique_words.sort_by(|a, b| a.len() < b.len());\n        return\
    \ unique_words.first();\n    }\n    let mut max_count: usize = 0;\n    let mut\
    \ max_word: String = String::from(\"\");\n    for (word, count) in unique_words.iter().cloned()\
    \ {\n        if count > max_count {\n            max_count = count;\n        \
    \    max_word = word;\n        }\n    }\n    max_word.push_str(\" of \");\n  \
    \  max_word.push_str(unique_words);\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswx2sp3u.rs:14:9\n   |\n\
    14 |     for (word, count) in words {\n   |         ^^^^^^^^^^^^^    ----- this\
    \ expression has type `Option<String>`\n   |         |\n   |         expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `String`\n  \
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpswx2sp3u.rs:23:37\n\
    \   |\n23 |         unique_words.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpswx2sp3u.rs:24:16\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n24\
    \ |         return unique_words.first();\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<&String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpswx2sp3u.rs:28:9\n   |\n28 |     for (word, count) in unique_words.iter().cloned()\
    \ {\n   |         ^^^^^^^^^^^^^    ---------------------------- this expression\
    \ has type `Option<String>`\n   |         |\n   |         expected struct `String`,\
    \ found tuple\n   |\n   = note: expected struct `String`\n               found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpswx2sp3u.rs:35:23\n\
    \   |\n35 |     max_word.push_str(unique_words);\n   |                       ^^^^^^^^^^^^\
    \ expected `&str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \                 found struct `Vec<String>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut map = HashMap::new();\n\
    \    for word in words {\n        if let Some(count) = map.get(&word) {\n    \
    \        if *count >= 2 {\n                return word;\n            }\n     \
    \   } else {\n            *map.insert(word, 1) = Some(1);\n        }\n    }\n\
    \    return match &map[&words[0]] {\n        None => String::from(\"\"),\n   \
    \     Some(_) => words[0],\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp8vkfa6p2.rs:12:19\n   |\n12 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // Create a set of\
    \ all the unique characters\n    let mut char_set = HashSet::new();\n    for (i,\
    \ word) in words.iter().enumerate() {\n        for (j, char) in word.chars().enumerate()\
    \ {\n            char_set\n                .insert(char)\n                .expect(\"\
    Inserting into a set that doesn't work\");\n        }\n    }\n    // Get the characters\
    \ with maximum frequency\n    let mut max_chars: Vec<String> = Vec::new();\n \
    \   let mut max_len: usize = 0;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        if char_set.len() >= max_len {\n            max_len = char_set.len();\n\
    \        }\n        max_chars.push(word);\n    }\n    if max_len == 0 {\n    \
    \    String::from(\"No words with maximum number of unique characters found\"\
    )\n    } else {\n        // If multiple strings have maximum number of unique\
    \ characters,\n        // return the one which comes first in lexicographical\
    \ order\n        let mut best_order: Vec<String> = Vec::new();\n        for (i,\
    \ word) in max_chars.iter().enumerate() {\n            let mut order: usize =\
    \ 0;\n            word\n                .chars()\n                .enumerate()\n\
    \                .sort_by(|(a, b), (_, b)| order.cmp(&a));\n            let mut\
    \ cur_word: Vec<String> = Vec::new();\n            for (j, char) in word.chars().enumerate()\
    \ {\n                if j == 0 {\n                    cur_word.push(char);\n \
    \               }\n                if j == 1 {\n                    cur_word.push(String::from(\"\
    _\"));\n                }\n            }\n            for (j, char) in cur_word.iter().enumerate()\
    \ {\n                if char == char_set[order] {\n                    order +=\
    \ 1;\n                }\n            }\n            best_order.push(word.clone());\n\
    \        }\n        String::from(best_order[0])\n    }\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `b` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmp_pqgu099.rs:41:39\n   |\n41 |                 .sort_by(|(a,\
    \ b), (_, b)| order.cmp(&a));\n   |                                       ^ used\
    \ as parameter more than once\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp_pqgu099.rs:13:24\n   |\n13 |     let mut char_set\
    \ = HashSet::new();\n   |                        ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_pqgu099.rs:28:24\n   |\n\
    28 |         max_chars.push(word);\n   |                        ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&String`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `Enumerate` in the current scope\n\
    \  --> /tmp/tmp_pqgu099.rs:41:18\n   |\n41 |                 .sort_by(|(a, b),\
    \ (_, b)| order.cmp(&a));\n   |                  ^^^^^^^ method not found in `Enumerate<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_pqgu099.rs:45:35\n   |\n45 |\
    \                     cur_word.push(char);\n   |                             \
    \      ^^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                            |\n   |                                   expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0415, E0433, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words.clone();\n\
    \    let mut max_cnt = 0;\n\n    while let Some(word) = words.iter().max_by_key(|&word|\
    \ word.chars().count()) {\n        if word.chars().count() > max_cnt {\n     \
    \       max_cnt = word.chars().count();\n        }\n        words = words.remove(word);\n\
    \    }\n    words[0]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp119_n6vc.rs:19:30\n   |\n\
    19 |         words = words.remove(word);\n   |                              ^^^^\
    \ expected `usize`, found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp119_n6vc.rs:19:17\n\
    \   |\n12 |     let mut words = words.clone();\n   |                     -------------\
    \ expected due to this value\n...\n19 |         words = words.remove(word);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counts =\
    \ HashMap::new();\n    for word in words.iter() {\n        let mut num_chars =\
    \ word.chars().count();\n        if counts.contains_key(&num_chars) {\n      \
    \      counts.insert(num_chars, 1);\n        } else {\n            counts.insert(num_chars,\
    \ 0);\n        }\n    }\n\n    counts.iter().max_by_key(|(_, count)| count).unwrap()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxyr7d19f.rs:12:22\n   |\n12 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut m = std::collections::HashSet::new();\n\
    \    let mut max_word = String::new();\n    for word in words {\n        for c\
    \ in word.chars() {\n            if !m.contains_key(&c) {\n                m.insert(c);\n\
    \            } else {\n                if m.get(&c) < m.get(&max_word) {\n   \
    \                 max_word = word;\n                }\n            }\n       \
    \ }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains_key` found for struct `HashSet`\
    \ in the current scope\n  --> /tmp/tmp7aovvelu.rs:16:19\n   |\n16 |          \
    \   if !m.contains_key(&c) {\n   |                   ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `contains`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7aovvelu.rs:19:38\n   |\n19 |                 if m.get(&c)\
    \ < m.get(&max_word) {\n   |                                      ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n   |\n   = note: expected reference `&char`\n\
    \              found reference `&String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut sorted_count\
    \ = words.len();\n    let mut sorted_word = String::from(\"zzz\");\n    for word\
    \ in words {\n        let mut count = word.chars().filter(|c| *c != 'z').count();\n\
    \        if count > sorted_count {\n            sorted_count = count;\n      \
    \      sorted_word = word;\n        }\n    }\n    sorted_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp42lgezzy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut result = String::new();\n    let mut current_chars = Vec::new();\n\
    \    words.iter().for_each(|word| {\n        for c in word.chars().filter(|c|\
    \ !c.is_whitespace()) {\n            if c.chars().count() > max {\n          \
    \      max = c.chars().count();\n                result = word;\n            \
    \    current_chars = c.to_vec();\n            }\n        }\n    });\n    if max\
    \ > 0 {\n        result = result.unwrap().replace(current_chars.clone(), \"\"\
    ).to_owned();\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_kzs7gw5.rs:17:18\n   |\n17 |             if c.chars().count()\
    \ > max {\n   |                  ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmp_kzs7gw5.rs:18:25\n\
    \   |\n18 |                 max = c.chars().count();\n   |                   \
    \      ^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_kzs7gw5.rs:19:26\n   |\n13 |     let mut result = String::new();\n\
    \   |                      ------------- expected due to this value\n...\n19 |\
    \                 result = word;\n   |                          ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                          |\n\
    \   |                          expected struct `String`, found `&String`\n\nerror[E0599]:\
    \ no method named `to_vec` found for type `char` in the current scope\n  --> /tmp/tmp_kzs7gw5.rs:20:35\n\
    \   |\n20 |                 current_chars = c.to_vec();\n   |                \
    \                   ^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmp_kzs7gw5.rs:25:25\n\
    \   |\n25 |         result = result.unwrap().replace(current_chars.clone(), \"\
    \").to_owned();\n   |                         ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counters\
    \ = vec![String::from(\"Z\"), String::from(\"A\"), String::from(\"Z\")];\n   \
    \ for word in words {\n        for character in word.chars() {\n            if\
    \ counters[character] == 0 {\n                counters[character] = 1;\n     \
    \       } else {\n                counters[character] += 1;\n            }\n \
    \       }\n    }\n\n    let mut max_counters = String::from(\"Z\");\n    let mut\
    \ max_word = String::from(\"Z\");\n    for character in counters.iter().cloned()\
    \ {\n        if counters[character] > counters[max_counters] {\n            max_counters\
    \ = character;\n            max_word = word;\n        }\n    }\n\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmpv2vtdnc_.rs:28:24\n\
    \   |\n28 |             max_word = word;\n   |                        ^^^^ help:\
    \ a local variable with a similar name exists: `words`\n\nerror[E0277]: the type\
    \ `[String]` cannot be indexed by `char`\n  --> /tmp/tmpv2vtdnc_.rs:15:16\n  \
    \ |\n15 |             if counters[character] == 0 {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<String>`\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `char`\n  --> /tmp/tmpv2vtdnc_.rs:16:17\n\
    \   |\n16 |                 counters[character] = 1;\n   |                 ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<String>`\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `char`\n  --> /tmp/tmpv2vtdnc_.rs:18:17\n\
    \   |\n18 |                 counters[character] += 1;\n   |                 ^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<String>`\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `String`\n  --> /tmp/tmpv2vtdnc_.rs:26:12\n\
    \   |\n26 |         if counters[character] > counters[max_counters] {\n   |  \
    \          ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `Index<String>` for `Vec<String>`\n\nerror[E0277]: the type `[String]` cannot\
    \ be indexed by `String`\n  --> /tmp/tmpv2vtdnc_.rs:26:34\n   |\n26 |        \
    \ if counters[character] > counters["
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_counts\
    \ = HashMap::new();\n    let mut max_count = 0;\n    let mut best_word = String::from(\"\
    \");\n    for w in words {\n        if unique_counts.contains_key(&w) {\n    \
    \        unique_counts.entry(w).and_modify(|count| {\n                count +=\
    \ 1;\n            }).or_insert(0);\n        } else {\n            unique_counts.entry(w).and_modify(|count|\
    \ {\n                count += 1;\n            }).or_insert(1);\n        }\n  \
    \      if count > max_count {\n            max_count = count;\n            best_word\
    \ = w;\n        }\n    }\n    if unique_counts.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    if max_count < words.len() {\n        return best_word;\n   \
    \ }\n    let mut unique_char = String::from(\"\");\n    for w in words {\n   \
    \     if unique_counts.contains_key(&w) {\n            if let Some(m) = unique_counts[w]\
    \ {\n                if m > max_count {\n                    max_count = m;\n\
    \                    unique_char = w;\n                }\n            }\n    \
    \    }\n    }\n    unique_char\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk3tengx6.rs:12:29\n   |\n12 |     let mut unique_counts = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `count` in this scope\n  --> /tmp/tmpk3tengx6.rs:25:12\n\
    \   |\n25 |         if count > max_count {\n   |            ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `count` in this scope\n  --> /tmp/tmpk3tengx6.rs:26:25\n\
    \   |\n26 |             max_count = count;\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ HashMap::new();\n\n    for word in words {\n        for c in word.chars() {\n\
    \            counter.insert(c, counter.entry(c).or_insert(0));\n        }\n  \
    \  }\n    let mut max_key = String::new();\n    let mut max_value = String::new();\n\
    \n    for (_, value) in counter.iter() {\n        if value > max_value.len() {\n\
    \            max_value = value;\n            max_key = String::from(*max_key);\n\
    \        }\n    }\n\n    if max_value.is_empty() {\n        max_value = \"0\"\
    .to_string();\n    }\n\n    max_key\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpzqcrphk2.rs:12:23\n   |\n12 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ can't compare `String` with `usize`\n  --> /tmp/tmpzqcrphk2.rs:23:18\n   |\n\
    23 |         if value > max_value.len() {\n   |                  ^ no implementation\
    \ for `String < usize` and `String > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             String\n             str\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpzqcrphk2.rs:25:36\n    |\n25  |             max_key = String::from(*max_key);\n\
    \    |                       ------------ ^^^^^^^^ doesn't have a size known at\
    \ compile-time\n    |                       |\n    |                       required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `from`\n\nerror[E0277]:\
    \ the trait bound `String: From<str>` is not satisfied\n  --> /tmp/tmpzqcrphk2.rs:25:23\n\
    \   |\n25 |             max_key = String::from(*max_key);\n   |              \
    \         ^^^^^^^^^^^^ the trait `From<str>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut len = words[0].len();\n\
    \    let mut max_count = std::i32::MAX;\n    let mut max_word = None;\n    for\
    \ &w in words {\n        let c = w.chars().filter(|c| c < ' ').count();\n    \
    \    len = c.max(len);\n        if max_count == std::i32::MAX {\n            max_word\
    \ = w;\n        }\n        if c == max_count {\n            max_word = w;\n  \
    \      }\n        if c > max_count {\n            max_count = c;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpra1h9x1e.rs:15:9\n   |\n\
    15 |     for &w in words {\n   |         ^^    ----- this expression has type\
    \ `Option<String>`\n   |         |\n   |         expected struct `String`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `w`\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpra1h9x1e.rs:28:5\n   |\n11 | fn\
    \ find_max(words: Vec<String>) -> String {\n   |                             \
    \       ------ expected `String` because of return type\n...\n28 |     max_word\n\
    \   |     ^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut counter =\
    \ vec![String::new(); words.len()];\n\n    for word in words {\n        let mut\
    \ current = String::new();\n        for c in word.chars() {\n            current\
    \ += c;\n            if current.len() > counter[counter.len() - 1].len() {\n \
    \               counter[counter.len() - 1] = current;\n            }\n       \
    \ }\n    }\n\n    let mut current = String::new();\n    let mut max = String::new();\n\
    \n    for i in 0..counter.len() {\n        if counter[i].len() > current.len()\
    \ {\n            current = counter[i];\n            max = words[i as usize];\n\
    \        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw0fv2ltq.rs:17:24\n   |\n\
    17 |             current += c;\n   |                        ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        String::new()\n    } else {\n        let mut words: Vec<_> = words.into_iter().collect();\n\
    \        words.sort_by(|a, b| a.chars().count() as u32.cmp(&b.chars().count()).unwrap());\n\
    \        let mut max = 0;\n        let mut index = words.iter().position(|w| w.chars().count()\
    \ > max);\n        if let Some(_) = index {\n            max = 0;\n          \
    \  index = words.iter().position(|w| w.chars().count() > max);\n        }\n  \
    \      let mut max = max;\n        let mut result = words[index];\n        let\
    \ mut word = 0;\n        loop {\n            if max < w.chars().count() {\n  \
    \              max = w.chars().count();\n                result = w;\n       \
    \         word += 1;\n            } else if w < result.chars().count() {\n   \
    \             max -= w.chars().count();\n                result = w;\n       \
    \         word += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        result.to_string()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpz4yjk0yv.rs:16:30\n\
    \   |\n16 |         words.sort_by(|a, b| a.chars().count() as u32.cmp(&b.chars().count()).unwrap());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n16 |         words.sort_by(|a, b| (a.chars().count()\
    \ as u32).cmp(&b.chars().count()).unwrap());\n   |                           \
    \   +                        +\n\nerror[E0425]: cannot find value `w` in this\
    \ scope\n  --> /tmp/tmpz4yjk0yv.rs:27:22\n   |\n27 |             if max < w.chars().count()\
    \ {\n   |                      ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `w` in this scope\n  --> /tmp/tmpz4yjk0yv.rs:28:23\n   |\n28 |  \
    \               max = w.chars().count();\n   |                       ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `w` in this scope\n  --> /tmp/tmpz4yjk0yv.rs:29:26\n\
    \   |\n29 |                 result = w;\n   |                          ^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `w` in this scope\n  --> /tmp/tmpz4yjk0yv.rs:31:23\n\
    \   |\n31 |             } else if w < result.chars().count() {\n   |         \
    \              ^ not found in this scope\n\nerror[E0425]: cannot find value `w`\
    \ in this scope\n  --> /tmp/tmpz4yjk0yv.rs:32:24\n   |\n32 |                 max\
    \ -= w.chars().count();\n   |                        ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `w` in this scope\n  --> /tmp/tmpz4yjk0yv.rs:33:26\n\
    \   |\n33 |                 result = w;\n   |                          ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4yjk0yv.rs:16:59\n\
    \   |\n16 |         words.sort_by(|a, b| a.chars().count() as u32.cmp(&b.chars().count()).unwrap());\n\
    \   |                                                           ^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\n   = note: expected reference `&u32`\n\
    \              found reference `&usize`\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpz4yjk0yv.r"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // We use a HashMap\
    \ (map), keyed by character positions, to keep track of the\n    // number of\
    \ unique characters.\n    let mut characters = HashMap::new();\n    for word in\
    \ words {\n        for ch in word.chars().chain(word.chars().skip(1)).filter(|c|\
    \ !characters.contains_key(&c)) {\n            characters.insert(ch, 1);\n   \
    \     }\n    }\n\n    // Sort descending by number of characters. Since we sort\
    \ in descending order,\n    // the first word is the one with the maximum number\
    \ of unique characters.\n    characters.into_iter().sort_by(|a, b| b.cmp(&a)).last()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpm34h52k9.rs:14:26\n   |\n14 |     let mut characters = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976175
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut cur = 0;\n    for word in words {\n        let mut count = 0;\n \
    \       for c in word.chars() {\n            if !cur.contains(&c) {\n        \
    \        cur += 1;\n                count += 1;\n            }\n        }\n  \
    \      if count > max {\n            max = count;\n        }\n    }\n    if max\
    \ > 0 {\n        words.iter().find(|w| w.chars().count() > max).unwrap()\n   \
    \ } else {\n        String::new()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `contains` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmph909neol.rs:17:21\n   |\n17 |             if !cur.contains(&c)\
    \ {\n   |                     ^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n13 |     let mut cur: i32 = 0;\n   |       \
    \  ~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph909neol.rs:27:9\n\
    \   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                \
    \                    ------ expected `String` because of return type\n...\n27\
    \ |         words.iter().find(|w| w.chars().count() > max).unwrap()\n   |    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |         |\n   |         expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976175
