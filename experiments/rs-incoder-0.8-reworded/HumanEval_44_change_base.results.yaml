language: rs
name: HumanEval_44_change_base
results:
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    match x {\n        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a => s.push('0'),\n\
    \        b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s\
    \ => s.push(x),\n        x => {\n            let mut y = x;\n            while\
    \ y > base {\n                y /= base;\n                s.push(*'0' + base);\n\
    \            }\n            while y < 10 {\n                s.push(y % base);\n\
    \                y /= base;\n            }\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0408]: variable `a` is not bound in all patterns\n  --> /tmp/tmp2nqknhml.rs:13:9\n\
    \   |\n13 |         0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a => s.push('0'),\n\
    \   |         ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   - variable not in all patterns\n\
    \   |         |   |   |   |   |   |   |   |   |   |\n   |         |   |   |  \
    \ |   |   |   |   |   |   pattern doesn't bind `a`\n   |         |   |   |   |\
    \   |   |   |   |   pattern doesn't bind `a`\n   |         |   |   |   |   | \
    \  |   |   pattern doesn't bind `a`\n   |         |   |   |   |   |   |   pattern\
    \ doesn't bind `a`\n   |         |   |   |   |   |   pattern doesn't bind `a`\n\
    \   |         |   |   |   |   pattern doesn't bind `a`\n   |         |   |   |\
    \   pattern doesn't bind `a`\n   |         |   |   pattern doesn't bind `a`\n\
    \   |         |   pattern doesn't bind `a`\n   |         pattern doesn't bind\
    \ `a`\n\nerror[E0408]: variable `d` is not bound in all patterns\n  --> /tmp/tmp2nqknhml.rs:14:9\n\
    \   |\n14 |         b | c | d | e | f | g | h | i | j | k | l | m | n | o | p\
    \ | q | r | s => s.push(x),\n   |         ^   ^   -   ^   ^   ^   ^   ^   ^  \
    \ ^   ^   ^   ^   ^   ^   ^   ^   ^ pattern doesn't bind `d`\n   |         | \
    \  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n   |       \
    \  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   pattern doesn't\
    \ bind `d`\n   |         |   |   |   |   |   |   |   |   |   |   |   |   |   |\
    \   |   pattern doesn't bind `d`\n   |         |   |   |   |   |   |   |   | \
    \  |   |   |   |   |   |   pattern doesn't bind `d`\n   |         |   |   |  \
    \ |   |   |   |   |   |   |   |   |   |   pattern doesn't bind `d`\n   |     \
    \    |   |   |   |   |   |   |   |   |   |   |   |   pattern doesn't bind `d`\n\
    \   |         |   |   |   |   |   |   |   |   |   |   |   pattern doesn't bind\
    \ `d`\n   |         |   |   |   |   |   |   |   |   |   |   pattern doesn't bind\
    \ `d`\n   |         |   |   |   |   |   |   |   |   |   pattern doesn't bind `d`\n\
    \   |         |   |   |   |   |   |   |   |   pattern doesn't bind `d`\n   | \
    \        |   |   |   |   |   |   | "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    String::from_str(to_str(x)).to_string(base)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_str` in this scope\n  --> /tmp/tmp1x8quzgq.rs:11:22\n\
    \   |\n11 |     String::from_str(to_str(x)).to_string(base)\n   |            \
    \          ^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated\
    \ item named `from_str` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp1x8quzgq.rs:11:13\n   |\n11 |     String::from_str(to_str(x)).to_string(base)\n\
    \   |             ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    panic!(\"base number must be less than 2\");\n    }\n    if x < base {\n\
    \        panic!(\"base number must be greater than x\");\n    }\n\n    let mut\
    \ s = String::from(\"\");\n    for i in 0..base {\n        let mut c = x;\n  \
    \      while c > base {\n            c -= base;\n        }\n        s += format!(\"\
    {}\", c);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4s_9tq1b.rs:24:14\n   |\n\
    24 |         s += format!(\"{}\", c);\n   |              ^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found struct `String`\n   |\n   = note: this error originates in the\
    \ macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}{}\", x\
    \ / base, &(x % base))\n}\n\nfn main() {\n    let candidate = change_base;\n \
    \   assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"30\"`,\n right: `\"100\"`', /tmp/tmp2uptdafc.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut carry = false;\n    for i in (0..x).step_by(base) {\n        let\
    \ digit = x.0 % base;\n        let digit = digit > 9 ? digit - 9 + 9 : digit;\n\
    \        if digit != 0 {\n            s.push((digit as u32 + '0').to_string());\n\
    \        }\n        carry += digit < 10;\n        x = x / base - 1;\n    }\n \
    \   if carry != 0 {\n        s.push((1 as u32 + '0').to_string());\n    }\n  \
    \  s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `digit`\n\
    \  --> /tmp/tmpv7nah1d6.rs:15:33\n   |\n15 |         let digit = digit > 9 ? digit\
    \ - 9 + 9 : digit;\n   |                                 ^^^^^ expected one of\
    \ `.`, `;`, `?`, `else`, or an operator\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv7nah1d6.rs:13:29\n   |\n13 |     for i in (0..x).step_by(base) {\n\
    \   |                             ^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n13 |     for i in (0..x).step_by(base.try_into().unwrap())\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpv7nah1d6.rs:14:23\n\
    \   |\n14 |         let digit = x.0 % base;\n   |                       ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpv7nah1d6.rs:22:17\n   |\n22 |  \
    \   if carry != 0 {\n   |                 ^ expected `bool`, found integer\n\n\
    error[E0277]: cannot add `char` to `u32`\n  --> /tmp/tmpv7nah1d6.rs:23:26\n  \
    \ |\n23 |         s.push((1 as u32 + '0').to_string());\n   |                \
    \          ^ no implementation for `u32 + char`\n   |\n   = help: the trait `Add<char>`\
    \ is not implemented for `u32`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut digits = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits.insert(0, format!(\"{}\", remainder));\n        x /= base;\n \
    \   }\n    if x != 0 {\n        digits.insert(0, format!(\"{}\", x));\n    }\n\
    \    digits\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0e9j8fn3.rs:15:26\n   |\n\
    15 |         digits.insert(0, format!(\"{}\", remainder));\n   |             \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0e9j8fn3.rs:19:26\n   |\n19 |         digits.insert(0, format!(\"\
    {}\", x));\n   |                          ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base > 10 {\n   \
    \     String::from(\"bases lower than 10\")\n    } else {\n        match x {\n\
    \            0 => String::from(\"0\"),\n            1 => String::from(\"1\"),\n\
    \            base if base == 10 => String::from(\"10\"),\n            x if x ==\
    \ 0 => String::from(\"0\"),\n            x if x > 0 => String::from(\"1\"),\n\
    \            _ => String::from(\"0\"),\n        }\n        .to_digits()\n    \
    \    .unwrap()\n        .collect::<Vec<_>>()\n        .join(\"\")\n    }\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp6k8__81i.rs:22:10\n   |\n22 |         .to_digits()\n\
    \   |          ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     String::from(\"0\").to_string()\n    }\n    let mut res = String::from(\"\
    \");\n    let mut pow = 1;\n    while x > base {\n        res.push_str(&format!(\"\
    {}\", x / base));\n        res.push_str(&format!(\"{}\", x%base));\n        pow\
    \ *= base;\n        x /= base;\n    }\n    res.push_str(&format!(\"{}\", x));\n\
    \    res.push_str(&format!(\"{}\", pow));\n    res\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgnjm4f9z.rs:12:9\n   |\n\
    11 | /     if base < 10 {\n12 | |         String::from(\"0\").to_string()\n  \
    \ | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    13 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n12 |         String::from(\"0\").to_string();\n   |\
    \                                      +\nhelp: consider using a semicolon here\n\
    \   |\n13 |     };\n   |      +\nhelp: you might have meant to return this value\n\
    \   |\n12 |         return String::from(\"0\").to_string();\n   |         ++++++\
    \                              +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match base {\n     \
    \   1 => \"1\",\n        2 => \"10\",\n        _ => format!(\"{}\", num2str(x,\
    \ base)),\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num2str` in this scope\n  --> /tmp/tmprqxdoq09.rs:14:28\n\
    \   |\n14 |         _ => format!(\"{}\", num2str(x, base)),\n   |            \
    \                ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprqxdoq09.rs:12:14\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n11 |     match base {\n12 |         1 => \"1\",\n  \
    \ |              ^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |              |\n   |              expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    x.to_string().as_bytes()\
    \ + base.to_string().as_bytes().to_radix(base, &mut [0; 36]).to_string()\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_radix` found for reference `&[u8]` in\
    \ the current scope\n  --> /tmp/tmp5av2hb6l.rs:11:60\n   |\n11 |     x.to_string().as_bytes()\
    \ + base.to_string().as_bytes().to_radix(base, &mut [0; 36]).to_string()\n   |\
    \                                                            ^^^^^^^^ method not\
    \ found in `&[u8]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut x = x;\n    while x != 0 {\n        if x < base {\n            result.push(b'0');\n\
    \        }\n        result.push(b'1');\n        x /= base;\n    }\n    if base\
    \ == 2 {\n        result.reverse();\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprz21l3aa.rs:15:25\n   |\n\
    15 |             result.push(b'0');\n   |                         ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprz21l3aa.rs:17:21\n\
    \   |\n17 |         result.push(b'1');\n   |                     ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprz21l3aa.rs:21:16\n   |\n21 | \
    \        result.reverse();\n   |                ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder: isize = x;\n    let mut remainder_base: isize = 1;\n\n\
    \    if base > 10 {\n        panic!(\"Base must less than 10\");\n    }\n\n  \
    \  while remainder != 0 {\n        let mut remainder_temp: isize = 0;\n      \
    \  let mut current_digit: isize = 0;\n        let mut quotient: isize = 0;\n \
    \       quotient = remainder / base;\n        remainder = remainder % base;\n\n\
    \        while quotient != 0 {\n            current_digit = quotient % base;\n\
    \            quotient = quotient / base;\n            remainder_temp = remainder_temp\
    \ + current_digit*remainder_base;\n            remainder_base = base;\n      \
    \  }\n\n        remainder = remainder_temp;\n        s.push(i);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp9u4dcq1t.rs:34:16\n\
    \   |\n34 |         s.push(i);\n   |                ^ help: a local variable with\
    \ a similar name exists: `s`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match base {\n     \
    \   2 => \"0{}\",\n        3 => \"00{}\",\n        4 => \"000{}\",\n        5\
    \ => \"0000{}\",\n        _ => if base == 10 {\n            format!(\"{}\", x)\n\
    \        } else {\n            let mut s = String::new();\n            let mut\
    \ digits: Vec<isize> = vec![x, 0, 1];\n            while let Some(&i) = digits.iter().nth(0)\
    \ {\n                s = format!(\"{}{}\", s, i).to_string();\n              \
    \  digits.pop();\n            }\n            format!(\"{}\", s)\n        },\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3u0f5v3.rs:12:14\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n11\
    \ |     match base {\n12 |         2 => \"0{}\",\n   |              ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |              |\n   |   \
    \           expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut digits = String::new();\n\
    \    for d in x.to_string().chars().cloned().rev() {\n        digits.push_str(d.to_string(base).chars().cloned().rev());\n\
    \    }\n    digits\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp5mxrkx1v.rs:12:36\n     |\n12   |     for d in x.to_string().chars().cloned().rev()\
    \ {\n     |                                    ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `rev` exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp5mxrkx1v.rs:12:45\n   |\n12 |       for d in x.to_string().chars().cloned().rev()\
    \ {\n   |                                               ^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ let mut y = base;\n\n    let mut digits = String::new();\n\n    while x > 0\
    \ {\n        let tmp = x % base;\n        digits.push(&to_digit(&tmp));\n    \
    \    y /= base;\n        x = x;\n    }\n\n    let mut tmp = to_digit(y);\n   \
    \ while tmp.len() > 1 {\n        digits.unshift(tmp[tmp.len() - 1]);\n       \
    \ tmp = &tmp[tmp.len() - 1];\n    }\n    digits.unshift(tmp);\n\n    digits\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_digit` in this scope\n  --> /tmp/tmppj_4v3em.rs:18:22\n\
    \   |\n18 |         digits.push(&to_digit(&tmp));\n   |                      ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `to_digit` in\
    \ this scope\n  --> /tmp/tmppj_4v3em.rs:23:19\n   |\n23 |     let mut tmp = to_digit(y);\n\
    \   |                   ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `unshift` found for struct `String` in the current scope\n  --> /tmp/tmppj_4v3em.rs:25:16\n\
    \   |\n25 |         digits.unshift(tmp[tmp.len() - 1]);\n   |                ^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `unshift` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmppj_4v3em.rs:28:12\n\
    \   |\n28 |     digits.unshift(tmp);\n   |            ^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    for i in 0..x.bit_length() {\n        let mut binary = if x > (base * ((x\
    \ as usize - 1) as isize))\n            then base * ((x as usize - 1) as isize)\n\
    \            else (x as usize - 1);\n        if i > 0 && (x & ((base * (i as isize))\
    \ - 1) as isize) != 0 {\n            binary += 1;\n        }\n        s += binary.to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `then`\n  --> /tmp/tmp29wph613.rs:14:13\n  \
    \ |\n13 |         let mut binary = if x > (base * ((x as usize - 1) as isize))\n\
    \   |                          -- this `if` expression has a condition, but no\
    \ block\n14 |             then base * ((x as usize - 1) as isize)\n   |      \
    \       ^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n\
    \   |\n14 |             { then } base * ((x as usize - 1) as isize)\n   |    \
    \         +      +\n\nerror[E0599]: no method named `bit_length` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp29wph613.rs:12:19\n   |\n12 |  \
    \   for i in 0..x.bit_length() {\n   |                   ^^^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut y = x;\n   \
    \ let mut carry: isize = 0;\n    let mut new_base: isize = base;\n    let mut\
    \ new_str: String = \"\";\n\n    // While x is greater than the base and carry\
    \ is non-zero, shift x by\n    // one and add carry to the new base.\n    while\
    \ y >= new_base && carry != 0 {\n        new_str = format!(\"{}{}\", &new_str,\
    \ &new_base);\n        y = y / new_base;\n        carry = y % new_base;\n    }\n\
    \n    // If x is greater than the base, add carry to the new base.\n    while\
    \ y > new_base {\n        new_str = format!(\"{}{}\", &new_str, &new_base);\n\
    \        y = y / new_base;\n        carry = y % new_base;\n    }\n\n    // If\
    \ carry is not 0, add it to the new base.\n    if carry != 0 {\n        new_str\
    \ = format!(\"{}{}\", &new_str, &carry);\n    }\n\n    new_str\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgbytybkw.rs:14:31\n   |\n\
    14 |     let mut new_str: String = \"\";\n   |                      ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut string = String::new();\n\
    \    while x >= base {\n        string.push((x%base) as char);\n        x /= base;\n\
    \    }\n    string.push((x as char) as char);\n    string.push((x) as char);\n\
    \    string\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpxe9pckwj.rs:13:21\n\
    \   |\n13 |         string.push((x%base) as char);\n   |                     ^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpxe9pckwj.rs:13:21\n   |\n13 |         string.push((x%base) as char);\n\
    \   |                     ^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpxe9pckwj.rs:16:17\n   |\n16 |     string.push((x\
    \ as char) as char);\n   |                 ^^^^^^^^^^^ invalid cast\n   |\nhelp:\
    \ try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpxe9pckwj.rs:16:17\n\
    \   |\n16 |     string.push((x as char) as char);\n   |                 ^^^^^^^^^^^\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpxe9pckwj.rs:17:17\n\
    \   |\n17 |     string.push((x) as char);\n   |                 ^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpxe9pckwj.rs:17:17\n\
    \   |\n17 |     string.push((x) as char);\n   |                 ^^^^^^^^^^^\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!(base < 10, \"\
    Base must be less than 10.\");\n    let mut s = String::new();\n    for i in 0..(x\
    \ / base) {\n        let base = i as isize;\n        let mut tmp = 1;\n      \
    \  for j in 0..(base - 1) {\n            tmp *= x;\n        }\n        let mut\
    \ digit = String::from(\"0\");\n        for i in 0..base.to_digit() {\n      \
    \      digit.push((tmp % base) as char);\n            tmp /= base;\n        }\n\
    \        s.push_str(&digit);\n    }\n    if x % base != 0 {\n        let mut tmp\
    \ = 1;\n        for i in 0..(base.to_digit() - 1) {\n            tmp *= x;\n \
    \       }\n        let mut digit = String::from(\"0\");\n        for i in 0..base.to_digit()\
    \ {\n            digit.push((tmp % base) as char);\n            tmp /= base;\n\
    \        }\n        s.push_str(&digit);\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpjyjcpm02.rs:20:26\n   |\n20 |         for i in\
    \ 0..base.to_digit() {\n   |                          ^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `to_digit` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpjyjcpm02.rs:28:27\n   |\n28 |         for\
    \ i in 0..(base.to_digit() - 1) {\n   |                           ^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0599]: no method named `to_digit` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpjyjcpm02.rs:32:26\n   |\n32 |  \
    \       for i in 0..base.to_digit() {\n   |                          ^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `isize`\n  --> /tmp/tmpjyjcpm02.rs:21:24\n   |\n21 |             digit.push((tmp\
    \ % base) as char);\n   |                        ^^^^^^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpjyjcpm02.rs:21:24\n\
    \   |\n21 |             digit.push((tmp % base) as char);\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `isize`\n  --> /tmp/tmpjyjcpm02.rs:33:24\n   |\n33 |             digit.push((tmp\
    \ % base) as char);\n   |                        ^^^^^^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpjyjcpm02.rs:33:24\n\
    \   |\n33 |             digit.push((tmp % base) as char);\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0599, E0604.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut digits = String::new();\n\
    \    let mut x = x.to_digits(base);\n    while !x.is_empty() {\n        digits.push_str(&x[..]);\n\
    \        x = x.to_digits(base);\n    }\n    String::from(digits)\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpaaqi3cu0.rs:12:19\n   |\n12 |     let mut x = x.to_digits(base);\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut string: String\
    \ = String::new();\n\n    // convert x to base 10 to get the number of digits\n\
    \    let mut num_digits = to_base10(x);\n\n    // add the new base to the number\
    \ of digits\n    num_digits = num_digits.to_string(base).unwrap();\n\n    // now\
    \ convert the number of digits to base 10\n    let mut num_base10 = from_base10(num_digits);\n\
    \n    // add leading zeros if needed.\n    // this works because we know the base\
    \ is less than 10\n    while num_base10 > base {\n        num_base10 = num_base10.saturating_sub(base);\n\
    \        string.push(b'0');\n    }\n\n    // now add the number in base 10\n \
    \   string.push_str(&num_base10).unwrap();\n\n    string\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_base10` in this scope\n  --> /tmp/tmp_kg8hc5e.rs:14:26\n\
    \   |\n14 |     let mut num_digits = to_base10(x);\n   |                     \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `from_base10` in this scope\n  --> /tmp/tmp_kg8hc5e.rs:20:26\n   |\n20 |   \
    \  let mut num_base10 = from_base10(num_digits);\n   |                       \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_kg8hc5e.rs:26:21\n   |\n26 |         string.push(b'0');\n   |     \
    \                ^^^^ expected `char`, found `u8`\n\nerror[E0599]: no method named\
    \ `unwrap` found for unit type `()` in the current scope\n  --> /tmp/tmp_kg8hc5e.rs:30:34\n\
    \   |\n30 |     string.push_str(&num_base10).unwrap();\n   |                 \
    \                 ^^^^^^ method not found in `()`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::with_capacity(x.to_string().len());\n\
    \    if base == 10 {\n        if x >= 0 {\n            result.push_str(x.to_string());\n\
    \        } else {\n            result.push_str(\"-0\".to_string());\n        }\n\
    \    } else {\n        let mut r = x;\n        while r > 0 {\n            if r\
    \ % base == 0 {\n                result.push_str(r.to_string_lossy().to_string());\n\
    \                break;\n            }\n            r = r / base;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5sxrs8a.rs:14:29\n   |\n\
    14 |             result.push_str(x.to_string());\n   |                       \
    \      ^^^^^^^^^^^^^\n   |                             |\n   |               \
    \              expected `&str`, found struct `String`\n   |                  \
    \           help: consider borrowing here: `&x.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps5sxrs8a.rs:16:29\n   |\n16 |             result.push_str(\"\
    -0\".to_string());\n   |                             ^^^^^^^^^^^^^^^^\n   |  \
    \                           |\n   |                             expected `&str`,\
    \ found struct `String`\n   |                             help: consider borrowing\
    \ here: `&\"-0\".to_string()`\n\nerror[E0599]: no method named `to_string_lossy`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmps5sxrs8a.rs:22:35\n\
    \   |\n22 |                 result.push_str(r.to_string_lossy().to_string());\n\
    \   |                                   ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut n = x;\n    while n > 0 {\n        if n < base {\n            s.push_str(&str::from_digit(n\
    \ % base, 10));\n        }\n        n /= base;\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_digit` found for\
    \ type `str` in the current scope\n  --> /tmp/tmpfoc06gqq.rs:15:30\n   |\n15 |\
    \             s.push_str(&str::from_digit(n % base, 10));\n   |              \
    \                ^^^^^^^^^^ function or associated item not found in `str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    String::from(\"0\")\n    }\n    let mut s = String::from(\"0\");\n    let\
    \ mut i = 0;\n    while i < base.to_i32() {\n        if i >= 10 {\n          \
    \  s.push('0');\n            i += 1;\n        } else {\n            s.push('1');\n\
    \            i += 1;\n        }\n    }\n    s += x.to_digits(10);\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9cay116m.rs:12:9\n   |\n\
    11 | /     if base < 2 {\n12 | |         String::from(\"0\")\n   | |         ^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n13 | |     }\n   | |_____- expected this\
    \ to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n12 |        \
    \ String::from(\"0\");\n   |                          +\nhelp: consider using\
    \ a semicolon here\n   |\n13 |     };\n   |      +\nhelp: you might have meant\
    \ to return this value\n   |\n12 |         return String::from(\"0\");\n   | \
    \        ++++++                  +\n\nerror[E0599]: no method named `to_i32` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmp9cay116m.rs:16:20\n   |\n\
    16 |     while i < base.to_i32() {\n   |                    ^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `to_digits` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp9cay116m.rs:25:12\n   |\n25 |  \
    \   s += x.to_digits(10);\n   |            ^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x as usize;\n\
    \    let mut r = String::new();\n\n    while x >= base {\n        r.push((x %\
    \ base) as char);\n        x = x / base;\n    }\n    r.push((x as char));\n  \
    \  r\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp7nzwau9w.rs:18:12\n\
    \   |\n18 |     r.push((x as char));\n   |            ^         ^\n   |\n   =\
    \ note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -     r.push((x as char));\n18 +     r.push(x as char);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7nzwau9w.rs:14:16\n   |\n14 |     while x >=\
    \ base {\n   |                ^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |     while x >= base.try_into().unwrap() {\n   |            \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7nzwau9w.rs:15:21\n\
    \   |\n15 |         r.push((x % base) as char);\n   |                     ^^^^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot mod `usize` by `isize`\n\
    \  --> /tmp/tmp7nzwau9w.rs:15:19\n   |\n15 |         r.push((x % base) as char);\n\
    \   |                   ^ no implementation for `usize % isize`\n   |\n   = help:\
    \ the trait `Rem<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7nzwau9w.rs:16:17\n   |\n16 |         x = x / base;\n \
    \  |                 ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ divide `usize` by `isize`\n  --> /tmp/tmp7nzwau9w.rs:16:15\n   |\n16 |     \
    \    x = x / base;\n   |               ^ no implementation for `usize / isize`\n\
    \   |\n   = help: the trait `Div<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Di"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x: u64 = x;\n\
    \    let base = base;\n    let mut result: String = String::new();\n    if x <=\
    \ base {\n        if x % base == 0 {\n            return x.to_string();\n    \
    \    }\n        x.set_bit(base - 1);\n        result.set_bit(base - 1);\n    \
    \    let mut j = base;\n        while j > 1 {\n            x.set_bit(j - 1);\n\
    \            x.set_bit(j - 2);\n            result.push((x % base).to_string());\n\
    \            x.set_bit(j - 2);\n            x.set_bit(j - 1);\n            j -=\
    \ 2;\n        }\n        result.push((x % base).to_string());\n    } else {\n\
    \        x.set_bit(base - 1);\n        result.set_bit(base - 1);\n        let\
    \ mut j = base;\n        while j > 1 {\n            x.set_bit(j - 1);\n      \
    \      x.set_bit(j - 2);\n            result.push((x % base).to_string());\n \
    \           x.set_bit(j - 2);\n            x.set_bit(j - 1);\n            j -=\
    \ 2;\n        }\n        let mut j = base - 1;\n        while j >= 1 {\n     \
    \       result.push((x % base).to_string());\n            x.set_bit(j - 1);\n\
    \            x.set_bit(j - 2);\n            j -= 2;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsoqblnrz.rs:11:22\n   |\n\
    11 |     let mut x: u64 = x;\n   |                ---   ^ expected `u64`, found\
    \ `isize`\n   |                |\n   |                expected due to this\n \
    \  |\nhelp: you can convert an `isize` to a `u64` and panic if the converted value\
    \ doesn't fit\n   |\n11 |     let mut x: u64 = x.try_into().unwrap();\n   |  \
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsoqblnrz.rs:14:13\n   |\n14 |     if x <= base {\n   |        \
    \     ^^^^ expected `u64`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u64` and panic if the converted value doesn't fit\n   |\n14 |     if x\
    \ <= base.try_into().unwrap() {\n   |                 ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsoqblnrz.rs:15:16\n   |\n15 |  \
    \       if x % base == 0 {\n   |                ^^^^ expected `u64`, found `isize`\n\
    \nerror[E0277]: cannot mod `u64` by `isize`\n  --> /tmp/tmpsoqblnrz.rs:15:14\n\
    \   |\n15 |         if x % base == 0 {\n   |              ^ no implementation\
    \ for `u64 % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented\
    \ for `u64`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0599]: no method named `set_bit` found for type `u64` in\
    \ the current scope\n  --> /tmp/tmpsoqblnrz.rs:18:11\n   |\n18 |         x.set_bit(base\
    \ - 1);\n   |           ^^^^^^^ method not found in `u64`\n\nerror[E0599]: no\
    \ method named `set_bit` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpsoqblnrz.rs:19:16\n   |\n19 |         result.set_bit(base - 1);\n  \
    \ |                ^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `set_bit` found for type `u64` in the current scope\n  --> /tmp/tmpsoqblnrz.rs:22:15"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match base {\n     \
    \   1 => String::from(\"0\"),\n        2 => String::from(\"1\"),\n        3 =>\
    \ String::from(\"10\"),\n        4 => String::from(\"11\"),\n        5 => String::from(\"\
    100\"),\n        6 => String::from(\"101\"),\n        7 => String::from(\"110\"\
    ),\n        8 => String::from(\"111\"),\n        _ => {\n            let mut s\
    \ = String::from(\"0\");\n            for (i, j) in x.chars().enumerate() {\n\
    \                let c = (i * base) + j as usize;\n                s.push_str(&from_digit(c));\n\
    \            }\n            s\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `from_digit` in this scope\n  --> /tmp/tmpbz0cv719.rs:24:29\n\
    \   |\n24 |                 s.push_str(&from_digit(c));\n   |                \
    \             ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::char::from_digit;\n   |\n\nerror[E0599]:\
    \ no method named `chars` found for type `isize` in the current scope\n  --> /tmp/tmpbz0cv719.rs:22:29\n\
    \   |\n22 |             for (i, j) in x.chars().enumerate() {\n   |          \
    \                   ^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    0\");\n    while x != 0 {\n        let mut div = x;\n        while div > 0 {\n\
    \            res.insert(res, base, '0');\n            div /= base;\n        }\n\
    \        res.insert(res, base, '1');\n        x /= base;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \    --> /tmp/tmpqsjeazlt.rs:15:17\n     |\n15   |             res.insert(res,\
    \ base, '0');\n     |                 ^^^^^^ ---  ----  --- supplied 3 arguments\n\
    \     |                 |\n     |                 expected 2 arguments\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 2\
    \ arguments but 3 arguments were supplied\n    --> /tmp/tmpqsjeazlt.rs:18:13\n\
    \     |\n18   |         res.insert(res, base, '1');\n     |             ^^^^^^\
    \ ---  ----  --- supplied 3 arguments\n     |             |\n     |          \
    \   expected 2 arguments\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    match x {\n        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | _ as v =>\
    \ s.push_str(&format!(\"{:#0{}b}\", v, base)),\n        _ => panic!(\"Input out\
    \ of base range\"),\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=>`, `if`, or `|`, found keyword `as`\n  --> /tmp/tmp3_zu1qi5.rs:13:51\n\
    \   |\n13 |         0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | _ as v => s.push_str(&format!(\"\
    {:#0{}b}\", v, base)),\n   |                                                 \
    \  ^^ expected one of `=>`, `if`, or `|`\n\nwarning: unreachable expression\n\
    \  --> /tmp/tmp3_zu1qi5.rs:16:5\n   |\n12 | /     match x {\n13 | |         0\
    \ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | _ as v => s.push_str(&format!(\"{:#0{}b}\"\
    , v, base)),\n14 | |         _ => panic!(\"Input out of base range\"),\n15 | |\
    \     }\n   | |_____- any code following this expression is unreachable\n16 |\
    \       s\n   |       ^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror: aborting due to previous error; 1 warning emitted\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x <= base {\n   \
    \     return String::from_str(&format!(\"{}\", x as isize))\n    } else {\n  \
    \      let mut res = String::new();\n        for i in x.to_string().chars().rev()\
    \ {\n            res.push_str(&format!(\"{}{}\", base * (i as usize), i));\n \
    \       }\n        res\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp7rtut09j.rs:12:24\n   |\n\
    12 |         return String::from_str(&format!(\"{}\", x as isize))\n   |     \
    \                   ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7rtut09j.rs:16:50\n   |\n16 |             res.push_str(&format!(\"\
    {}{}\", base * (i as usize), i));\n   |                                      \
    \            ^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ multiply `isize` by `usize`\n  --> /tmp/tmp7rtut09j.rs:16:48\n   |\n16 |   \
    \          res.push_str(&format!(\"{}{}\", base * (i as usize), i));\n   |   \
    \                                             ^ no implementation for `isize *\
    \ usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut base = x;\n    let mut i = 1;\n\n    while base >= 10 {\n       \
    \ result = format!(\"{}{}\", &result, &base % 10);\n        base /= 10;\n    \
    \    i += 1;\n    }\n\n    if base > 0 {\n        result = format!(\"{}{}\", &result,\
    \ &base);\n    }\n\n    String::from(result)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8\"`,\n right: `\"22\"`', /tmp/tmpu3vjwxov.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::with_capacity(x.checked_mul(base).unwrap_or(x.checked_div(base).unwrap_or(10)));\n\
    \    let mut x = x;\n    while x >= base {\n        let digit = x % base;\n  \
    \      s += digit.to_string();\n        x /= base;\n    }\n    s += x.to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvabnbvue.rs:11:39\n   |\n\
    11 |     let mut s = String::with_capacity(x.checked_mul(base).unwrap_or(x.checked_div(base).unwrap_or(10)));\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n11 |     let mut\
    \ s = String::with_capacity(x.checked_mul(base).unwrap_or(x.checked_div(base).unwrap_or(10)).try_into().unwrap());\n\
    \   |                                                                        \
    \                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvabnbvue.rs:15:14\n   |\n15 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvabnbvue.rs:18:10\n\
    \   |\n18 |     s += x.to_string();\n   |          ^^^^^^^^^^^^^\n   |       \
    \   |\n   |          expected `&str`, found struct `String`\n   |          help:\
    \ consider borrowing here: `&x.to_string()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x / base;\n\
    \    let result = x.to_string();\n    while x < 10 {\n        x += (base as isize);\n\
    \        result += (x as isize).to_string();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpiczm5h9n.rs:14:14\n\
    \   |\n14 |         x += (base as isize);\n   |              ^             ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n14 -         x += (base as isize);\n14 +         x += base as isize;\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiczm5h9n.rs:15:19\n  \
    \ |\n15 |         result += (x as isize).to_string();\n   |                  \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                   |\n   |                   expected\
    \ `&str`, found struct `String`\n   |                   help: consider borrowing\
    \ here: `&(x as isize).to_string()`\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x % base;\n\
    \    if x < base {\n        x = base;\n    }\n    String::from(\"{}{}\".format(&x,\
    \ &base))\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `format` found for reference `&'static str`\
    \ in the current scope\n  --> /tmp/tmp33zx1fhn.rs:15:25\n   |\n15 |     String::from(\"\
    {}{}\".format(&x, &base))\n   |                         ^^^^^^ method not found\
    \ in `&'static str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use std::str::FromStr;\n\
    \    let mut result = String::new();\n    loop {\n        let digits = x.to_digits().unwrap();\n\
    \        if digits < base {\n            result.push(digits);\n            x +=\
    \ digits;\n            continue;\n        }\n        let based = digits / base;\n\
    \        let remainder = digits % base;\n        result.push(based.to_string());\n\
    \        x = base;\n        x += remainder;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::str::FromStr`\n  --> /tmp/tmpry_sn6bk.rs:11:9\n\
    \   |\n11 |     use std::str::FromStr;\n   |         ^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmpry_sn6bk.rs:14:24\n\
    \   |\n14 |         let digits = x.to_digits().unwrap();\n   |               \
    \         ^^^^^^^^^ method not found in `isize`\n\nerror[E0277]: can't compare\
    \ `char` with `isize`\n  --> /tmp/tmpry_sn6bk.rs:15:19\n   |\n15 |         if\
    \ digits < base {\n   |                   ^ no implementation for `char < isize`\
    \ and `char > isize`\n   |\n   = help: the trait `PartialOrd<isize>` is not implemented\
    \ for `char`\n   = help: the trait `PartialOrd` is implemented for `char`\n\n\
    error[E0277]: cannot add-assign `char` to `isize`\n  --> /tmp/tmpry_sn6bk.rs:17:15\n\
    \   |\n17 |             x += digits;\n   |               ^^ no implementation\
    \ for `isize += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0369]: cannot divide `char` by `isize`\n  --> /tmp/tmpry_sn6bk.rs:20:28\n\
    \   |\n20 |         let based = digits / base;\n   |                     ------\
    \ ^ ---- isize\n   |                     |\n   |                     char\n\n\
    error[E0369]: cannot mod `char` by `isize`\n  --> /tmp/tmpry_sn6bk.rs:21:32\n\
    \   |\n21 |         let remainder = digits % base;\n   |                     \
    \    ------ ^ ---- isize\n   |                         |\n   |               \
    \          char\n\nwarning: unreachable expression\n  --> /tmp/tmpry_sn6bk.rs:26:5\n\
    \   |\n13 | /     loop {\n14 | |         let digits = x.to_digits().unwrap();\n\
    15 | |         if digits < base {\n16 |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use core::borrow::Cow;\n\
    \    let mut result: Vec<usize> = x.to_string().chars().collect();\n    let mut\
    \ base = base_from_digit(base);\n\n    for mut i = result.len() - 1; i >= 0; i\
    \ -= 1 {\n        let digit = base_to_digit(result[i]);\n        result[i] = digit\
    \ + 1;\n    }\n\n    Cow::Owned(result.into_owned())\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmprhdptf7q.rs:15:14\n  \
    \ |\n15 |     for mut i = result.len() - 1; i >= 0; i -= 1 {\n   |           \
    \   ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  -->\
    \ /tmp/tmprhdptf7q.rs:15:15\n   |\n15 |     for mut i = result.len() - 1; i >=\
    \ 0; i -= 1 {\n   |               ^ expected expression\n\nerror[E0433]: failed\
    \ to resolve: maybe a missing crate `core`?\n  --> /tmp/tmprhdptf7q.rs:11:9\n\
    \   |\n11 |     use core::borrow::Cow;\n   |         ^^^^ maybe a missing crate\
    \ `core`?\n\nerror[E0425]: cannot find function `base_from_digit` in this scope\n\
    \  --> /tmp/tmprhdptf7q.rs:13:20\n   |\n13 |     let mut base = base_from_digit(base);\n\
    \   |                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ a value of type `Vec<usize>` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmprhdptf7q.rs:12:56\n     |\n12   |     let mut\
    \ result: Vec<usize> = x.to_string().chars().collect();\n     |              \
    \                                          ^^^^^^^ value of type `Vec<usize>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<usize>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    for i in x.to_string().chars() {\n        if i.is_digit() {\n     \
    \       if i.to_digit() >= base {\n                s.insert(0, &format!(\"{}\"\
    , i));\n            } else {\n                s.insert(0, &format!(\"{}\", i.to_digit()\
    \ % base));\n            }\n        } else {\n            s.insert(0, \"0\");\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmppfx24yab.rs:13:14\n    |\n13  |         if i.is_digit() {\n  \
    \  |              ^^^^^^^^- supplied 0 arguments\n    |              |\n    |\
    \              expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmppfx24yab.rs:14:18\n    |\n14  |             if i.to_digit() >=\
    \ base {\n    |                  ^^^^^^^^- supplied 0 arguments\n    |       \
    \           |\n    |                  expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfx24yab.rs:14:32\n\
    \   |\n14 |             if i.to_digit() >= base {\n   |                      \
    \          ^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<u32>`\n              found type `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppfx24yab.rs:15:29\n   |\n15 |                 s.insert(0,\
    \ &format!(\"{}\", i));\n   |                             ^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&String`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmppfx24yab.rs:17:46\n    |\n17  |  \
    \               s.insert(0, &format!(\"{}\", i.to_digit() % base));\n    |   \
    \                                           ^^^^^^^^- supplied 0 arguments\n \
    \   |                                              |\n    |                  \
    \                            expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0369]: cannot mod `Option<u32>` by `isize`\n  --> /tmp/tmppfx24yab.rs:17:57\n\
    \   |\n17 |                 s.insert(0, &format!(\"{}\", i.to_digit() % base));\n\
    \   |                                            ------------ ^ ---- isize\n \
    \  |                                            |\n   |                      \
    \                      Option<u32>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfx24yab.rs:20:25\n\
    \   |\n20 |             s.insert(0, \"0\");\n   |                         ^^^\
    \ expected `char`, found `&str`"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ if base == 10 {\n        return String::from(\"0\");\n    }\n    while x >=\
    \ base {\n        x /= base;\n    }\n    let mut rep = String::from(\"\".to_string());\n\
    \    while x >= base {\n        rep.insert(0, x % base);\n        x /= base;\n\
    \    }\n    rep.insert(0, x);\n    rep\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpupmlh83e.rs:20:23\n   |\n\
    20 |         rep.insert(0, x % base);\n   |                       ^^^^^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpupmlh83e.rs:23:19\n\
    \   |\n23 |     rep.insert(0, x);\n   |                   ^ expected `char`, found\
    \ `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    x.div_rem(&base, &mut s);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `div_rem` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp8o7ovj1q.rs:12:7\n   |\n12 |     x.div_rem(&base, &mut\
    \ s);\n   |       ^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \n    let mut base_digit = x.to_digits().collect::<Vec<_>>();\n\n    let mut i\
    \ = 0;\n\n    while i < base_digit.len() {\n        let mut rem = base_digit[i]\
    \ - base;\n        if rem < 0 {\n            base_digit.remove(i);\n         \
    \   i += 1;\n        } else {\n            base_digit[i] = rem + base;\n     \
    \       i += 1;\n        }\n    }\n\n    result.set_str(base_digit, |s| s.to_string());\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpqwkdllr4.rs:13:28\n   |\n13 |     let mut base_digit\
    \ = x.to_digits().collect::<Vec<_>>();\n   |                            ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `set_str` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpqwkdllr4.rs:28:12\n\
    \   |\n28 |     result.set_str(base_digit, |s| s.to_string());\n   |         \
    \   ^^^^^^^ help: there is an associated function with a similar name: `insert_str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    while x > 0 {\n        if x % base == 0 {\n            s += String::from(&format!(\"\
    {}\", x / base));\n        }\n        x = x / base;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplj00_6zd.rs:14:18\n   |\n\
    14 |             s += String::from(&format!(\"{}\", x / base));\n   |        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                  |\n \
    \  |                  expected `&str`, found struct `String`\n   |           \
    \       help: consider borrowing here: `&String::from(&format!(\"{}\", x / base))`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    match x.checked_mul(base) {\n        Some(mut v) => s += &mut to_string(v),\n\
    \        None => {}\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpqyfgfde3.rs:13:34\n\
    \   |\n13 |         Some(mut v) => s += &mut to_string(v),\n   |             \
    \                     ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut ret: String\
    \ = \"\";\n    let mut base_val = x;\n    let mut base_in_hex = base;\n    let\
    \ mut base_in_oct = base;\n    if x > base {\n        base_val -= base;\n    \
    \    base_in_hex = base;\n        base_in_oct = base;\n    }\n    while base_val\
    \ > 0 {\n        ret += to_digit(base_val % base_in_oct);\n        base_val =\
    \ (base_val / base_in_oct).wrapping_mul(base_in_oct);\n    }\n    ret += to_digit(base_val);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_digit` in this scope\n  --> /tmp/tmp400offqt.rs:21:16\n\
    \   |\n21 |         ret += to_digit(base_val % base_in_oct);\n   |           \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_digit`\
    \ in this scope\n  --> /tmp/tmp400offqt.rs:24:12\n   |\n24 |     ret += to_digit(base_val);\n\
    \   |            ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp400offqt.rs:11:27\n   |\n11 |     let mut ret: String =\
    \ \"\";\n   |                  ------   ^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                  |        |\n   |                  |  \
    \      expected struct `String`, found `&str`\n   |                  expected\
    \ due to this\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match x.checked_mul(base)\
    \ {\n        Some(x) => String::from(x),\n        None => String::from(x.to_string()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmp9ky4gaht.rs:12:20\n   |\n12 |         Some(x) => String::from(x),\n\
    \   |                    ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x: i32 = x;\n\
    \    let mut base: i32 = base;\n    let mut result: i32;\n\n    // base can be\
    \ negative or positive\n    if base > 0 && x >= 10 {\n        x = x - 10;\n  \
    \      result = x;\n    }\n    if base < 0 && x <= 10 {\n        result = x *\
    \ -1;\n    }\n\n    let mut s = String::new();\n    while result != 0 {\n    \
    \    s = format!(\"{}{}\", result, s);\n        result = result / base;\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk2s4agyt.rs:11:22\n   |\n\
    11 |     let mut x: i32 = x;\n   |                ---   ^ expected `i32`, found\
    \ `isize`\n   |                |\n   |                expected due to this\n \
    \  |\nhelp: you can convert an `isize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     let mut x: i32 = x.try_into().unwrap();\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk2s4agyt.rs:12:25\n   |\n12 |     let mut base: i32 = base;\n \
    \  |                   ---   ^^^^ expected `i32`, found `isize`\n   |        \
    \           |\n   |                   expected due to this\n   |\nhelp: you can\
    \ convert an `isize` to an `i32` and panic if the converted value doesn't fit\n\
    \   |\n12 |     let mut base: i32 = base.try_into().unwrap();\n   |          \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut new_str = String::from(\"\
    0\");\n    for &b in x.to_digits().iter() {\n        let a = b / base;\n     \
    \   if a > 9 {\n            new_str = new_str.push_str(&format!(\"{}\", a + 10).to_string());\n\
    \        } else {\n            new_str = new_str.push_str(&format!(\"{}\", a).to_string());\n\
    \        }\n    }\n    new_str\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpxfmli9yt.rs:12:17\n   |\n12 |     for &b in x.to_digits().iter()\
    \ {\n   |                 ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxfmli9yt.rs:15:23\n   |\n11 |     let mut new_str\
    \ = String::from(\"0\");\n   |                       ----------------- expected\
    \ due to this value\n...\n15 |             new_str = new_str.push_str(&format!(\"\
    {}\", a + 10).to_string());\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpxfmli9yt.rs:15:31\n   |\n15 |         \
    \    new_str = new_str.push_str(&format!(\"{}\", a + 10).to_string());\n   | \
    \                      ------- ^^^^^^^^ this call modifies `new_str` in-place\n\
    \   |                       |\n   |                       you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxfmli9yt.rs:17:23\n\
    \   |\n11 |     let mut new_str = String::from(\"0\");\n   |                 \
    \      ----------------- expected due to this value\n...\n17 |             new_str\
    \ = new_str.push_str(&format!(\"{}\", a).to_string());\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpxfmli9yt.rs:17:31\n   |\n17 |             new_str = new_str.push_str(&format!(\"\
    {}\", a).to_string());\n   |                       ------- ^^^^^^^^ this call\
    \ modifies `new_str` in-place\n   |                       |\n   |            \
    \           you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    for d in x.checked_mul::<i32>().unwrap() {\n        let d = d * base;\n \
    \       if d < 10 {\n            result.push_str(&d.to_string());\n        } else\
    \ {\n            result.push_str(&format!(\"{:03}\", d).to_string());\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0107]: this associated function takes 0 generic arguments but 1\
    \ generic argument was supplied\n  --> /tmp/tmp8m23n9hs.rs:12:16\n   |\n12 | \
    \    for d in x.checked_mul::<i32>().unwrap() {\n   |                ^^^^^^^^^^^-------\
    \ help: remove these generics\n   |                |\n   |                expected\
    \ 0 generic arguments\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmp8m23n9hs.rs:12:16\n    |\n12  |     for d in x.checked_mul::<i32>().unwrap()\
    \ {\n    |                ^^^^^^^^^^^------- supplied 0 arguments\n    |     \
    \           |\n    |                expected 1 argument\n    |\nnote: associated\
    \ function defined here\n    = note: this error originates in the macro `int_impl`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ `isize` is not an iterator\n  --> /tmp/tmp8m23n9hs.rs:12:14\n   |\n12 |    \
    \ for d in x.checked_mul::<i32>().unwrap() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0107, E0277.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    if x <= base {\n        s ++= &to_digit(x - base);\n    } else {\n\
    \        s ++= &to_digit(x / base) as String;\n        x -= base * to_digit(x\
    \ / base);\n    }\n    while x > 0 {\n        s ++= &to_digit(x / base) as String;\n\
    \        x -= base * to_digit(x / base);\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+=`\n  --> /tmp/tmpcdz0l13m.rs:13:12\n\
    \   |\n13 |         s ++= &to_digit(x - base);\n   |            ^^ expected expression\n\
    \nerror: expected expression, found `+=`\n  --> /tmp/tmpcdz0l13m.rs:15:12\n  \
    \ |\n15 |         s ++= &to_digit(x / base) as String;\n   |            ^^ expected\
    \ expression\n\nerror: expected expression, found `+=`\n  --> /tmp/tmpcdz0l13m.rs:19:12\n\
    \   |\n19 |         s ++= &to_digit(x / base) as String;\n   |            ^^ expected\
    \ expression\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    while x > 0 {\n        result.push((x / base).to_string());\n        x %=\
    \ base;\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo7mzuydg.rs:13:21\n   |\n\
    13 |         result.push((x / base).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!((base >= 2 &&\
    \ base <= 36), \"Invalid base\");\n\n    let mut numeral = String::new();\n\n\
    \    for i in x.to_digits(10) {\n        numeral.push(i / base);\n        numeral.push(i%base);\n\
    \    }\n\n    numeral.to_owned()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp_jitpxqr.rs:15:16\n   |\n15 |     for i in x.to_digits(10)\
    \ {\n   |                ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    let mut str = String::from(\"0\");\n        for x in x.to_string().chars().rev()\
    \ {\n            str = format!(\"{}{}\", str.chars().remove(x), x.to_digit(base).to_string());\n\
    \        }\n        return str;\n    }\n    let mut str = String::from(\"1\");\n\
    \    for i in x.to_string().chars().rev() {\n        let digit = i.to_digit(base).unwrap();\n\
    \        str = format!(\"{}{}\", str.chars().remove(0), digit);\n    }\n    str\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpkle_vrsd.rs:14:47\n   |\n14 |             str =\
    \ format!(\"{}{}\", str.chars().remove(x), x.to_digit(base).to_string());\n  \
    \ |                                               ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkle_vrsd.rs:14:69\n   |\n14 |\
    \             str = format!(\"{}{}\", str.chars().remove(x), x.to_digit(base).to_string());\n\
    \   |                                                                     ^^^^\
    \ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n14 |             str = format!(\"\
    {}{}\", str.chars().remove(x), x.to_digit(base.try_into().unwrap()).to_string());\n\
    \   |                                                                        \
    \ ++++++++++++++++++++\n\nerror[E0599]: `Option<u32>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmpkle_vrsd.rs:14:75\n    |\n14  |               str = format!(\"\
    {}{}\", str.chars().remove(x), x.to_digit(base).to_string());\n    |         \
    \                                                                    ^^^^^^^^^\
    \ `Option<u32>` cannot be formatted with the default formatter\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<u32>: std::fmt::Display`\n\
    \            which is required by `Option<u32>: ToString`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkle_vrsd.rs:20:32\n   |\n20 |         let digit = i.to_digit(base).unwrap();\n\
    \   |                                ^^^^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n20 |         let digit = i.to_digit(base.try_into().unwrap()).unwrap();\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `remove` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmpkle_vrsd.rs:21:43\n   |\n21 |         str = format!(\"{}{}\", str.chars().remove(0),\
    \ digit);\n   |                        "
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < 10 {\n      \
    \  if base < 10 {\n            format!(\"0{}\", x)\n        } else {\n       \
    \     format!(\"{}\", x)\n        }\n    } else {\n        let mut res = String::from(\"\
    \".to_string());\n        let mut base = x % base;\n        for i in 1..10 {\n\
    \            let mut c = base / i;\n            base = i % base;\n           \
    \ res.push_str(&format!(\"{}\", c));\n        }\n        res.push_str(&format!(\"\
    {}\", base));\n        res\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"08\"`,\n right: `\"22\"`', /tmp/tmpaqb2njcd.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s: String =\
    \ \"\".to_string();\n    let mut base_num: isize = 1;\n    for y in x.divmod_mul(base)\
    \ {\n        base_num *= base;\n        if y < base_num {\n            s += char::from(\"\
    0\").to_string();\n        } else {\n            s += char::from(\"1\").to_string();\n\
    \        }\n    }\n    s += String::from_str(&x.to_string()[..base_num.digits()\
    \ - 1]).unwrap()\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `divmod_mul` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpqv6zenwm.rs:13:16\n   |\n13 |     for y in x.divmod_mul(base)\
    \ {\n   |                ^^^^^^^^^^ method not found in `isize`\n\nerror[E0277]:\
    \ the trait bound `char: From<&str>` is not satisfied\n  --> /tmp/tmpqv6zenwm.rs:16:18\n\
    \   |\n16 |             s += char::from(\"0\").to_string();\n   |            \
    \      ^^^^^^^^^^ the trait `From<&str>` is not implemented for `char`\n   |\n\
    \   = help: the trait `From<u8>` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqv6zenwm.rs:16:18\n   |\n16 |             s += char::from(\"\
    0\").to_string();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \               |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&char::from(\"0\").to_string()`\n\
    \nerror[E0277]: the trait bound `char: From<&str>` is not satisfied\n  --> /tmp/tmpqv6zenwm.rs:18:18\n\
    \   |\n18 |             s += char::from(\"1\").to_string();\n   |            \
    \      ^^^^^^^^^^ the trait `From<&str>` is not implemented for `char`\n   |\n\
    \   = help: the trait `From<u8>` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqv6zenwm.rs:18:18\n   |\n18 |             s += char::from(\"\
    1\").to_string();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \               |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&char::from(\"1\").to_string()`\n\
    \nerror[E0599]: no function or associated item named `from_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpqv6zenwm.rs:21:18\n   |\n21 | \
    \    s += String::from_str(&x.to_string()[..base_num.digits() - 1]).unwrap()\n\
    \   |                  ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no method\
    \ named"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    x.to_string().parse::<usize>().checked_mul(base).ok()\n\
    \        .to_string()\n        .parse::<isize>()\n        .ok()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_mul` found for enum `Result` in\
    \ the current scope\n  --> /tmp/tmp4c5f7f02.rs:11:36\n   |\n11 |     x.to_string().parse::<usize>().checked_mul(base).ok()\n\
    \   |                                    ^^^^^^^^^^^ method not found in `Result<usize,\
    \ ParseIntError>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x != 0 && base !=\
    \ 0 && base < 10 {\n        let mut result = String::new();\n        if base >\
    \ 10 {\n            result.push_str(&format!(\"{:#}\", x / base));\n         \
    \   result.push_str(&format!(\"0{}\", base % base));\n        } else {\n     \
    \       result.push_str(&format!(\"{}\", x % base));\n        }\n        result\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmp9m4mkv6v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    for n in x.to_string().chars().skip(base) {\n        s.push_str(&n.to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7esurwex.rs:12:41\n   |\n\
    12 |     for n in x.to_string().chars().skip(base) {\n   |                   \
    \                      ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n12 |     for n in x.to_string().chars().skip(base.try_into().unwrap())\
    \ {\n   |                                             ++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!(base < 10);\n\
    \    let mut result = String::from(\"\".to_string());\n    if base < 10 {\n  \
    \      result = result.push_str(&x.to_string());\n    }\n    if base > 10 {\n\
    \        let mut digits = x.to_string().chars().collect::<Vec<_>>();\n       \
    \ for i in base..10 {\n            digits.insert((base * i) - 10, i);\n      \
    \  }\n        result = result.push_str(&digits.join(\"\"));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7h56y_n4.rs:14:18\n   |\n\
    12 |     let mut result = String::from(\"\".to_string());\n   |              \
    \        ---------------------------- expected due to this value\n13 |     if\
    \ base < 10 {\n14 |         result = result.push_str(&x.to_string());\n   |  \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmp7h56y_n4.rs:14:25\n\
    \   |\n14 |         result = result.push_str(&x.to_string());\n   |          \
    \        ------ ^^^^^^^^ this call modifies `result` in-place\n   |          \
    \        |\n   |                  you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7h56y_n4.rs:19:27\n   |\n19 |\
    \             digits.insert((base * i) - 10, i);\n   |                       \
    \    ^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |             digits.insert(((base * i) - 10).try_into().unwrap(), i);\n  \
    \ |                           +               +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7h56y_n4.rs:19:44\n   |\n19 |             digits.insert((base\
    \ * i) - 10, i);\n   |                                            ^ expected `char`,\
    \ found `isize`\n\nerror[E0599]: the method `join` exists for struct `Vec<char>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp7h56y_n4.rs:21:42\n \
    \  |\n21 |         result = result.push_str(&digits.join(\"\"));\n   |       \
    \                                   ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7h56y_n4.rs:21:18\n   |\n12 |     let mut result = String::from(\"\
    \".to_string());\n   |                      ---------------------------- expected\
    \ due to this value\n...\n21 |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(x);\n\
    \    let mut result = String::new();\n    while base > 0 {\n        let mut rem\
    \ = &s[..base.digits().len()];\n        let mut digits = &mut result[..base.digits().len()];\n\
    \        digits.copy_from_slice(rem.digits());\n        let mut carry = &mut digits[base.digits().len()];\n\
    \        let mut quotient = x;\n        let mut remainder = 0;\n        while\
    \ quotient > 0 {\n            carry += &mut quotient % 10;\n            quotient\
    \ /= 10;\n        }\n        if carry > 0 {\n            carry += 1;\n       \
    \     digits.insert(0, &mut carry);\n        }\n        result = &result[..base.digits().len()]\
    \ + &digits[base.digits().len()..];\n        base /= 10;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmpkwntni8x.rs:11:17\n   |\n11 |     let mut s = String::from(x);\n\
    \   |                 ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpkwntni8x.rs:14:33\n   |\n14 |         let mut rem = &s[..base.digits().len()];\n\
    \   |                                 ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpkwntni8x.rs:15:45\n   |\n15 |         let mut digits = &mut result[..base.digits().len()];\n\
    \   |                                             ^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `copy_from_slice` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpkwntni8x.rs:16:16\n   |\n16 |\
    \         digits.copy_from_slice(rem.digits());\n   |                ^^^^^^^^^^^^^^^\
    \ method not found in `&mut str`\n\nerror[E0599]: no method named `digits` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpkwntni8x.rs:16:36\n\
    \   |\n16 |         digits.copy_from_slice(rem.digits());\n   |              \
    \                      ^^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `digits` found for type `isize` in the current scope\n  --> /tmp/tmpkwntni8x.rs:17:42\n\
    \   |\n17 |         let mut carry = &mut digits[base.digits().len()];\n   |  \
    \                                        ^^^^^^ method not found in `isize`\n\n\
    error[E0369]: cannot mod `&mut isize` by `{integer}`\n  --> /tmp/tmpkwntni8x.rs:21:36\n\
    \   |\n21 |             carry += &mut quotient % 10;\n   |                   \
    \   ------------- ^ -- {integer}\n   |                 "
  stdout: ''
  timestamp: 1659976155
- exit_code: -1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut new_x = x;\n\
    \    while new_x != 0 {\n        let new_base = if base > 10 { base % 10 } else\
    \ { 0 };\n        let mut new_num = new_x % base;\n        new_x /= base;\n  \
    \      new_x = new_base * new_x + new_num;\n    }\n    String::from(format!(\"\
    {:?}\", new_x))\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    if base < 10 {\n            return String::from(\"0\".to_string(base));\n\
    \        } else {\n            return String::from(x.to_string(base));\n     \
    \   }\n    }\n    let mut res = String::new();\n    for i in 0..x.len() {\n  \
    \      res.extend(&x.chars().nth(i).unwrap().to_string());\n    }\n    let mut\
    \ base = BigUint::from(base);\n    while base.is_even() {\n        if res.length()\
    \ > base.len() {\n            base.negate();\n        }\n        res.insert(res.len()\
    \ - base.len(), base.to_string());\n        base.mul_mod(2, &base);\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BigUint`\n  -->\
    \ /tmp/tmprbszccq6.rs:22:20\n   |\n22 |     let mut base = BigUint::from(base);\n\
    \   |                    ^^^^^^^ use of undeclared type `BigUint`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmprbszccq6.rs:13:37\n\
    \     |\n13   |             return String::from(\"0\".to_string(base));\n    \
    \ |                                     ^^^^^^^^^ ---- supplied 1 argument\n \
    \    |                                     |\n     |                         \
    \            expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmprbszccq6.rs:15:35\n     |\n15   |             return String::from(x.to_string(base));\n\
    \     |                                   ^^^^^^^^^ ---- supplied 1 argument\n\
    \     |                                   |\n     |                          \
    \         expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmprbszccq6.rs:19:19\n   |\n19 |     for i in 0..x.len() {\n   | \
    \                  ^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `chars` found for type `isize` in the current scope\n  --> /tmp/tmprbszccq6.rs:20:23\n\
    \   |\n20 |         res.extend(&x.chars().nth(i).unwrap().to_string());\n   |\
    \                       ^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmprbszccq6.rs:24:16\n   |\n24 |         if res.length() > base.len() {\n\
    \   |                ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut buff = String::new();\n\
    \    let mut rem = x;\n    while rem != 0 {\n        let q = rem / base;\n   \
    \     rem = rem % base;\n        buff.push((base * q).to_string());\n    }\n \
    \   buff\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4e82w2kw.rs:16:19\n   |\n\
    16 |         buff.push((base * q).to_string());\n   |                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    x.to_string().chars().for_each(|c| {\n        let digit = match c as char\
    \ {\n            '0' | '1' => c - '0',\n            '2' | '3' => c - '2',\n  \
    \          '4' | '5' => c - '4',\n            '6' | '7' => c - '6',\n        \
    \    '8' | '9' => c - '8',\n            _ => panic!(\"Invalid character {:?} in\
    \ change base!\", c),\n        };\n        if digit < base {\n            result.append(digit\
    \ as char);\n        } else {\n            result.push((base - digit) as char);\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpshu5n_ef.rs:14:28\n\
    \   |\n14 |             '0' | '1' => c - '0',\n   |                          -\
    \ ^ --- char\n   |                          |\n   |                          char\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpshu5n_ef.rs:15:28\n\
    \   |\n15 |             '2' | '3' => c - '2',\n   |                          -\
    \ ^ --- char\n   |                          |\n   |                          char\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpshu5n_ef.rs:16:28\n\
    \   |\n16 |             '4' | '5' => c - '4',\n   |                          -\
    \ ^ --- char\n   |                          |\n   |                          char\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpshu5n_ef.rs:17:28\n\
    \   |\n17 |             '6' | '7' => c - '6',\n   |                          -\
    \ ^ --- char\n   |                          |\n   |                          char\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpshu5n_ef.rs:18:28\n\
    \   |\n18 |             '8' | '9' => c - '8',\n   |                          -\
    \ ^ --- char\n   |                          |\n   |                          char\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpshu5n_ef.rs:22:20\n   |\n22 |             result.append(digit\
    \ as char);\n   |                    ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    \");\n    loop {\n        if x >= base {\n            x -= base;\n           \
    \ s = format!(\"{}{}\", s, x);\n        } else {\n            s += &format!(\"\
    {}\", x);\n            break;\n        }\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpi9cscnq1.rs:14:13\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n14 |      \
    \       x -= base;\n   |             ^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    String::from(format!(\"\
    {}{:0>+}\".to_string(), x, base))\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `,`, found `.`\n  --> /tmp/tmp6djo5rry.rs:11:36\n   |\n\
    11 |     String::from(format!(\"{}{:0>+}\".to_string(), x, base))\n   |      \
    \                              ^ expected `,`\n\nerror: argument never used\n\
    \  --> /tmp/tmp6djo5rry.rs:11:53\n   |\n11 |     String::from(format!(\"{}{:0>+}\"\
    .to_string(), x, base))\n   |                          ----------            \
    \     ^^^^ argument never used\n   |                          |\n   |        \
    \                  formatting specifier missing\n\nerror[E0425]: cannot find function\
    \ `to_string` in this scope\n  --> /tmp/tmp6djo5rry.rs:11:37\n   |\n11 |     String::from(format!(\"\
    {}{:0>+}\".to_string(), x, base))\n   |                                     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x >= base * 10 +\
    \ 1 && x <= base {\n        let mut result = String::from(\"1\");\n        let\
    \ digit = x / base % 10;\n        result.push_str(&format!(\"{:0>0{}}\", digit,\
    \ base - 1));\n        return result;\n    }\n    format!(\"{}\", x)\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmp8m69yb3f.rs:14:40\n\
    \   |\n14 |         result.push_str(&format!(\"{:0>0{}}\", digit, base - 1));\n\
    \   |                                   -    ^ expected `}` in format string\n\
    \   |                                   |\n   |                              \
    \     because of this opening brace\n   |\n   = note: if you intended to print\
    \ `{`, you can escape it using `{{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x <= 0 {\n      \
    \  String::from(\"0\")\n    }\n    if base < 2 {\n        String::from(\"0\")\n\
    \    }\n    if base < 10 {\n        match x {\n            1 => String::from(\"\
    1\"),\n            x => String::from(\n                format!(\"{}{}\", x / base,\
    \ change_base((x - x / base) * base, base).to_owned())\n            ),\n     \
    \   }\n    } else {\n        match x {\n            1 => String::from(\"10\"),\n\
    \            x => String::from(\n                format!(\"{}{}\", x / base, change_base((x\
    \ - x / base) * base, base).to_owned())\n            ),\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi_88ri_7.rs:12:9\n   |\n\
    11 | /     if x <= 0 {\n12 | |         String::from(\"0\")\n   | |         ^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n13 | |     }\n   | |_____- expected this\
    \ to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n12 |        \
    \ String::from(\"0\");\n   |                          +\nhelp: consider using\
    \ a semicolon here\n   |\n13 |     };\n   |      +\nhelp: you might have meant\
    \ to return this value\n   |\n12 |         return String::from(\"0\");\n   | \
    \        ++++++                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_88ri_7.rs:15:9\n\
    \   |\n14 | /     if base < 2 {\n15 | |         String::from(\"0\")\n   | |  \
    \       ^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n16 | |     }\n\
    \   | |_____- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n15 |         String::from(\"0\");\n   |                        \
    \  +\nhelp: consider using a semicolon here\n   |\n16 |     };\n   |      +\n\
    help: you might have meant to return this value\n   |\n15 |         return String::from(\"\
    0\");\n   |         ++++++                  +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::with_capacity(x);\n\
    \    for &n in x.to_string().chars().take(x.len() * 2) {\n        result.push((n\
    \ % base) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplda69atc.rs:11:44\n   |\n\
    11 |     let mut result = String::with_capacity(x);\n   |                    \
    \                        ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n11 |     let mut result = String::with_capacity(x.try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmplda69atc.rs:12:44\n\
    \   |\n12 |     for &n in x.to_string().chars().take(x.len() * 2) {\n   |    \
    \                                        ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplda69atc.rs:12:9\n   |\n12 |     for &n in x.to_string().chars().take(x.len()\
    \ * 2) {\n   |         ^^    --------------------------------------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `n`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut i = x;\n    while (i /= base) {\n        *s = i.to_string().to_string()[..1];\n\
    \        s += *s;\n    }\n    s += x.to_string()[..];\n    String::from(s)\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpq_94kqr6.rs:13:11\n\
    \   |\n13 |     while (i /= base) {\n   |           ^         ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    13 -     while (i /= base) {\n13 +     while i /= base {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq_94kqr6.rs:13:11\n   |\n13 |     while (i /=\
    \ base) {\n   |           ^^^^^^^^^^^ expected `bool`, found `()`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpq_94kqr6.rs:14:9\n   |\n14 |         *s = i.to_string().to_string()[..1];\n\
    \   |         ^^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: the left-hand-side of\
    \ an assignment must have a statically known size\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq_94kqr6.rs:15:14\n   |\n15 |         s += *s;\n   |  \
    \            ^^\n   |              |\n   |              expected `&str`, found\
    \ `str`\n   |              help: consider borrowing here: `&*s`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq_94kqr6.rs:17:10\n   |\n17 |     s += x.to_string()[..];\n\
    \   |          ^^^^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`,\
    \ found `str`\n   |          help: consider borrowing here: `&x.to_string()[..]`\n\
    \nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    return String::from(\"0\".to_string(base).to_string());\n    }\n    let mut\
    \ s = String::from(\"1\".to_string(base).to_string());\n    x.to_string().reverse().iter().for_each(|&i|\
    \ {\n        s.push((i as usize) - base + 1).to_string();\n    });\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpgto5d5dm.rs:12:33\n     |\n12   |         return String::from(\"\
    0\".to_string(base).to_string());\n     |                                 ^^^^^^^^^\
    \ ---- supplied 1 argument\n     |                                 |\n     | \
    \                                expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n    --> /tmp/tmpgto5d5dm.rs:14:34\n     |\n14   |   \
    \  let mut s = String::from(\"1\".to_string(base).to_string());\n     |      \
    \                            ^^^^^^^^^ ---- supplied 1 argument\n     |      \
    \                            |\n     |                                  expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpgto5d5dm.rs:15:19\n   |\n15 |     x.to_string().reverse().iter().for_each(|&i|\
    \ {\n   |                   ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgto5d5dm.rs:16:31\n\
    \   |\n16 |         s.push((i as usize) - base + 1).to_string();\n   |       \
    \                        ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract `isize` from `usize`\n  --> /tmp/tmpgto5d5dm.rs:16:29\n   |\n\
    16 |         s.push((i as usize) - base + 1).to_string();\n   |              \
    \               ^ no implementation for `usize - isize`\n   |\n   = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgto5d5dm.rs:16:16\n   |\n16 |         s.push("
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    x.to_string().chars().map(|x|\
    \ *x).collect::<String>().to_string()\n        .chars()\n        .enumerate()\n\
    \        .filter(|(i, _)| i >= base)\n        .map(|(i, _)| {\n            let\
    \ mut n = x.to_string().chars().map(|x| *x).collect::<String>();\n           \
    \ n.insert(i, *base);\n            String::from(n)\n        })\n        .collect::<Vec<String>>()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6wtjmm2j.rs:11:35\n\
    \   |\n11 |     x.to_string().chars().map(|x| *x).collect::<String>().to_string()\n\
    \   |                                   ^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6wtjmm2j.rs:14:31\n   |\n14 |         .filter(|(i, _)| i >= base)\n\
    \   |                               ^^^^ expected `&usize`, found `isize`\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6wtjmm2j.rs:16:55\n\
    \   |\n16 |             let mut n = x.to_string().chars().map(|x| *x).collect::<String>();\n\
    \   |                                                       ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp6wtjmm2j.rs:17:25\n   |\n\
    17 |             n.insert(i, *base);\n   |                         ^^^^^\n\nerror[E0599]:\
    \ `Vec<String>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmp6wtjmm2j.rs:21:10\n\
    \    |\n21  |           .to_string()\n    |            ^^^^^^^^^ `Vec<String>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<String>: std::fmt::Display`\n\
    \            which is required by `Vec<String>: ToString`\n            `[String]:\
    \ std::fmt::Display`\n            which is required by `[String]: ToString`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result: String\
    \ = String::new();\n    while x > 0 {\n        let quotient = x / base;\n    \
    \    x = x - quotient * base;\n        let digit = x.to_digit(base, 10);\n   \
    \     result.append(&digit);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpt17bof27.rs:15:23\n   |\n15 |         let digit\
    \ = x.to_digit(base, 10);\n   |                       ^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpt17bof27.rs:16:16\n   |\n16 |         result.append(&digit);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = \"\
    1\";\n    for &d in x.to_string().chars() {\n        let digit = match d { \n\
    \            '0' => 0, \n            '1' => 1, \n            '2' => 2, \n    \
    \        '3' => 3, \n            '4' => 4, \n            '5' => 5, \n        \
    \    '6' => 6, \n            '7' => 7, \n            '8' => 8, \n            '9'\
    \ => 9, \n            _ => unimplemented!()\n        };\n        result = format!(\"\
    {}{}\", result, digit.to_string());\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyoae7d6z.rs:12:9\n   |\n\
    12 |     for &d in x.to_string().chars() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `d`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyoae7d6z.rs:26:18\n  \
    \ |\n26 |         result = format!(\"{}{}\", result, digit.to_string());\n   |\
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyoae7d6z.rs:28:5\n   |\n10 | fn change_base(x:\
    \ isize, base: isize) -> String {\n   |                                      \
    \    ------ expected `String` because of return type\n...\n28 |     result\n \
    \  |     ^^^^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \  |\n   |     expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut string = String::new();\n\
    \    let mut remain = x;\n    while remain > base {\n        remain = remain -\
    \ base;\n        string.push((remain / base).to_string());\n    }\n    if remain\
    \ > 0 {\n        string.push((remain / base).to_string());\n    }\n    string\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcd0f5ly5.rs:15:21\n   |\n\
    15 |         string.push((remain / base).to_string());\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcd0f5ly5.rs:18:21\n   |\n18 |         string.push((remain\
    \ / base).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!(base > 0 &&\
    \ base < 10);\n    match base {\n        1 => String::from(x),\n        2 => {\n\
    \            let mut r = String::from(\"\");\n            r.push(x);\n       \
    \     while r.len() < x.len() {\n                r.push(x.chars().nth(x.len()\
    \ - 1 - r.len()).unwrap().to_string());\n            }\n            r\n      \
    \  }\n        _ => {\n            let mut r = String::from(\"\");\n          \
    \  r.push(x);\n            while r.len() < x.len() {\n                r.push(x[x.len()\
    \ - 1 - r.len()]);\n            }\n            r\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmp7uab905u.rs:13:14\n   |\n13 |         1 => String::from(x),\n \
    \  |              ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7uab905u.rs:16:20\n   |\n16 |\
    \             r.push(x);\n   |                    ^ expected `char`, found `isize`\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp7uab905u.rs:17:31\n   |\n17 |             while r.len() < x.len()\
    \ {\n   |                               ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `chars` found for type `isize` in the current scope\n  --> /tmp/tmp7uab905u.rs:18:26\n\
    \   |\n18 |                 r.push(x.chars().nth(x.len() - 1 - r.len()).unwrap().to_string());\n\
    \   |                          ^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp7uab905u.rs:18:40\n\
    \   |\n18 |                 r.push(x.chars().nth(x.len() - 1 - r.len()).unwrap().to_string());\n\
    \   |                                        ^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7uab905u.rs:24:20\n   |\n24 |\
    \             r.push(x);\n   |                    ^ expected `char`, found `isize`\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp7uab905u.rs:25:31\n   |\n25 |             while r.len() < x.len()\
    \ {\n   |                               ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp7uab905u.rs:26:28\n\
    \   |\n26 |                 r.push(x[x.len() - 1 - r.len()]);\n   |          \
    \           "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut tmp = x;\n    let mut power: Vec<isize> = vec![1isize; base];\n\n\
    \    while tmp >= 10isize {\n        tmp = tmp / 10isize;\n        power = power.push(1isize);\n\
    \    }\n\n    for n in power.iter() {\n        s = s.push_str(&format!(\"{}\"\
    , tmp % 10).unwrap());\n        tmp = tmp / n;\n    }\n    s += s.push_str(&format!(\"\
    {}\", tmp).unwrap());\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiqjzmkni.rs:13:46\n   |\n\
    13 |     let mut power: Vec<isize> = vec![1isize; base];\n   |               \
    \                               ^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n13 |     let mut power: Vec<isize> = vec![1isize; base.try_into().unwrap()];\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiqjzmkni.rs:17:17\n   |\n13 |  \
    \   let mut power: Vec<isize> = vec![1isize; base];\n   |                    ----------\
    \ expected due to this type\n...\n17 |         power = power.push(1isize);\n \
    \  |                 ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    note: method `push` modifies its receiver in-place\n  --> /tmp/tmpiqjzmkni.rs:17:23\n\
    \   |\n17 |         power = power.push(1isize);\n   |                 ----- ^^^^\
    \ this call modifies `power` in-place\n   |                 |\n   |          \
    \       you probably want to use this value after calling the method...\n   =\
    \ note: ...instead of the `()` output of method `push`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpiqjzmkni.rs:21:49\n\
    \   |\n21 |         s = s.push_str(&format!(\"{}\", tmp % 10).unwrap());\n   |\
    \                                                 ^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiqjzmkni.rs:21:13\n   |\n11 |\
    \     let mut s = String::new();\n   |                 ------------- expected\
    \ due to this value\n...\n21 |         s = s.push_str(&format!(\"{}\", tmp % 10).unwrap());\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n\
    \  --> /tmp/tmpiqjzmkni.rs:21:15\n   |\n21 |         s = s.push_str(&format!(\"\
    {}\", tmp % 10).unwrap());\n   |             - ^^^^^^^^ this call modifies `s`\
    \ in-place\n   |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    s.push_str(&x.to_string());\n    let mut pos = 0;\n    let mut digits = x.digits();\n\
    \    let mut x = digits.get(base);\n    while x >= 10 {\n        s.insert(pos,\
    \ x % 10);\n        x /= 10;\n        pos.push((x % 10) + 1);\n    }\n    s.insert(pos,\
    \ x);\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpr7m5o3ts.rs:14:24\n   |\n14 |     let mut digits = x.digits();\n\
    \   |                        ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `push` found for type `usize` in the current scope\n  --> /tmp/tmpr7m5o3ts.rs:19:13\n\
    \   |\n19 |         pos.push((x % 10) + 1);\n   |             ^^^^ method not\
    \ found in `usize`\n\nerror[E0277]: can't compare `char` with `{integer}`\n  -->\
    \ /tmp/tmpr7m5o3ts.rs:16:13\n   |\n16 |     while x >= 10 {\n   |            \
    \ ^^ no implementation for `char < {integer}` and `char > {integer}`\n   |\n \
    \  = help: the trait `PartialOrd<{integer}>` is not implemented for `char`\n \
    \  = help: the trait `PartialOrd` is implemented for `char`\n\nerror[E0277]: cannot\
    \ mod `char` by `{integer}`\n  --> /tmp/tmpr7m5o3ts.rs:17:25\n   |\n17 |     \
    \    s.insert(pos, x % 10);\n   |                         ^ no implementation\
    \ for `char % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not implemented\
    \ for `char`\n\nerror[E0277]: cannot divide-assign `char` by `{integer}`\n  -->\
    \ /tmp/tmpr7m5o3ts.rs:18:11\n   |\n18 |         x /= 10;\n   |           ^^ no\
    \ implementation for `char /= {integer}`\n   |\n   = help: the trait `DivAssign<{integer}>`\
    \ is not implemented for `char`\n\nerror[E0277]: cannot mod `char` by `{integer}`\n\
    \  --> /tmp/tmpr7m5o3ts.rs:19:21\n   |\n19 |         pos.push((x % 10) + 1);\n\
    \   |                     ^ no implementation for `char % {integer}`\n   |\n \
    \  = help: the trait `Rem<{integer}>` is not implemented for `char`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    return String::from(\"0\");\n    }\n    let mut result = String::from(\"\
    1\");\n    while x >= base {\n        if x > base {\n            result += String::from(\"\
    0\");\n        }\n        result += '0';\n        x -= base;\n    }\n    result\
    \ += '0';\n    while x >= base {\n        if x > base {\n            result +=\
    \ '0';\n        }\n        result += String::from('0');\n        x -= base;\n\
    \    }\n    while x < base {\n        if x < base {\n            result += String::from(\"\
    0\");\n        }\n        result += '0';\n        x += base;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:17:23\n   |\n\
    17 |             result += String::from(\"0\");\n   |                       ^^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&str`, found\
    \ struct `String`\n   |                       help: consider borrowing here: `&String::from(\"\
    0\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:19:19\n   |\n\
    19 |         result += '0';\n   |                   ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n19 |         result += \"0\";\n   |                   ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbt_k489l.rs:22:15\n   |\n22 |     result +=\
    \ '0';\n   |               ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n22 |     result +=\
    \ \"0\";\n   |               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:25:23\n\
    \   |\n25 |             result += '0';\n   |                       ^^^ expected\
    \ `&str`, found `char`\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n25 |             result += \"0\";\n   |               \
    \        ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:27:19\n\
    \   |\n27 |         result += String::from('0');\n   |                   ^^^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&str`, found struct\
    \ `String`\n   |                   help: consider borrowing here: `&String::from('0')`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:32:23\n   |\n32 |\
    \             result += String::from(\"0\");\n   |                       ^^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected `&str`, found\
    \ struct `String`\n   |                       help: consider borrowing here: `&String::from(\"\
    0\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbt_k489l.rs:34:19\n   |\n\
    34 |         result += '0';\n   |                   ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    fn get_digit(digit:\
    \ isize) -> String {\n        format!(\"{:0{}}\", digit, base)\n    }\n\n    let\
    \ mut result = String::from(\"\");\n    let mut current_digit = x; // start with\
    \ x as the value of the digit.\n    while current_digit > 0 {\n        let remain\
    \ = current_digit % base;\n        result.push( get_digit(remain));\n        current_digit\
    \ /= base;\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpfbzj0p3n.rs:12:21\n\
    \   |\n12 |         format!(\"{:0{}}\", digit, base)\n   |                  -\
    \  ^ expected `}` in format string\n   |                  |\n   |            \
    \      because of this opening brace\n   |\n   = note: if you intended to print\
    \ `{`, you can escape it using `{{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfbzj0p3n.rs:19:22\n\
    \   |\n19 |         result.push( get_digit(remain));\n   |                   \
    \   ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder = x%base;\n\
    \        x /= base;\n        s = format!(\"{}{}\", s, &remainder);\n    }\n  \
    \  if x > 0 {\n        s = format!(\"{}{}\", s, x);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpo9lwsmns.rs:12:13\n\
    \   |\n12 |     let mut remainder = 0;\n   |             ^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `x`\n\
    \  --> /tmp/tmpo9lwsmns.rs:15:9\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n15 |         x /= base;\n   |         ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 0 || base\
    \ > 10 {\n        panic!(\"Base must be between 0 and 10\");\n    }\n    let mut\
    \ s: String = \"\";\n    for i in x.to_string().chars().rev() {\n        if base\
    \ % i == 0 {\n            s += &i.to_string();\n            base /= i;\n     \
    \   }\n    }\n    s + \"0\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp39jp7c47.rs:14:25\n   |\n\
    14 |     let mut s: String = \"\";\n   |                ------   ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                |        |\n\
    \   |                |        expected struct `String`, found `&str`\n   |   \
    \             expected due to this\n\nerror[E0277]: cannot mod `isize` by `char`\n\
    \  --> /tmp/tmp39jp7c47.rs:16:17\n   |\n16 |         if base % i == 0 {\n   |\
    \                 ^ no implementation for `isize % char`\n   |\n   = help: the\
    \ trait `Rem<char>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n    \
    \         <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n      \
    \       <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n          \
    \   <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a\
    \ isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]: cannot divide-assign\
    \ `isize` by `char`\n  --> /tmp/tmp39jp7c47.rs:18:18\n   |\n18 |             base\
    \ /= i;\n   |                  ^^ no implementation for `isize /= char`\n   |\n\
    \   = help: the trait `DivAssign<char>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `DivAssign<Rhs>`:\n             <f32\
    \ as DivAssign<&f32>>\n             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n\
    \             <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n  \
    \           <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n     \
    \        <i16 as DivAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp39jp7c47.rs:21:9\n   |\n21 |     s + \"0\".to_string()\n\
    \   |         ^^^^^^^^^^^^^^^\n   |         |\n   |         expected `&str`, found\
    \ struct `String`\n   |         help: consider borrowing here: `&\"0\".to_string()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::with_capacity(10);\n\
    \    let mut temp: isize = x;\n    let mut base = base;\n    while temp > 0 {\n\
    \        let digit = temp mod base;\n        result.push((digit as char).to_string());\n\
    \        temp /= base;\n    }\n    if base > 2 {\n        result.push((base as\
    \ char).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator,\
    \ found keyword `mod`\n  --> /tmp/tmpod208gbe.rs:15:26\n   |\n15 |         let\
    \ digit = temp mod base;\n   |                          ^^^ expected one of 8\
    \ possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpod208gbe.rs:20:21\n\
    \   |\n20 |         result.push((base as char).to_string());\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpod208gbe.rs:20:21\n\
    \   |\n20 |         result.push((base as char).to_string());\n   |           \
    \          ^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpod208gbe.rs:20:21\n   |\n20 |         result.push((base\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0604.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\n        \"\
    {:0{}b}\",\n        x as u32, base\n    )\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpjm771trv.rs:12:13\n\
    \   |\n12 |         \"{:0{}b}\",\n   |          -  ^ expected `}` in format string\n\
    \   |          |\n   |          because of this opening brace\n   |\n   = note:\
    \ if you intended to print `{`, you can escape it using `{{`\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!(base < 10);\n\
    \    let mut res = String::new();\n    let mut num = x;\n    for _ in 0..base\
    \ {\n        res.push_str(&num.to_string());\n        num -= 1;\n    }\n    res.push_str(&num.to_string());\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8765\"`,\n right: `\"22\"`', /tmp/tmp_vf6mrbw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ match base {\n        2 => {\n            x = x * 2;\n            String::from_str(\"\
    100\")\n        }\n        3 => {\n            x = x * 3;\n            String::from_str(\"\
    1000\")\n        }\n        4 => {\n            x = x * 4;\n            String::from_str(\"\
    10000\")\n        }\n        5 => {\n            x = x * 5;\n            String::from_str(\"\
    100000\")\n        }\n        6 => {\n            x = x * 6;\n            String::from_str(\"\
    1000000\")\n        }\n        7 => {\n            x = x * 7;\n            String::from_str(\"\
    10000000\")\n        }\n        8 => {\n            x = x * 8;\n            String::from_str(\"\
    100000000\")\n        }\n        9 => {\n            x = x * 9;\n            String::from_str(\"\
    1000000000\")\n        }\n        10 => {\n            x = x * 10;\n         \
    \   String::from_str(\"10000000000\")\n        }\n        _ => panic!(\"Base is\
    \ out of range\"),\n    }\n    String::from_str(format!(\"{}\", x))\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmprgp5m6g5.rs:15:21\n   |\n\
    15 |             String::from_str(\"100\")\n   |                     ^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::str::FromStr;\n   |\n\nerror[E0599]: no function or associated item named\
    \ `from_str` found for struct `String` in the current scope\n  --> /tmp/tmprgp5m6g5.rs:19:21\n\
    \   |\n19 |             String::from_str(\"1000\")\n   |                     ^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::str::FromStr;\n   |\n\nerror[E0599]: no function or associated item named\
    \ `from_str` found for struct `String` in the current scope\n  --> /tmp/tmprgp5m6g5.rs:23:21\n\
    \   |\n23 |             String::from_str(\"10000\")\n   |                    \
    \ ^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or associated item\
    \ named `from_str` found for struct `String` in the current scope\n  --> /tmp/tmprgp5m6g5.rs:27:21\n\
    \   |\n27 |             String::from_str(\"100000\")\n   |                   \
    \  ^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or associated item\
    \ named `from_str` found for struct `String` in the current scope\n  --> /tmp/tmprgp5m6g5.rs:31:21\n\
    \   |\n31 |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    let mut s = String::from(\"\");\n        for i in 0..(base - x) {\n     \
    \       s.push(&format!(\"{}\", i));\n        }\n        s.append(&format!(\"\
    {}\", x));\n        return s;\n    }\n    let mut s = String::from(\"\");\n  \
    \  for i in 0..x {\n        s.push(&format!(\"{}\", i));\n    }\n    s.append(&format!(\"\
    {}\", base));\n    return s;\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr0ee4kuc.rs:14:20\n   |\n\
    14 |             s.push(&format!(\"{}\", i));\n   |                    ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpr0ee4kuc.rs:16:11\n\
    \   |\n16 |         s.append(&format!(\"{}\", x));\n   |           ^^^^^^ method\
    \ not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr0ee4kuc.rs:21:16\n\
    \   |\n21 |         s.push(&format!(\"{}\", i));\n   |                ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpr0ee4kuc.rs:23:7\n \
    \  |\n23 |     s.append(&format!(\"{}\", base));\n   |       ^^^^^^ method not\
    \ found in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::from(\"\
    0\");\n    if x > base {\n        result.push_str(&format!(\"{}\", &x / &base));\n\
    \        x = x;\n    }\n    while x > 0 {\n        if x % base == 0 {\n      \
    \      result.push_str(&format!(\"{}\", &x % base));\n        } else {\n     \
    \       result.push_str(&format!(\"{}\", &x % base));\n            result.push_front(match\
    \ x % base {\n                0 => \"0\",\n                1 => \"1\",\n     \
    \           _ => unreachable!(),\n            });\n        }\n        x = x /\
    \ base;\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_front` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp27y646d_.rs:21:20\n   |\n21 |             result.push_front(match\
    \ x % base {\n   |                    ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use std::cmp::min;\n\
    \    use std::cmp::max;\n\n    if x < base {\n        let mut r = String::new();\n\
    \        let mut c = x;\n        while c > base {\n            c /= base;\n  \
    \          r = format!(\"{}{}\", r, c);\n        }\n        while c < 10 {\n \
    \           c *= base;\n            r = format!(\"{}{}\", r, c);\n        }\n\
    \        r = format!(\"{}\", r);\n        if min (x, base) < base {\n        \
    \    r = String::from(\"0\".to_string());\n        }\n        r\n    } else {\n\
    \        if base == 2 {\n            format!(\"{:b}\", x)\n        } else {\n\
    \            format!(\"{}\", x)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8\"`,\n right: `\"22\"`', /tmp/tmp4asmo_7g.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ let mut base = 10usize;\n    while base > 10 {\n        x /= base;\n       \
    \ base /= 10;\n    }\n    String::from_radix(x as u32, base).unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbl2yhjl_.rs:14:14\n   |\n\
    14 |         x /= base;\n   |              ^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpbl2yhjl_.rs:14:11\n\
    \   |\n14 |         x /= base;\n   |           ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0599]: no function or associated item named `from_radix`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpbl2yhjl_.rs:17:13\n\
    \   |\n17 |     String::from_radix(x as u32, base).unwrap()\n   |            \
    \ ^^^^^^^^^^ function or associated item not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    let mut carry = false;\n    while x >= base {\n        let digit =\
    \ (x / base) as u8;\n        s = String::from(format!(\"{}{}\", s, digit));\n\
    \        x = x % base;\n        carry = true;\n    }\n    if carry {\n       \
    \ s = String::from(format!(\"{}\", x));\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpfczpvli_.rs:16:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n16 |      \
    \   x = x % base;\n   |         ^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match (base,x) {\n \
    \       (0,0) => String::from(\"0\"),\n        (0,x) => String::from(\"0\"),\n\
    \        (1,x) => String::from(\"1\"),\n        (2,x) => String::from(\"10\"),\n\
    \        (3,x) => String::from(\"100\"),\n        (4,x) => String::from(\"1000\"\
    ),\n        (5,x) => String::from(\"10000\"),\n        (6,x) => String::from(\"\
    100000\"),\n        (7,x) => String::from(\"1000000\"),\n        (8,x) => String::from(\"\
    10000000\"),\n        (9,x) => String::from(\"100000000\"),\n        (10,x) =>\
    \ String::from(\"1000000000\"),\n        (11,x) => String::from(\"10000000000\"\
    ),\n        (12,x) => String::from(\"100000000000\"),\n        (13,x) => String::from(\"\
    1000000000000\"),\n        (14,x) => String::from(\"10000000000000\"),\n     \
    \   (15,x) => String::from(\"100000000000000\"),\n        (16,x) => String::from(\"\
    1000000000000000\"),\n        (17,x) => String::from(\"10000000000000000\"),\n\
    \        (18,x) => String::from(\"100000000000000000\"),\n        (19,x) => String::from(\"\
    1000000000000000000\"),\n        (20,x) => String::from(\"10000000000000000000\"\
    ),\n        (21,x) => String::from(\"100000000000000000000\"),\n        (22,x)\
    \ => String::from(\"1000000000000000000000\"),\n        (23,x) => String::from(\"\
    10000000000000000000000\"),\n        (24,x) => String::from(\"100000000000000000000000\"\
    ),\n        (25,x) => String::from(\"1000000000000000000000000\"),\n        (26,x)\
    \ => String::from(\"10000000000000000000000000\"),\n        (27,x) => String::from(\"\
    100000000000000000000000000\"),\n        (28,x) => String::from(\"1000000000000000000000000000\"\
    ),\n        (29,x) => String::from(\"10000000000000000000000000000\"),\n     \
    \   (30,x) => String::from(\"100000000000000000000000000000\"),\n        (31,x)\
    \ => String::from(\"1000000000000000000000000000000\"),\n        (32,x) => String::from(\"\
    10000000000000000000000000000000\"),\n        (33,x) => String::from(\"100000000000000000000000000000000\"\
    ),\n        (34,x) => String::from(\"1000000000000000000000000000000000\"),\n\
    \        (35,x) => String::from(\"1000000000000000000000000000000000\"),\n   \
    \     (36,x) => String::from(\"1000000000000000000000000000000000\"),\n      \
    \  (37,x) => String::from(\"1000000000000000000000000000000000\"),\n        (38,x)\
    \ => String::from(\"1000000000000000000\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpcyf2sxnr.rs:67:48\n\
    \   |\n67 |       assert_eq!(candidate(7, 8), String::from(\"7\"));\n   |  ________________________________________________^\n\
    68 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     String::from(x * BASE[base])\n    } else {\n        String::from(format!(\"\
    {}\", x))\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `BASE` in this scope\n  --> /tmp/tmp6xjrttb0.rs:12:26\n\
    \   |\n12 |         String::from(x * BASE[base])\n   |                       \
    \   ^^^^ help: a local variable with a similar name exists: `base`\n\nerror[E0277]:\
    \ the trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmp6xjrttb0.rs:12:9\n\
    \   |\n12 |         String::from(x * BASE[base])\n   |         ^^^^^^^^^^^^ the\
    \ trait `From<isize>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    let mut string = \"\";\n        loop {\n            let mut num = x;\n  \
    \          let mut remainder = num % base;\n            while remainder == 0 {\n\
    \                remainder = num % base;\n                num /= base;\n     \
    \       }\n            string += char::to_string(num);\n            if num > 0\
    \ {\n                string += char::to_string(base);\n            }\n       \
    \     if num == 0 && remainder == 0 {\n                break;\n            }\n\
    \        }\n        String::from(&string)\n    } else {\n        let mut string\
    \ = \"\";\n        for &x in char::digits(x).iter() {\n            if x > base\
    \ {\n                string += char::to_string(x - base);\n            } else\
    \ {\n                string += char::to_string(x);\n            }\n        }\n\
    \        String::from(&string)\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph72qqo4u.rs:20:39\n   |\n\
    20 |             string += char::to_string(num);\n   |                       \
    \                ^^^ expected `&char`, found `isize`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmph72qqo4u.rs:20:13\n\
    \   |\n20 |             string += char::to_string(num);\n   |             ------^--^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |      |\n   |             |      `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |             cannot use `+=` on type `&str`\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph72qqo4u.rs:22:43\n   |\n22 |\
    \                 string += char::to_string(base);\n   |                     \
    \                      ^^^^ expected `&char`, found `isize`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmph72qqo4u.rs:22:17\n\
    \   |\n22 |                 string += char::to_string(base);\n   |           \
    \      ------^--^^^^^^^^^^^^^^^^^^^^^^\n   |                 |      |\n   |  \
    \               |      `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |                 cannot use `+=` on type `&str`\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\n\nerror[E0277]: the trait\
    \ bound `String: From<&&str>` is not satisfied\n  --> /tmp/tmph72qqo4u.rs:28:9\n\
    \   |\n28 |         String::from(&string)\n   |         ^^^^^^^^^^^^ the trait\
    \ `From<&&str>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0599]: no function or\
    \ associated item named `digits` found for type `char` in the current scope\n\
    \  --> /tmp/tmph72qqo4u.rs:31:25\n   |\n31 |         for &x in char::digits(x).iter()\
    \ {\n   |       "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!((base >= 2)\
    \ && (base <= 36));\n    let mut s = String::new();\n    s.push_str(&format!(\"\
    {:#0{}b}\", x, base));\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmps271pdt1.rs:13:30\n\
    \   |\n13 |     s.push_str(&format!(\"{:#0{}b}\", x, base));\n   |           \
    \               -   ^ expected `}` in format string\n   |                    \
    \      |\n   |                          because of this opening brace\n   |\n\
    \   = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut out = String::with_capacity(x.to_string().len());\n\
    \    let mut num = x;\n\n    while num > 0 {\n        out.push_str(&num % base);\n\
    \        num /= base;\n    }\n\n    out\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9dq8wgeh.rs:15:22\n   |\n\
    15 |         out.push_str(&num % base);\n   |                      ^^^^^^^^^^^\
    \ expected `&str`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = x;\n\
    \    let mut power = 1;\n    while result >= base {\n        result = result /\
    \ base;\n        power += 1;\n    }\n    let mut base_size = base;\n    while\
    \ base_size != 1 {\n        if x % base_size == 0 {\n            result -= base_size;\n\
    \            x = x / base_size;\n        } else {\n            base_size *= base;\n\
    \        }\n    }\n    format!(\"{}\", result)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable `power` is assigned to, but never used\n  --> /tmp/tmpz25m6gs1.rs:12:13\n\
    \   |\n12 |     let mut power = 1;\n   |             ^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_power` instead\n\nerror[E0384]: cannot\
    \ assign to immutable argument `x`\n  --> /tmp/tmpz25m6gs1.rs:21:13\n   |\n10\
    \ | fn change_base(x: isize, base: isize) -> String {\n   |                - help:\
    \ consider making this binding mutable: `mut x`\n...\n21 |             x = x /\
    \ base_size;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = vec![String::from(\"\")];\n    while x != 0 {\n        let\
    \ digit = x % base;\n        digits.push(format!(\"{:0>2}\", digit));\n      \
    \  x = x / base;\n    }\n    for &s in &digits {\n        result = format!(\"\
    {}{}\", result, s);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp_n9lctfj.rs:16:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n16 |      \
    \   x = x / base;\n   |         ^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0507]: cannot move out of a shared reference\n  --> /tmp/tmp_n9lctfj.rs:18:15\n\
    \   |\n18 |     for &s in &digits {\n   |         --    ^^^^^^^\n   |        \
    \ ||\n   |         |data moved here\n   |         |move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n   |         help:\
    \ consider removing the `&`: `s`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0384, E0507.\nFor more information\
    \ about an error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    for i in x.checked_div(base).unwrap() {\n        s = format!(\"{}{}\"\
    , s, i % base);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmp_bjuv7qk.rs:12:14\n\
    \   |\n12 |     for i in x.checked_div(base).unwrap() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut buffer = String::new();\n\
    \    let mut digits = 0..x;\n    loop {\n        let digit = digits % base;\n\
    \        buffer.insert(0, digit.to_string());\n        buffer.insert(0, base);\n\
    \        buffer.insert(0, String::from(\"0\"));\n        digits /= base;\n   \
    \     if digits == 0 {\n            break;\n        }\n    }\n    buffer\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `std::ops::Range<isize>` by `isize`\n  --> /tmp/tmpuhwe3jj4.rs:14:28\n\
    \   |\n14 |         let digit = digits % base;\n   |                     ------\
    \ ^ ---- isize\n   |                     |\n   |                     std::ops::Range<isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuhwe3jj4.rs:16:26\n   |\n16 |\
    \         buffer.insert(0, base);\n   |                          ^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhwe3jj4.rs:17:26\n\
    \   |\n17 |         buffer.insert(0, String::from(\"0\"));\n   |             \
    \             ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0368]:\
    \ binary assignment operation `/=` cannot be applied to type `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpuhwe3jj4.rs:18:9\n   |\n18 |         digits /= base;\n   |    \
    \     ------^^^^^^^^\n   |         |\n   |         cannot use `/=` on type `std::ops::Range<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpuhwe3jj4.rs:19:22\n   |\n19 |\
    \         if digits == 0 {\n   |                      ^ expected struct `std::ops::Range`,\
    \ found integer\n   |\n   = note: expected struct `std::ops::Range<isize>`\n \
    \               found type `{integer}`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    String::from(\"0\")\n    } else {\n        let mut s = String::from(\"1\"\
    );\n        while x != 0 {\n            s.push_str(&format!(\"{:0>{}}\", x / base,\
    \ base));\n            x %= base;\n        }\n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmp1rm52j1u.rs:16:38\n\
    \   |\n16 |             s.push_str(&format!(\"{:0>{}}\", x / base, base));\n \
    \  |                                  -   ^ expected `}` in format string\n  \
    \ |                                  |\n   |                                 \
    \ because of this opening brace\n   |\n   = note: if you intended to print `{`,\
    \ you can escape it using `{{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    if base < 10 {\n        s.push_str(&format!(\"{}\", x).as_str().to_string());\n\
    \        return s;\n    }\n\n    for i in x.chars().skip_while(|&b| b != 0).take(base)\
    \ {\n        s.push(&format!(\"{}\", i).as_str().to_string());\n    }\n    s[..]\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6lacptpv.rs:17:16\n   |\n17 |     for i in x.chars().skip_while(|&b|\
    \ b != 0).take(base) {\n   |                ^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6lacptpv.rs:18:16\n   |\n18 |\
    \         s.push(&format!(\"{}\", i).as_str().to_string());\n   |            \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6lacptpv.rs:20:5\n   |\n10 | fn\
    \ change_base(x: isize, base: isize) -> String {\n   |                       \
    \                   ------ expected `String` because of return type\n...\n20 |\
    \     s[..]\n   |     ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut ix = x;\n    while ix != 0 {\n        let r = ix % base;\n      \
    \  s = format!(\"{:b}\", r) + s;\n        ix = ix / base;\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphml6d7ng.rs:15:34\n   |\n\
    15 |         s = format!(\"{:b}\", r) + s;\n   |                             \
    \     ^\n   |                                  |\n   |                       \
    \           expected `&str`, found struct `String`\n   |                     \
    \             help: consider borrowing here: `&s`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0; base];\n    format!(\"{}\", x).parse::<isize>().unwrap().unwrap()\n\
    \        .chars().enumerate().for_each(|(pos, c)| {\n            *digits[pos.0]\
    \ += usize::from(c) * usize::from(base::from(digits));\n        });\n    for digit\
    \ in digits {\n        if digit > 0 {\n            s.push_str(digit.to_string());\n\
    \        } else {\n            s.push('0');\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `base`\n\
    \  --> /tmp/tmpataiff6m.rs:15:60\n   |\n15 |             *digits[pos.0] += usize::from(c)\
    \ * usize::from(base::from(digits));\n   |                                   \
    \                         ^^^^ use of undeclared crate or module `base`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpataiff6m.rs:12:30\n   |\n12 |     let mut digits\
    \ = vec![0; base];\n   |                              ^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n12 |     let mut digits = vec![0; base.try_into().unwrap()];\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmpataiff6m.rs:13:48\n\
    \   |\n13 |     format!(\"{}\", x).parse::<isize>().unwrap().unwrap()\n   |  \
    \                                              ^^^^^^ method not found in `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpataiff6m.rs:19:24\n   |\n19 |\
    \             s.push_str(digit.to_string());\n   |                        ^^^^^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     String::from_str(format!(\"{}\", x * base))\n    } else {\n        let mut\
    \ res = String::new();\n        res.push_str(\"0\");\n        while res.length()\
    \ < base {\n            res.push('0');\n        }\n        res.push_str(format!(\"\
    {}\", x));\n        res\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp7z3exaat.rs:12:17\n   |\n\
    12 |         String::from_str(format!(\"{}\", x * base))\n   |               \
    \  ^^^^^^^^ function or associated item not found in `String`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::str::FromStr;\n   |\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp7z3exaat.rs:16:19\n\
    \   |\n16 |         while res.length() < base {\n   |                   ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7z3exaat.rs:19:22\n   |\n19 |         res.push_str(format!(\"\
    {}\", x));\n   |                      ^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ let mut res = String::new();\n    while x > 0 {\n        res.push_str(&to_base(x\
    \ % base));\n        x /= base;\n    }\n    res.reverse();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmpfklho21f.rs:14:23\n\
    \   |\n14 |         res.push_str(&to_base(x % base));\n   |                  \
    \     ^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpfklho21f.rs:17:9\n\
    \   |\n17 |     res.reverse();\n   |         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut string = \"\"\
    .to_string();\n    let mut remain = x;\n    let mut digit = base;\n    while remain\
    \ > 0 {\n        remain -= digit;\n        string = &string[digit..].to_string()\
    \ + &string[digit];\n        digit *= base;\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpp7hjn88q.rs:16:19\n   |\n16 |         string = &string[digit..].to_string()\
    \ + &string[digit];\n   |                   ^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<isize>`\n   |\n   = help: the trait `Index<RangeFrom<isize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpp7hjn88q.rs:16:50\n   |\n16 |         string = &string[digit..].to_string()\
    \ + &string[digit];\n   |                                                  ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    x.to_string().chars().take(base).collect::<String>()\
    \ + format!(\"{:0{}b}\", x, base)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpcam9p8yv.rs:11:72\n\
    \   |\n11 |     x.to_string().chars().take(base).collect::<String>() + format!(\"\
    {:0{}b}\", x, base)\n   |                                                    \
    \                 -  ^ expected `}` in format string\n   |                   \
    \                                                  |\n   |                   \
    \                                                  because of this opening brace\n\
    \   |\n   = note: if you intended to print `{`, you can escape it using `{{`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcam9p8yv.rs:11:32\n   |\n11 |\
    \     x.to_string().chars().take(base).collect::<String>() + format!(\"{:0{}b}\"\
    , x, base)\n   |                                ^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     x.to_string().chars().take(base.try_into().unwrap()).collect::<String>()\
    \ + format!(\"{:0{}b}\", x, base)\n   |                                    ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcam9p8yv.rs:11:60\n   |\n11 |\
    \     x.to_string().chars().take(base).collect::<String>() + format!(\"{:0{}b}\"\
    , x, base)\n   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    if x > base {\n        let mut t = x;\n        while t > base {\n       \
    \     t /= base;\n        }\n        for i in 0..(t - 1) {\n            let mut\
    \ y = i_to_base(i, base);\n            s += &mut y;\n        }\n        s += &mut\
    \ i_to_base(t - 1, base);\n    } else if x < 0 {\n        let mut t = x;\n   \
    \     while t < 0 {\n            t *= base;\n        }\n        for i in 0..(t\
    \ + 1) {\n            let mut y = i_to_base(i, base);\n            s += &mut y;\n\
    \        }\n        s += &mut i_to_base(0, base);\n    } else {\n        for i\
    \ in 0..(x + 1) {\n            let mut y = i_to_base(i, base);\n            s\
    \ += &mut y;\n        }\n    }\n    String::from(s)\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `i_to_base` in this scope\n  --> /tmp/tmpa2k2jzvr.rs:18:25\n\
    \   |\n18 |             let mut y = i_to_base(i, base);\n   |                \
    \         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `i_to_base` in this scope\n  --> /tmp/tmpa2k2jzvr.rs:21:19\n   |\n21 |     \
    \    s += &mut i_to_base(t - 1, base);\n   |                   ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `i_to_base` in this scope\n\
    \  --> /tmp/tmpa2k2jzvr.rs:28:25\n   |\n28 |             let mut y = i_to_base(i,\
    \ base);\n   |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `i_to_base` in this scope\n  --> /tmp/tmpa2k2jzvr.rs:31:19\n\
    \   |\n31 |         s += &mut i_to_base(0, base);\n   |                   ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `i_to_base` in\
    \ this scope\n  --> /tmp/tmpa2k2jzvr.rs:34:25\n   |\n34 |             let mut\
    \ y = i_to_base(i, base);\n   |                         ^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}{}\", x\
    \ as usize * base, base)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppseu5fi3.rs:11:34\n   |\n\
    11 |     format!(\"{}{}\", x as usize * base, base)\n   |                    \
    \              ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply\
    \ `usize` by `isize`\n  --> /tmp/tmppseu5fi3.rs:11:32\n   |\n11 |     format!(\"\
    {}{}\", x as usize * base, base)\n   |                                ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut base = [0u8; 10];\n    let mut i = 5;\n    match x % 10 {\n     \
    \   0 => {\n            base[i] += 1;\n            i += 1;\n        }\n      \
    \  _ => {\n            let mut j = 0;\n            while i > 0 {\n           \
    \     base[j] += 1;\n                i /= 10;\n                j += 1;\n     \
    \       }\n        }\n    }\n    let mut result = [0u8; base.length];\n    if\
    \ base[0] > 0 {\n        base[0] -= 1;\n        result[0] += 1;\n    }\n    for\
    \ i in 0..base.length - 1 {\n        result[i] = result[i - 1] * base[i];\n  \
    \  }\n    if x < 0 {\n        result.insert(0, '-');\n    }\n    for i in result\
    \ {\n        s += i.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpb2ieq8rt.rs:28:28\n   |\n12 |     let mut base = [0u8; 10];\n   |  \
    \   ------------ help: consider using `const` instead of `let`: `const base`\n\
    ...\n28 |     let mut result = [0u8; base.length];\n   |                     \
    \       ^^^^ non-constant value\n\nerror[E0609]: no field `length` on type `[u8;\
    \ 10]`\n  --> /tmp/tmpb2ieq8rt.rs:33:22\n   |\n33 |     for i in 0..base.length\
    \ - 1 {\n   |                      ^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0435, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0435`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    s.push_str(&x.to_digits().to_string());\n    s.push_str(&base.to_digits().to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp8_52yhis.rs:12:19\n   |\n12 |     s.push_str(&x.to_digits().to_string());\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp8_52yhis.rs:13:22\n   |\n13 |     s.push_str(&base.to_digits().to_string());\n\
    \   |                      ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remaining = x;\n    while remaining >= base {\n        result.push((remaining\
    \ % base) as char);\n        remaining = remaining / base;\n    }\n    if remaining\
    \ > 0 {\n        result.push((remaining as char) as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp2g0gnx_i.rs:14:21\n\
    \   |\n14 |         result.push((remaining % base) as char);\n   |           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp2g0gnx_i.rs:14:21\n   |\n14 |         result.push((remaining\
    \ % base) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp2g0gnx_i.rs:18:21\n\
    \   |\n18 |         result.push((remaining as char) as char);\n   |          \
    \           ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp2g0gnx_i.rs:18:21\n   |\n18 |         result.push((remaining\
    \ as char) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0604`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base <= 0 {\n   \
    \     return String::from(\"\");\n    }\n    let mut result: String = \"0\";\n\
    \    let mut base_digits: Vec<&str> = x.to_string().chars().collect();\n    let\
    \ mut x = base_digits.iter().rev().take(base).collect::<Vec<_>>();\n    for &i\
    \ in x {\n        result = format!(\"{}{}\", result, i);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9dvtq04a.rs:14:30\n   |\n\
    14 |     let mut result: String = \"0\";\n   |                     ------   ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0277]: a value\
    \ of type `Vec<&str>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmp9dvtq04a.rs:15:60\n     |\n15   |     let mut base_digits: Vec<&str>\
    \ = x.to_string().chars().collect();\n     |                                 \
    \                           ^^^^^^^ value of type `Vec<&str>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<&str>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9dvtq04a.rs:16:47\n   |\n16 |     let mut x\
    \ = base_digits.iter().rev().take(base).collect::<Vec<_>>();\n   |           \
    \                                    ^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |     let mut x = base_digits.iter().rev().take(base.try_into().unwrap()).collect::<Vec<_>>();\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut number = x;\n\
    \    let mut result = String::new();\n\n    while number.is_even() {\n       \
    \ number /= base;\n        result.push((base).to_string());\n    }\n\n    if number\
    \ > 0 {\n        while number.is_odd() {\n            number *= base;\n      \
    \      result.push((base).to_string());\n        }\n    }\n\n    result.push_str(&number)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp1_fg3pk2.rs:14:18\n   |\n14 |     while number.is_even()\
    \ {\n   |                  ^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1_fg3pk2.rs:16:21\n   |\n16 |         result.push((base).to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `is_odd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp1_fg3pk2.rs:20:22\n   |\n20 |         while number.is_odd()\
    \ {\n   |                      ^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1_fg3pk2.rs:22:25\n   |\n22 |             result.push((base).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_fg3pk2.rs:26:21\n\
    \   |\n26 |     result.push_str(&number)\n   |                     ^^^^^^^ expected\
    \ `str`, found `isize`\n   |\n   = note: expected reference `&str`\n         \
    \     found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_fg3pk2.rs:26:5\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n26 |     result.push_str(&number)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp1_fg3pk2.rs:26:12\n   |\n26 |     result.push_str(&number)\n\
    \   |     ------ ^^^^^^^^ this call modifies `result` in-place\n   |     |\n \
    \  |     you probably want to use this value after calling the method...\n   =\
    \ note: ...instead of the `()` output of method `push_str`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut digits = String::new();\n\
    \    let mut power = 0;\n\n    for digit in digits_iter(x).by_ref() {\n      \
    \  if digit < base {\n            digits += digit.to_string();\n        } else\
    \ {\n            digits += digit.to_string() + &format!(\"{}\", base);\n     \
    \       power += 1;\n        }\n    }\n    digits += &format!(\"{}\", power);\n\
    \    digits\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digits_iter` in this scope\n  --> /tmp/tmpb3f44bdn.rs:14:18\n\
    \   |\n14 |     for digit in digits_iter(x).by_ref() {\n   |                 \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::new();\n\
    \    match x {\n        x if base == 10 => format!(\"{:10}\", x).into_owned(),\n\
    \        x if base == 8 => format!(\"{:02}\", x).into_owned(),\n        x if base\
    \ == 5 => format!(\"{:05}\", x).into_owned(),\n        x if base == 2 => format!(\"\
    {:02}\", x).into_owned(),\n        x if base == 1 => format!(\"{:01}\", x).into_owned(),\n\
    \        _ => panic!(\"The base of the input number {} must be between 2 and 10\"\
    , x),\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp9gqaco1r.rs:13:48\n   |\n13 |         x if\
    \ base == 10 => format!(\"{:10}\", x).into_owned(),\n   |                    \
    \                            ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp9gqaco1r.rs:14:47\n   |\n14 |         x if base == 8 => format!(\"\
    {:02}\", x).into_owned(),\n   |                                              \
    \ ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `into_owned`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp9gqaco1r.rs:15:47\n\
    \   |\n15 |         x if base == 5 => format!(\"{:05}\", x).into_owned(),\n  \
    \ |                                               ^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `into_owned` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9gqaco1r.rs:16:47\n   |\n16 |         x\
    \ if base == 2 => format!(\"{:02}\", x).into_owned(),\n   |                  \
    \                             ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp9gqaco1r.rs:17:47\n   |\n17 |         x if base == 1 => format!(\"\
    {:01}\", x).into_owned(),\n   |                                              \
    \ ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut buf: Vec<u8>\
    \ = vec![];\n    let mut carry: isize = 0;\n    let mut digits: Vec<isize> = vec![];\n\
    \    for i in 0..(base ** x.checked_div(10).unwrap().unwrap_or(0)) {\n       \
    \ digits.push(i / base);\n        carry += i % base;\n        digits.push(&*carry\
    \ as u8);\n    }\n    buf.resize(digits.pop().unwrap_or(0), 0);\n    if carry\
    \ > 0 {\n        buf.resize(digits.pop().unwrap_or(0), 0);\n    }\n    for &i\
    \ in digits {\n        buf[buf.len() - 1] = (i as u8).into();\n    }\n    String::from_utf8(buf)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpo62bjdzd.rs:14:53\n   |\n14 |     for i in 0..(base\
    \ ** x.checked_div(10).unwrap().unwrap_or(0)) {\n   |                        \
    \                             ^^^^^^^^^ method not found in `isize`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpo62bjdzd.rs:17:22\n   |\n\
    17 |         digits.push(&*carry as u8);\n   |                      ^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpo62bjdzd.rs:19:16\n   |\n19 |  \
    \   buf.resize(digits.pop().unwrap_or(0), 0);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n19 |     buf.resize(digits.pop().unwrap_or(0).try_into().unwrap(),\
    \ 0);\n   |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo62bjdzd.rs:21:20\n   |\n21 |         buf.resize(digits.pop().unwrap_or(0),\
    \ 0);\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |         buf.resize(digits.pop().unwrap_or(0).try_into().unwrap(),\
    \ 0);\n   |                                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo62bjdzd.rs:23:9\n   |\n23 | \
    \    for &i in digits {\n   |         ^^    ------ this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo62bjdzd.rs:26:5\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n...\n26 |     String::from_utf8(buf)\n   |     ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Result`\n   |\n   = n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     if base == 1 {\n            return \"0\".to_string();\n        }\n     \
    \   let mut s = String::new();\n        let mut carry = true;\n        for i in\
    \ 0..base {\n            if x&1 != 0 {\n                s = format!(\"{}{}\",\
    \ s, &\"0\");\n                carry = false;\n            }\n            s =\
    \ format!(\"{}{}\", s, &(x&0) - 1);\n            x = x >> 1;\n        }\n    \
    \    if carry {\n            s = format!(\"{}{}\", s, &\"1\");\n        }\n  \
    \      s\n    } else {\n        format!(\"{}{}\", &x, &base)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpi5fzhlwt.rs:17:13\n   |\n\
    17 |         for i in 0..base {\n   |             ^ help: if this is intentional,\
    \ prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `x`\n  -->\
    \ /tmp/tmpi5fzhlwt.rs:23:13\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n23 |             x = x >> 1;\n   |             ^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    \");\n    let mut remaining = x;\n\n    if base < 2 || base > 36 {\n        bail!(\"\
    The base is not between 2 and 36\");\n    }\n\n    while remaining > 0 {\n   \
    \     if remaining % base == 0 {\n            res += &format!(\"{:0{}}\", remaining\
    \ / base, base).to_owned();\n        } else {\n            res += &format!(\"\
    {}{:0{}}\", base, remaining / base, base).to_owned();\n        }\n\n        remaining\
    \ /= base;\n    }\n\n    res.to_owned()\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpr25d4t2u.rs:20:33\n\
    \   |\n20 |             res += &format!(\"{:0{}}\", remaining / base, base).to_owned();\n\
    \   |                              -  ^ expected `}` in format string\n   |  \
    \                            |\n   |                              because of this\
    \ opening brace\n   |\n   = note: if you intended to print `{`, you can escape\
    \ it using `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n\
    \  --> /tmp/tmpr25d4t2u.rs:22:35\n   |\n22 |             res += &format!(\"{}{:0{}}\"\
    , base, remaining / base, base).to_owned();\n   |                            \
    \    -  ^ expected `}` in format string\n   |                                |\n\
    \   |                                because of this opening brace\n   |\n   =\
    \ note: if you intended to print `{`, you can escape it using `{{`\n\nerror: cannot\
    \ find macro `bail` in this scope\n  --> /tmp/tmpr25d4t2u.rs:15:9\n   |\n15 |\
    \         bail!(\"The base is not between 2 and 36\");\n   |         ^^^^\n\n\
    error: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut out = String::new();\n\
    \    let mut digits = [0u8; (x * base) + 1];\n\n    for _ in 0..digits.len() {\n\
    \        let mut digit = digits.iter().next().unwrap();\n\n        while digit\
    \ > 0 {\n            out.push((digit % base) as char);\n            digit /= base;\n\
    \        }\n    }\n\n    out\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpodt2u1s8.rs:12:29\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - this would need to be a `const`\n11 |   \
    \  let mut out = String::new();\n12 |     let mut digits = [0u8; (x * base) +\
    \ 1];\n   |                             ^\n\nerror[E0435]: attempt to use a non-constant\
    \ value in a constant\n  --> /tmp/tmpodt2u1s8.rs:12:33\n   |\n10 | fn change_base(x:\
    \ isize, base: isize) -> String {\n   |                          ---- this would\
    \ need to be a `const`\n11 |     let mut out = String::new();\n12 |     let mut\
    \ digits = [0u8; (x * base) + 1];\n   |                                 ^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpodt2u1s8.rs:17:23\n   |\n17 |\
    \         while digit > 0 {\n   |                       ^\n   |              \
    \         |\n   |                       expected `&u8`, found integer\n   |  \
    \                     help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpodt2u1s8.rs:18:31\n   |\n18 |             out.push((digit\
    \ % base) as char);\n   |                               ^^^^ expected `u8`, found\
    \ `isize`\n\nerror[E0277]: cannot mod `&u8` by `isize`\n  --> /tmp/tmpodt2u1s8.rs:18:29\n\
    \   |\n18 |             out.push((digit % base) as char);\n   |              \
    \               ^ no implementation for `&u8 % isize`\n   |\n   = help: the trait\
    \ `Rem<isize>` is not implemented for `&u8`\n   = help: the following other types\
    \ implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n          \
    \   <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n            \
    \ <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a\
    \ i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n             <&'a isize\
    \ as Rem<isize>>\n           and 54 others\n\nerror[E0368]: binary assignment\
    \ operation `/=` cannot be applied to type `&u8`\n  --> /tmp/tmpodt2u1s8.rs:19:13\n\
    \   |\n19 |             digit /= base;\n   |             -----^^^^^^^^\n   | \
    \            |\n   |             cannot use `/=` on type `&u8`\n\nerror"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    format!(\"{:?}\", x / base ** base)\n    } else {\n        format!(\"{:?}\"\
    , x / base)\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmprk0r25dz.rs:12:35\n\
    \   |\n12 |         format!(\"{:?}\", x / base ** base)\n   |                \
    \                   ^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::from(\"\
    0\");\n    match base {\n        2 | 4 | 8 | 10 => if x <= 10 { format!(\"{}\"\
    , x) } else { result.push(\"0\") },\n        _ => {\n            result.push_str(&format!(\"\
    {}\", x / base))\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_7gi4e8n.rs:13:40\n   |\n\
    13 |         2 | 4 | 8 | 10 => if x <= 10 { format!(\"{}\", x) } else { result.push(\"\
    0\") },\n   |                           -------------^^^^^^^^^^^^^^^^----------------------------\n\
    \   |                           |            |\n   |                         \
    \  |            expected `()`, found struct `String`\n   |                   \
    \        expected this to be `()`\n   |\n   = note: this error originates in the\
    \ macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_7gi4e8n.rs:13:78\n   |\n13 |\
    \         2 | 4 | 8 | 10 => if x <= 10 { format!(\"{}\", x) } else { result.push(\"\
    0\") },\n   |                                                                \
    \              ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to\
    \ write a `char` literal, use single quotes\n   |\n13 |         2 | 4 | 8 | 10\
    \ => if x <= 10 { format!(\"{}\", x) } else { result.push('0') },\n   |      \
    \                                                                        ~~~\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    \");\n    while x != 0 {\n        if x % base == 0 {\n            res += &format!(\"\
    {}\", x);\n        } else {\n            res += &format!(\"{}{}\", x / base, &base);\n\
    \        }\n        x /= base;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpkv_dut8l.rs:18:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n18 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match base {\n     \
    \   2 => {\n            let mut y = x\n            while y >= base {\n       \
    \         y /= base;\n            }\n            format!(\"{}\", y)\n        }\n\
    \        3 => {\n            let mut y = x\n            while y >= base {\n  \
    \              y /= base;\n            }\n            format!(\"{}\", y)\n   \
    \     }\n        4 => {\n            let mut y = x\n            while y >= base\
    \ {\n                y /= base;\n            }\n            format!(\"{}\", y)\n\
    \        }\n        5 => {\n            let mut y = x\n            while y >=\
    \ base {\n                y /= base;\n            }\n            format!(\"{}\"\
    , y)\n        }\n        6 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        7 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        8 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        9 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        10 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        11 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        12 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        13 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        14 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        15 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n        }\n        16 => {\n            let mut y = x\n            while\
    \ y >= base {\n                y /= base;\n            }\n            format!(\"\
    {}\", y)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpq80eos_u.rs:132:3\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n11  |     match\
    \ base {\n    |                - unclosed delimiter\n...\n110 |         16 =>\
    \ {\n    |               - this delimiter might not be properly closed...\n...\n\
    116 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    132 | }\n    |   ^\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:13:26\n\
    \   |\n13 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n14 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:20:26\n\
    \   |\n20 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n21 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:27:26\n\
    \   |\n27 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n28 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:34:26\n\
    \   |\n34 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n35 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:41:26\n\
    \   |\n41 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n42 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:48:26\n\
    \   |\n48 |             let mut y = x\n   |                          ^ help: add\
    \ `;` here\n49 |             while y >= base {\n   |             ----- unexpected\
    \ token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpq80eos_u.rs:55:26\n\
    \   |\n55 |             let mut y = x\n   |                          ^ h"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut num = 1;\n\n    for n in x_to_base(x % base, base).into_iter().take(base)\
    \ {\n        if n == 0 {\n            num *= base;\n        } else {\n       \
    \     num += n;\n        }\n    }\n\n    s += &format!(\"{}\", num).to_string();\n\
    \n    return s;\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `x_to_base` in this scope\n  --> /tmp/tmpt802m9ap.rs:14:14\n\
    \   |\n14 |     for n in x_to_base(x % base, base).into_iter().take(base) {\n\
    \   |              ^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut string = String::from(\"\
    0\");\n    while x > base {\n        string = format!(\"{}{}\", string, &format!(\"\
    {}\", x % base));\n        x /= base;\n    }\n    string = format!(\"{}\", x)\
    \ + string;\n    String::from(string)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_mo8fk_.rs:16:33\n   |\n\
    16 |     string = format!(\"{}\", x) + string;\n   |                         \
    \        ^^^^^^\n   |                                 |\n   |                \
    \                 expected `&str`, found struct `String`\n   |               \
    \                  help: consider borrowing here: `&string`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match x {\n        x\
    \ if x >= 10 && x <= 36 => x.to_string().into(),\n        _ => String::from(\"\
    0\".to_string()),\n    }\n    .to_string()\n    .parse::<isize>()\n    .unwrap()\n\
    \    .checked_mul(base)\n    .ok()\n    .unwrap()\n    .to_string()\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpb_ip7ap_.rs:19:6\n   |\n19 |     .ok()\n   |      ^^ help:\
    \ there is an associated function with a similar name: `or`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::with_capacity(x.to_string());\n\
    \    let mut n = x;\n    let mut base = base as isize;\n    while base > 10 {\n\
    \        if n % base == 0 {\n            result.push((n - n % base) as char);\n\
    \        } else {\n            result.push('-');\n            result.push((n -\
    \ n % base) as char);\n        }\n        n /= base;\n        base *= 10;\n  \
    \  }\n    if base > 10 {\n        result.push('-');\n        result.push((n -\
    \ n % base) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6vmykdp6.rs:11:44\n   |\n\
    11 |     let mut result = String::with_capacity(x.to_string());\n   |        \
    \                                    ^^^^^^^^^^^^^ expected `usize`, found struct\
    \ `String`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  -->\
    \ /tmp/tmp6vmykdp6.rs:16:25\n   |\n16 |             result.push((n - n % base)\
    \ as char);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp6vmykdp6.rs:16:25\n\
    \   |\n16 |             result.push((n - n % base) as char);\n   |           \
    \              ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `isize`\n  --> /tmp/tmp6vmykdp6.rs:19:25\n   |\n19 |           \
    \  result.push((n - n % base) as char);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp6vmykdp6.rs:19:25\n   |\n19 |             result.push((n - n % base)\
    \ as char);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp6vmykdp6.rs:26:21\n\
    \   |\n26 |         result.push((n - n % base) as char);\n   |               \
    \      ^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmp6vmykdp6.rs:26:21\n   |\n26 |         result.push((n\
    \ - n % base) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    x.to_string().chars().map(|c|\
    \ if c < base { c.to_string() + x } else { c })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp7yu4yh0.rs:11:42\n   |\n\
    11 |     x.to_string().chars().map(|c| if c < base { c.to_string() + x } else\
    \ { c })\n   |                                          ^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp7yu4yh0.rs:11:65\n\
    \   |\n11 |     x.to_string().chars().map(|c| if c < base { c.to_string() + x\
    \ } else { c })\n   |                                                        \
    \         ^ expected `&str`, found `isize`\n\nerror[E0308]: `if` and `else` have\
    \ incompatible types\n  --> /tmp/tmpp7yu4yh0.rs:11:76\n   |\n11 |     x.to_string().chars().map(|c|\
    \ if c < base { c.to_string() + x } else { c })\n   |                        \
    \                         -----------------          ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                               \
    \  |                          |\n   |                                        \
    \         |                          expected struct `String`, found `char`\n\
    \   |                                                 expected because of this\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut str: String\
    \ = String::new();\n    let mut num: isize = x;\n    loop {\n        if num >\
    \ 0 {\n            str = format!(\"{}{}\", num, str);\n            num -= base;\n\
    \        }\n        if num == 0 {\n            return str;\n        }\n      \
    \  num = num / base;\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"18\"`,\n right: `\"22\"`', /tmp/tmpbydjx0fd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use std::cmp::Ordering;\n\
    \    use std::fmt::{self, Display};\n    use std::str::FromStr;\n    use super::Base;\n\
    \    if base < 10 {\n        return String::from(x.to_string());\n    }\n    let\
    \ mut result = x.to_string();\n    match base.cmp(&Base::base) {\n        Ordering::Less\
    \ => {\n            let mut tmp: String = String::new();\n            for i in\
    \ 0..result.len() {\n                let c: char = result[i];\n              \
    \  if let Some(b) = Base::base.find(c) {\n                    let mut res = String::new();\n\
    \                    res.push(*b as char);\n                    res.push(c);\n\
    \                    tmp = res.clone();\n                    result.push_str(&tmp);\n\
    \                } else {\n                    result.push(c);\n             \
    \   }\n            }\n        }\n        Ordering::Greater => {\n            let\
    \ mut tmp: String = String::new();\n            for i in 0..result.len() {\n \
    \               let c: char = result[i];\n                if let Some(b) = Base::base.find(c)\
    \ {\n                    let mut res = String::new();\n                    res.push(*b\
    \ as char);\n                    res.push(c);\n                    tmp = res.clone();\n\
    \                    result.push_str(&tmp);\n                } else {\n      \
    \              result.push(c);\n                }\n            }\n        }\n\
    \        Ordering::Equal => {\n            for i in 0..result.len() {\n      \
    \          let c: char = result[i];\n                if let Some(b) = Base::base.find(c)\
    \ {\n                    let mut res = String::new();\n                    res.push(*b\
    \ as char);\n                    res.push(c);\n                    result = res.clone();\n\
    \                }\n            }\n        }\n    }\n    let mut num = x.to_string();\n\
    \    num = num.chars().enumerate().filter_map(|(i, c)| {\n        if c.is_digit()\
    \ {\n            let num = c - '0';\n            if num < 0 {\n              \
    \  let mut num = -num;\n                let mut base = Base::base;\n         \
    \       if num < 0 {\n                    num = -num;\n                    base\
    \ *= -1;\n                }\n                (num, base)\n            } else {\n\
    \                (num, base)\n            }\n        } else {\n            None\n\
    \        }\n    }).collect();\n    let mut pow = 1;\n    for (n, base) in num\
    \ {\n        pow <<= Base::base.digits();\n        if pow >= base {\n        \
    \    return String::from(num.to_string());\n        }\n        pow /= base;\n\
    \    }\n    String::from(num.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: there are too many leading `super` keywords\n\
    \  --> /tmp/tmpfrmzgj2n.rs:14:9\n   |\n14 |     use super::Base;\n   |       \
    \  ^^^^^ there are too many leading `super` keywords\n\nwarning: unused imports:\
    \ `Display`, `self`\n  --> /tmp/tmpfrmzgj2n.rs:12:20\n   |\n12 |     use std::fmt::{self,\
    \ Display};\n   |                    ^^^^  ^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nwarning: unused import: `std::str::FromStr`\n  --> /tmp/tmpfrmzgj2n.rs:13:9\n\
    \   |\n13 |     use std::str::FromStr;\n   |         ^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfrmzgj2n.rs:23:31\n\
    \   |\n23 |                 let c: char = result[i];\n   |                   \
    \            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfrmzgj2n.rs:38:31\n   |\n38 |                 let c: char = result[i];\n\
    \   |                               ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfrmzgj2"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut buf = [0u8;\
    \ 16];\n    let mut result = [0u8; 3];\n    let mut powers = vec![![1u8, 2u8,\
    \ 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8];\
    \ 32];\n    let mut remainder = 1;\n    let mut powers2 = vec![![1u8, 2u8, 3u8,\
    \ 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n\
    \    let mut powers21 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8,\
    \ 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let mut powers3 = vec![![1u8,\
    \ 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8;\
    \ 16u8]; 32];\n    let mut powers31 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8,\
    \ 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let mut powers4\
    \ = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8,\
    \ 14u8, 15u8; 16u8]; 32];\n    let mut powers41 = vec![![1u8, 2u8, 3u8, 4u8; 5u8,\
    \ 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n    let\
    \ mut powers5 = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8,\
    \ 12u8, 13u8, 14u8, 15u8; 16u8\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpv3k94gqt.rs:22:1\n   |\n22 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpv3k94gqt.rs:21:29\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                                                 - closing\
    \ delimiter possibly meant for this\n...\n21 |     let mut powers5 = vec![![1u8,\
    \ 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8;\
    \ 16u8\n   |                             ^ unclosed delimiter\n22 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror: expected one of `,`, `.`, `?`, `]`, or\
    \ an operator, found `;`\n  --> /tmp/tmpv3k94gqt.rs:13:47\n   |\n13 |     let\
    \ mut powers = vec![![1u8, 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8,\
    \ 12u8, 13u8, 14u8, 15u8; 16u8]; 32];\n   |                                  \
    \             ^\n   |                                               |\n   |  \
    \                                             expected one of `,`, `.`, `?`, `]`,\
    \ or an operator\n   |                                               help: missing\
    \ `,`\n\nerror: expected one of `,`, `.`, `?`, `]`, or an operator, found `;`\n\
    \  --> /tmp/tmpv3k94gqt.rs:13:108\n   |\n13 |     let mut powers = vec![![1u8,\
    \ 2u8, 3u8, 4u8; 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8;\
    \ 16u8]; 32];\n   |                                                          \
    \                                                  ^\n   |                   \
    \                                                                            \
    \             |\n   |                                                        \
    \                                                    expected one of `,`, `.`,\
    \ `?`, `]`, or an operator\n   |                                             \
    \                                                               help: missing\
    \ `,`\n\nerror: expected one of `,`, `.`, `?`, `]`, or an operator, found `;`\n\
    \  --> /tmp/tmpv3k94gqt.rs:15:48\n   |\n15 |     let mut powers2 = vec![![1u8,\
    \ 2u8, 3u8,"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    if x < base {\n        let mut num: isize = x;\n        while num > base\
    \ {\n            num = num / base;\n            s += String::from(\"0\");\n  \
    \      }\n        s += String::from((num.to_string()));\n    } else {\n      \
    \  let mut num: isize = x;\n        while num < base {\n            num = num\
    \ * base;\n            s += String::from((num.to_string()));\n        }\n    \
    \    s += String::from((num.to_string()));\n    }\n    String::from(s)\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around function argument\n  --> /tmp/tmp72h6fcdw.rs:18:27\n\
    \   |\n18 |         s += String::from((num.to_string()));\n   |              \
    \             ^               ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n18 -         s += String::from((num.to_string()));\n\
    18 +         s += String::from(num.to_string());\n   | \n\nwarning: unnecessary\
    \ parentheses around function argument\n  --> /tmp/tmp72h6fcdw.rs:23:31\n   |\n\
    23 |             s += String::from((num.to_string()));\n   |                 \
    \              ^               ^\n   |\nhelp: remove these parentheses\n   |\n\
    23 -             s += String::from((num.to_string()));\n23 +             s +=\
    \ String::from(num.to_string());\n   | \n\nwarning: unnecessary parentheses around\
    \ function argument\n  --> /tmp/tmp72h6fcdw.rs:25:27\n   |\n25 |         s +=\
    \ String::from((num.to_string()));\n   |                           ^         \
    \      ^\n   |\nhelp: remove these parentheses\n   |\n25 -         s += String::from((num.to_string()));\n\
    25 +         s += String::from(num.to_string());\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp72h6fcdw.rs:16:18\n   |\n16 |             s += String::from(\"\
    0\");\n   |                  ^^^^^^^^^^^^^^^^^\n   |                  |\n   |\
    \                  expected `&str`, found struct `String`\n   |              \
    \    help: consider borrowing here: `&String::from(\"0\")`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp72h6fcdw.rs:18:14\n   |\n18 |         s += String::from((num.to_string()));\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |              |\n   |\
    \              expected `&str`, found struct `String`\n   |              help:\
    \ consider borrowing here: `&String::from((num.to_string()))`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp72h6fcdw.rs:23:18\n   |\n23 |             s\
    \ += String::from((num.to_string()));\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    if x < 10 {\n            return String::from(format!(\"{}\", x));\n     \
    \   } else {\n            return String::from(format!(\"{}{}\", x%base, base_to_string(x/base)));\n\
    \        }\n    } else {\n        return String::from(format!(\"{}{}\", x, base_to_string(x%base)));\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `base_to_string` in this scope\n  -->\
    \ /tmp/tmpu6ac93ll.rs:15:57\n   |\n15 |             return String::from(format!(\"\
    {}{}\", x%base, base_to_string(x/base)));\n   |                              \
    \                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `base_to_string` in this scope\n  --> /tmp/tmpu6ac93ll.rs:18:48\n\
    \   |\n18 |         return String::from(format!(\"{}{}\", x, base_to_string(x%base)));\n\
    \   |                                                ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut acc = String::new();\n\
    \    let mut s = String::from(\"1\");\n    if x < base {\n        for _ in 0..(x\
    \ - base) {\n            s = format!(\"{}{}\", s, base);\n        }\n    } else\
    \ {\n        for _ in 0..(base - x) {\n            acc = format!(\"{}{}\", acc,\
    \ s);\n        }\n    }\n    format!(\"{}\", acc)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"22\"`', /tmp/tmpimhqqeqd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    String::from(\"0\".to_string())\n    }\n    let mut base = format!(\"{}\"\
    , base);\n    let mut result = String::from(\"\");\n    for i in base.chars().cloned()\
    \ {\n        if i <= '0' {\n            result.push_str(&format!(\"{}\", x));\n\
    \            return result;\n        }\n        x /= base;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ejkvjev.rs:12:9\n   |\n\
    11 | /     if base < 2 {\n12 | |         String::from(\"0\".to_string())\n   |\
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    13 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n12 |         String::from(\"0\".to_string());\n   |\
    \                                      +\nhelp: consider using a semicolon here\n\
    \   |\n13 |     };\n   |      +\nhelp: you might have meant to return this value\n\
    \   |\n12 |         return String::from(\"0\".to_string());\n   |         ++++++\
    \                              +\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp6ejkvjev.rs:16:27\n     |\n16   |\
    \     for i in base.chars().cloned() {\n     |                           ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp6ejkvjev.rs:16:14\n   |\n16 |     for i in base.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp6ejkvjev.rs:16:14\n   |\n16 |     for\
    \ i in base.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found reference\n   |\n   = note:   expected type `char`\n         \
    \  found reference `&_`\n   = note: required because of the requirements on the\
    \ impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror[E0277]: cannot divide-assign\
    \ `isize` by `String`\n  --> /tmp/tmp6ejkvjev.rs:21:11\n   |\n21 |         x /=\
    \ base;\n   |           ^^ no implementation for `isize /="
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match x.cmp(&base) {\n\
    \        Ordering::Less => String::from(\"0\".to_string()),\n        Ordering::Greater\
    \ => String::from(\"9\".to_string()),\n        Ordering::Equal => {\n        \
    \    let mut buff = String::new();\n            let mut digit: usize = 10;\n \
    \           while digit <= base.to_digits() + 1 {\n                buff.push_str(digit.to_string());\n\
    \                digit = (digit as usize * base) + x;\n            }\n       \
    \     buff.push_str(digit.to_string());\n            buff\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp0ky9z_hg.rs:12:9\n   |\n12 |         Ordering::Less => String::from(\"\
    0\".to_string()),\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp0ky9z_hg.rs:13:9\n\
    \   |\n13 |         Ordering::Greater => String::from(\"9\".to_string()),\n  \
    \ |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp0ky9z_hg.rs:14:9\n\
    \   |\n14 |         Ordering::Equal => {\n   |         ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0599]: no method named `to_digits` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp0ky9z_hg.rs:17:33\n   |\n17 |  \
    \           while digit <= base.to_digits() + 1 {\n   |                      \
    \           ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0ky9z_hg.rs:18:31\n   |\n18 |                 buff.push_str(digit.to_string());\n\
    \   |                               ^^^^^^^^^^^^^^^^^\n   |                  \
    \             |\n   |                               expected `&str`, found struct\
    \ `String`\n   |                               help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ky9z_hg.rs:19:43\n\
    \   |\n19 |                 digit = (digit as usize * base) + x;\n   |       \
    \                                    ^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmp0ky9z_hg.rs:19:41\n\
    \   |\n19 |                 digit = (digit as usize * base) + x;\n   |       \
    \                                  ^ no implementation for `usize * isize`\n \
    \  |\n   = help: the trait `Mul<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as M"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    let mut digits = x;\n    let mut power = 1;\n    while (digits > base)\
    \ {\n        digits -= base;\n        power = power << 1;\n    }\n    let mut\
    \ rem = digits;\n    while rem > 0 {\n        rem = rem >> 1;\n        s = format!(\"\
    {}{}\", s, String::from(\"0\".to_string(base)));\n    }\n    format!(\"{}\", s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn39btkqs.rs:14:11\n\
    \   |\n14 |     while (digits > base) {\n   |           ^             ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n14 -     while (digits > base) {\n14 +     while digits > base {\n   |\
    \ \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpn39btkqs.rs:21:49\n     |\n21   |         s = format!(\"{}{}\"\
    , s, String::from(\"0\".to_string(base)));\n     |                           \
    \                      ^^^^^^^^^ ---- supplied 1 argument\n     |            \
    \                                     |\n     |                              \
    \                   expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = vec![0u8; MAX_DIGITS];\n\n    if x > base {\n        while\
    \ x >= base {\n            digits[x / base] = 1;\n            x -= base;\n   \
    \     }\n    } else {\n        while x <= base {\n            digits[x % base]\
    \ = 1;\n            x += base;\n        }\n    }\n\n    for i in 0..digits.len()\
    \ {\n        if digits[i] != 0 {\n            result.push(i);\n        }\n   \
    \ }\n\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmpfgr19y_4.rs:12:32\n\
    \   |\n12 |     let mut digits = vec![0u8; MAX_DIGITS];\n   |                \
    \                ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpfgr19y_4.rs:16:13\n   |\n\
    16 |             digits[x / base] = 1;\n   |             ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<u8>`\n\nerror[E0277]: the type `[u8]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpfgr19y_4.rs:21:13\n   |\n21 |  \
    \           digits[x % base] = 1;\n   |             ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfgr19y_4.rs:28:25\n\
    \   |\n28 |             result.push(i);\n   |                         ^ expected\
    \ `char`, found `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    \");\n    let mut i = x;\n    while i > 0 {\n        res = match i / base {\n\
    \            0 => String::from(\"0\"),\n            1 => String::from(\"1\"),\n\
    \            _ => String::from(\"0\") + res.clone(),\n        };\n        i %=\
    \ base;\n    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphy5p9h2m.rs:17:38\n   |\n\
    17 |             _ => String::from(\"0\") + res.clone(),\n   |               \
    \                       ^^^^^^^^^^^\n   |                                    \
    \  |\n   |                                      expected `&str`, found struct\
    \ `String`\n   |                                      help: consider borrowing\
    \ here: `&res`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::from(\"\
    0\");\n    for x in x.to_str() {\n        result += &x.chars().nth(base.to_string().chars().count()\
    \ * x as usize).to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_str` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpz52jpq0o.rs:12:16\n   |\n12 |     for x in x.to_str() {\n\
    \   |                ^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut out = String::new();\n\
    \    let mut temp = 1;\n    let mut last = 0;\n    while temp > 0 {\n        if\
    \ last + 1 < base {\n            out.push((x % base) as char);\n            last\
    \ += 1;\n        }\n        x /= base;\n        temp *= base;\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpa0rxjprg.rs:16:22\n\
    \   |\n16 |             out.push((x % base) as char);\n   |                  \
    \    ^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpa0rxjprg.rs:16:22\n   |\n16 |             out.push((x\
    \ % base) as char);\n   |                      ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0604`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    String::from(format!(\"\
    {}\", x / base))\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmp920xdq4b.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}\", x as\
    \ usize * base).to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4aufh310.rs:11:32\n   |\n\
    11 |     format!(\"{}\", x as usize * base).to_string()\n   |                \
    \                ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ multiply `usize` by `isize`\n  --> /tmp/tmp4aufh310.rs:11:30\n   |\n11 |   \
    \  format!(\"{}\", x as usize * base).to_string()\n   |                      \
    \        ^ no implementation for `usize * isize`\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     String::from(format!(\"{}\", x))\n    } else {\n        if base == 1 {\n\
    \            String::from(\"1\")\n        } else {\n            match x % base\
    \ {\n                0 => String::from(\"\"),\n                _ => {\n      \
    \              let mut s = String::from(\"\".to_string());\n                 \
    \   s.push_str(&format!(\"{}\", x));\n                    while x != 0 {\n   \
    \                     s.push_str(&format!(\"{}\", x % base));\n              \
    \          x /= base;\n                    }\n                    s\n        \
    \        }\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpsno9zgc8.rs:24:25\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n24 |      \
    \                   x /= base;\n   |                         ^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::with_capacity(x.to_string().len());\n\
    \    if x >= base {\n        for x in s.chars() {\n            *x = *x + (*x as\
    \ char) - base;\n        }\n    }\n    if x < base {\n        for x in s.chars().rev()\
    \ {\n            *x = *x + (*x as char) + base;\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:14:13\n\
    \   |\n14 |             *x = *x + (*x as char) - base;\n   |             ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:14:18\n\
    \   |\n14 |             *x = *x + (*x as char) - base;\n   |                 \
    \ ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:14:24\n\
    \   |\n14 |             *x = *x + (*x as char) - base;\n   |                 \
    \       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:19:13\n\
    \   |\n19 |             *x = *x + (*x as char) + base;\n   |             ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:19:18\n\
    \   |\n19 |             *x = *x + (*x as char) + base;\n   |                 \
    \ ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp0buo18_g.rs:19:24\n\
    \   |\n19 |             *x = *x + (*x as char) + base;\n   |                 \
    \       ^^\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    return String::from(\"0\");\n    }\n\n    if x % base == 0 {\n        return\
    \ String::from(\"0\");\n    }\n\n    let mut y = x;\n    let mut r = 1;\n\n  \
    \  while y > 0 {\n        let t = y % base;\n        r <<= 1;\n        if t >\
    \ 0 {\n            r |= 1;\n        }\n\n        y /= base;\n    }\n\n    let\
    \ mut result = String::from(\"0\");\n    for i in 0..r {\n        result.push_str(&format!(\"\
    {:0>2}\", i as u32));\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000010203040506\"`,\n right: `\"22\"`', /tmp/tmpws5ojoz_.rs:42:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = (0..x).collect::<String>().to_owned();\n\
    \    let mut new_base = base;\n    for &x in result.chars() {\n        if x <\
    \ new_base {\n            let base = new_base;\n            let mut result = String::from(\"\
    1\");\n            result += &x*(base);\n            new_base = base;\n      \
    \  }\n        result += &x*(new_base);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `isize`\n    --> /tmp/tmp5urgmjr3.rs:11:29\n     |\n11\
    \   |     let mut result = (0..x).collect::<String>().to_owned();\n     |    \
    \                         ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait `FromIterator<isize>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5urgmjr3.rs:13:9\n\
    \   |\n13 |     for &x in result.chars() {\n   |         ^^    --------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `x`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5urgmjr3.rs:17:23\n  \
    \ |\n17 |             result += &x*(base);\n   |                       ^^^^^^^^^\
    \ expected `&str`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5urgmjr3.rs:20:19\n\
    \   |\n20 |         result += &x*(new_base);\n   |                   ^^^^^^^^^^^^^\
    \ expected `&str`, found `isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x; // remainder after division by base\n    while remainder\
    \ > base {\n        remainder = remainder % base;\n        s = format!(\"{}{}\"\
    , s, base);\n    }\n    s = format!(\"{}{}\", s, remainder);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"32\"`,\n right: `\"22\"`', /tmp/tmpanliti4c.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::from(\"\
    0\");\n    for i in x.checked_mul(base.pow(i)).unwrap() {\n        result.push_str(&*i.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpkigt66ku.rs:12:37\n\
    \   |\n12 |     for i in x.checked_mul(base.pow(i)).unwrap() {\n   |         \
    \                            ^ help: a local variable with a similar name exists:\
    \ `x`\n\nerror[E0277]: `isize` is not an iterator\n  --> /tmp/tmpkigt66ku.rs:12:14\n\
    \   |\n12 |     for i in x.checked_mul(base.pow(i)).unwrap() {\n   |         \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `isize` is not an iterator\n   |\n \
    \  = help: the trait `Iterator` is not implemented for `isize`\n   = note: if\
    \ you want to iterate between `start` until a value `end`, use the exclusive range\
    \ syntax `start..end` or the inclusive range syntax `start..=end`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut y = x;\n   \
    \ let mut base = base as usize;\n    let mut base_rev = base as usize;\n    let\
    \ mut str = \"\";\n    while y > 0 {\n        if base_rev % 10 == 0 {\n      \
    \      base_rev /= 10;\n            str += \"0\".to_string();\n        }\n   \
    \     str += &format!(\"{}\", y % base).to_string();\n        y /= base;\n   \
    \ }\n    String::from(str)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpdwxu4g3o.rs:18:13\n   |\n18 |             str += \"0\"\
    .to_string();\n   |             ---^--^^^^^^^^^^^^^^^^\n   |             |   |\n\
    \   |             |   `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |             cannot use `+=` on type `&str`\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpdwxu4g3o.rs:20:35\n   |\n20 |         str += &format!(\"{}\", y\
    \ % base).to_string();\n   |                                   ^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  --> /tmp/tmpdwxu4g3o.rs:20:33\n\
    \   |\n20 |         str += &format!(\"{}\", y % base).to_string();\n   |     \
    \                            ^ no implementation for `isize % usize`\n   |\n \
    \  = help: the trait `Rem<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Rem<Rhs>`:\n             <&'a f32 as\
    \ Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n\
    \             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n    \
    \         <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n          \
    \   <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpdwxu4g3o.rs:20:9\n\
    \   |\n20 |         str += &format!(\"{}\", y % base).to_string();\n   |     \
    \    ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdwxu4g3o.rs:21:14\n\
    \   |\n21 |         y /= base;\n   |              ^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide-assign `isize` by `usize`\n  --> /tmp/tmpdwxu4g3o.rs:21:11\n\
    \   |\n21 |         y /= base;\n   |           ^^ no implementation for `isize\
    \ /= usize`\n   |\n   = help: the trait `DivAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    String::from(x.to_string().parse::<i64>().unwrap().pow(base).to_string())\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8963reu.rs:11:60\n   |\n\
    11 |     String::from(x.to_string().parse::<i64>().unwrap().pow(base).to_string())\n\
    \   |                                                            ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n11 |     String::from(x.to_string().parse::<i64>().unwrap().pow(base.try_into().unwrap()).to_string())\n\
    \   |                                                                ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    let mut x = x;\n        assert!(x <= 10, \"Base must be less than 10\");\n\
    \        let mut res = String::new();\n        while x > 0 {\n            res.push((x\
    \ - base as u32).to_string());\n            x /= base;\n        }\n        while\
    \ res.len() > 0 {\n            x.insert(0, res.pop().to_string());\n        }\n\
    \        res.to_string()\n    } else {\n        x.to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq92yj32b.rs:16:27\n   |\n\
    16 |             res.push((x - base as u32).to_string());\n   |              \
    \             ^^^^^^^^^^^ expected `isize`, found `u32`\n\nerror[E0277]: cannot\
    \ subtract `u32` from `isize`\n  --> /tmp/tmpq92yj32b.rs:16:25\n   |\n16 |   \
    \          res.push((x - base as u32).to_string());\n   |                    \
    \     ^ no implementation for `isize - u32`\n   |\n   = help: the trait `Sub<u32>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq92yj32b.rs:16:22\n\
    \   |\n16 |             res.push((x - base as u32).to_string());\n   |       \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `insert` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpq92yj32b.rs:20:15\n   |\n20 |             x.insert(0, res.pop().to_string());\n\
    \   |               ^^^^^^ method not found in `isize`\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpq92yj32b.rs:20:35\n  \
    \  |\n20  |               x.insert(0, res.pop().to_string());\n    |         \
    \                            ^^^^^^^^^ `Option<char>` cannot be formatted with\
    \ the default formatter\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    0\");\n    let mut digits = 0;\n    let mut tens = false;\n\n    while x != 0\
    \ {\n        let digit = x % base;\n        digits = digits*10 + digit;\n    \
    \    x /= base;\n\n        if x == 10 {\n            tens = true;\n        }\n\
    \n        res = res.push(String::from(digits));\n\n        if tens {\n       \
    \     res.push_str(\" \");\n        }\n    }\n\n    return res.trim_end();\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmpi36ltsty.rs:24:24\n   |\n24 |         res = res.push(String::from(digits));\n\
    \   |                        ^^^^^^^^^^^^ the trait `From<isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi36ltsty.rs:24:24\n   |\n24 |\
    \         res = res.push(String::from(digits));\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpi36ltsty.rs:24:15\n   |\n11 |     let mut res = String::from(\"\
    0\");\n   |                   ----------------- expected due to this value\n...\n\
    24 |         res = res.push(String::from(digits));\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push` modifies its\
    \ receiver in-place\n  --> /tmp/tmpi36ltsty.rs:24:19\n   |\n24 |         res =\
    \ res.push(String::from(digits));\n   |               --- ^^^^ this call modifies\
    \ `res` in-place\n   |               |\n   |               you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi36ltsty.rs:31:12\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n31 |     return res.trim_end();\n   |            ^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |            |\n   |         \
    \   expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    String::from(format!(\"{}\", x))\n    } else {\n        String::from(format!(\"\
    {}{}\", x / base, base))\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"23\"`,\n right: `\"22\"`', /tmp/tmp8u2wuvrh.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res: String\
    \ = \"\";\n    for i in x.to_string().chars().nth(base) {\n        if i > '9'\
    \ {\n            res += &format!(\"{}{}\", i as char, i as char);\n        } else\
    \ {\n            res += &format!(\"{}\", i as char);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpztkuhbbn.rs:11:27\n   |\n\
    11 |     let mut res: String = \"\";\n   |                  ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |     \
    \   |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpztkuhbbn.rs:12:40\n   |\n12 |     for i in x.to_string().chars().nth(base)\
    \ {\n   |                                        ^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n12 |     for i in x.to_string().chars().nth(base.try_into().unwrap())\
    \ {\n   |                                            ++++++++++++++++++++\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    if x <= base {\n        s.push(x);\n    } else {\n        let mut x = x;\n\
    \        let mut base = base;\n        while x > base {\n            x /= base;\n\
    \            s.push(x)\n        }\n        s.push(x);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6uqywkh.rs:13:16\n   |\n\
    13 |         s.push(x);\n   |                ^ expected `char`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp6uqywkh.rs:19:20\n   |\n19 |\
    \             s.push(x)\n   |                    ^ expected `char`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp6uqywkh.rs:21:16\n   |\n21 |\
    \         s.push(x);\n   |                ^ expected `char`, found `isize`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}\", x.to_base2(base))\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_base2` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpf7nef5gz.rs:11:21\n   |\n11 |     format!(\"{}\"\
    , x.to_base2(base))\n   |                     ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    format!(\"{}\", x)\n    } else {\n        let mut s = String::new();\n  \
    \      for i in 0..base.abs() {\n            let digit = x as isize / base;\n\
    \            let digits = digit as usize * base;\n            s.push_str(&format!(\"\
    {}\", digits));\n            x = x - digits as isize;\n        }\n        s\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpim0b2khi.rs:17:43\n   |\n\
    17 |             let digits = digit as usize * base;\n   |                   \
    \                        ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot multiply `usize` by `isize`\n  --> /tmp/tmpim0b2khi.rs:17:41\n   |\n\
    17 |             let digits = digit as usize * base;\n   |                   \
    \                      ^ no implementation for `usize * isize`\n   |\n   = help:\
    \ the trait `Mul<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x.abs();\n\
    \    let mut i = base;\n    let mut result = String::with_capacity(x.to_string().len()\
    \ * base.to_string().len());\n    while i > 0{\n        if x % i == 0 {\n    \
    \        result.append(&mut x.to_string().to_owned());\n            x /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    result.append(&mut\
    \ x.to_string().to_owned());\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpq719zkjd.rs:16:20\n   |\n16 |             result.append(&mut\
    \ x.to_string().to_owned());\n   |                    ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpq719zkjd.rs:22:12\n   |\n22 |     result.append(&mut\
    \ x.to_string().to_owned());\n   |            ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    String::from(\n    \
    \    (format!(\"{}\", x / base) as isize).to_string(),\n    )\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0605]: non-primitive cast: `String` as `isize`\n  --> /tmp/tmp_noum0sc.rs:12:9\n\
    \   |\n12 |         (format!(\"{}\", x / base) as isize).to_string(),\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used\
    \ to convert between primitive types or to coerce to a specific trait object\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0605`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut rep = String::new();\n\
    \    let mut digits = String::new();\n    for d in x.to_digits(base) {\n     \
    \   rep.push(*d);\n        digits.push_str(&to_string(*d));\n    }\n    if digits.len()\
    \ > 1 {\n        rep.push_str(&digits[..digits.len() - 1]);\n    }\n    if digits.len()\
    \ < base {\n        rep.push_str(&digits[base..]);\n    }\n    rep\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpypjysf30.rs:15:26\n\
    \   |\n15 |         digits.push_str(&to_string(*d));\n   |                   \
    \       ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpypjysf30.rs:13:16\n\
    \   |\n13 |     for d in x.to_digits(base) {\n   |                ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpypjysf30.rs:20:23\n\
    \   |\n20 |     if digits.len() < base {\n   |                       ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |     if digits.len()\
    \ < base.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<isize>`\n  -->\
    \ /tmp/tmpypjysf30.rs:21:23\n   |\n21 |         rep.push_str(&digits[base..]);\n\
    \   |                       ^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<isize>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x.to_string();\n\
    \    let mut base: String = base.to_string();\n    let mut base: String = base.to_digits();\n\
    \    while base.len() != 0 {\n        if base.len() < base.len() {\n         \
    \   x = x.rotate_left(base);\n        } else {\n            x = x.rotate_right(base);\n\
    \        }\n        let mut base: String = base.to_string();\n        base.reserve(base.len()\
    \ - 1);\n    }\n    x\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp1vplja9v.rs:13:33\n   |\n13 |     let mut base:\
    \ String = base.to_digits();\n   |                                 ^^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `rotate_left` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp1vplja9v.rs:16:19\n   |\n\
    16 |             x = x.rotate_left(base);\n   |                   ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `rotate_right`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp1vplja9v.rs:18:19\n\
    \   |\n18 |             x = x.rotate_right(base);\n   |                   ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `trim_right`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    // if base is less than\
    \ 10 then use radix conversion\n    if base < 10 {\n        let mut s = String::new();\n\
    \        // set base as string\n        s.push_str(&bases[base as usize]);\n \
    \       let mut x = x as isize;\n        // set x to new base\n        loop {\n\
    \            s.push_str(&xs[x as usize]);\n            if x > 0 {\n          \
    \      x /= base;\n            } else {\n                break;\n            }\n\
    \        }\n        String::from(s)\n    } else {\n        let mut s = String::new();\n\
    \        // set base as string\n        s.push_str(&bases[base as usize]);\n \
    \       let mut x = x as isize;\n        // set x to new base\n        loop {\n\
    \            s.push_str(&xs[x as usize]);\n            if x > 0 {\n          \
    \      x %= base;\n                if x == 0 {\n                    break;\n \
    \               }\n            }\n        }\n        String::from(s)\n    }\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bases` in this scope\n  --> /tmp/tmpvbo3bo44.rs:15:21\n\
    \   |\n15 |         s.push_str(&bases[base as usize]);\n   |                 \
    \    ^^^^^ help: a local variable with a similar name exists: `base`\n\nerror[E0425]:\
    \ cannot find value `xs` in this scope\n  --> /tmp/tmpvbo3bo44.rs:19:25\n   |\n\
    19 |             s.push_str(&xs[x as usize]);\n   |                         ^^\
    \ help: a local variable with a similar name exists: `s`\n\nerror[E0425]: cannot\
    \ find value `bases` in this scope\n  --> /tmp/tmpvbo3bo44.rs:30:21\n   |\n30\
    \ |         s.push_str(&bases[base as usize]);\n   |                     ^^^^^\
    \ help: a local variable with a similar name exists: `base`\n\nerror[E0425]: cannot\
    \ find value `xs` in this scope\n  --> /tmp/tmpvbo3bo44.rs:34:25\n   |\n34 | \
    \            s.push_str(&xs[x as usize]);\n   |                         ^^ help:\
    \ a local variable with a similar name exists: `s`\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    for i in 0..x.to_usize() {\n        if i % base == 0 {\n            s.push('0');\n\
    \        }\n        s.push((x as usize * base) + i as u8);\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_usize` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpqce9yv2s.rs:12:19\n   |\n12 |     for i in 0..x.to_usize()\
    \ {\n   |                   ^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqce9yv2s.rs:16:30\n   |\n16 |         s.push((x\
    \ as usize * base) + i as u8);\n   |                              ^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot multiply `usize` by `isize`\n\
    \  --> /tmp/tmpqce9yv2s.rs:16:28\n   |\n16 |         s.push((x as usize * base)\
    \ + i as u8);\n   |                            ^ no implementation for `usize\
    \ * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqce9yv2s.rs:16:38\n   |\n16 |         s.push((x\
    \ as usize * base) + i as u8);\n   |                                      ^^^^^^^\
    \ expected `usize`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqce9yv2s.rs:16:16\n\
    \   |\n16 |         s.push((x as usize * base) + i as u8);\n   |             \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0277]:\
    \ cannot add `u8` to `usize`\n  --> /tmp/tmpqce9yv2s.rs:16:36\n   |\n16 |    \
    \     s.push((x as usize * base) + i as u8);\n   |                           \
    \         ^ no implementation for `usize + u8`\n   |\n   = help: the trait `Add<u8>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    assert!(base < 10);\n\
    \    let mut s = String::new();\n    while x > 0 {\n        write!(s, \"{}\",\
    \ x % base).unwrap();\n        x /= base;\n    }\n    s\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `write_fmt` found for struct `String` in\
    \ the current scope\n   --> /tmp/tmpk9u3rsku.rs:14:9\n    |\n14  |         write!(s,\
    \ \"{}\", x % base).unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ method\
    \ not found in `String`\n    |\n    = help: items from traits can only be used\
    \ if the trait is in scope\n    = note: this error originates in the macro `write`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n\
    1   | use std::fmt::Write;\n    |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut n = x;\n    while n > 0 {\n        let q = n%base;\n        s.push((&mut\
    \ s[q]).to_string()[q]);\n        n = n/base;\n    }\n    s.reverse();\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpiu7hhnwk.rs:15:22\n\
    \   |\n15 |         s.push((&mut s[q]).to_string()[q]);\n   |                \
    \      ^^^^ `String` cannot be indexed by `isize`\n   |\n   = help: the trait\
    \ `Index<isize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpiu7hhnwk.rs:18:7\n   |\n18 |     s.reverse();\n\
    \   |       ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::new();\n\
    \    let mut digits = Vec::new();\n\n    while x >= base {\n        res.push_str(&format!(\"\
    {}\", x / base).to_string());\n        digits.push(x);\n        x -= base;\n \
    \   }\n    res.push_str(&format!(\"{}\", x).to_string());\n\n    if res.length()\
    \ > 0 {\n        res.push_str(&format!(\"+{}\", digits.len()).to_string());\n\
    \        res.push_str(&digits.into_iter().collect::<String>());\n    }\n\n   \
    \ res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmph02yl4ez.rs:21:12\n   |\n21 |     if res.length()\
    \ > 0 {\n   |            ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0277]: a value of type `String` cannot be built from an\
    \ iterator over elements of type `isize`\n    --> /tmp/tmph02yl4ez.rs:23:42\n\
    \     |\n23   |         res.push_str(&digits.into_iter().collect::<String>());\n\
    \     |                                          ^^^^^^^ value of type `String`\
    \ cannot be built from `std::iter::Iterator<Item=isize>`\n     |\n     = help:\
    \ the trait `FromIterator<isize>` is not implemented for `String`\n     = help:\
    \ the following other types implement trait `FromIterator<A>`:\n             \
    \  <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut acc = String::new();\n\
    \    let mut digit = 0;\n    let mut pow = x;\n    while pow >= base {\n     \
    \   digit = pow % base;\n        pow = (pow / base) as usize;\n        acc.push(digit\
    \ as char);\n    }\n    acc.push((pow % base) as char);\n    acc\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf41rbmew.rs:16:15\n   |\n\
    13 |     let mut pow = x;\n   |                   - expected due to this value\n\
    ...\n16 |         pow = (pow / base) as usize;\n   |               ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `isize`\n  --> /tmp/tmpf41rbmew.rs:17:18\n   |\n17 |         acc.push(digit\
    \ as char);\n   |                  ^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try\
    \ `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpf41rbmew.rs:17:18\n  \
    \ |\n17 |         acc.push(digit as char);\n   |                  ^^^^^^^^^^^^^\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpf41rbmew.rs:19:14\n\
    \   |\n19 |     acc.push((pow % base) as char);\n   |              ^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpf41rbmew.rs:19:14\n   |\n19 |     acc.push((pow % base) as char);\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    0\");\n    while x > 0 {\n        res.insert(0, char::to_digit(x % base));\n \
    \       x /= base;\n    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpl8drz058.rs:13:23\n    |\n13  |         res.insert(0, char::to_digit(x\
    \ % base));\n    |                       ^^^^^^^^^^^^^^ -------- supplied 1 argument\n\
    \    |                       |\n    |                       expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl8drz058.rs:13:23\n   |\n13 |         res.insert(0, char::to_digit(x\
    \ % base));\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<u32>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result: String\
    \ = String::new();\n    while x > 0 {\n        if x % base == 0 {\n          \
    \  result += &x[..(base - 1)].to_string();\n        }\n        x /= base;\n  \
    \  }\n    if x > 0 {\n        result += &x[..(base - 1)].to_string();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpjq9rcj1d.rs:14:24\n\
    \   |\n14 |             result += &x[..(base - 1)].to_string();\n   |        \
    \                ^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `isize`\n  --> /tmp/tmpjq9rcj1d.rs:19:20\n   |\n19 |         result +=\
    \ &x[..(base - 1)].to_string();\n   |                    ^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     let mut s = String::new();\n        for (i, digit) in x.to_digits().chars().enumerate()\
    \ {\n            if i >= base {\n                s.push('0');\n            }\n\
    \            s.push(digit);\n        }\n        String::from(s)\n    } else {\n\
    \        String::from(x.to_digits().to_base10(base))\n    }\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpjhcp4kwn.rs:13:29\n   |\n13 |         for (i, digit)\
    \ in x.to_digits().chars().enumerate() {\n   |                             ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `to_digits` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpjhcp4kwn.rs:21:24\n   |\n\
    21 |         String::from(x.to_digits().to_base10(base))\n   |               \
    \         ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    match base {\n     \
    \   1 => String::from(\"1\"),\n        2 => String::from(\"10\"),\n        3 =>\
    \ String::from(\"100\"),\n        4 => String::from(\"1000\"),\n        5 => String::from(\"\
    10000\"),\n        6 => String::from(\"100000\"),\n        7 => String::from(\"\
    1000000\"),\n        8 => String::from(\"10000000\"),\n        9 => String::from(\"\
    100000000\"),\n        10 => String::from(\"1000000000\"),\n        _ => {\n \
    \           let mut buf: Vec<String> = vec![String::new(); 12];\n            let\
    \ mut base = base;\n            while base.is_positive() {\n                let\
    \ mut s = String::new();\n                let mut carry = 0;\n               \
    \ for n in x.iter().rev() {\n                    if n == 0 {\n               \
    \         break;\n                    }\n                    let mut q = base;\n\
    \                    if let Some(factor) = &mut carry {\n                    \
    \    if *n >= factor {\n                            q.0 += *n;\n             \
    \               carry = *n / factor;\n                        } else {\n     \
    \                       q.0 -= factor + 1;\n                            carry\
    \ = *n / factor;\n                        }\n                    } else {\n  \
    \                      if *n > 0 {\n                            q.0 += *n;\n \
    \                           carry = 1;\n                        } else if *n <\
    \ 0 {\n                            q.0 -= *n;\n                            carry\
    \ = -1;\n                        } else {\n                            q.0 +=\
    \ 1;\n                            carry = 0;\n                        }\n    \
    \                }\n                    *s = String::from(format!(\"{}{}\", q.0,\
    \ q.1%base));\n                }\n                if carry != 0 {\n          \
    \          s.prepend(String::from(\"{}\", -carry));\n                }\n     \
    \           buf.push(*s);\n                base = q;\n            }\n        \
    \    String::concat(&buf)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `q` in this scope\n  --> /tmp/tmpyucd816y.rs:59:24\n\
    \   |\n59 |                 base = q;\n   |                        ^ help: a local\
    \ variable with a similar name exists: `s`\n\nerror[E0599]: no method named `iter`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpyucd816y.rs:28:28\n\
    \   |\n28 |                 for n in x.iter().rev() {\n   |                  \
    \          ^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyucd816y.rs:33:28\n   |\n33 |                     if let Some(factor)\
    \ = &mut carry {\n   |                            ^^^^^^^^^^^^   ---------- this\
    \ expression has type `&mut {integer}`\n   |                            |\n  \
    \ |                            expected integer, found enum `Option`\n   |\n \
    \  = note: expected type `{integer}`\n              found enum `Option<_>`\n\n\
    error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpyucd816y.rs:35:31\n   |\n35 | ...                   q.0 += *n;\n\
    \   |                         ^\n\nerror[E0610]: `isize` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpyucd816y.rs:38:31\n   |\n38 | ...\
    \                   q.0 -= factor + 1;\n   |                         ^\n\nerror[E0369]:\
    \ cannot add `{integer}` to `&mut _`\n  --> /tmp/tmpyucd816y.rs:38:43\n   |\n\
    38 | ...                   q.0 -= factor + 1;\n   |                          \
    \    ------ ^ - {integer}\n   |                              |\n   |         \
    \                     &mut _\n\nerror[E0610]: `isize` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpyucd816y.rs:43:31\n   |\n43 | ...\
    \                   q.0 += *n;\n   |                         ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpyucd816y.rs:46:31\n\
    \   |\n46 | ...                   q.0 -= *n;\n   |                         ^\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpyucd816y.rs:49:31\n   |\n49 | ...                   q.0 += 1;\n\
    \   |                         ^\n\nerror[E0610]: "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::from(\"\
    0\");\n    if x == 0 {\n        return s; // base case of recursion\n    }\n \
    \   if base == 0 {\n        if x > 10 {\n            // we do not need to keep\
    \ any sign for base < 10.\n            let mut tmp = s.to_string();\n        \
    \    tmp = tmp.split_last_mut(1);\n            tmp += \"0\".to_string();\n   \
    \         s = tmp;\n        }\n        return s;\n    }\n    let mut digits =\
    \ Vec::new();\n    for digit in &x.to_digits() {\n        let mut i = digit;\n\
    \        if base > 10 {\n            i = digit.to_digits();\n            i +=\
    \ 1;\n        }\n        if i >= base {\n            i += base - i;\n        }\n\
    \        digits.push(i as u8);\n    }\n    // reverse the digits so that digits\
    \ are in descending order.\n    let mut revdigits = digits.clone();\n    revdigits.rev();\n\
    \    String::from_utf8(revdigits.as_bytes()).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_last_mut` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp73fl1u04.rs:19:23\n   |\n19 |          \
    \   tmp = tmp.split_last_mut(1);\n   |                       ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `split_at`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp73fl1u04.rs:20:20\n   |\n20 |             tmp\
    \ += \"0\".to_string();\n   |                    ^^^^^^^^^^^^^^^\n   |       \
    \             |\n   |                    expected `&str`, found struct `String`\n\
    \   |                    help: consider borrowing here: `&\"0\".to_string()`\n\
    \nerror[E0599]: no method named `to_digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp73fl1u04.rs:26:21\n   |\n26 |     for digit in &x.to_digits()\
    \ {\n   |                     ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ `Vec<_>` is not an iterator\n   --> /tmp/tmp73fl1u04.rs:39:15\n    |\n39  |\
    \       revdigits.rev();\n    |                 ^^^ `Vec<_>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<_>: Iterator`\n            which is required by `&mut Vec<_>: Iterator`\n\
    \            `[_]: Iterator`\n            which is required by `&mut [_]: Iterator`\n\
    \nerror[E0599]: no method named `as_bytes` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmp73fl1u04.rs:40:33\n   |\n40 |     String::from_utf8(revdigits.as_bytes()).unwrap()\n\
    \   |                                 ^^^^^^^^ method not found in `Vec<_>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use std::ascii::AsciiExt;\n\
    \    use std::ascii::Lower;\n\n    // TODO: handle negative numbers\n\n    use\
    \ num_traits::FromPrimitive;\n    let x = x.to_digits();\n    let mut xstr = String::new();\n\
    \    for i in x.iter() {\n        xstr.push(match i {\n            0 => \"0\"\
    ,\n            1 => \"1\",\n            2 => \"11\",\n            3 => \"12\"\
    ,\n            4 => \"13\",\n            5 => \"14\",\n            6 => \"15\"\
    ,\n            7 => \"16\",\n            8 => \"17\",\n            9 => \"18\"\
    ,\n            _ => format!(\"{}\", i).into(),\n        });\n    }\n    let xstr\
    \ = xstr.to_ascii_lowercase();\n\n    let mut basestr = String::new();\n    match\
    \ base {\n        10 => basestr.push_str(\"0\"),\n        11 => basestr.push_str(\"\
    1\"),\n        12 => basestr.push_str(\"10\"),\n        13 => basestr.push_str(\"\
    11\"),\n        14 => basestr.push_str(\"12\"),\n        15 => basestr.push_str(\"\
    13\"),\n        16 => basestr.push_str(\"14\"),\n        17 => basestr.push_str(\"\
    15\"),\n        18 => basestr.push_str(\"16\"),\n        19 => basestr.push_str(\"\
    17\"),\n        20 => basestr.push_str(\"18\"),\n        21 => basestr.push_str(\"\
    19\"),\n        22 => basestr.push_str(\"20\"),\n        23 => basestr.push_str(\"\
    21\"),\n        24 => basestr.push_str(\"22\"),\n        25 => basestr.push_str(\"\
    23\"),\n        26 => basestr.push_str(\"24\"),\n        27 => basestr.push_str(\"\
    25\"),\n        28 => basestr.push_str(\"26\"),\n        29 => basestr.push_str(\"\
    27\"),\n        30 => basestr.push_str(\"28\"),\n        31 => basestr.push_str(\"\
    29\"),\n        _ => panic!(\"base number must be 10..31\"),\n    }\n    basestr.to_ascii_lowercase()\n\
    \        .into_string()\n        .unwrap()\n        .into_ascii_lowercase()\n\
    \        .into_string()\n        .unwrap()\n        .into_digits()\n        .unwrap()\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `std::ascii::Lower`\n  --> /tmp/tmpqqa15i_f.rs:12:9\n\
    \   |\n12 |     use std::ascii::Lower;\n   |         ^^^^^^^^^^^^^^^^^ no `Lower`\
    \ in `ascii`\n\nerror[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpqqa15i_f.rs:16:9\n\
    \   |\n16 |     use num_traits::FromPrimitive;\n   |         ^^^^^^^^^^ maybe\
    \ a missing crate `num_traits`?\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`:\
    \ use inherent methods instead\n  --> /tmp/tmpqqa15i_f.rs:11:21\n   |\n11 |  \
    \   use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpqqa15i_f.rs:17:15\n\
    \   |\n17 |     let x = x.to_digits();\n   |               ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqqa15i_f.rs:21:18\n\
    \   |\n21 |             0 => \"0\",\n   |                  ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n21 |             0 => '0',\n   |                  ~~~\n\nerror[E0599]:\
    \ no method named `into_string` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpqqa15i_f.rs:63:10\n   |\n63 |         .into_string()\n   |    \
    \      ^^^^^^^^^^^ method not found in `String`\n\nwarning: unused import: `std::ascii::AsciiExt`\n\
    \  --> /tmp/tmpqqa15i_f.rs:11:9\n   |\n11 |     use std::ascii::AsciiExt;\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\
    \nSome errors have detailed explanations: E0308, E0432, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x;\n   \
    \ let mut base = 2**base;\n    let mut result = String::new();\n    while x !=\
    \ 0 {\n        if x % base == 0 {\n            result.push((x % base) as char);\n\
    \        }\n        x /= base;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp6e9pkzi0.rs:12:22\n\
    \   |\n12 |     let mut base = 2**base;\n   |                      ^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp6e9pkzi0.rs:16:25\n\
    \   |\n16 |             result.push((x % base) as char);\n   |               \
    \          ^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmp6e9pkzi0.rs:16:25\n   |\n16 |             result.push((x\
    \ % base) as char);\n   |                         ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0604, E0614.\nFor more information about an error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}{}\", to_base(x,\
    \ base), to_base(base - 1, base))\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmpwstjtlzl.rs:11:21\n\
    \   |\n11 |     format!(\"{}{}\", to_base(x, base), to_base(base - 1, base))\n\
    \   |                     ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `to_base` in this scope\n  --> /tmp/tmpwstjtlzl.rs:11:39\n   |\n\
    11 |     format!(\"{}{}\", to_base(x, base), to_base(base - 1, base))\n   |  \
    \                                     ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut number = x;\n    let mut divisor = base;\n    while number > 0 {\n\
    \        if number % divisor == 0 {\n            s.insert(0, number as isize);\n\
    \        }\n        number /= divisor;\n        divisor /= base;\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt9nqrvmp.rs:16:25\n   |\n\
    16 |             s.insert(0, number as isize);\n   |                         ^^^^^^^^^^^^^^^\
    \ expected `char`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::from(\"\
    0\");\n    for &i in x.to_string().chars().filter_map(|c| match c {\n        '0'..='9'\
    \ => {\n            let mut r = 1;\n            for i in c.to_string().chars().filter_map(|c|\
    \ match c {\n                '0'..='9' => {\n                    r = r * 10 +\
    \ c - '0';\n                }\n                _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n            }) {\n                res = res.insert(i, r as\
    \ char);\n            }\n        }\n        _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n    }) {\n        res = res.insert(i, '0');\n    }\n    for\
    \ i in base.to_string().chars().filter_map(|c| match c {\n        '0'..='9' =>\
    \ {\n            let mut r = 1;\n            for i in res.chars().filter_map(|c|\
    \ match c {\n                '0'..='9' => {\n                    r = r * 10 +\
    \ c - '0';\n                }\n                _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n            }) {\n                res = res.insert(i, r as\
    \ char);\n            }\n        }\n        _ => return Err(format!(\"{}: invalid\
    \ character\", c)),\n    }) {\n        res = res.insert(i, '0');\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `char` to `{integer}`\n  --> /tmp/tmpj0ytxwqo.rs:17:32\n\
    \   |\n17 |                     r = r * 10 + c - '0';\n   |                  \
    \              ^ no implementation for `{integer} + char`\n   |\n   = help: the\
    \ trait `Add<char>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj0ytxwqo.rs:16:30\n   |\n16 |                   '0'..='9'\
    \ => {\n   |  ______________________________^\n17 | |                     r =\
    \ r * 10 + c - '0';\n18 | |                 }\n   | |_________________^ expected\
    \ enum `Option`, found `()`\n   |\n   = note:   expected enum `Option<_>`\n  \
    \         found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0ytxwqo.rs:19:29\n\
    \   |\n19 |                 _ => return Err(format!(\"{}: invalid character\"\
    , c)),\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found enum `Result<_, String>`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n19 |                 _ => return Some(Err(format!(\"\
    {}: invalid character\", c))),\n   |                             +++++       \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj0ytxwqo.rs:21:23\n\
    \   |\n11 |     let mut res = String::from(\"0\");\n   |                   -----------------\
    \ expected due to this value\n...\n21 |                 res = res.insert(i, r\
    \ as char);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `insert` modifies its receiver in-place\n\
    \  --> /tmp/tmpj0ytxwqo.rs:21:27\n   |\n21 |                 res = res.insert(i,\
    \ r as char);\n   |"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut y = x;\n   \
    \ let mut z = base;\n    while y >= z {\n        let mut i = y;\n        y = i\
    \ / z;\n        z = z * base;\n    }\n    String::from_str(format!(\"{}\", y)).unwrap()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp9j3l145t.rs:18:13\n   |\n\
    18 |     String::from_str(format!(\"{}\", y)).unwrap()\n   |             ^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::str::FromStr;\n   |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x < base {\n    \
    \    let mut buffer = String::new();\n        for i in 0..x.log10() {\n      \
    \      let num = base ** i;\n            let digit = x % num;\n            buffer.push_str(&format!(\"\
    {}\", digit));\n        }\n        buffer\n    } else {\n        let mut buffer\
    \ = String::new();\n        for i in 0..(base.log10() - x.log10()) {\n       \
    \     let num = base ** (x.log10() - i);\n            let digit = x % num;\n \
    \           buffer.push_str(&format!(\"{}\", digit));\n        }\n        buffer.push_str(&format!(\"\
    {}\", x))\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpn5dtxj6q.rs:13:23\n\
    \   |\n13 |         for i in 0..x.log10() {\n   |                       ^^^^^\n\
    \   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0614]: type `u32` cannot be dereferenced\n  -->\
    \ /tmp/tmpn5dtxj6q.rs:14:29\n   |\n14 |             let num = base ** i;\n   |\
    \                             ^^^\n\nerror[E0658]: use of unstable library feature\
    \ 'int_log'\n  --> /tmp/tmpn5dtxj6q.rs:21:27\n   |\n21 |         for i in 0..(base.log10()\
    \ - x.log10()) {\n   |                           ^^^^^\n   |\n   = note: see issue\
    \ #70887 <https://github.com/rust-lang/rust/issues/70887> for more information\n\
    \nerror[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpn5dtxj6q.rs:21:39\n\
    \   |\n21 |         for i in 0..(base.log10() - x.log10()) {\n   |           \
    \                            ^^^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0658]: use of unstable library feature 'int_log'\n\
    \  --> /tmp/tmpn5dtxj6q.rs:22:34\n   |\n22 |             let num = base ** (x.log10()\
    \ - i);\n   |                                  ^^^^^\n   |\n   = note: see issue\
    \ #70887 <https://github.com/rust-lang/rust/issues/70887> for more information\n\
    \nerror[E0614]: type `u32` cannot be dereferenced\n  --> /tmp/tmpn5dtxj6q.rs:22:29\n\
    \   |\n22 |             let num = base ** (x.log10() - i);\n   |             \
    \                ^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn5dtxj6q.rs:26:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n26 |         buffer.push_str(&format!(\"{}\", x))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpn5dtxj6q.rs:26:16\n   |\n26 |         buffer.push_str(&format!(\"\
    {}\", x))\n   |         ------ ^^^^^^^^ this call modifies `buf"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::with_capacity(x.to_string().len());\n\
    \    while x > 0 {\n        res.push_str(&to_base(x, base));\n        x /= base;\n\
    \    }\n    res.push_str(&to_base(x - 1, base));\n    return res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmpaht7c80m.rs:13:23\n\
    \   |\n13 |         res.push_str(&to_base(x, base));\n   |                   \
    \    ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_base`\
    \ in this scope\n  --> /tmp/tmpaht7c80m.rs:16:19\n   |\n16 |     res.push_str(&to_base(x\
    \ - 1, base));\n   |                   ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if x <= 0 {\n      \
    \  String::from(\"\".to_string())\n    }\n    if base > 10 {\n        String::from(\"\
    \".to_string())\n    }\n    let mut string_res = String::new();\n    let mut base\
    \ = x;\n    let mut base_pre = 1;\n    while base != 1 {\n        let mut mul\
    \ = 1;\n        let mut div = 1;\n        let mut remainder = 0;\n        let\
    \ mut carry = 1;\n        while base != 1 {\n            let mut tmp = base;\n\
    \            tmp = tmp * mul + carry;\n            remainder %= 10;\n        \
    \    div = div * 10 + remainder;\n            carry = tmp / 10;\n            base\
    \ = tmp % 10;\n        }\n        string_res = string_res[..0].to_string() + to_string(carry)\
    \ + to_string(remainder);\n        base = base_pre * div;\n        base_pre =\
    \ base_pre * mul;\n    }\n    if base_pre * 10 == x {\n        string_res\n  \
    \  } else {\n        string_res[..0].to_string() + String::from(\"\".to_string())\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmp6_qjlzsm.rs:33:52\n\
    \   |\n33 |         string_res = string_res[..0].to_string() + to_string(carry)\
    \ + to_string(remainder);\n   |                                              \
    \      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `to_string` in this scope\n  --> /tmp/tmp6_qjlzsm.rs:33:71\n   |\n33 |     \
    \    string_res = string_res[..0].to_string() + to_string(carry) + to_string(remainder);\n\
    \   |                                                                       ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_qjlzsm.rs:12:9\n\
    \   |\n11 | /     if x <= 0 {\n12 | |         String::from(\"\".to_string())\n\
    \   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    13 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n12 |         String::from(\"\".to_string());\n   | \
    \                                    +\nhelp: consider using a semicolon here\n\
    \   |\n13 |     };\n   |      +\nhelp: you might have meant to return this value\n\
    \   |\n12 |         return String::from(\"\".to_string());\n   |         ++++++\
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_qjlzsm.rs:15:9\n\
    \   |\n14 | /     if base > 10 {\n15 | |         String::from(\"\".to_string())\n\
    \   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    16 | |     }\n   | |_____- expected this to be `()`\n   |\nhelp: consider using\
    \ a semicolon here\n   |\n15 |         String::from(\"\".to_string());\n   | \
    \                                    +\nhelp: consider using a semicolon here\n\
    \   |\n16 |     };\n   |      +\nhelp: you might have meant to return this value\n\
    \   |\n15 |         return String::from(\"\".to_string());\n   |         ++++++\
    \                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_qjlzsm.rs:40:39\n\
    \   |\n40 |         string_res[..0].to_string() + String::from(\"\".to_string())\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base == 0 {\n   \
    \     String::from(\"0\")\n    } else {\n        if x < 10 {\n            format!(\"\
    {}\", x)\n        } else {\n            format!(\"{}\", x / base).to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8\"`,\n right: `\"22\"`', /tmp/tmpn0gloeye.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}{}\", digit_to_base(x,\
    \ base), digit_to_base(x, base))\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digit_to_base` in this scope\n  -->\
    \ /tmp/tmphcvld0ox.rs:11:21\n   |\n11 |     format!(\"{}{}\", digit_to_base(x,\
    \ base), digit_to_base(x, base))\n   |                     ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `digit_to_base` in this\
    \ scope\n  --> /tmp/tmphcvld0ox.rs:11:45\n   |\n11 |     format!(\"{}{}\", digit_to_base(x,\
    \ base), digit_to_base(x, base))\n   |                                       \
    \      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x.to_string();\n\
    \    if base > 10 {\n        let mut x = x.trim_start();\n        if x.len() <\
    \ base.to_string().len() {\n            x = &x[..(x.len() - base.to_string().len())]\
    \ + &base.to_string()[..];\n        }\n    }\n    String::from(x)\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmplq8zy7cq.rs:15:58\n\
    \   |\n15 |             x = &x[..(x.len() - base.to_string().len())] + &base.to_string()[..];\n\
    \   |                 ---------------------------------------- ^ ---------------------\
    \ &str\n   |                 |                                        |\n   |\
    \                 |                                        `+` cannot be used\
    \ to concatenate two `&str` strings\n   |                 &str\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\nhelp: remove the\
    \ borrow to obtain an owned `String`\n   |\n15 -             x = &x[..(x.len()\
    \ - base.to_string().len())] + &base.to_string()[..];\n15 +             x = x[..(x.len()\
    \ - base.to_string().len())] + &base.to_string()[..];\n   | \n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    format!(\"{}\", x.to_digits(base))\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpose6gamm.rs:11:21\n   |\n11 |     format!(\"{}\"\
    , x.to_digits(base))\n   |                     ^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut v = base::to_string(x);\n\
    \    while v.len() > base {\n        v = &v[v.len() - 1];\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `base`\n\
    \  --> /tmp/tmpm8bjnh5x.rs:11:17\n   |\n11 |     let mut v = base::to_string(x);\n\
    \   |                 ^^^^ use of undeclared crate or module `base`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: -1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    String::from(\"0\".to_string())\n    } else {\n        let mut result = String::from(\"\
    0\".to_string());\n        while x != 0 {\n            let digit = x % base;\n\
    \            let x = x / base;\n            result = format!(\"{}{}\", result,\
    \ digit);\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut ret = String::with_capacity(x.to_string().len()\
    \ * base.to_string().len());\n    let mut remaining = x;\n    let mut base10 =\
    \ base.pow(10);\n    while remaining > 0 {\n        let digit = remaining.rem::<usize>();\n\
    \        remaining = remaining.div::<usize>(base10);\n        ret += digit.to_string();\n\
    \    }\n    ret.reverse();\n    ret\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rem` found for type `isize` in the current\
    \ scope\n   --> /tmp/tmp0wpqok5c.rs:15:31\n    |\n15  |         let digit = remaining.rem::<usize>();\n\
    \    |                               ^^^ method not found in `isize`\n    |\n\
    \    = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n    |\n1   | use std::ops::Rem;\n    |\n\nerror[E0599]: no method named\
    \ `div` found for type `isize` in the current scope\n   --> /tmp/tmp0wpqok5c.rs:16:31\n\
    \    |\n16  |         remaining = remaining.div::<usize>(base10);\n    |     \
    \                          ^^^ method not found in `isize`\n    |\n    = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n    |\n\
    1   | use std::ops::Div;\n    |\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp0wpqok5c.rs:19:9\n \
    \  |\n19 |     ret.reverse();\n   |         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    return format!(\"{:?}\", x);\n    }\n\n    let mut res = String::new();\n\
    \n    while x > base {\n        x /= base;\n        res += \"0\";\n    }\n\n \
    \   res += &x.to_string()[..base];\n    res\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmp799usxzs.rs:22:13\n   |\n22 |     res += &x.to_string()[..base];\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    while x != 0 {\n        match x % base {\n            0 => s.push_str(\"\
    0\"),\n            1 => s.push_str(\"1\"),\n            _ => s.push_str(\"0\"\
    ),\n        }\n        x /= base;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpwwwi2jet.rs:18:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n18 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut res = String::new();\n\
    \    while x > 0 {\n        let digit = x % base;\n        res.insert(0, digit.to_string());\n\
    \        x /= base;\n    }\n    while res.ends_with('0') {\n        res.pop();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9mqssvxv.rs:14:23\n   |\n\
    14 |         res.insert(0, digit.to_string());\n   |                       ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 2 {\n    \
    \    return String::new();\n    }\n    let mut res = String::from(\"0\");\n  \
    \  match (base, x) {\n        (10, n) => {\n            res.push_str(&n.to_string());\n\
    \        }\n        (d, 10) => panic!(\"base 10 not supported\"),\n        (_,\
    \ n) => {\n            if n >= 10 {\n                res.push_str(&n.to_string());\n\
    \            } else {\n                if n >= d {\n                    res.push_str(&n.to_string()\
    \ + &\"0\".to_string());\n                } else {\n                    res.push_str(&n.to_string()\
    \ + &\"1\".to_string());\n                }\n            }\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `d` in this scope\n  --> /tmp/tmp4hke195e.rs:24:25\n\
    \   |\n24 |                 if n >= d {\n   |                         ^ help:\
    \ a local variable with a similar name exists: `n`\n\nerror[E0369]: cannot add\
    \ `&String` to `&String`\n  --> /tmp/tmp4hke195e.rs:25:49\n   |\n25 |        \
    \             res.push_str(&n.to_string() + &\"0\".to_string());\n   |       \
    \                           -------------- ^ ---------------- &String\n   |  \
    \                                |              |\n   |                      \
    \            |              `+` cannot be used to concatenate two `&str` strings\n\
    \   |                                  &String\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: remove the borrow to obtain an\
    \ owned `String`\n   |\n25 -                     res.push_str(&n.to_string() +\
    \ &\"0\".to_string());\n25 +                     res.push_str(n.to_string() +\
    \ &\"0\".to_string());\n   | \n\nerror[E0369]: cannot add `&String` to `&String`\n\
    \  --> /tmp/tmp4hke195e.rs:27:49\n   |\n27 |                     res.push_str(&n.to_string()\
    \ + &\"1\".to_string());\n   |                                  --------------\
    \ ^ ---------------- &String\n   |                                  |        \
    \      |\n   |                                  |              `+` cannot be used\
    \ to concatenate two `&str` strings\n   |                                  &String\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n27 -              \
    \       res.push_str(&n.to_string() + &\"1\".to_string());\n27 +             \
    \        res.push_str(n.to_string() + &\"1\".to_string());\n   | \n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0369, E0425.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 0 || base\
    \ > 10 {\n        panic!(\"Base has to be between 0 and 10.\");\n    }\n    let\
    \ mut s = String::new();\n    let mut i = x;\n    while i > 0 {\n        s +=\n\
    \            i.to_str() + if i < 10 { char::from('0') } else { char::from('1')\
    \ };\n        i = i / base;\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_str` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpigaycmym.rs:18:15\n   |\n18 |             i.to_str() +\
    \ if i < 10 { char::from('0') } else { char::from('1') };\n   |              \
    \ ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    use std::cmp::Ordering;\n\
    \    use std::fmt::{self, Display};\n    use std::num::One;\n    let one: One\
    \ = One::new();\n    let mut s = String::with_capacity(4);\n    let mut nums =\
    \ &x[..];\n    while nums.len() >= base {\n        let mut base = &nums[..];\n\
    \        if base < base {\n            let mut base = &nums[..];\n           \
    \ while base.len() < base {\n                base.push('0');\n            }\n\
    \        }\n        let mut num = &nums[..];\n        let digits = num.len()-base;\n\
    \        while num.len() < digits {\n            num.push('0');\n        }\n \
    \       let mut nums: Vec<_> = base\n            .iter()\n            .zip(num.iter())\n\
    \            .map(|(a, b)| a.to_digit(base).unwrap().checked_add(&b.to_digit(base).unwrap()))\n\
    \            .collect();\n        while nums.len() > 1 {\n            let mut\
    \ bases: Vec<_> = nums\n                .iter()\n                .map(|n| n.checked_mul(base).unwrap())\n\
    \                .collect();\n            num = &bases[..];\n            nums\
    \ = num.iter()\n                .map(|a| a.to_digit(base).unwrap().clone())\n\
    \                .collect();\n        }\n        s = s.push_str(&nums.into_iter().collect());\n\
    \    }\n    if nums.len() > 4 {\n        s = s.push_str(&nums.into_iter().take(4).collect());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `std::num::One`\n  --> /tmp/tmp87iu1waz.rs:13:9\n\
    \   |\n13 |     use std::num::One;\n   |         ^^^^^^^^^^^^^ no `One` in `num`\n\
    \nwarning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp87iu1waz.rs:11:9\n\
    \   |\n11 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports:\
    \ `Display`, `self`\n  --> /tmp/tmp87iu1waz.rs:12:20\n   |\n12 |     use std::fmt::{self,\
    \ Display};\n   |                    ^^^^  ^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmp87iu1waz.rs:16:21\n   |\n16 |  \
    \   let mut nums = &x[..];\n   |                     ^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp87iu1waz.rs:45:13\n   |\n15 |     let mut s = String::with_capacity(4);\n\
    \   |                 ------------------------ expected due to this value\n...\n\
    45 |         s = s.push_str(&nums.into_iter().collect());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmp87iu1waz.rs:45:15\n   |\n45 |         s\
    \ = s.push_str(&nums.into_iter().collect());\n   |             - ^^^^^^^^ this\
    \ call modifies `s` in-place\n   |             |\n   |             you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp87iu1waz.rs:48:13\n   |\n15 |     let mut s = String::with_capacity(4);\n\
    \   |                 ------------------------ expected due to this value\n...\n\
    48 |         s = s.push_str(&nums.into_iter().take(4).collect());\n   |      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmp87iu1waz.rs:48:15\n   |\n48 |         s = s.push_str(&nums.into_iter().take(4).collect());\n\
    \   |             - ^^^^^^^^ this call modifies `s` in-place\n   |           \
    \  |\n   |             you probably want to use this "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut digits = String::new();\n\
    \    let mut exp = 0;\n    let mut rem = 0;\n    while x >= base {\n        rem\
    \ = x / base;\n        x = x - base * rem;\n        exp++;\n        digits +=\
    \ format!(\"{}\", rem).to_string();\n    }\n    digits += format!(\"{}\", x).to_string();\n\
    \    if exp > 0 {\n        digits.push_str(&format!(\"e{}\", exp).to_owned());\n\
    \    }\n    digits\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpulx9fcpu.rs:17:12\n\
    \   |\n17 |         exp++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n17 |         { let tmp = exp; exp += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n17 -         exp++;\n\
    17 +         exp += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpulx9fcpu.rs:20:15\n\
    \   |\n20 |     digits += format!(\"{}\", x).to_string();\n   |              \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |               |\n   |               expected\
    \ `&str`, found struct `String`\n   |               help: consider borrowing here:\
    \ `&format!(\"{}\", x).to_string()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut num = String::from(\"\
    0\");\n    if x >= base {\n        num = x.to_str_base(base, 0).to_string();\n\
    \        num = format!(\"{:0>#}\", num).to_string();\n    } else {\n        while\
    \ x != 0 {\n            x = x % base;\n            num = format!(\"{:0>#}\", x).to_string();\n\
    \        }\n    }\n    String::from(num)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_str_base` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp6x08a916.rs:13:17\n   |\n13 |         num = x.to_str_base(base,\
    \ 0).to_string();\n   |                 ^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    if base < 10 {\n   \
    \     let mut digits = vec![];\n        digits.push(x % base);\n        let mut\
    \ x = x / base;\n        while x != 0 {\n            digits.push(x % base);\n\
    \            x /= base;\n        }\n        digits.reverse();\n        return\
    \ String::from(\"0\".to_string() + digits);\n    }\n    return format!(\"{}\"\
    , x);\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2nxh4lkk.rs:20:47\n   |\n\
    20 |         return String::from(\"0\".to_string() + digits);\n   |          \
    \                                     ^^^^^^ expected `&str`, found struct `Vec`\n\
    \   |\n   = note: expected reference `&str`\n                 found struct `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut x = x % base;\n\
    \    match x {\n        0 => return String::from(\"0\"),\n        x => String::from(x.to_string()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmp6m_t8b10.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    while x > 0 {\n        let remainder = x % base;\n        x += 1;\n     \
    \   s += char::to_digit(remainder + '0').to_string();\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `char` to `isize`\n  --> /tmp/tmp6wljsppc.rs:15:39\n\
    \   |\n15 |         s += char::to_digit(remainder + '0').to_string();\n   |  \
    \                                     ^ no implementation for `isize + char`\n\
    \   |\n   = help: the trait `Add<char>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0061]: this\
    \ function takes 2 arguments but 1 argument was supplied\n   --> /tmp/tmp6wljsppc.rs:15:14\n\
    \    |\n15  |         s += char::to_digit(remainder + '0').to_string();\n    |\
    \              ^^^^^^^^^^^^^^ --------------- supplied 1 argument\n    |     \
    \         |\n    |              expected 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0599]: `Option<u32>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp6wljsppc.rs:15:46\n    |\n15  |           s += char::to_digit(remainder\
    \ + '0').to_string();\n    |                                                ^^^^^^^^^\
    \ `Option<u32>` cannot be formatted with the default formatter\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<u32>: std::fmt::Display`\n\
    \            which is required by `Option<u32>: ToString`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976156
