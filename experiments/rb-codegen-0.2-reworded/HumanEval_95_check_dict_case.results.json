{
  "name": "HumanEval_95_check_dict_case",
  "language": "rb",
  "prompt": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n",
  "tests": "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
  "stop_tokens": [
    "\nclass",
    "\ndef",
    "\n#",
    "\n\n"
  ],
  "results": [
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp1fh10d8i.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp1fh10d8i.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp1fh10d8i.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmp1fh10d8i.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp1fh10d8i.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp1fh10d8i.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp1fh10d8i.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower() == False and key.isupper() == False:\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp_rpdmb17.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp_rpdmb17.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp_rpdmb17.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp_rpdmb17.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...lse and key.isupper() == False:\n...                              ^\n/tmp/tmp_rpdmb17.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp_rpdmb17.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower() != True:\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpay7gdfcy.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpay7gdfcy.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpay7gdfcy.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpay7gdfcy.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...      if key.islower() != True:\n...                              ^\n/tmp/tmpay7gdfcy.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpay7gdfcy.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not isinstance(dict[key], str):\n            return False\n        if key.isupper() and not isinstance(dict[key], str):\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9igviv4z.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp9igviv4z.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp9igviv4z.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9igviv4z.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpxpwzorh2.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpxpwzorh2.rb:17: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpxpwzorh2.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpxpwzorh2.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpxpwzorh2.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpxpwzorh2.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpxpwzorh2.rb:17: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpxpwzorh2.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpxpwzorh2.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpxpwzorh2.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp3c1rvqmi.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp3c1rvqmi.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp3c1rvqmi.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp3c1rvqmi.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3c1rvqmi.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not isinstance(dict[key], str):\n            return False\n        if key.isupper() and not isinstance(dict[key], str):\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpk1sa9jaj.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmpk1sa9jaj.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmpk1sa9jaj.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmpk1sa9jaj.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmpk1sa9jaj.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1sa9jaj.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not isinstance(dict[key], str):\n            return False\n        if key.isupper() and not isinstance(dict[key], str):\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9igviv4z.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp9igviv4z.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp9igviv4z.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9igviv4z.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2fdmnuf5.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmp2fdmnuf5.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2fdmnuf5.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2fdmnuf5.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2fdmnuf5.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp1fh10d8i.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp1fh10d8i.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp1fh10d8i.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmp1fh10d8i.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp1fh10d8i.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp1fh10d8i.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp1fh10d8i.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpbuf44g7n.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmpbuf44g7n.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmpbuf44g7n.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpbuf44g7n.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpbuf44g7n.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpzwyzlucs.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpzwyzlucs.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpzwyzlucs.rb:19: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmpzwyzlucs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpzwyzlucs.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpzwyzlucs.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not isinstance(dict[key], str):\n            return False\n        if key.isupper() and not isinstance(dict[key], str):\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9igviv4z.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp9igviv4z.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp9igviv4z.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9igviv4z.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if type(key) is not str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9zxghi86.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmp9zxghi86.rb:17: syntax error, unexpected local variable or method, expecting `then' or ';' or '\\n'\n        if type(key) is not str:\n                     ^~\n/tmp/tmp9zxghi86.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp9zxghi86.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9zxghi86.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and key.isupper():\n            return False\n        if key.isupper() and key.islower():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpdoqcrtgy.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpdoqcrtgy.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpdoqcrtgy.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmpdoqcrtgy.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...ey.islower() and key.isupper():\n...                              ^\n/tmp/tmpdoqcrtgy.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...ey.isupper() and key.islower():\n...                              ^\n/tmp/tmpdoqcrtgy.rb:27: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpdoqcrtgy.rb:38: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower() and type(dict[key]) != str:\n            return False\n        if key.isupper() and type(dict[key]) != str:\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpz47c9kuf.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpz47c9kuf.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpz47c9kuf.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...r() and type(dict[key]) != str:\n...                              ^\n/tmp/tmpz47c9kuf.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...r() and type(dict[key]) != str:\n...                              ^\n/tmp/tmpz47c9kuf.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpz47c9kuf.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp51l475zs.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp51l475zs.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp51l475zs.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp51l475zs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp51l475zs.rb:26: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp51l475zs.rb:37: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2fdmnuf5.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmp2fdmnuf5.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2fdmnuf5.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2fdmnuf5.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2fdmnuf5.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and not isinstance(dict[key], str):\n            return False\n        if key.isupper() and not isinstance(dict[key], str):\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9igviv4z.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp9igviv4z.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp9igviv4z.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...not isinstance(dict[key], str):\n...                              ^\n/tmp/tmp9igviv4z.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9igviv4z.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp3c1rvqmi.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp3c1rvqmi.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp3c1rvqmi.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp3c1rvqmi.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3c1rvqmi.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower() and key.isupper():\n            return False\n        if key.isupper() and key.islower():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpt49732pq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpt49732pq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpt49732pq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpt49732pq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...ey.islower() and key.isupper():\n...                              ^\n/tmp/tmpt49732pq.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...ey.isupper() and key.islower():\n...                              ^\n/tmp/tmpt49732pq.rb:27: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpt49732pq.rb:38: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp3c1rvqmi.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp3c1rvqmi.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp3c1rvqmi.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp3c1rvqmi.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3c1rvqmi.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if not key.islower() and not key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpol4j567g.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmpol4j567g.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmpol4j567g.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...slower() and not key.isupper():\n...                              ^\n/tmp/tmpol4j567g.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpol4j567g.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower() and key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp9v4n5rot.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp9v4n5rot.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp9v4n5rot.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp9v4n5rot.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...ey.islower() and key.isupper():\n...                              ^\n/tmp/tmp9v4n5rot.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp9v4n5rot.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        else:\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmphirsqrzy.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmphirsqrzy.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmphirsqrzy.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmphirsqrzy.rb:21: else without rescue is useless\n        else:\n        ^~~~\n/tmp/tmphirsqrzy.rb:21: syntax error, unexpected ':'\n        else:\n            ^\n/tmp/tmphirsqrzy.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmphirsqrzy.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp3c1rvqmi.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp3c1rvqmi.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp3c1rvqmi.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp3c1rvqmi.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp3c1rvqmi.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp51l475zs.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp51l475zs.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp51l475zs.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp51l475zs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp51l475zs.rb:26: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp51l475zs.rb:37: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp6rpgewkq.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp6rpgewkq.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp6rpgewkq.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp6rpgewkq.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp6rpgewkq.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp6rpgewkq.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower() == False and key.isupper() == False:\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp_rpdmb17.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp_rpdmb17.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp_rpdmb17.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp_rpdmb17.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...lse and key.isupper() == False:\n...                              ^\n/tmp/tmp_rpdmb17.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp_rpdmb17.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp51l475zs.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp51l475zs.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp51l475zs.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp51l475zs.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp51l475zs.rb:26: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp51l475zs.rb:37: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpbuf44g7n.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict.keys():\n                          ^\n/tmp/tmpbuf44g7n.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmpbuf44g7n.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpbuf44g7n.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpbuf44g7n.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpwpcb_qpw.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmpwpcb_qpw.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpwpcb_qpw.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpwpcb_qpw.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpwpcb_qpw.rb:25: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpwpcb_qpw.rb:36: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2ejyb75y.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2ejyb75y.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2ejyb75y.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmp2ejyb75y.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2ejyb75y.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2ejyb75y.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ejyb75y.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    for key in dict:\n        if type(key) != str:\n            return False\n        if key.isupper():\n            return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmpp_bxvumh.rb:16: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmpp_bxvumh.rb:17: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if type(key) != str:\n                           ^\n/tmp/tmpp_bxvumh.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmpp_bxvumh.rb:23: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpp_bxvumh.rb:34: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "# Given a hash, return true if all keys are strings in lower \n# case or all keys are strings in upper case, else return false.\n# The function should return false is the given hash is empty.\n# Examples:\n# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n    if len(dict) == 0:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            continue\n        if key.isupper():\n            continue\n        return False\n    return True\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "/tmp/tmp2bsnf7l0.rb:16: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n    if len(dict) == 0:\n                     ^\n/tmp/tmp2bsnf7l0.rb:18: syntax error, unexpected ':', expecting `do' for condition or ';' or '\\n'\n    for key in dict:\n                   ^\n/tmp/tmp2bsnf7l0.rb:19: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n...   if not isinstance(key, str):\n...                              ^\n/tmp/tmp2bsnf7l0.rb:21: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.islower():\n                        ^\n/tmp/tmp2bsnf7l0.rb:23: syntax error, unexpected ':', expecting `then' or ';' or '\\n'\n        if key.isupper():\n                        ^\n/tmp/tmp2bsnf7l0.rb:28: class definition in method body\nclass TestHumanEval < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmp2bsnf7l0.rb:39: syntax error, unexpected end-of-input, expecting `end'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}