{
  "language": "scala",
  "name": "HumanEval_119_match_parens",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mqueue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mqueue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueueSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mqueueSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mqueueSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1659795018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodString = mutable.Set[String]()\n        val badString = mutable.Set[String]()\n        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n        val goodParensString = mutable.Set[String]()\n        val badParensString = mutable.Set[String]()\n        val goodParensParens = mutable.Set[String]()\n        val badParensParens = mutable.Set[String]()\n        val goodParensParensString = mutable.Set[String]()\n        val badParensParensString = mutable.Set[String]()\n        val goodParensParensParens = mutable.Set[String]()\n        val badParensParensParens = mutable.Set[String]()\n        val goodParensParensParensString = mutable.Set[String]()\n        val badParensParensParensString = mutable.Set[String]()\n        val goodParensParensParensParens = mutable.Set[String]()\n        val badParensParensParensParens = mutable.Set[String]()\n        val goodParensParensParensParensString = mutable.Set[String]()\n        val badParensParensParensParensString = mutable.Set[String]()\n        val goodParensParensParensParensParens = mutable.Set[String]()\n        val badParensParensParensParensParens = mutable.Set[String]()\n        val goodParensParensParensParensParensString = mutable.Set[String]()\n        val badParensParensParensParensParensString = mutable.Set[String]()\n        val goodParensParensParensParensParensParens = mutable.Set[String]()\n        val badParensParensParensParensParensParens = mutable.Set[String]()\n        val goodParensParensParensParensParensParensString = mutable.Set[String]()\n        val badParensParensParensParensParensParensString = mutable.Set[String\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphba7x9mv.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodString\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-e",
      "stdout": "",
      "timestamp": 1659795441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            val newStack = if (open < 0 || close < 0) stack.toList else stack.drop(open).drop(close).reverse\n            val newStr = if (open < 0 || close < 0) str else str.substring(open + 1, close)\n            val newResult = if (newStack.isEmpty) result else result.dropRight(newStack.size)\n            val newResult2 = if (newStr.isEmpty) newResult else newResult :+ newStr\n            stack.push(newStr)\n            result += newResult2\n        }\n        if (result.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            if(str == \"(\") {\n                stack.push(str)\n            } else if(str == \")\") {\n                val popped = stack.pop()\n                if(popped == \"(\") {\n                    result.append(\"Yes\")\n                } else {\n                    result.append(\"No\")\n                }\n            } else {\n                result.append(\"No\")\n            }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result.append(\"No\")\n            } else {\n                val openCount = stack.length\n                val closeCount = stack.length\n                while(openCount > 0 && closeCount > 0) {\n                    if(openCount > closeCount) {\n                        stack.pop()\n                        openCount -= 1\n                    } else {\n                        stack.pop()\n                        closeCount -= 1\n                    }\n                }\n                val openParens = stack.length\n                val closeParens = stack.length\n                while(openParens > 0 && closeParens > 0) {\n                    if(openParens > closeParens) {\n                        stack.pop()\n                        openParens -= 1\n                    } else {\n                        stack.pop()\n                        closeParens -= 1\n                    }\n                }\n                val newStack = stack.mkString(\"(\", \")\")\n                if(newStack == str) {\n                    result.append(\"Yes\")\n                } else {\n                    result.append(\"No\")\n                }\n            }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659795440
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            val openCount = stack.length\n            val closeCount = stack.length\n            if(openCount > closeCount) {\n                stack += str\n                result += \"Yes\"\n            } else if(openCount < closeCount) {\n                stack += str\n                result += \"No\"\n            } else {\n                result += \"No\"\n            }\n        }\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n        val stackMin = stackSize + 1\n        val stackMinIndex = stackSize + 1\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n        val stackMin\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwpvc8sfy.scala:66:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(stackMinIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(stackMinIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(stackMinIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(stackMinIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.sc",
      "stdout": "",
      "timestamp": 1659795441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open != -1 && close != -1) {\n                val openCount = stack.length\n                val closeCount = stack.length\n                val openParen = str.indexOf(\"(\")\n                val closeParen = str.indexOf(\")\")\n                val openParenCount = stack.length\n                val closeParenCount = stack.length\n                stack.push(str)\n                while(openParenCount > closeParenCount && openParenCount > openCount && closeParenCount > closeCount) {\n                    if(stack.size == openParenCount) {\n                        val temp = stack.pop()\n                        if(temp.equals(str)) {\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n                            result.append(\"Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpofq68dqu.scala:110:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m110 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpofq68dqu.scala:20:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m 20 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until lst.size) {\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = lst(i)\n\u001b[31m 22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = str.indexOf(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m 23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = str.indexOf(\u001b[31m\")\"\u001b[0m)\n\u001b[31m 24 |\u001b[0m            \u001b[33mif\u001b[0m(open != -\u001b[31m1\u001b[0m && close != -\u001b[31m1\u001b[0m) {\n\u001b[31m 25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = stack.length\n\u001b[31m 26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = stack.length\n\u001b[31m 27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mopenParen\u001b[0m = str.indexOf(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m 28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcloseParen\u001b[0m = str.indexOf(\u001b[31m\")\"\u001b[0m)\n\u001b[31m 29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mopenParenCount\u001b[0m = stack.length\n\u001b[31m 30 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcloseParenCount\u001b[0m = stack.length\n\u001b[31m 31 |\u001b[0m            ",
      "stdout": "",
      "timestamp": 1659795441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\") => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n            case x => badStr += x\n        })\n        while(!queue.isEmpty) {\n            val curr = queue.dequeue()\n            if(!good.contains(curr)) {\n                good += curr\n                goodStr += curr\n            }\n            if(!bad.contains(curr)) {\n                bad += curr\n                badStr += curr\n            }\n            if(!stack.isEmpty) {\n                val top = stack.dequeue()\n                if(!good.contains(top)) {\n                    good += top\n                    goodStr += top\n                }\n                if(!bad.contains(top)) {\n                    bad += top\n                    badStr += top\n                }\n            }\n        }\n        if(good.size == lst.size) {\n            return \"Yes\"\n        }\n        if(bad.size == lst.size) {\n            return \"No\"\n        }\n        if(goodStr.size == lst.size) {\n            return \"Yes\"\n        }\n        if(badStr.size == lst.size) {\n            return \"No\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.push(x)\n                }\n                case \")(\"  => {\n                    open.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8jgqcjag.scala:128:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m128 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8jgqcjag.scala:145:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m145 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp8jgqcjag.scala:129:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m129 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0",
      "stdout": "",
      "timestamp": 1659795059
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"(\") stack.push(x) else if (x == \")\") queue.push(x) else if (stack.size == 0 && queue.size == 0) good.add(x))\n        if (good.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same gro",
      "stdout": "",
      "timestamp": 1659795049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    queue.enqueue(x)\n                }\n                case \")()\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")()()\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")(()\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")()(\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")()(()\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \")()(()()\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n                    queue.en\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo399t2jt.scala:122:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m122 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-",
      "stdout": "",
      "timestamp": 1659795441
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => open.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpymzfq6v3.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpymzfq6v3.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpymzfq6v3.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        lst.foreach(x => if (x.contains(\"(\")) stack.push(x) else if (x.contains(\")\")) queue.push(x) else if (stack.size == 0 && queue.size == 0) good.add(x) else if (stack.size > 0 && queue.size == 0) bad.add(x) else if (stack.size > 0 && queue.size > 0) goodStr.add(x) else if (stack.size == 0 && queue.size > 0) badStr.add(x))\n        if (good.size == 0 && bad.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => stack.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n                open += s\n            } else if (s.startsWith(\")\")) {\n                close += s\n            } else {\n                stack += s\n            }\n        }\n        val openCount = open.count\n        val closeCount = close.count\n        if (openCount == closeCount) {\n            val openParens = open.mkString(\"(\", \", \", \")\")\n            val closeParens = close.mkString(\"(\", \", \", \")\")\n            val newStack = stack.filterNot(s => openParens.contains(s))\n            val newStack2 = stack.filterNot(s => closeParens.contains(s))\n            if (newStack.isEmpty && newStack2.isEmpty) {\n                result += \"Yes\"\n            } else {\n                result += \"No\"\n            }\n        } else {\n            result += \"No\"\n        }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n        stack.foreach(x => if (x == \"(\") result += \"Yes\" else result += \"No\")\n        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach {\n            x =>\n                if (x == \"(\") open += x\n                else if (x == \")\") close += x\n                else {\n                    if (open.contains(x)) stack += x\n                    else if (close.contains(x)) queue += x\n                    else {\n                        if (stack.size == 0 && queue.size == 0) result += \"Yes\"\n                        else if (stack.size == 0 && queue.size == 1) result += \"No\"\n                        else if (stack.size > 0 && queue.size == 0) result += \"No\"\n                        else if (stack.size > 0 && queue.size == 1) result += \"Yes\"\n                        else if (stack.size == 1 && queue.size == 0) result += \"Yes\"\n                        else if (stack.size == 1 && queue.size == 1) result += \"No\"\n                        else result += \"No\"\n                    }\n                }\n        }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2nggw4af.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxSize\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxSize\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:28:12 --",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach { s =>\n            val isOpen = s.contains(\"(\")\n            val isClose = s.contains(\")\")\n            if (isOpen && isClose) {\n                stack += s\n            } else if (isOpen) {\n                stack += s\n            } else if (isClose) {\n                val open = stack.pop()\n                val close = s\n                result += (open + close)\n            }\n        }\n        if (result.size == lst.size) {\n            val str = result.mkString\n            if (str.contains(\"(\") && str.contains(\")\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9tkp2wv9.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9tkp2wv9.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stackMax = stackSize - 1\n        val queueMax = queueSize - 1\n        val stackIndex = 0\n        val queueIndex = 0\n        val stackIsEmpty = stackIndex == stackMax\n        val queueIsEmpty = queueIndex == queueMax\n        while(stackIsEmpty || queueIsEmpty) {\n            if(stackIsEmpty) {\n                stackIndex += 1\n                stackIsEmpty = stackIndex == stackMax\n            }\n            if(queueIsEmpty) {\n                queueIndex += 1\n                queueIsEmpty = queueIndex == queueMax\n            }\n            val stack = lst(stackIndex)\n            val queue = lst(queueIndex)\n            val stackSize = stack.size\n            val queueSize = queue.size\n            val stackMax = stackSize - 1\n            val queueMax = queueSize - 1\n            val stackIndex = 0\n            val queueIndex = 0\n            val stackIsEmpty = stackIndex == stackMax\n            val queueIsEmpty = queueIndex == queueMax\n            val stackIsOpen = stackIndex > 0\n            val queueIsOpen = queueIndex > 0\n            val stackIsClosed = stackIndex < stackMax\n            val queueIsClosed = queueIndex < queueMax\n            val stackIsOpenParen = stackIsOpen && stackIsClosed\n            val queueIsOpenParen = queueIsOpen && queueIsClosed\n            val stackIsCloseParen = stackIsClosed && stackIsOpen\n            val queueIsCloseParen = queueIsClosed && queueIsOpen\n            val stackIsCloseParenOrOpen = stackIsCloseParen || stackIsOpenParen\n            val queueIsCloseParenOrOpen = queueIsCloseParen || queueIsOpenParen\n            if(stackIsOpenParen) {\n                stackIndex += 1\n                stackIsEmpty = stackIndex == stackMax\n            }\n            if(queueIsOpenParen) {\n                queueIndex += 1\n                queueIsEmpty = queueIndex == queueMax\n            }\n            val stack = lst(stackIndex)\n            val queue = lst(queueIndex)\n            val stackSize = stack.size\n            val queueSize = queue.size\n            val stackMax = stackSize - 1\n            val queueMax = queueSize - 1\n            val stackIndex = 0\n            val queueIndex = 0\n            val stackIsEmpty = stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpisaamshz.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisaamshz.scala:66:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = lst(stackIndex)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisaamshz.scala:67:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = lst(queueIndex)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mqueue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mqueue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b",
      "stdout": "",
      "timestamp": 1659979659
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach {\n            s =>\n                val openCount = open.count(_ == s)\n                val closeCount = close.count(_ == s)\n                if (openCount == closeCount) {\n                    result += s\n                } else if (openCount > closeCount) {\n                    stack += s\n                } else if (openCount < closeCount) {\n                    result += s\n                    stack += s\n                }\n        }\n        if (stack.size == 0) {\n            return \"No\"\n        } else {\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => open.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")\" => close.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1f3zwzxm.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1f3zwzxm.scala:22:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m23 |\u001b[0m            x \u001b[33mmatch\u001b[0m {\n\u001b[31m24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m => close.",
      "stdout": "",
      "timestamp": 1659979658
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.push(x)\n                }\n                case \")(\"  => {\n                    open.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")(\" => {\n                    stack.push(x)\n                }\n                case \")\" => {\n                    close.push(x)\n                }\n                case \")\" => {\n                    result.add(\"Yes\")\n                }\n                case \")\" => {\n                    result.add(\"No\")\n                }\n                case \")(\" => {\n                    val temp = stack.pop()\n                    val temp2 = stack.pop()\n                    val temp3 = stack.pop()\n                    val temp4 = stack.pop()\n                    val temp5 = stack.pop()\n                    val temp6 = stack.pop()\n                    val temp7 = stack.pop()\n                    val temp8 = stack.pop()\n                    val temp9 = stack.pop()\n                    val temp10 = stack.pop()\n                    val temp11 = stack.pop()\n                    val temp12 = stack.pop()\n                    val temp13 = stack.pop()\n                    val temp14 = stack.pop()\n                    val temp15 = stack.pop()\n                    val temp16 = stack.pop()\n                    val temp17 = stack.pop()\n                    val temp18 = stack.pop()\n                    val temp19 = stack.pop()\n                    val temp20 = stack.pop()\n                    val temp21 = stack.pop()\n                    val temp22 = stack.pop()\n                    val temp23 = stack.pop()\n                    val temp24 = stack.pop()\n                    val temp25 = stack.pop()\n                    val temp26 = stack.pop()\n                    val temp27 = stack.pop()\n                    val temp28 = stack.pop()\n                    val temp29 = stack.pop()\n                    val temp30 = stack.pop()\n                    val temp31 = stack.pop()\n                    val temp32 = stack.pop()\n                    val temp33 = stack.pop()\n                    val temp34 = stack.pop()\n                    val temp35 = stack.pop()\n                    val temp36 = stack.pop()\n                    val temp37 = stack.pop()\n                    val temp38 = stack.pop()\n                    val temp39 = stack.pop()\n                    val temp40 = stack.pop()\n                    val temp41 = stack.pop()\n                    val temp42 = stack.pop()\n                    val temp43 = stack.pop()\n                    val temp44 = stack.pop()\n                    val temp45 = stack.pop()\n                    val temp4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc7i30t2h.scala:92:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc7i30t2h.scala:109:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m109 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpc7i30t2h.scala:93:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m93 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b",
      "stdout": "",
      "timestamp": 1659979655
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => stack.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stackMax = stackSize - 1\n        val queueMax = queueSize - 1\n        val stackArray = Array.ofDim[String](stackMax)\n        val queueArray = Array.ofDim[String](queueMax)\n        val stackArraySize = stackMax * 2\n        val queueArraySize = queueMax * 2\n        val stackArrayIndex = 0\n        val queueArrayIndex = 0\n        val stackArrayIndex2 = 0\n        val queueArrayIndex2 = 0\n        val stackArrayIndex3 = 0\n        val queueArrayIndex3 = 0\n        val stackArrayIndex4 = 0\n        val queueArrayIndex4 = 0\n        val stackArrayIndex5 = 0\n        val queueArrayIndex5 = 0\n        val stackArrayIndex6 = 0\n        val queueArrayIndex6 = 0\n        val stackArrayIndex7 = 0\n        val queueArrayIndex7 = 0\n        val stackArrayIndex8 = 0\n        val queueArrayIndex8 = 0\n        val stackArrayIndex9 = 0\n        val queueArrayIndex9 = 0\n        val stackArrayIndex10 = 0\n        val queueArrayIndex10 = 0\n        val stackArrayIndex11 = 0\n        val queueArrayIndex11 = 0\n        val stackArrayIndex12 = 0\n        val queueArrayIndex12 = 0\n        val stackArrayIndex13 = 0\n        val queueArrayIndex13 = 0\n        val stackArrayIndex14 = 0\n        val queueArrayIndex14 = 0\n        val stackArrayIndex15 = 0\n        val queueArrayIndex15 = 0\n        val stackArrayIndex16 = 0\n        val queueArrayIndex16 = 0\n        val stackArrayIndex17 = 0\n        val queueArrayIndex17 = 0\n        val stackArrayIndex18 = 0\n        val queueArrayIndex18 = 0\n        val stackArrayIndex19 = 0\n        val queueArrayIndex19 = 0\n        val stackArrayIndex20 = 0\n        val queueArrayIndex20 = 0\n        val stackArrayIndex21 = 0\n        val queueArrayIndex21 = 0\n        val stackArrayIndex22 = 0\n        val queueArrayIndex22 = 0\n        val stackArrayIndex23 = 0\n        val queueArrayIndex23 = 0\n        val stackArrayIndex24 = 0\n        val queueArrayIndex24 = 0\n        val stackArrayIndex25 = 0\n        val queueArray\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx9tuq6oj.scala:79:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx9tuq6oj.scala:79:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\") => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n            case x => bad.add(x)\n        })\n        while(!queue.isEmpty && !stack.isEmpty) {\n            val x = queue.dequeue()\n            val y = stack.pop()\n            good += x + y\n            bad += y\n            x match {\n                case x if x.startsWith(\"(\") => queue.enqueue(x)\n                case x if x.startsWith(\")\") => stack.push(x)\n                case x => bad.add(x)\n            }\n        }\n        if (good.size == lst.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open += x\n            if (x == \")\") close += x\n        })\n        val openCount = open.count\n        val closeCount = close.count\n        if (openCount == closeCount) {\n            val openList = open.mkString(\"(\", \")\")\n            val closeList = close.mkString(\"(\", \")\")\n            val newList = openList + closeList\n            val newStack = mutable.Stack[String]()\n            newStack.push(newList)\n            while (!newStack.isEmpty) {\n                val newList = newStack.pop()\n                if (newList.contains(\"(\") && newList.contains(\")\")) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                }\n            }\n        } else {\n            result += \"No\"\n        }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:32:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewStack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        for(i <- 0 until lst.length){\n            val str = lst(i)\n            if(!(str.contains(\"(\") || str.contains(\")\"))){\n                return \"No\"\n            }\n            if(!(str.contains(\"(\"))){\n                stack += str\n            }\n            if(!(str.contains(\")\"))) {\n                queue += str\n            }\n        }\n        while(!stack.isEmpty && !queue.isEmpty){\n            val str = stack.pop()\n            val str2 = queue.pop()\n            if(str2.contains(\"(\") && str2.contains(\")\")){\n                result += (str)\n            }\n        }\n        if(!stack.isEmpty && !queue.isEmpty){\n            return \"No\"\n        }\n        if(!stack.isEmpty && queue.isEmpty){\n            return \"Yes\"\n        }\n        if(!queue.isEmpty && !stack.isEmpty){\n            return \"Yes\"\n        }\n        if(!queue.isEmpty && stack.isEmpty){\n            return \"No\"\n        }\n        if(!queue.isEmpty && !stack.isEmpty){\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n            val cur = stack.pop()\n            val len = cur.length\n            val newStack = mutable.Stack[String]()\n            for(i <- 0 until len) {\n                val c = cur.charAt(i)\n                if(c == '(') {\n                    newStack += cur.substring(0, i)\n                    stack.push(\"(\" + cur.substring(i + 1))\n                } else if(c == ')') {\n                    if(newStack.nonEmpty) {\n                        val newStackSize = newStack.size - 1\n                        val newStackString = newStack.mkString\n                        if(newStackSize == 0) {\n                            result += \"(\" + newStackString + \")\"\n                        } else if(newStackSize == stackSize) {\n                            result += \"(\" + newStackString + \")\"\n                        } else {\n                            result += \"(\" + newStackString + \")\"\n                        }\n                    }\n                    newStack += cur.substring(i + 1)\n                    stack.pop\n                }\n            }\n        }\n        if(result.nonEmpty) {\n            val result = result.mkString\n            if(result.length == stackSize) {\n                result\n            } else {\n                \"No\"\n            }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewStack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpg3438fmo.scala:49:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = result.mkString\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n            case x if x == \"(\" => open.add(x)\n            case _ => queue.enqueue(x)\n        })\n        while(!queue.isEmpty) {\n            val x = queue.poll\n            x match {\n                case x if x == \")\" => close.add(x)\n                case x if x == \"(\" => open.add(x)\n                case _ => stack.push(x)\n            }\n        }\n        while(!stack.isEmpty) {\n            val x = stack.poll\n            x match {\n                case x if x == \")\" => close.add(x)\n                case x if x == \"(\" => open.add(x)\n                case _ => result.enqueue(x)\n            }\n        }\n        if(close.size == open.size && close.size == result.size) {\n            val good = close.intersect(open).intersect(result)\n            if(good.size == 0) {\n                return \"No\"\n            } else {\n                return \"Yes\"\n            }\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result += \"No\"\n            } else {\n                val stackSize = stack.size\n                if(open < close && stackSize > 0) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                }\n                stack.push(str)\n            }\n        }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprdrq5gbj.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprdrq5gbj.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.add(x)\n                    stack.push(x)\n                }\n                case \"(\" => {\n                    open.add(x)\n                    stack.push(x)\n                }\n                case _ => {\n                    stack.push(x)\n                }\n            }\n        })\n        while(stack.nonEmpty) {\n            val x = stack.pop()\n            x match {\n                case \")\" => {\n                    close.add(x)\n                    stack.push(x)\n                }\n                case \"(\" => {\n                    open.add(x)\n                    stack.push(x)\n                }\n                case _ => {\n                    result.add(x)\n                }\n            }\n        }\n        if(close.size == open.size && close.size == result.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => stack.pop\n                case \")(\"  => stack.pop\n                case \")()\" => stack.pop\n                case \")()()\" => stack.pop\n                case \")()()()\" => stack.pop\n                case \")()()()()\" => stack.pop\n                case \")()()()()()\" => stack.pop\n                case \")()()()()()()\" => stack.pop\n                case \")()()()()()()()\" => stack.pop\n                case \")()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmppkz13n0z.scala:51:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                \u001b[33mcase\u001b[0m \")()()()()()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmppkz13n0z.scala:53:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppkz13n0z.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:53:4 -------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36marg",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x contains \"(\") {\n                open += x\n            } else {\n                close += x\n            }\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openStr = open.toList\n            val closeStr = close.toList\n            val openStrCount = openStr.size\n            val closeStrCount = closeStr.size\n            if (openStrCount == closeStrCount) {\n                val openStrSet = openStr.toSet\n                val closeStrSet = closeStr.toSet\n                if (openStrSet.size == closeStrSet.size && openStrSet.size == openStrCount) {\n                    val openStrSetCount = openStrSet.size\n                    val closeStrSetCount = closeStrSet.size\n                    if (openStrSetCount == closeStrSetCount) {\n                        val openStrSetSet = openStrSet.toSet\n                        val closeStrSetSet = closeStrSet.toSet\n                        if (openStrSetSet.size == closeStrSetSet.size && openStrSetSet.size == openStrSetCount) {\n                            val openStrSetSetCount = openStrSetSet.size\n                            val closeStrSetSetCount = closeStrSetSet.size\n                            if (openStrSetSetCount == closeStrSetSetCount) {\n                                val openStrSetSetSetCount = openStrSetSet.size\n                                val closeStrSetSetCount = closeStrSetSet.size\n                                if (openStrSetSetCount == closeStrSetSetCount) {\n                                    val openStrSetSetSetCount = openStrSetSet.size\n                                    val closeStrSetSetCount = closeStrSetSet.size\n                                    if (openStrSetSetCount == closeStrSetSetCount) {\n                                        val openStrSetSetSetCount = openStrSetSet.size\n                                        val closeStrSetSetCount = closeStrSetSet.size\n                                        if (openStrSetSetCount == closeStrSetSetCount) {\n                                            return \"Yes\"\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            if (x == \"(\") {\n                open += x\n                stack.push(x)\n            } else if (x == \")\") {\n                close += x\n                val last = stack.pop()\n                if (last == \"(\") {\n                    open += last\n                } else if (last == \")\") {\n                    close += last\n                } else {\n                    result += \"No\"\n                    return\n                }\n            } else {\n                result += \"No\"\n                return\n            }\n        })\n        if (open.length == close.length) {\n            result += \"Yes\"\n        } else {\n            result += \"No\"\n        }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3lyzf2o0.scala:35:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Unit\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3lyzf2o0.scala:39:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        val goodStr = mutable.Set[String\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoihlwpih.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:28:12 ---------------------------\u001b[0m\u001b[0",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n        val queueSize = lst.size\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_f9vagxb.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackIsFull\u001b[0m = stackSize == stackIsEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackIsFull is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackIsFull\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueueIsFull\u001b[0m = queueSize == queueIsEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mqueueIsFull is already defined as \u001b[33mvalue\u001b[0m \u001b[35mqueueIsFull\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultIsFull\u001b[0m = resultSize == resultIsEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresultIsFull is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresultIsFull\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackIsEmpty\u001b[0m = stack.isEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackIsEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackIsEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tm",
      "stdout": "",
      "timestamp": 1659979658
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3 * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6 = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8 * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11 = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 = stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 = stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 = stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 = stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 = stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 = stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 = stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 = stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 = stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpch5x3hl7.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpch5x3hl7.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.add(x)\n                case \")(\"  => open.add(x)\n                case \")(\"  => stack += x\n                case \")\" => stack += x\n                case _ => stack += x\n            }\n        })\n        while(stack.nonEmpty) {\n            val s = stack.pop()\n            val openCount = open.count(_ == s)\n            val closeCount = close.count(_ == s)\n            val count = openCount + closeCount\n            if(count == openCount) {\n                result += s\n            }\n        }\n        if(result.size == lst.size) {\n            val str = result.mkString\n            val stackStr = stack.mkString\n            if(str.equals(stackStr)) {\n                return \"Yes\"\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.foreach(c => stack += c)\n                    result ++= stack.reverse\n                    stack.toList.foreach(x => stack.toList.remove(x))\n                    stack.toList.foreach(x => stack.toList.remove(x))\n                case \")(\" =>\n                    open += x\n                case _ =>\n                    stack += x\n            }\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openList = open.toList\n            val closeList = close.toList\n            val openSet = openList.distinct\n            val closeSet = closeList.distinct\n            if (openSet.size == closeSet.size)\n                if (openSet.size == openCount)\n                    result.append(\"Yes\")\n                else\n                    result.append(\"No\")\n            else\n                result.append(\"No\")\n        }\n        else\n            result.append(\"No\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979654
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    stack += x\n                }\n                case \")(\"  => {\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n                    stack += x\n                    queue += x\n                }\n                case \")(\" => {\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp81vn5svg.scala:139:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m139 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodParens\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[",
      "stdout": "",
      "timestamp": 1659979666
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        val openCount = mutable.Map[String, Int]()\n        val closeCount = mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    closeCount += x -> 1\n                case \")(\"  =>\n                    closeCount += x -> 2\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")()\" =>\n                    closeCount += x -> 1\n                case \")()()\" =>\n                    closeCount += x -> 3\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    closeCount += x -> 1\n                case \")(\" =>\n                    close\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgaih8dq8.scala:105:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m105 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when com",
      "stdout": "",
      "timestamp": 1659979665
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n            case x if x == \")\" => close.remove(x)\n            case x if x == \"(\" => open.add(x)\n            case x if x == \"(\" => open.remove(x)\n            case x => stack += x\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val stackSize = stack.size\n            if (stackSize == 0) {\n                result.append(\"Yes\")\n            } else {\n                val stack = stack.dropRight(stackSize)\n                val stackSize = stack.size\n                if (stackSize == 0) {\n                    result.append(\"Yes\")\n                } else {\n                    val stack = stack.dropRight(stackSize)\n                    val stackSize = stack.size\n                    if (stackSize == 0) {\n                        result.append(\"Yes\")\n                    } else {\n                        val stack = stack.dropRight(stackSize)\n                        val stackSize = stack.size\n                        if (stackSize == 0) {\n                            result.append(\"Yes\")\n                        } else {\n                            val stack = stack.dropRight(stackSize)\n                            val stackSize = stack.size\n                            if (stackSize == 0) {\n                                result.append(\"Yes\")\n                            } else {\n                                val stack = stack.dropRight(stackSize)\n                                val stackSize = stack.size\n                                if (stackSize == 0) {\n                                    result.append(\"Yes\")\n                                } else {\n                                    val stack = stack.dropRight(stackSize)\n                                    val stackSize = stack.size\n                                    if (stackSize == 0) {\n                                        result.append(\"Yes\")\n                                    } else {\n                                        val stack = stack.dropRight(stackSize)\n                                        val stackSize = stack.size\n                                        if (stackSize == 0) {\n                                            result.append(\"Yes\")\n                                        } else {\n                                            val stack = stack.dropRight(stackSize)\n                                            val stackSize = stack.size\n                                            if (stackSize == 0) {\n                                                result.append(\"Yes\")\n                                            } else {\n                                                val stack = stack.dropRight(stackSize)\n                                                val stackSize = stack.size\n                                                if (stackSize == 0) {\n                                                    result.append(\"Yes\")\n                                                } else {\n                                                    val stack = stack.dropRight(stackSize)\n                                                    val stackSize = stack.size\n                                                    if (stackSize == 0) {\n                                                        result.append(\"Yes\")\n                                                    } else {\n                                                        val stack = stack.dropRight(stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5c3pzg76.scala:87:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5c3pzg76.scala:104:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m104 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5c3pzg76.scala:36:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = stack.dropRight(stackSize",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.foreach(y => stack += y)\n                    close.clear()\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n                case \")(\" => {\n                    open += x\n                }\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_dnuk6ud.scala:145:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m145 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_dnuk6ud.scala:22:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m 22 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 23 |\u001b[0m            x \u001b[33mmatch\u001b[0m {\n\u001b[31m 24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m => {\n\u001b[31m 25 ",
      "stdout": "",
      "timestamp": 1659979666
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n                    stack += x\n                }\n            }\n        })\n        val stackSize = stack.size\n        val stackMax = stackSize - 1\n        stack.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n                    stack += x\n                }\n            }\n        })\n        val stackSize = stack.size\n        val stackMax = stackSize - 1\n        stack.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n                    stack += x\n                }\n            }\n        })\n        val stackSize = stack.size\n        val stackMax = stackSize - 1\n        stack.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n                    stack += x\n                }\n            }\n        })\n        val stackSize = stack.size\n        val stackMax = stackSize - 1\n        stack.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n                    stack += x\n                }\n            }\n        })\n        val stackSize = stack.size\n        val stackMax = stackSize - 1\n        stack.foreach(x => {\n            x match {\n                case \")\" => {\n                    stackSize -= 1\n                    stack += x\n                }\n                case \"(\" => {\n                    stackSize += 1\n                    stack += x\n                }\n                case _ => {\n                    stackSize -= 1\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvwzz326k.scala:142:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m142 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = stack.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMax\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:56:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = stack.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:57:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMax\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:74:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = stack.size\n\u001b[31",
      "stdout": "",
      "timestamp": 1659979665
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => stack.pop()\n                case \")(\"  => stack.pop(); queue.enqueue(x)\n                case \")(\"  => bad.add(x)\n                case \")\"  => good.add(x)\n                case _    => queue.enqueue(x)\n            }\n        })\n        if (stack.size == 0 && queue.size == 0) \"Yes\"\n        else if (!good.isEmpty) \"No\"\n        else matchParens(queue.dequeue)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979661
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    stack.pop()\n                    result += (stack.mkString())\n                }\n                case \"(\" => {\n                    stack += x\n                }\n                case _ => {\n                    stack += x\n                }\n            }\n        })\n        if (result.size == lst.length) {\n            val stackStr = stack.mkString\n            if (stackStr.contains(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ipy9xes.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ipy9xes.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n        lst.foreach { s =>\n            val open = if (s.startsWith(\"(\")) \"(\" else \"\"\n            val close = if (s.endsWith(\")\")) \")\" else \"\"\n            val count = if (s.startsWith(\"(\")) 1 else if (s.endsWith(\")\")) -1 else 0\n            open += open\n            close += close\n            openCount += count\n            closeCount += count\n            stack += s\n        }\n        val openCount = openCount.sum\n        val closeCount = closeCount.sum\n        val openCount = openCount.toInt\n        val closeCount = closeCount.toInt\n        if (openCount == closeCount) {\n            val stackSize = stack.size\n            if (stackSize == 0) {\n                result += \"Yes\"\n            } else {\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n                val stack = stack.drop(stackSize - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf5j6ovks.scala:89:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf5j6ovks.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = ",
      "stdout": "",
      "timestamp": 1659979666
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n                open += s\n                stack.push(s)\n            } else if (s.endsWith(\")\")) {\n                close += s\n                stack.pop\n            } else {\n                result += (open :+ s) + (close :+ s)\n            }\n        }\n        if (stack.size == 0) {\n            result += \"No\"\n        } else {\n            result += \"Yes\"\n        }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            val openCount = stack.length\n            val closeCount = stack.length\n            stack.push(str)\n            while(openCount > 0 && closeCount > 0) {\n                val openStr = stack.pop()\n                val closeStr = stack.pop()\n                if(openStr == closeStr) {\n                    openCount -= 1\n                    closeCount -= 1\n                } else {\n                    if(openStr == \"()\") {\n                        openCount -= 1\n                    } else {\n                        closeCount -= 1\n                    }\n                }\n            }\n            if(openCount == 0 && closeCount == 0) {\n                result += \"Yes\"\n            } else {\n                result += \"No\"\n            }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzo6515y0.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzo6515y0.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979663
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        for(i <- 0 until lst.size) {\n            if(!open.isEmpty && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(openCount == closeCount) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                    break\n                }\n            }\n            if(!open.isEmpty && close.isEmpty) {\n                result += \"Yes\"\n                break\n            }\n            if(!close.isEmpty && open.isEmpty) {\n                result += \"No\"\n                break\n            }\n            if(!open.isEmpty && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(openCount > closeCount) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                    break\n                }\n            }\n            if(!close.isEmpty && !open.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(closeCount > openCount) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                    break\n                }\n            }\n            if(!open.isEmpty && close.isEmpty) {\n                result += \"No\"\n                break\n            }\n            if(!open.isEmpty && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(openCount > closeCount) {\n                    result += \"No\"\n                } else {\n                    result += \"Yes\"\n                    break\n                }\n            }\n            if(!open.isEmpty && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(closeCount > openCount) {\n                    result += \"No\"\n                } else {\n                    result += \"Yes\"\n                    break\n                }\n            }\n            if(!open.isEmpty && close.isEmpty) {\n                result += \"No\"\n                break\n            }\n            if(!open.isEmpty && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_ == lst(i))\n                if(openCount > closeCount) {\n                    result += \"No\"\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphteklys_.scala:112:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m112 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:30:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphtekl",
      "stdout": "",
      "timestamp": 1659979663
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.synchronized {\n                        stack.pop() match {\n                            case Some(open) => open.remove(open)\n                            case None => result.synchronized {\n                                result += open\n                                result += close\n                                result\n                            }\n                        }\n                    }\n                case \")(\"  =>\n                    stack.synchronized {\n                        stack += x\n                    }\n                case \")(\" =>\n                    stack.synchronized {\n                        stack += x\n                    }\n                case _ =>\n                    open.synchronized {\n                        open += x\n                    }\n            }\n        })\n        stack.synchronized {\n            stack.reverseIterator.foreach(x => result.synchronized {\n                result += x\n            })\n        }\n        result.synchronized {\n            val res = result.mkString(\"(\", \", \", \")\")\n            if (res.contains(\"(\") && res.contains(\")\")) {\n                res\n            } else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => open.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => stack.push(x)\n                case _ => stack.push(x)\n            }\n        })\n        val openCount = open.count\n        val closeCount = close.count\n        if (openCount == closeCount) {\n            val openStack = stack.toList\n            val closeStack = stack.toList.reverse\n            val openStackSize = openStack.size\n            val closeStackSize = closeStack.size\n            val openStackElement = openStack.last\n            val closeStackElement = closeStack.last\n            val openStackElementIndex = openStack.lastIndexOf(openStackElement)\n            val closeStackElementIndex = closeStack.lastIndexOf(closeStackElement)\n            val openStackElementSize = openStackElementIndex + 1\n            val closeStackElementSize = closeStackElementIndex + 1\n            val openStackElementElement = openStack.slice(openStackElementIndex, openStackElementSize)\n            val closeStackElementElement = closeStack.slice(closeStackElementIndex, closeStackElementSize)\n            val openStackElementElementElement = openStack.slice(openStackElementIndex + 1, openStackElementSize)\n            val closeStackElementElementElement = closeStack.slice(closeStackElementIndex + 1, closeStackElementSize)\n            val openStackElementElementElementElement = openStack.slice(openStackElementIndex + 2, openStackElementSize)\n            val closeStackElementElementElement = closeStack.slice(closeStackElementIndex + 2, closeStackElementSize)\n            val openStackElementElementElementElement = openStack.slice(openStackElementIndex + 3, openStackElementSize)\n            val closeStackElementElementElement = closeStack.slice(closeStackElementIndex + 3, closeStackElementSize)\n            val openStackElementElementElementElement = openStack.slice(openStackElementIndex + 4, openStackElementSize)\n            val closeStackElementElementElement = closeStack.slice(closeStackElementIndex + 4, closeStackElementSize)\n            val openStackElementElementElementElement = openStack.slice(openStackElementIndex + 5, openStackElement\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0lvpg396.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0lvpg396.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0lvpg396.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0lvpg396.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0lvpg396.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0lvpg396.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0lvpg396.scala:50:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcloseStackElementElementElemen",
      "stdout": "",
      "timestamp": 1659979666
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n            case x if x == \"(\" => open.push(x)\n            case _ => ()\n        })\n        while(!close.isEmpty && !open.isEmpty) {\n            val closed = close.pop()\n            val opened = open.pop()\n            val newStack = stack :+ opened\n            val newResult = result :+ closed\n            val newOpen = open - opened\n            val newClose = close - closed\n            if(newOpen.isEmpty && newClose.isEmpty) {\n                val newStack2 = newStack.dropRight(1)\n                val newResult2 = newResult.dropRight(1)\n                if(newStack2.toList == newResult2.toList) {\n                    return \"Yes\"\n                }\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.push(x)\n                case \")(\"  =>\n                    open.push(x)\n                case \")()\" =>\n                    stack.push(x)\n                case \")()()\" =>\n                    val s = stack.pop()\n                    val c = close.pop()\n                    val o = open.pop()\n                    result.append((s + c).mkString(\"\"))\n                    result.append((o + c).mkString(\"\"))\n            }\n        })\n        if (close.isEmpty) result.mkString(\"\") else\n            if (open.isEmpty) result.mkString(\"\") else\n                if (stack.size == 0) result.mkString(\"\") else\n                    result.mkString(\"\").reverse.mkString(\"\").reverse\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979662
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue += x else ())\n        while (stack.nonEmpty || queue.nonEmpty) {\n            val a = stack.pop\n            val b = queue.pop\n            if (a == \"(\") stack += b else if (!b == \"(\") queue += b else ()\n            if (stack.nonEmpty || queue.nonEmpty) {\n                val c = stack.pop\n                val d = queue.pop\n                if (c == \"(\") stack += d else if (!d == \"(\") queue += d else ()\n                if (stack.nonEmpty || queue.nonEmpty) {\n                    val e = stack.pop\n                    val f = queue.pop\n                    if (e == \"(\") stack += f else if (!f == \"(\") queue += f else ()\n                    if (stack.nonEmpty || queue.nonEmpty) {\n                        val g = stack.pop\n                        val h = queue.pop\n                        if (g == \"(\") stack += h else if (!h == \"(\") queue += h else ()\n                        if (stack.nonEmpty || queue.nonEmpty) {\n                            val i = stack.pop\n                            val j = queue.pop\n                            if (i == \"(\") stack += j else if (!j == \"(\") queue += j else ()\n                            if (stack.nonEmpty || queue.nonEmpty) {\n                                val k = stack.pop\n                                val l = queue.pop\n                                if (k == \"(\") stack += l else if (!l == \"(\") queue += l else ()\n                                if (stack.nonEmpty || queue.nonEmpty) {\n                                    val m = stack.pop\n                                    val n = queue.pop\n                                    if (m == \"(\") stack += n else if (!n == \"(\") queue += n else ()\n                                    if (stack.nonEmpty || queue.nonEmpty) {\n                                        val o = stack.pop\n                                        val p = queue.pop\n                                        if (o == \"(\") stack += p else if (!p == \"(\") queue += p else ()\n                                        if (stack.nonEmpty || queue.nonEmpty) {\n                                            val q = stack.pop\n                                            val r = queue.pop\n                                            if (q == \"(\") stack += r else if (!r == \"(\") queue += r else ()\n                                            if (stack.nonEmpty || queue.nonEmpty) {\n                                                val s = stack.pop\n                                                val t = queue.pop\n                                                if (s == \"(\") stack += t else if (!t == \"(\") queue += t else ()\n                                                if (stack.nonEmpty || queue.nonEmpty) {\n                                                    val u = stack.pop\n                                                    val v = \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgnfc9ha9.scala:64:59 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m                                                    \u001b[33mval\u001b[0m \u001b[36mv\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgnfc9ha9.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgnfc9ha9.scala:21:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"(\"\u001b[0m) stack += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\"(\"\u001b[0m) queue += x \u001b[33melse\u001b[0m ())\n\u001b[31m\u001b[31m   |\u001b[0m                ",
      "stdout": "",
      "timestamp": 1659979668
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    queue.enqueue(x)\n                    stack.pop()\n                }\n                case \"(\" => {\n                    stack.push(x)\n                }\n                case _ => {\n                    queue.enqueue(x)\n                }\n            }\n        })\n        while(!stack.isEmpty && !queue.isEmpty) {\n            val curr = queue.poll()\n            val next = stack.pop()\n            if(!result.contains(curr)) {\n                result.enqueue(curr)\n                result.enqueue(next)\n            }\n        }\n        if(!stack.isEmpty && !queue.isEmpty) {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979665
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.foreach(y => stack.pop())\n                    result ++= stack\n                    stack.clear()\n                case x if x != \"(\" =>\n                    open += x\n                case x if x == \")\" =>\n                    close.foreach(y => stack.pop())\n                    result ++= stack\n                    stack.clear()\n                case x if x == \")\" =>\n                    close.foreach(y => stack.pop())\n                    result ++= stack\n                    stack.clear()\n                case x if x != \"(\" =>\n                    open += x\n            }\n        })\n        result match {\n            case Nil => \"No\"\n            case x => x.mkString(\"(\", \")\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979665
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val stackMinIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue = lst(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp1k_50mv7.scala:69:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinValue\u001b[0m = lst(stackMin)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValue\u001b[0m = lst(stackMax)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMa",
      "stdout": "",
      "timestamp": 1659979668
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open.append(x)\n            if (x == \")\") close.append(x)\n            if (open.isEmpty && close.isEmpty) stack.append(x)\n            if (open.isEmpty && close.isNotEmpty) result.append(x)\n            if (open.isNotEmpty && close.isEmpty) result.append(x)\n            if (open.isNotEmpty && close.isNotEmpty) stack.append(x)\n        })\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979666
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val len = lst.size\n        for(i <- 0 until len){\n            val str = lst(i)\n            if(str == \"(\"){\n                stack.push(str)\n            }else if(str == \")\"){\n                val top = stack.pop()\n                if(top == \"(\"){\n                    queue.enqueue(str)\n                }else{\n                    result.enqueue(str)\n                }\n            }else{\n                result.enqueue(str)\n            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n        }else{\n            val top = stack.pop()\n            if(top == \"(\"){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n        }else{\n            val top = queue.dequeue()\n            if(top == \"(\"){\n                stack.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n        }else{\n            val top = stack.pop()\n            if(top == \"(\"){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n        }else{\n            val top = queue.dequeue()\n            if(top == \"(\"){\n                stack.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n        }else{\n            val top = stack.pop()\n            if(top == \"(\"){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n        }else{\n            val top = queue.dequeue()\n            if(top == \"(\"){\n                stack.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n        }else{\n            val top = stack.pop()\n            if(top == \"(\"){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n        }else{\n            val top = queue.dequeue()\n            if(top == \"(\"){\n                stack.enqueue(top)\n            }else{\n                result.enqueue\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpibbwwod8.scala:132:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m132 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibbwwod8.scala:131:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m131 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: String\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpibbwwod8.scala:116:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m116 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979669
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => stack.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize - 1\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmprt_pi9r7.scala:74:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxSize\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMax\u001b[0m = stackMaxSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValue\u001b[0m = lst(stackMaxIndex).charAt(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackValue\u001b[0m = lst(stackIndex).charAt(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValue\u001b[0m = lst(stackMaxIndex).charAt(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach { s =>\n            s match {\n                case \")\" =>\n                    close.foreach(c => stack += c)\n                    result ++= stack\n                    stack.toList.reverse.foreach(c => stack += c)\n                    stack.clear()\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")\" =>\n                    open += s\n                case \")\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n                    open += s\n                case \")(\" =>\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsa0dearv.scala:122:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m122 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsa0dearv.scala:22:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m 22 |\u001b[0m        lst.foreach { \u001b[36ms\u001b[0m =>\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 23 |\u001b[0m            s \u001b[33mmatch\u001b[0m {\n\u001b[31m 24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m =>\n\u001b[31m 25 |\u001b",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open += x\n            else if (x == \")\") close += x\n            else stack += x\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n            val closeStack = stack.drop(openCount)\n            val openStackSize = openStack.size\n            val closeStackSize = closeStack.size\n            if (openStackSize == closeStackSize) {\n                val openStackElement = openStack.last\n                val closeStackElement = closeStack.last\n                if (openStackElement == closeStackElement) {\n                    result += \"Yes\"\n                } else {\n                    result += \"No\"\n                }\n            } else {\n                result += \"No\"\n            }\n        } else {\n            result += \"No\"\n        }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach { s =>\n            s match {\n                case \")\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\"  =>\n                    close.clear()\n                    stack.clear()\n                case \")(\"  =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n                case \")(\" =>\n                    close.clear()\n                    stack.clear()\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu3loa0jc.scala:132:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m132 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu3loa0jc.scala:22:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m 22 |\u001b[0m        lst.foreach { \u001b[36ms\u001b[0m =>\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 23 |\u001b[0m            s \u001b[33mmatch\u001b[0m {\n\u001b[31m 24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m ",
      "stdout": "",
      "timestamp": 1659979674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n                open += s\n            } else {\n                close += s\n            }\n        }\n        open foreach { s =>\n            stack push s\n        }\n        close foreach { s =>\n            queue push s\n        }\n        while(!queue.isEmpty && !stack.isEmpty) {\n            val s = queue.poll\n            val c = stack.pop()\n            if (s.startsWith(\"(\")) {\n                open += c\n            } else {\n                close += c\n            }\n            result push s\n        }\n        if (open.isEmpty && close.isEmpty) {\n            return \"No\"\n        }\n        if (open.isEmpty || close.isEmpty) {\n            return \"Yes\"\n        }\n        if (result.size == 1) {\n            result.toList\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        val good = mutable.HashSet[String]()\n        lst.foreach(x => x match {\n            case x if x == \"\" => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")\" => close.push(x)\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")\" => close.push(x)\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")\" => close.push(x)\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")\" => close.push(x)\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty => ()\n            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzyl_j_8u.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzyl_j_8u.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:22:19 ------------------------\u001b[0m\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => stack.pop() match {\n                    case \")\" => result += \"Yes\"\n                    case \")()\" => result += \"No\"\n                    case \")()()\" => result += \"No\"\n                    case \")()()()\" => result += \"No\"\n                    case \")()()()()\" => result += \"No\"\n                    case \")()()()()()\" => result += \"No\"\n                    case \")()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpquc2ncha.scala:47:25 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                    \u001b[33mcase\u001b[0m \")()()()()()()()()()()()()()()()()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpquc2ncha.scala:49:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpquc2ncha.scala:65:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:49:4 -------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    Not found: )()()()()()()()()()()()()()()()()def\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "stdout": "",
      "timestamp": 1659979670
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result.append(\"No\")\n            } else {\n                val left = str.substring(0, open)\n                val right = str.substring(close + 1)\n                val newStack = stack.toList\n                newStack.push(left)\n                newStack.push(right)\n                while(!newStack.isEmpty) {\n                    val str = newStack.pop()\n                    if(str.length == 0) {\n                        result.append(\"Yes\")\n                        break\n                    } else {\n                        val open = str.indexOf(\"(\")\n                        val close = str.indexOf(\")\")\n                        if(open < 0 || close < 0) {\n                            result.append(\"No\")\n                            break\n                        } else {\n                            val left = str.substring(0, open)\n                            val right = str.substring(close + 1)\n                            val newStack = stack.toList\n                            newStack.push(left)\n                            newStack.push(right)\n                        }\n                    }\n                }\n            }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:42:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                            break\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979671
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n        val stackValue = lst(0)\n        val stackIndex = 0\n        val stackMaxValueIndex = stackSize - 1\n        val stackMaxValueValue = lst(stackMaxValueIndex)\n        val stackValueIndex = stackSize - 1\n        val stackValueValue = lst(0)\n        val stackMaxValueIndexValue = stackSize - 1\n        val stackMaxValueValueValue = lst(stackMaxValueIndexValue)\n        val stackValueIndexValue = stackSize - 1\n        val stackValueValueValue = lst(0)\n        val stackMaxValueIndexValueValue = stackSize - 1\n        val stackMaxValueValueValueValue = lst(stackMaxValueIndexValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValue = lst(0)\n        val stackMaxValueIndexValueValueValue = stackSize - 1\n        val stackMaxValueValueValueValueValue = lst(stackMaxValueIndexValueValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValue = lst(0)\n        val stackMaxValueIndexValueValueValueValue = stackSize - 1\n        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValue = lst(0)\n        val stackMaxValueIndexValueValueValueValueValue = stackSize - 1\n        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValueValue = lst(0)\n        val stackMaxValueIndexValueValueValueValueValueValue = stackSize - 1\n        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValueValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValueValueValue = lst(0)\n        val stackMaxValueIndexValueValueValueValueValueValueValue = stackSize - 1\n        val stackMaxValueValueValueValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValueValueValueValueValue)\n        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValue\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8nz_rx4l.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackValueIndexValueValue\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackValueIndexValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackValueIndexValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackValueIndexValueValue\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackValueIndexValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackValueIndexValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackValueIndexValueValue\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackValueIndexValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackValueIndexValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackValueIndexValueValue\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackValueIndexValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackValueInd",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        lst.foreach(x => if (x == \"(\") queue.enqueue(x) else stack.push(x))\n        while(stack.nonEmpty) {\n            val x = stack.pop()\n            if (x == \"(\") {\n                queue.enqueue(x)\n            } else {\n                val y = queue.pop()\n                if (y == \"(\") queue.enqueue(y) else stack.push(y)\n            }\n        }\n        if (queue.nonEmpty) result.enqueue(\"Yes\") else result.enqueue(\"No\")\n        result.dequeue()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979671
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val stackMinIndex = 0\n        val stackMaxStack = mutable.Stack[String]()\n        val stackMinStack = mutable.Stack[String]()\n        val stackMaxStackSize = stackMaxStack.size()\n        val stackMinStackSize = stackMinStack.size()\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = 0\n        val stackMaxStackMinIndex = 0\n        val stackMaxStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackIndex = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMin\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjh0n391z.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh0n391z.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\u001b[0m = stackMaxStackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh0n391z.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh0n391z.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group",
      "stdout": "",
      "timestamp": 1659979675
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => stack.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val stackMinIndex = 0\n        val stackMinSize = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMinMax = stackSize - 1\n        val stackMinMaxIndex = stackSize - 1\n        val stackMinMaxSize = stackSize - 1\n        val stackMinMaxMin = stackSize - 1\n        val stackMinMaxMinIndex = stackSize - 1\n        val stackMinMaxMinSize = stackSize - 1\n        val stackMinMaxMinMax = stackSize - 1\n        val stackMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMin = stackSize - 1\n        val stackMinMaxMinMaxMinIndex = stackSize - 1\n        val stackMinMaxMinMaxMinSize = stackSize - 1\n        val stackMinMaxMinMaxMinMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMin = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize - 1\n        val stackMinMax\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpanjr6nzy.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinMaxMinMaxMinMaxMinMaxMax\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinMaxMinMaxMinMaxMinMaxMax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinMaxMinMaxMinMaxMinMaxMax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinMaxMinMaxMinMaxMinMaxMaxIndex\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinMaxMinMaxMinMaxMinMaxMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinMaxMinMaxMinMaxMinMaxMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:53:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinMaxMinMaxMinMaxMinMaxMaxSize\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinMaxMinMaxMinMaxMinMaxMaxSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinMaxMinMaxMinMaxMinMaxMaxSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:54:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinMaxMinMaxMinMaxMinMaxMax\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659979676
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        val openCount = mutable.Map[String, Int]()\n        val closeCount = mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => closeCount += ((x, 1))\n                case \")(\"  => openCount += ((x, 1))\n                case \")(\"  => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount += ((\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpwcw0d1_i.scala:64:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m => openCount += ((\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwcw0d1_i.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explan",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val len = lst.size\n        for(i <- 0 until len){\n            val str = lst(i)\n            val len = str.length\n            val isOpen = str.charAt(0) == '('\n            val isClose = str.charAt(len-1) == ')'\n            if(!isOpen && !isClose){\n                queue.enqueue(str)\n            }\n            else if(isOpen && !isClose){\n                stack.push(str)\n            }\n            else if(isClose && !isOpen){\n                val str = stack.pop()\n                if(!queue.contains(str)){\n                    result.enqueue(str)\n                }\n            }\n        }\n        if(result.size == len){\n            return \"Yes\"\n        }\n        else{\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n        lst.foreach(x => {\n            if (x == \"(\") {\n                open += x\n                openCount += 1\n            } else if (x == \")\") {\n                close += x\n                closeCount += 1\n            } else {\n                stack += x\n            }\n        })\n        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n        if (openCount.size == closeCount.size) {\n            val open = open.toList\n            val close = close.toList\n            val stack = stack.toList\n            val len = openCount.size\n            val stackLen = stack.length\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0gee6whc.scala:142:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m142 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0gee6whc.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0gee6whc.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0gee6whc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0gee6whc.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0gee6whc.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659979678
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open += x\n            if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:74:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        lst.foreach(x => if (x == \"(\") stack += x else if (!stack.isEmpty && x == \")\") result += stack.pop())\n        if (result.size == lst.length) result.mkString(\"Yes\") else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr7vg0zev.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr7vg0zev.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n            case x if x == \"(\" => open.push(x)\n            case _ => stack += x\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openStr = open.toList\n            val closeStr = close.toList\n            val openStrLen = openStr.size\n            val closeStrLen = closeStr.size\n            val openStrSet = openStr.distinct\n            val closeStrSet = closeStr.distinct\n            val openStrSetLen = openStrSet.size\n            val closeStrSetLen = closeStrSet.size\n            val openStrSetSet = openStrSet.intersect(closeStrSet)\n            val closeStrSetSet = closeStrSet.intersect(openStrSet)\n            val openStrSetSetLen = openStrSetSet.size\n            val closeStrSetSetLen = closeStrSetSet.size\n            val openStrSetSetSet = openStrSetSet.intersect(closeStrSetSet)\n            val closeStrSetSetSet = closeStrSetSet.intersect(openStrSetSet)\n            val openStrSetSetSetLen = openStrSetSetSet.size\n            val closeStrSetSetSetLen = closeStrSetSet.size\n            val openStrSetSetSetSet = openStrSetSet.intersect(closeStrSetSetSet)\n            val closeStrSetSetSet = closeStrSetSet.intersect(openStrSetSetSet)\n            val openStrSetSetSetSetLen = openStrSetSetSet.size\n            val closeStrSetSetSetLen = closeStrSetSet.size\n            val openStrSetSetSetSet = openStrSetSet.intersect(closeStrSetSetSet)\n            val closeStrSetSetSet = closeStrSetSet.intersect(openStrSetSetSet)\n            val openStrSetSetSetSetLen = openStrSetSetSetSet.size\n            val closeStrSetSetSetLen = closeStrSetSet.size\n            val openStrSetSetSetSet = openStrSetSetSet.intersect(closeStrSetSetSet)\n            \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc4rdd_an.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc4rdd_an.scala:47:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcloseStrSetSetSet\u001b[0m = closeStrSetSet.intersect(openStrSetSetSet)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseStrSetSetSet is already defined as \u001b[33mvalue\u001b[0m",
      "stdout": "",
      "timestamp": 1659979678
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackIndex = 0\n        val stackMaxValue = lst(stackMaxIndex)\n        val stackMaxValueIndex = stackMaxIndex\n        val stackMaxValueValue = lst(stackMaxValueIndex)\n        val stackMaxValueValueIndex = stackMaxValueIndex\n        val stackMaxValueValueValue = lst(stackMaxValueValueIndex)\n        val stackMaxValueValueValueIndex = stackMaxValueValueIndex\n        val stackMaxValueValueValueValue = lst(stackMaxValueValueValueIndex)\n        val stackMaxValueValueValueValueIndex = stackMaxValueValueValueIndex\n        val stackMaxValueValueValueValueValue = lst(stackMaxValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueValueIndex)\n        val stackMaxValueValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueValueIndex\n        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMax\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoup9ntn8.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoup9ntn8.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValueValueValueValueValueIndex\u001b[0m = stackMaxValueValueValueValueValueIndex\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxValueValueValueValueValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxValueValueValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoup9ntn8.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValueValueValueValueValueValue\u001b[0m = lst(stackMaxValueValueValueValueValueIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxValueValueValueValueValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxValueValueValueValueValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoup9ntn8.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxValueValueValueValueValueIndex\u001b[0m = stackMaxValueValueValueValueValueValueIndex\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxValueValueValueValueValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxValueValueValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoup9ntn8.scala:40:12 -",
      "stdout": "",
      "timestamp": 1659979677
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize - 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp55rx3h15.scala:34:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxSize\u001b[0m = stackMaxMaxMaxMaxMaxMaxMax * \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Recursive \u001b[33mvalue\u001b[0m \u001b[35mstackMaxMaxMaxMaxMaxMaxMax\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:40:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\u001b[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:41:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\u001b[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ",
      "stdout": "",
      "timestamp": 1659979679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stackIsEmpty = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmptyOrFull = stackIsEmpty || stackIsFull\n        val resultIsEmptyOrFull = resultIsEmpty || resultIsFull\n        val stackIsFullOrEmpty = stackIsFull || stackIsEmpty\n        val resultIsFullOrEmpty = resultIsFull || resultIsEmpty\n        val stackIsEmptyOrFullOrEmpty = stackIsEmptyOrFull || stackIsFullOrEmpty\n        val resultIsEmptyOrFullOrEmpty = resultIsEmptyOrFull || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIs\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackIsFullOrFullOrEmpty\u001b[0m = stackIsFullOrEmpty || stackIsFullOrEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackIsFullOrFullOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackIsFullOrFullOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultIsFullOrFullOrEmpty\u001b[0m = resultIsFullOrEmpty || resultIsFullOrEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresultIsFullOrFullOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresultIsFullOrFullOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackIsFullOrFullOrEmpty\u001b[0m = stackIsFullOrEmpty || stackIsFullOrEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackIsFullOrFullOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackIsFullOrFullOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultIsFullOrFullOrEmpty\u001b[0m = resultIsFullOrEmpty || resultIsFullOrEmpty\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresultIsFullOrFullOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresultIsFullOrFullOrEmpt",
      "stdout": "",
      "timestamp": 1659979679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n            case x if x == \")\" => stack.push(x)\n            case x if x == \"(\" => open.push(x)\n            case x if x == \")\" => stack.pop() match {\n                case x if x == \")\" => close.push(x)\n                case x if x == \")\" => result.add(\"Yes\")\n                case x if x == \"(\" => open.push(x)\n                case x => result.add(\"No\")\n            }\n            case x => result.add(\"No\")\n        })\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979677
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => stack.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptiiwc0ku.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptiiwc0ku.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmptiiwc0ku.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m])",
      "stdout": "",
      "timestamp": 1659979678
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n        val goodParens = mutable.ListBuffer[String]()\n        val badParens = mutable.ListBuffer[String]()\n        val goodParensCount = mutable.ListBuffer[Int]()\n        val badParensCount = mutable.ListBuffer[Int]()\n        val goodParensCount2 = mutable.ListBuffer[Int]()\n        val badParensCount2 = mutable.ListBuffer[Int]()\n        val goodParensCount3 = mutable.ListBuffer[Int]()\n        val badParensCount3 = mutable.ListBuffer[Int]()\n        val goodParensCount4 = mutable.ListBuffer[Int]()\n        val badParensCount4 = mutable.ListBuffer[Int]()\n        val goodParensCount5 = mutable.ListBuffer[Int]()\n        val badParensCount5 = mutable.ListBuffer[Int]()\n        val goodParensCount6 = mutable.ListBuffer[Int]()\n        val badParensCount6 = mutable.ListBuffer[Int]()\n        val goodParensCount7 = mutable.ListBuffer[Int]()\n        val badParensCount7 = mutable.ListBuffer[Int]()\n        val goodParensCount8 = mutable.ListBuffer[Int]()\n        val badParensCount8 = mutable.ListBuffer[Int]()\n        val goodParensCount9 = mutable.ListBuffer[Int]()\n        val badParensCount9 = mutable.ListBuffer[Int]()\n        val goodParensCount10 = mutable.ListBuffer[Int]()\n        val badParensCount10 = mutable.ListBuffer[Int]()\n        val goodParensCount11 = mutable.ListBuffer[Int]()\n        val badParensCount11 = mutable.ListBuffer[Int]()\n        val goodParensCount12 = mutable.ListBuffer[Int]()\n        val badParensCount12 = mutable.ListBuffer[Int]()\n        val goodParensCount13 = mutable.ListBuffer[Int]()\n        val badParensCount13 = mutable.ListBuffer[Int]()\n        val goodParensCount14 = mutable.ListBuffer[Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmprc5i4xhy.scala:51:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodParens\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659979681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    if (!stack.isEmpty) {\n                        stack.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.isEmpty) {\n                        queue.pop()\n                    }\n                }\n                case \")(\" => {\n                    if (!queue.is\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf7x6qfkk.scala:128:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m128 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf7x6qfkk.scala:145:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m145 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStr\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m ",
      "stdout": "",
      "timestamp": 1659979679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") stack += x\n            if (x == \")\") stack -= x\n            if (stack.size == 0 && queue.size == 0) good += x\n            if (stack.size == 0 && queue.size != 0) bad += x\n            if (stack.size != 0 && queue.size == 0) bad += x\n            if (stack.size != 0 && queue.size != 0) queue += x\n        })\n        if (good.size == lst.size) good.toList.mkString(\"(\", \")\")\n        else if (bad.size == lst.size) \"No\"\n        else matchParens(lst.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979678
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue += x else ())\n        while (stack.nonEmpty || queue.nonEmpty) {\n            if (stack.nonEmpty && queue.nonEmpty) {\n                if (stack.head == \"(\" && queue.head == \"(\") stack.pop() else if (!stack.head == \"(\" && queue.head == \"(\") queue.pop() else ()\n            } else if (stack.nonEmpty) {\n                result += \"(\"\n                stack.pop()\n            } else if (queue.nonEmpty) {\n                result += \")\"\n                queue.pop()\n            }\n        }\n        if (result.nonEmpty) result.mkString\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptv5fqwiq.scala:21:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"(\"\u001b[0m) stack += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\"(\"\u001b[0m) queue += x \u001b[33melse\u001b[0m ())\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value unary_! is not a member of String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        val len = lst.size\n        for(i <- 0 until len) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result.enqueue(str)\n            } else {\n                val stackStr = str.substring(0, open)\n                val queueStr = str.substring(open + 1, close)\n                stack.push(stackStr)\n                queue.enqueue(queueStr)\n            }\n        }\n        while(stack.nonEmpty) {\n            val str = stack.pop()\n            val queueStr = queue.pop()\n            if(!queueStr.equals(str)) {\n                result.enqueue(str)\n            }\n        }\n        if(result.isEmpty) {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3 * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6 = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8 * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11 = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 = stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 = stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 = stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 = stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 = stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 = stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 = stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 = stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 = stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpch5x3hl7.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpch5x3hl7.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979657
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n        val stackIndex = 0\n        val resultIndex = 0\n        val stackIsEmpty = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackMax == stackIndex\n        val resultIsFull = resultMax == resultIndex\n        while(stackIsEmpty || resultIsEmpty) {\n            val stackSize = lst.size\n            val resultSize = lst.size\n            val stackMax = stackSize - 1\n            val resultMax = resultSize - 1\n            val stackIndex = 0\n            val resultIndex = 0\n            val stackIsEmpty = stack.isEmpty\n            val resultIsEmpty = result.isEmpty\n            val stackIsFull = stackMax == stackIndex\n            val resultIsFull = resultMax == resultIndex\n            while(stackIsEmpty || resultIsEmpty) {\n                val stackSize = lst.size\n                val resultSize = lst.size\n                val stackMax = stackSize - 1\n                val resultMax = resultSize - 1\n                val stackIndex = 0\n                val resultIndex = 0\n                val stackIsEmpty = stack.isEmpty\n                val resultIsEmpty = result.isEmpty\n                val stackIsFull = stackMax == stackIndex\n                val resultIsFull = resultMax == resultIndex\n                while(stackIsEmpty || resultIsEmpty) {\n                    val stackSize = lst.size\n                    val resultSize = lst.size\n                    val stackMax = stackSize - 1\n                    val resultMax = resultSize - 1\n                    val stackIndex = 0\n                    val resultIndex = 0\n                    val stackIsEmpty = stack.isEmpty\n                    val resultIsEmpty = result.isEmpty\n                    val stackIsFull = stackMax == stackIndex\n                    val resultIsFull = resultMax == resultIndex\n                    while(stackIsEmpty || resultIsEmpty) {\n                        val stackSize = lst.size\n                        val resultSize = lst.size\n                        val stackMax = stackSize - 1\n                        val resultMax = resultSize - 1\n                        val stackIndex = 0\n                        val resultIndex = 0\n                        val stackIsEmpty = stack.isEmpty\n                        val resultIsEmpty = result.isEmpty\n                        val stackIsFull = stackMax == stackIndex\n                        val resultIsFull = resultMax == resultIndex\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpot37uayc.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpot37uayc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpot37uayc.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpot37uayc.scala:30:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mwhile\u001b[0m(stackIsEmpty || resultIsEmpty) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultSize\u001b[0m = lst.size\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstackMax\u001b[0m = stackSize - \u001b[31m1\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultMax\u001b[0m = resultSize - \u001b[31m1\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstackIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstackIsEmpty\u001b[0m = stack.isEmpty\n\u001b[31m38 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultIsEmpty\u001b[0m = result.isEmpty\n\u001b[31m39 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstackIsFull\u001b[0m = stackMax == stackIndex\n\u001b[31m40 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultIsFull\u001b[0m = resultMax == resultIndex\n\u001b[31m41 |\u001b[0m            \u001b[33mwhile\u001b[0m(stackIsEmpty || resultIsEmpty) {\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659979683
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        val openCount = mutable.Map[String, Int]()\n        val closeCount = mutable.Map[String, Int]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => closeCount += ((x, 1))\n            case x if x == \"(\" => open += x\n            case x => stack += x\n        })\n        val openCount = openCount.toSeq\n        val closeCount = closeCount.toSeq\n        val openCount = openCount.sortBy(_._2).reverse\n        val closeCount = closeCount.sortBy(_._2).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n        val openCount = openCount.take(openCoun\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwk_mukb8.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.toSeq\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.toSeq\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.sortBy(_._2).reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.sortBy(_._2).reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:33:12 ------",
      "stdout": "",
      "timestamp": 1659979682
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\") => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n            case x => bad.add(x)\n        })\n        while(!queue.isEmpty && !stack.isEmpty) {\n            val x = queue.poll\n            val y = stack.pop()\n            good += x + y\n            bad += y\n            x match {\n                case x if x.startsWith(\"(\") => queue.enqueue(x)\n                case x if x.startsWith(\")\") => stack.push(x)\n                case x => bad.add(x)\n            }\n        }\n        if(good.size == lst.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979682
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.foreach(x => stack.pop())\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n                case \")(\"  =>\n                    open += x\n                case \")(\"  =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1lsnqkyb.scala:129:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m129 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    stack = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-expl",
      "stdout": "",
      "timestamp": 1659979682
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue += x else if (!x == \")\") bad += x else if (!x == \")\") good += x)\n        val goodStr = good.toList\n        val badStr = bad.toList\n        if (goodStr.size == 0 && badStr.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp65e4c363.scala:22:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"(\"\u001b[0m) stack += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\"(\"\u001b[0m) queue += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\")\"\u001b[0m) bad += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\")\"\u001b[0m) good += x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value unary_! is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /",
      "stdout": "",
      "timestamp": 1659979685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.foreach(y => stack += y)\n                    stack.toList.reverse.foreach(y => result += y)\n                    stack.toList.reverse.clear()\n                }\n                case \"(\" => {\n                    open.foreach(y => stack += y)\n                    stack.toList.reverse.foreach(y => result += y)\n                    stack.toList.reverse.clear()\n                }\n                case _ => stack += x\n            }\n        })\n        if (stack.size == 0)\n            \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => if (open(x) ) open(x) += x else close(x) += x)\n        open.foreach(x => if (close(x) ) close(x) -= x else stack += x)\n        close.foreach(x => if (open(x) ) open(x) -= x else stack += x)\n        stack.foreach(x => if (close(x) ) close(x) -= x else queue += x)\n        queue.foreach(x => if (open(x) ) open(x) -= x else queue += x)\n        if (stack.size == 0 && queue.size == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n        val goodSize = mutable.Set[String\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo1od9pxi.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodSize\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadSize\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodSize\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadSize\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:28:12 ------------------",
      "stdout": "",
      "timestamp": 1659979685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        lst.foreach { x =>\n            x match {\n                case \")\" =>\n                    close.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqxacvx1s.scala:123:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m123 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqxacvx1s.scala:22:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m 22 |\u001b[0m        lst.foreach { \u001b[36mx\u001b[0m =>\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 23 |\u001b[0m            x \u001b[33mmatch\u001b[0m {\n\u001b[31m 24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m =>\n\u001b[31m 25",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresultSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresultSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue += x else ())\n        val stackSize = stack.size\n        val queueSize = queue.size\n        if (stackSize == queueSize) {\n            val stackElements = stack.take(stackSize)\n            val queueElements = queue.take(queueSize)\n            val stackElementsLen = stackElements.size\n            val queueElementsLen = queueElements.size\n            if (stackElementsLen == queueElementsLen) {\n                val stackElementsLen2 = stackElements.take(stackElementsLen)\n                val queueElementsLen2 = queueElements.take(queueElementsLen)\n                val stackElementsLen3 = stackElements.take(stackElementsLen)\n                val queueElementsLen3 = queueElements.take(queueElementsLen)\n                val stackElementsLen4 = stackElements.take(stackElementsLen)\n                val queueElementsLen4 = queueElements.take(queueElementsLen)\n                val stackElementsLen5 = stackElements.take(stackElementsLen)\n                val queueElementsLen5 = queueElements.take(queueElementsLen)\n                val stackElementsLen6 = stackElements.take(stackElementsLen)\n                val queueElementsLen6 = queueElements.take(queueElementsLen)\n                val stackElementsLen7 = stackElements.take(stackElementsLen)\n                val queueElementsLen7 = queueElements.take(queueElementsLen)\n                val stackElementsLen8 = stackElements.take(stackElementsLen)\n                val queueElementsLen8 = queueElements.take(queueElementsLen)\n                val stackElementsLen9 = stackElements.take(stackElementsLen)\n                val queueElementsLen9 = queueElements.take(queueElementsLen)\n                val stackElementsLen10 = stackElements.take(stackElementsLen)\n                val queueElementsLen10 = queueElements.take(queueElementsLen)\n                val stackElementsLen11 = stackElements.take(stackElementsLen)\n                val queueElementsLen11 = queueElements.take(queueElementsLen)\n                val stackElementsLen12 = stackElements.take(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp05kfsn7r.scala:50:60 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstackElementsLen12\u001b[0m = stackElements.take(\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp05kfsn7r.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp05kfsn7r.scala:21:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"(\"\u001b[0m) stack += x \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!x == \u001b[31m\"(\"\u001b[0m) queue += x \u001b[33melse\u001b[0m ())\n\u001b[31m\u001b[31m   |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n            case x if x == \"(\" => open.push(x)\n            case _ => stack += x\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n            val closeStack = stack.drop(closeCount)\n            val openStackSize = openStack.size\n            val closeStackSize = closeStack.size\n            if (openStackSize == closeStackSize) {\n                val openStack = openStack.mkString\n                val closeStack = closeStack.mkString\n                val openStackSize = openStack.size\n                val closeStackSize = closeStack.size\n                if (openStackSize == closeStackSize) {\n                    val openStack = openStack.mkString\n                    val closeStack = closeStack.mkString\n                    val openStackSize = openStack.size\n                    val closeStackSize = closeStack.size\n                    if (openStackSize == closeStackSize) {\n                        val openStack = openStack.mkString\n                        val closeStack = closeStack.mkString\n                        val openStackSize = openStack.size\n                        val closeStackSize = closeStack.size\n                        if (openStackSize == closeStackSize) {\n                            val openStack = openStack.mkString\n                            val closeStack = closeStack.mkString\n                            val openStackSize = openStack.size\n                            val closeStackSize = closeStack.size\n                            if (openStackSize == closeStackSize) {\n                                val openStack = openStack.mkString\n                                val closeStack = closeStack.mkString\n                                val openStackSize = openStack.size\n                                val closeStackSize = closeStack.size\n                                if (openStackSize == closeStackSize) {\n                                    val openStack = openStack.mkString\n                                    val closeStack = closeStack.mkString\n                                    val openStackSize = openStack.size\n                                    val closeStackSize = closeStack.size\n                                    if (openStackSize == closeStackSize) {\n                                        val openStack = openStack.mkString\n                                        val closeStack = closeStack.mkString\n                                        val openStackSize = openStack.size\n                                        val closeStackSize = closeStack.size\n                                        if (openStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdjej9syl.scala:70:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdjej9syl.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjej9syl.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjej9syl.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjej9syl.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjej9syl.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdjej9syl.scala:35:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mopenStack\u001b[0m = openStack.mkString\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659979686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n        val goodParens = mutable.ListBuffer[String]()\n        val badParens = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")(\"  =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n                case \")()()\" =>\n                    stack.pop() match {\n                        case Some(\"(\") => goodParens += x\n                        case _ => badParens += x\n                    }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplx5t67_h.scala:103:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodParens\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compili",
      "stdout": "",
      "timestamp": 1659979688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize - 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbsmjiiza.scala:34:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxSize\u001b[0m = stackMaxMaxMaxMaxMaxMaxMax * \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Recursive \u001b[33mvalue\u001b[0m \u001b[35mstackMaxMaxMaxMaxMaxMaxMax\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:37:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMax\u001b[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:41:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\u001b[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ",
      "stdout": "",
      "timestamp": 1659979688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            if (x == \"(\") {\n                stack += x\n            } else if (x == \")\") {\n                val s = stack.pop()\n                if (queue.contains(s)) {\n                    result += \"No\"\n                } else {\n                    result += \"Yes\"\n                }\n                queue += s\n            }\n        })\n        result mkString \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") stack.push(x)\n            if (x == \")\") queue.push(x)\n            if (stack.size == 0 && queue.size == 0) {\n                good.add(x)\n            }\n        })\n        if (good.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        lst.foreach(x => {\n            if (open.isEmpty) {\n                open += x\n            } else if (close.isEmpty) {\n                close += x\n            } else if (open.isEmpty && close.isEmpty) {\n                result += x\n            } else if (open.isEmpty && close.contains(x)) {\n                result += x\n            } else if (open.contains(x) && close.isEmpty) {\n                result += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result += \"(\" + x + \")\"\n                stack += x\n            } else if (open.contains(x) && close.contains(x)) {\n                result \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1a02usrf.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1a02usrf.scala:22:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lst.foreach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (open.isEmpty) {\n\u001b[31m24 |\u001b[0m                open += x\n\u001b[31m25 |\u001b[0m            } ",
      "stdout": "",
      "timestamp": 1659979689
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.add(x)\n                case \")(\"  => open.add(x)\n                case \")(\"  => stack += x\n                case \")\" => stack += x\n                case _ => stack += x\n            }\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n            val closeStack = stack.drop(closeCount)\n            val openStackSize = openStack.size\n            val closeStackSize = closeStack.size\n            if (openStackSize == closeStackSize) {\n                val stackSize = stack.size\n                if (stackSize == 1) {\n                    val stackElement = stack.pop()\n                    val stackElementSize = stackElement.size\n                    if (stackElementSize == 1) {\n                        val stackElementElement = stackElement.pop()\n                        if (stackElementElement == closeStack.head) {\n                            result += \"Yes\"\n                        } else {\n                            result += \"No\"\n                        }\n                    } else {\n                        result += \"No\"\n                    }\n                } else {\n                    result += \"No\"\n                }\n            } else {\n                result += \"No\"\n            }\n        } else {\n            result += \"No\"\n        }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stack = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultSize\u001b[0m = lst.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresultSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mresultSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstack is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstack\u001b[0m\n\u001b[31m   |\u001b[0m\n",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => open.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpymzfq6v3.scala:74:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m                \u001b[33mcase\u001b[0m \")\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpymzfq6v3.scala:76:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpymzfq6v3.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set",
      "stdout": "",
      "timestamp": 1659795439
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.foreach(y => stack += y)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n                case x if !open.contains(x) =>\n                    stack += x\n                case x if open.contains(x) =>\n                    stack.lastOption match {\n                        case Some(last) => stack += x\n                        case None => stack += x\n                    }\n            }\n        })\n        stack.lastOption match {\n            case Some(last) => result ++= stack\n            case None => result ++= stack.reverse\n        }\n        result.lastOption match {\n            case Some(last) => last\n            case None => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    stack = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:42:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mcase\u001b[0m Some(last) => last\n\u001b[31m\u001b[31m   |\u001b[0m ",
      "stdout": "",
      "timestamp": 1659979687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        val good = mutable.HashSet[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.add(x)\n                case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n                case \")\" \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqp3wa7iq.scala:80:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqp3wa7iq.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:22:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m](",
      "stdout": "",
      "timestamp": 1659979688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n        val stackSize = lst.size\n        val resultSize = lst.size\n        val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n        val stackIndex = 0\n        val resultIndex = 0\n        val stackIsEmpty = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        while(stackIsEmpty || resultIsEmpty) {\n            val stackSize = lst.size\n            val resultSize = lst.size\n            val stackMax = stackSize - 1\n            val resultMax = resultSize - 1\n            val stackIndex = 0\n            val resultIndex = 0\n            val stackIsEmpty = stack.isEmpty\n            val resultIsEmpty = result.isEmpty\n            val stackIsFull = stackSize == stackMax\n            val resultIsFull = resultSize == resultMax\n            while(stackIsEmpty || resultIsEmpty) {\n                val stackSize = lst.size\n                val resultSize = lst.size\n                val stackMax = stackSize - 1\n                val resultMax = resultSize - 1\n                val stackIndex = 0\n                val resultIndex = 0\n                val stackIsEmpty = stack.isEmpty\n                val resultIsEmpty = result.isEmpty\n                val stackIsFull = stackSize == stackMax\n                val resultIsFull = resultSize == resultMax\n                if(stackIsEmpty && resultIsEmpty) {\n                    val stackSize = lst.size\n                    val resultSize = lst.size\n                    val stackMax = stackSize - 1\n                    val resultMax = resultSize - 1\n                    val stackIndex = 0\n                    val resultIndex = 0\n                    val stackIsEmpty = stack.isEmpty\n                    val resultIsEmpty = result.isEmpty\n                    val stackIsFull = stackSize == stackMax\n                    val resultIsFull = resultSize == resultMax\n                    if(stackIsEmpty && resultIsEmpty) {\n                        val stackSize = lst.size\n                        val resultSize = lst.size\n                        val stackMax = stackSize - 1\n                        val resultMax = resultSize - 1\n                        val stackIndex = 0\n                        val resultIndex = 0\n                        val stackIsEmpty = stack.isEmpty\n                        val resultIsEmpty = result.isEmpty\n                        val stackIsFull = stackSize == stackMax\n                        val resultIsFull = resultSize == resultMax\n                        if(stackIsEmpty && resultIsEmpty) {\n                            val stackSize = lst.size\n                            val resultSize = lst.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxg2e46uc.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxg2e46uc.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxg2e46uc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxg2e46uc.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpxg2e46uc.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979689
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    stack.pop()\n                }\n                case \")()\" => {\n                    stack.pop()\n                    stack.pop()\n                    stack.pop()\n                    result += \"Yes\"\n                }\n                case \")(\" => {\n                    stack.pop()\n                    stack.pop()\n                    result += \"No\"\n                }\n                case _ => {\n                    stack += x\n                }\n            }\n        })\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0opo0_ik.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0opo0_ik.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979689
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    close.foreach(c => stack += c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n                }\n                case \"(\" => {\n                    open.foreach(c => stack += c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n                }\n                case _ => {\n                    stack += x\n                }\n            }\n        })\n        if (stack.nonEmpty) {\n            result ++= stack\n        }\n        if (result.size == lst.size) {\n            val stack2 = mutable.Stack[String]()\n            val stack3 = mutable.Stack[String]()\n            val stack4 = mutable.Stack[String]()\n            val stack5 = mutable.Stack[String]()\n            val stack6 = mutable.Stack[String]()\n            val stack7 = mutable.Stack[String]()\n            val stack8 = mutable.Stack[String]()\n            val stack9 = mutable.Stack[String]()\n            val stack10 = mutable.Stack[String]()\n            val stack11 = mutable.Stack[String]()\n            val stack12 = mutable.Stack[String]()\n            val stack13 = mutable.Stack[String]()\n            val stack14 = mutable.Stack[String]()\n            val stack15 = mutable.Stack[String]()\n            val stack16 = mutable.Stack[String]()\n            val stack17 = mutable.Stack[String]()\n            val stack18 = mutable.Stack[String]()\n            val stack19 = mutable.Stack[String]()\n            val stack20 = mutable.Stack[String]()\n            val stack21 = mutable.Stack[String]()\n            val stack22 = mutable.Stack[String]()\n            val stack23 = mutable.Stack[String]()\n            val stack24 = mutable.Stack[String]()\n            val stack25 = mutable.Stack[String]()\n            val stack26 = mutable.Stack[String]()\n            val stack27 = mutable.Stack[String]()\n            val stack28 = mutable.Stack[String]()\n            val stack29 = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp38krmln2.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    stack = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain",
      "stdout": "",
      "timestamp": 1659979692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val stackMinIndex = 0\n        val stackMaxMin = stackSize - 1\n        val stackMaxMinIndex = stackSize - 1\n        val stackMaxMinIndex2 = stackSize - 1\n        val stackMaxMinIndex3 = stackSize - 1\n        val stackMaxMinIndex4 = stackSize - 1\n        val stackMaxMinIndex5 = stackSize - 1\n        val stackMaxMinIndex6 = stackSize - 1\n        val stackMaxMinIndex7 = stackSize - 1\n        val stackMaxMinIndex8 = stackSize - 1\n        val stackMaxMinIndex9 = stackSize - 1\n        val stackMaxMinIndex10 = stackSize - 1\n        val stackMaxMinIndex11 = stackSize - 1\n        val stackMaxMinIndex12 = stackSize - 1\n        val stackMaxMinIndex13 = stackSize - 1\n        val stackMaxMinIndex14 = stackSize - 1\n        val stackMaxMinIndex15 = stackSize - 1\n        val stackMaxMinIndex16 = stackSize - 1\n        val stackMaxMinIndex17 = stackSize - 1\n        val stackMaxMinIndex18 = stackSize - 1\n        val stackMaxMinIndex19 = stackSize - 1\n        val stackMaxMinIndex20 = stackSize - 1\n        val stackMaxMinIndex21 = stackSize - 1\n        val stackMaxMinIndex22 = stackSize - 1\n        val stackMaxMinIndex23 = stackSize - 1\n        val stackMaxMinIndex24 = stackSize - 1\n        val stackMaxMinIndex25 = stackSize - 1\n        val stackMaxMinIndex26 = stackSize - 1\n        val stackMaxMinIndex27 = stackSize - 1\n        val stackMaxMinIndex28 = stackSize - 1\n        val stackMaxMinIndex29 = stackSize - 1\n        val stackMaxMinIndex30 = stackSize - 1\n        val stackMaxMinIndex31 = stackSize - 1\n        val stackMaxMinIndex32 = stackSize - 1\n        val stackMaxMinIndex33 = stackSize - 1\n        val stackMaxMinIndex34 = stackSize - 1\n        val stackMaxMinIndex35 = stackSize - 1\n        val stackMaxMinIndex36 = stackSize - 1\n        val stackMaxMinIndex37 = stackSize - 1\n        val stackMaxMinIndex38 = \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgv1445je.scala:63:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxMinIndex38\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgv1445je.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgv1445je.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgv1445je.scala:64:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach {\n            s =>\n                val openCount = open.count(_ == s)\n                val closeCount = close.count(_ == s)\n                if (openCount > closeCount) {\n                    result += \"No\"\n                    return\n                }\n                if (openCount == closeCount) {\n                    result += \"Yes\"\n                    return\n                }\n                result += \"No\"\n                return\n        }\n        result += \"No\"\n        return\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit_jsh7i.scala:28:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Unit\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpit_jsh7i.scala:32:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m      ",
      "stdout": "",
      "timestamp": 1659979693
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    closeCount += closeCount.length\n                    closeCount -= 1\n                    close.toList.reverse.foreach(x => stack += x)\n                    stack.toList.reverse.foreach(x => result += x)\n                }\n                case \"(\" => {\n                    openCount += openCount.length\n                    openCount -= 1\n                    open += x\n                    stack += x\n                }\n                case _ => stack += x\n            }\n        })\n        val openCount = openCount.sum\n        val closeCount = closeCount.sum\n        val open = open.toList.reverse\n        val close = close.toList.reverse\n        val openCount = openCount.toInt\n        val closeCount = closeCount.toInt\n        if (openCount == closeCount && openCount == open.length)\n            result += \"Yes\"\n        else\n            result += \"No\"\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseCount\u001b[0m = closeCount.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mcloseCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcloseCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = open.toList.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = close.toList.reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mclose is already defined as \u001b[33mvalue\u001b[0m \u001b[35mclose\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openCount.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that over",
      "stdout": "",
      "timestamp": 1659979690
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result.append(\"No\")\n            } else {\n                val stackStr = str.substring(open + 1, close)\n                val stackStr = stackStr.trim\n                val stackStr = stackStr.substring(0,stackStr.length-1)\n                if(!stack.isEmpty && stackStr == stack.last) {\n                    result.append(\"Yes\")\n                } else {\n                    stack += stackStr\n                }\n            }\n        }\n        result.mkString(\",\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpesqnlw2t.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpesqnlw2t.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpesqnlw2t.scala:28:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstackStr\u001b[0m = stackStr.trim\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpesqnlw2t.scala:29:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstackStr\u001b[0m = stackStr.substring(\u001b[31m0\u001b[0m,stackStr.length-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackStr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open += x\n            if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (close.isEmpty && !open.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:74:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[",
      "stdout": "",
      "timestamp": 1659979690
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    queue.enqueue(x)\n                    stack.push(x)\n                }\n                case \"(\" => {\n                    stack.push(x)\n                }\n                case \")\" => {\n                    val top = stack.pop()\n                    val next = queue.dequeue()\n                    result.enqueue(top + next)\n                }\n                case \"(\" => {\n                    val top = stack.pop()\n                    val next = queue.dequeue()\n                    result.enqueue(top + next)\n                }\n            }\n        })\n        if (stack.size == 0)\n            result.enqueue(\"Yes\")\n        else\n            result.enqueue(\"No\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMax = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val stackMinIndex = stackSize - 1\n        val stackMaxStack = mutable.Stack[String]()\n        val stackMinStack = mutable.Stack[String]()\n        val stackMaxStackSize = stackMaxStack.size()\n        val stackMinStackSize = stackMinStack.size()\n        val stackMaxStackMax = stackMaxStack.last\n        val stackMinStackMin = stackMinStack.last\n        val stackMaxStackMin = stackMaxStack.last\n        val stackMinStackMax = stackMinStack.last\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppn_hzqye.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinStackMinIndex\u001b[0m = stackMinStackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinStackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxStackMinIndex\u001b[0m = stackMaxStackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxStackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxStackMinIndex\u001b[0m = stackMaxStackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxStackMinIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMinStackMinIndex\u001b[0m = stackMinStackSize - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMinStackMinIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMinS",
      "stdout": "",
      "timestamp": 1659979695
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") open += x\n            if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isNotEmpty) result += \"No\"\n            if (open.isNotEmpty && close.isEmpty) result += \"No\"\n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isNotEmpty) result += \"No\"\n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isEmpty) result += \"Yes\"\n            if (open.isNotEmpty && close.isEmpty) result += \"No\"\n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isNotEmpty) result += \"No\"\n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n        })\n        result mkString \"\\n\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach {\n            s =>\n                val l = s.toList\n                val len = l.length\n                for (i <- 0 until len) {\n                    val c = l(i)\n                    if (c == '(') {\n                        stack.push(c)\n                    } else if (c == ')') {\n                        val top = stack.pop()\n                        if (top == '(') {\n                            queue.enqueue(c)\n                        } else {\n                            bad.add (s\"$top$c\")\n                        }\n                    }\n                }\n        }\n        if (queue.size == 0) {\n            good.add(\"Yes\")\n        } else {\n            bad.add(\"No\")\n        }\n        if (good.size == 0) {\n            bad.add(\"No\")\n        } else {\n            good.add(\"Yes\")\n        }\n        good.toString.replace(\"[\", \"\").replace(\"]\", \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" =>\n                    close.foreach(y => stack += y)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n                case \")(\"  =>\n                    open += x\n                case \")(\"  =>\n                    open += x\n                case \")(\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n                    open += x\n                case \")\" =>\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuw9jey_k.scala:128:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m128 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    stack = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling wit",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach {\n            s =>\n                s match {\n                    case \"(\" =>\n                        stack.push(s)\n                        queue.enqueue(s)\n                    case \")\" =>\n                        val top = stack.pop()\n                        val next = queue.poll()\n                        val goodParens = s\"${top}${next}\"\n                        val badParens = s\"${top}${next}\"\n                        good += goodParens\n                        bad += badParens\n                }\n        }\n        if (good.size == lst.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n            case x if x == \")()\" => close.push(x)\n            case x if x == \"(\" => open.push(x)\n            case x if x == \")(\" => open.push(x)\n            case x if x == \")()()\" => close.push(x)\n            case x if x == \")()(\" => close.push(x)\n            case x if x == \")()()()\" => close.push(x)\n            case x if x == \")()()()()\" => close.push(x)\n            case x if x == \")()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()()()()()()()()\" \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:63:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not fo",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n        val stackMax = lst.last\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n        val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw1cor0zm.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = lst.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = lst.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = lst.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackMaxIndex\u001b[0m = lst.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstackMaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstackMaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m ",
      "stdout": "",
      "timestamp": 1659979696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n            if (x == \"(\") {\n                stack += x\n            } else if (x == \")\") {\n                val last = stack.pop()\n                if (last == x) {\n                    good += x\n                } else {\n                    bad += x\n                }\n            }\n        })\n        if (good.size == lst.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9lky_sr7.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9lky_sr7.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\") => open.push(x)\n            case x if x.startsWith(\")\") => close.push(x)\n            case x => stack.push(x)\n        })\n        val openCount = open.size\n        val closeCount = close.size\n        val openStack = stack.take(openCount)\n        val closeStack = stack.drop(closeCount)\n        val openStackSize = openStack.size\n        val closeStackSize = closeStack.size\n        val openStackIsEmpty = openStack.isEmpty\n        val closeStackIsEmpty = closeStack.isEmpty\n        val openStackIsFull = openStackSize == openCount\n        val closeStackIsFull = closeStackSize == closeCount\n        val openStackIsEmptyOrFull = openStackIsEmpty || openStackIsFull\n        val closeStackIsEmptyOrFull = closeStackIsEmpty || closeStackIsFull\n        val openStackIsFullOrEmpty = openStackIsFull || openStackIsEmpty\n        val closeStackIsFullOrEmpty = closeStackIsFull || closeStackIsEmpty\n        val openStackIsEmptyOrFullOrEmpty = openStackIsEmptyOrFull || closeStackIsEmptyOrFull\n        val closeStackIsEmptyOrFullOrEmpty = closeStackIsEmptyOrFull || closeStackIsEmptyOrEmpty\n        val openStackIsFullOrEmptyOrEmpty = openStackIsFullOrEmpty || closeStackIsFullOrEmpty\n        val closeStackIsFullOrEmptyOrEmpty = closeStackIsFullOrEmpty || closeStackIsFullOrEmpty\n        val openStackIsEmptyOrFullOrEmptyOrEmpty = openStackIsEmptyOrFullOrEmpty || closeStackIsEmptyOrFullOrEmpty\n        val closeStackIsEmptyOrFullOrEmptyOrEmpty = closeStackIsEmptyOrFullOrEmpty || closeStackIsFullOrEmptyOrEmpty\n        val openStackIsFullOrEmptyOrEmptyOrEmpty = openStackIsFullOrEmptyOrEmpty || closeStackIsFullOrEmptyOrEmpty\n        val closeStackIsFullOrEmptyOrEmptyOrEmpty = closeStackIsFullOrEmptyOrEmpty || closeStackIsFullOrEmptyOrEmpty\n        val openStackIsEmptyOr\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqa9gi82s.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqa9gi82s.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "stdout": "",
      "timestamp": 1659979696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size) {\n            val str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n                result += \"No\"\n            } else {\n                result += \"Yes\"\n                stack += str\n                while(open > -1) {\n                    val openParen = str.indexOf(\"(\", open)\n                    val closeParen = str.indexOf(\")\", open)\n                    if(openParen < 0 || closeParen < 0) {\n                        result += \"No\"\n                        break\n                    }\n                    val newStr = str.substring(0, open) + str.substring(open+1, close) + str.substring(close+1)\n                    stack += newStr\n                    if(stack.size == 1) {\n                        result += \"Yes\"\n                        break\n                    }\n                    val newOpen = str.indexOf(\"(\", openParen)\n                    val newClose = str.indexOf(\")\", closeParen)\n                    if(newOpen < 0 || newClose < 0) {\n                        result += \"No\"\n                        break\n                    }\n                    val newStr2 = str.substring(0, newOpen) + str.substring(newOpen+1, newClose) + str.substring(newClose+1)\n                    stack += newStr2\n                    if(stack.size == 1) {\n                        result += \"Yes\"\n                        break\n                    }\n                    open = newOpen\n                    close = newClose\n                }\n            }\n        }\n        result match {\n            case List(\"Yes\") => \"Yes\"\n            case List(\"No\") => \"No\"\n            case _ => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:40:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:46:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:52:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer exp",
      "stdout": "",
      "timestamp": 1659979695
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        lst.foreach { s =>\n            val openCount = if (open.contains(s)) open.count(_ == s) else 0\n            val closeCount = if (close.contains(s)) close.count(_ == s) else 0\n            if (openCount == 0 && closeCount == 0) {\n                result += s\n            } else {\n                if (openCount > closeCount) {\n                    stack += s\n                } else {\n                    result += s\n                }\n            }\n        }\n        if (stack.size == 0) {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979695
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack4\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack5\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659794997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpislgb2c_.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpislgb2c_.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodCount\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpislgb2c_.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadCount\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpislgb2c_.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodCount\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgoodCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgoodCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpislgb2c_.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbadCount\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbadCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbadCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of ",
      "stdout": "",
      "timestamp": 1659979696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n            } else if (x == \")\") {\n                if (stack.isEmpty) {\n                    result.append(\"No\")\n                } else {\n                    val top = stack.pop()\n                    val newTop = top + x\n                    stack += newTop\n                    result.append(\"Yes\")\n                }\n            }\n        })\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr7lqwqmw.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr7lqwqmw.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979695
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => close.push(x)\n                case \")(\"  => open.push(x)\n                case \")(\"  => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n                case \")\" => stack.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpncw96zaf.scala:79:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpncw96zaf.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:22:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.ListB",
      "stdout": "",
      "timestamp": 1659979696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match {\n                case \")\" => {\n                    stack.pop() match {\n                        case \")\" => good+=(queue.toList.reverse)\n                        case \")()\" => bad+=(queue.toList.reverse)\n                        case _ => bad+=(queue.toList.reverse)\n                    }\n                    queue+=x\n                }\n                case \"(\" => {\n                    stack+=x\n                    queue+=x\n                }\n                case _ => queue+=x\n            }\n        })\n        val stackSize = stack.size\n        val queueSize = queue.size\n        if(stackSize == queueSize) {\n            good.toList.mkString(\"\") match {\n                case \"\" => \"No\"\n                case x => \"Yes\"\n            }\n        } else {\n            bad.toList.mkString(\"\") match {\n                case \"\" => \"No\"\n                case x => \"Yes\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbad\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979695
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n        lst.foreach(x => stack += x)\n        while(stack.size > 0) {\n            val curr = stack.pop()\n            val newStack = stack.filter(_ != curr)\n            val newStackSize = newStack.size\n            val newResult = result.filter(_ != curr)\n            if(newStackSize == stackSize && newStack.size == 1 && newResult.size == 1) {\n                result += newResult\n            }\n        }\n        if(result.size == 1) {\n            result match {\n                case Nil => \"Yes\"\n                case _ => \"No\"\n            }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppvr5ng7z.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppvr5ng7z.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979696
    }
  ]
}