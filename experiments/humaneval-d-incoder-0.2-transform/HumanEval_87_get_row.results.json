{
  "language": "d",
  "name": "HumanEval_87_get_row",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2vt8ztlh.d(27): Error: no identifier for declarator `i`\n/tmp/tmp2vt8ztlh.d(27): Error: found `-` when expecting `;`\n/tmp/tmp2vt8ztlh.d(27): Error: expression expected, not `>`\n/tmp/tmp2vt8ztlh.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp2vt8ztlh.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp2vt8ztlh.d(27): Error: found `if` when expecting `)`\n/tmp/tmp2vt8ztlh.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp2vt8ztlh.d(30): Error: declaration expected, not `)`\n/tmp/tmp2vt8ztlh.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp2vt8ztlh.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmp2vt8ztlh.d(34): Error: declaration expected, not `return`\n/tmp/tmp2vt8ztlh.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2vt8ztlh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp66l9zisu.d(27): Error: no identifier for declarator `i`\n/tmp/tmp66l9zisu.d(27): Error: found `-` when expecting `;`\n/tmp/tmp66l9zisu.d(27): Error: expression expected, not `>`\n/tmp/tmp66l9zisu.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp66l9zisu.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp66l9zisu.d(27): Error: found `if` when expecting `)`\n/tmp/tmp66l9zisu.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp66l9zisu.d(30): Error: declaration expected, not `)`\n/tmp/tmp66l9zisu.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp66l9zisu.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmp66l9zisu.d(34): Error: declaration expected, not `return`\n/tmp/tmp66l9zisu.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp66l9zisu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = j;\n                res[i + 1] = i;\n                return Tuple!(long, long)[](res);\n            }\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxdvo6xe7.d(36): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\n/tmp/tmpxdvo6xe7.d(40): Error: function expected before `()`, not `Tuple!(long, long)[]` of type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdvo6xe7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) {\n            result ~= Tuple!(i, j);\n        }\n    }), range(0, size(lst)));\n    \n    sort(result, (a, b) => a.first > b.first ? 1 : a.first < b.first ? -1 : 0);\n    sort(result, (a, b) => a.second > b.second ? 1 : a.second < b.second ? -1 : 0);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfz4v9dvi.d(27): Error: no identifier for declarator `i`\n/tmp/tmpfz4v9dvi.d(27): Error: found `-` when expecting `;`\n/tmp/tmpfz4v9dvi.d(27): Error: expression expected, not `>`\n/tmp/tmpfz4v9dvi.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpfz4v9dvi.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpfz4v9dvi.d(27): Error: found `if` when expecting `)`\n/tmp/tmpfz4v9dvi.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpfz4v9dvi.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfz4v9dvi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                if(lst[i][j] == x)\n                {\n                    result.add(Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n    result.sort(function(a, b){return a.first > b.first;});\n    result.sort(function(a, b){return a.second > b.second;});\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcaftw7tk.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpcaftw7tk.d(35): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmpcaftw7tk.d(41): Error: no property `sort` for type `Tuple!(long, long)[]`\n/tmp/tmpcaftw7tk.d(42): Error: no property `sort` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcaftw7tk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, descending);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyn0_fg9w.d(27): Error: no identifier for declarator `lst`\n/tmp/tmpyn0_fg9w.d(27): Error: found `)` when expecting `;`\n/tmp/tmpyn0_fg9w.d(29): Error: no identifier for declarator `row`\n/tmp/tmpyn0_fg9w.d(29): Error: found `)` when expecting `;`\n/tmp/tmpyn0_fg9w.d(37): Error: found `}` when expecting `)`\n/tmp/tmpyn0_fg9w.d(44): Error: found `unittest` when expecting `)`\n/tmp/tmpyn0_fg9w.d(55): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyn0_fg9w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) \n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    sort(res);\n    sort(res, (a, b) -> -cmp(a.i, b.i));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7hh9b0yd.d(26): Error: no identifier for declarator `i`\n/tmp/tmp7hh9b0yd.d(26): Error: found `-` when expecting `;`\n/tmp/tmp7hh9b0yd.d(26): Error: expression expected, not `>`\n/tmp/tmp7hh9b0yd.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmp7hh9b0yd.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmp7hh9b0yd.d(26): Error: found `if` when expecting `)`\n/tmp/tmp7hh9b0yd.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmp7hh9b0yd.d(29): Error: declaration expected, not `)`\n/tmp/tmp7hh9b0yd.d(30): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp7hh9b0yd.d(30): Error: no identifier for declarator `sort(res)`\n/tmp/tmp7hh9b0yd.d(31): Error: unexpected `(` in declarator\n/tmp/tmp7hh9b0yd.d(31): Error: basic type expected, not `(`\n/tmp/tmp7hh9b0yd.d(31): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp7hh9b0yd.d(31): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[](Tuple!(0, i), Tuple!(0, j));\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjk6p27y5.d(26): Error: no identifier for declarator `i`\n/tmp/tmpjk6p27y5.d(26): Error: found `:` when expecting `;`\n/tmp/tmpjk6p27y5.d(28): Error: no identifier for declarator `j`\n/tmp/tmpjk6p27y5.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjk6p27y5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcb7wiqki.d(27): Error: no identifier for declarator `row`\n/tmp/tmpcb7wiqki.d(27): Error: found `:` when expecting `;`\n/tmp/tmpcb7wiqki.d(29): Error: no identifier for declarator `col`\n/tmp/tmpcb7wiqki.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcb7wiqki.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwld1a1w6.d(27): Error: no identifier for declarator `row`\n/tmp/tmpwld1a1w6.d(27): Error: found `:` when expecting `;`\n/tmp/tmpwld1a1w6.d(29): Error: no identifier for declarator `col`\n/tmp/tmpwld1a1w6.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwld1a1w6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            Tuple!(long, long)[] temp = new Tuple!(long, long)[];\n            for(int j = 0; j < lst[i].length; j++){\n                if(lst[i][j] == x){\n                    temp.add(new Tuple!(j, i));\n                }\n            }\n            res = temp;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp35uddl51.d(28): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp35uddl51.d(31): Error: no property `add` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35uddl51.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6kioxtiw.d(26): Error: no identifier for declarator `row`\n/tmp/tmp6kioxtiw.d(26): Error: found `:` when expecting `;`\n/tmp/tmp6kioxtiw.d(26): Error: expression expected, not `:`\n/tmp/tmp6kioxtiw.d(26): Error: found `lst` when expecting `)`\n/tmp/tmp6kioxtiw.d(26): Error: found `)` instead of statement\n/tmp/tmp6kioxtiw.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6kioxtiw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpffakebx2.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpffakebx2.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmpffakebx2.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpffakebx2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnm1135bf.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpnm1135bf.d(32): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnm1135bf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                result.add(Tuple!(long, long)(0, col));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) \n    {\n        return a.1 < b.1;\n    });\n    \n    result.sort(function(a, b) \n    {\n        return a.2 < b.2;\n    });\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmpcl9mf3.d(27): Error: no identifier for declarator `row`\n/tmp/tmpmpcl9mf3.d(27): Error: found `:` when expecting `;`\n/tmp/tmpmpcl9mf3.d(29): Error: no identifier for declarator `col`\n/tmp/tmpmpcl9mf3.d(29): Error: found `:` when expecting `;`\n/tmp/tmpmpcl9mf3.d(40): Error: found `0.1` when expecting `;` following `return` statement\n/tmp/tmpmpcl9mf3.d(40): Error: found `<` instead of statement\n/tmp/tmpmpcl9mf3.d(45): Error: found `0.2` when expecting `;` following `return` statement\n/tmp/tmpmpcl9mf3.d(45): Error: found `<` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpcl9mf3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst, i: 0) {\n        foreach(col: row, j: 0) {\n            if(col == x) {\n                res = Tuple!(long, long)[i, j];\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq91oz_uo.d(26): Error: no identifier for declarator `row`\n/tmp/tmpq91oz_uo.d(26): Error: found `:` when expecting `;`\n/tmp/tmpq91oz_uo.d(26): Error: found `:` when expecting `)`\n/tmp/tmpq91oz_uo.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpq91oz_uo.d(27): Error: no identifier for declarator `col`\n/tmp/tmpq91oz_uo.d(27): Error: found `:` when expecting `;`\n/tmp/tmpq91oz_uo.d(27): Error: found `:` when expecting `)`\n/tmp/tmpq91oz_uo.d(27): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq91oz_uo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long, long)[] {Tuple!(i, k)};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[i][j])\n                        {\n                            tuple2.push(Tuple!(l, k));\n                        }\n                    });\n                    tuple.push(tuple2);\n                }\n            });\n            result.push(tuple);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long, long)[] {Tuple!(i, k)};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[i][j])\n                        {\n                            tuple2.push(Tuple!(l, k));\n                        }\n                    });\n                    tuple.push(tuple2);\n                }\n            });\n            result.push(tuple);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long, long)[] {Tuple!(i, k)};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[i][j])\n                        {\n                            tuple2.push(Tuple!(l, k));\n                        }\n                    });\n                    tuple.push(tuple2);\n                }\n            });\n            result.push(tuple);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {Tuple!(i + 1, j + 1)};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][j])\n                {\n                    Tuple!(long, long)[] tuple2 = new Tuple!(long, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprqgbswu8.d(27): Error: no identifier for declarator `i`\n/tmp/tmprqgbswu8.d(27): Error: found `-` when expecting `;`\n/tmp/tmprqgbswu8.d(27): Error: expression expected, not `>`\n/tmp/tmprqgbswu8.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmprqgbswu8.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmprqgbswu8.d(27): Error: found `if` when expecting `)`\n/tmp/tmprqgbswu8.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmprqgbswu8.d(30): Error: semicolon expected, not `{`\n/tmp/tmprqgbswu8.d(30): Error: found `}` when expecting `;` following statement\n/tmp/tmprqgbswu8.d(30): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmprqgbswu8.d(31): Error: no identifier for declarator `k`\n/tmp/tmprqgbswu8.d(31): Error: found `-` when expecting `;`\n/tmp/tmprqgbswu8.d(31): Error: expression expected, not `>`\n/tmp/tmprqgbswu8.d(31): Error: found `{` when expecting `)`\n/tmp/tmprqgbswu8.d(34): Error: semicolon expected, not `{`\n/tmp/tmprqgbswu8.d(34): Error: found `}` when",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long, long)[] coord = Tuple!(i, j);\n                \n                if(coord.x < 0)\n                    coord.x += lst[i].length;\n                if(coord.y < 0)\n                    coord.y += lst[0].length;\n                \n                res.push(coord);\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp83px2807.d(27): Error: no identifier for declarator `i`\n/tmp/tmp83px2807.d(27): Error: found `:` when expecting `;`\n/tmp/tmp83px2807.d(29): Error: no identifier for declarator `j`\n/tmp/tmp83px2807.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83px2807.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                foreach(k -> \n                {\n                    if(lst[i][j] == x)\n                    {\n                        res.add((i, j));\n                    }\n                });\n            }\n            else\n            {\n                foreach(k -> \n                {\n                    if(lst[i][j] == x)\n                    {\n                        res.add((i, j));\n                    }\n                });\n            }\n        }), range(0, lst.length));\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1t12i_ts.d(27): Error: no identifier for declarator `i`\n/tmp/tmp1t12i_ts.d(27): Error: found `-` when expecting `;`\n/tmp/tmp1t12i_ts.d(27): Error: expression expected, not `>`\n/tmp/tmp1t12i_ts.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp1t12i_ts.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmp1t12i_ts.d(27): Error: found `if` when expecting `)`\n/tmp/tmp1t12i_ts.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmp1t12i_ts.d(31): Error: no identifier for declarator `k`\n/tmp/tmp1t12i_ts.d(31): Error: found `-` when expecting `;`\n/tmp/tmp1t12i_ts.d(31): Error: expression expected, not `>`\n/tmp/tmp1t12i_ts.d(32): Error: found `{` when expecting `)`\n/tmp/tmp1t12i_ts.d(37): Error: declaration expected, not `)`\n/tmp/tmp1t12i_ts.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1t12i_ts.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)((row,col)));\n            }\n        }\n    }\n    sort(res,fun(x1,x2) -> x1.1 > x2.1);\n    sort(res,fun(x1,x2) -> x1.2 > x2.2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp731ennea.d(26): Error: no identifier for declarator `lst`\n/tmp/tmp731ennea.d(26): Error: found `)` when expecting `;`\n/tmp/tmp731ennea.d(28): Error: no identifier for declarator `row`\n/tmp/tmp731ennea.d(28): Error: found `)` when expecting `;`\n/tmp/tmp731ennea.d(35): Error: found `}` when expecting `)`\n/tmp/tmp731ennea.d(36): Error: expression expected, not `>`\n/tmp/tmp731ennea.d(36): Error: found `x1` when expecting `,`\n/tmp/tmp731ennea.d(36): Error: found `0.1` when expecting `,`\n/tmp/tmp731ennea.d(37): Error: expression expected, not `>`\n/tmp/tmp731ennea.d(37): Error: found `x1` when expecting `,`\n/tmp/tmp731ennea.d(37): Error: found `0.2` when expecting `,`\n/tmp/tmp731ennea.d(40): Error: found `unittest` when expecting `)`\n/tmp/tmp731ennea.d(51): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp731ennea.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                foreach(k -> \n                {\n                    if(k == 0)\n                    {\n                        if(lst[i][j] == x)\n                        {\n                            res.add(new Tuple!(i, j));\n                        }\n                    }\n                    else\n                    {\n                        if(lst[i][j] > lst[i-1][k])\n                        {\n                            res.add(new Tuple!(i, j));\n                        }\n                    }\n                });\n            }\n            else\n            {\n                foreach(k -> \n                {\n                    if(k == 0)\n                    {\n                        if(lst[i][j] > lst[i-1][k])\n                        {\n                            res.add(new Tuple!(i, j));\n                        }\n                    }\n                    else\n                    {\n                        if(lst[i][j] > lst[i-1][k])\n                        {\n                            res.add(new Tuple!(i, j));\n                        }\n                    }\n                });\n            }\n        }), range(0, lst.length - 1));\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first);\n    \n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw7ifmgd0.d(27): Error: no identifier for declarator `i`\n/tmp/tmpw7ifmgd0.d(27): Error: found `-` when expecting `;`\n/tmp/tmpw7ifmgd0.d(27): Error: expression expected, not `>`\n/tmp/tmpw7ifmgd0.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpw7ifmgd0.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmpw7ifmgd0.d(27): Error: found `if` when expecting `)`\n/tmp/tmpw7ifmgd0.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmpw7ifmgd0.d(31): Error: no identifier for declarator `k`\n/tmp/tmpw7ifmgd0.d(31): Error: found `-` when expecting `;`\n/tmp/tmpw7ifmgd0.d(31): Error: expression expected, not `>`\n/tmp/tmpw7ifmgd0.d(32): Error: found `{` when expecting `)`\n/tmp/tmpw7ifmgd0.d(47): Error: declaration expected, not `)`\n/tmp/tmpw7ifmgd0.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7ifmgd0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            result.push((i, j));\n        }\n    }), range(0, lst.length));\n    \n    result.sort(function(a, b) {\n        if(a[0] == b[0]) {\n            return a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n    });\n    \n    result.sort(function(a, b) {\n        if(a[1] == b[1]) {\n            return a[0] - b[0];\n        } else {\n            return a[1] - b[1];\n        }\n    });\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpd_2i3xms.d(27): Error: no identifier for declarator `i`\n/tmp/tmpd_2i3xms.d(27): Error: found `-` when expecting `;`\n/tmp/tmpd_2i3xms.d(27): Error: expression expected, not `>`\n/tmp/tmpd_2i3xms.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpd_2i3xms.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpd_2i3xms.d(27): Error: found `if` when expecting `)`\n/tmp/tmpd_2i3xms.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpd_2i3xms.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd_2i3xms.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i].length == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                if(lst[i][j] == x)\n                {\n                    ret.add(new Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n    sort(ret, (a, b) -> a.first > b.first ? 1 : a.first < b.first ? -1 : 0);\n    sort(ret, (a, b) -> a.second > b.second ? 1 : a.second < b.second ? -1 : 0);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg2ypinwe.d(41): Error: expression expected, not `>`\n/tmp/tmpg2ypinwe.d(41): Error: found `a` when expecting `,`\n/tmp/tmpg2ypinwe.d(42): Error: expression expected, not `>`\n/tmp/tmpg2ypinwe.d(42): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg2ypinwe.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] tmp = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = i / j;\n            long c = i % j;\n            long r = r * j + c;\n            long c = r - j;\n            if(r == x)\n                tmp.add(new Tuple!(r, j));\n        });\n        if(tmp.length > 0)\n            res.add(tmp);\n    }), lst);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp356izy6h.d(27): Error: no identifier for declarator `i`\n/tmp/tmp356izy6h.d(27): Error: found `-` when expecting `;`\n/tmp/tmp356izy6h.d(27): Error: expression expected, not `>`\n/tmp/tmp356izy6h.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp356izy6h.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp356izy6h.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmp356izy6h.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmp356izy6h.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmp356izy6h.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp356izy6h.d(28): Error: found `tmp` when expecting `;` following statement\n/tmp/tmp356izy6h.d(28): Error: found `=` instead of statement\n/tmp/tmp356izy6h.d(29): Error: no identifier for declarator `k`\n/tmp/tmp356izy6h.d(29): Error: found `-` when expecting `;`\n/tmp/tmp356izy6h.d(29): Error: expression expected, not `>`\n/tmp/tmp356izy6h.d(29): Error: found `{` when expecting `)`\n/tmp/tmp356i",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            ret.push((i, j));\n        }\n    }), std.range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            ret.push((i, j));\n        }\n    }), std.range(0, lst.length));\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm5lnksac.d(27): Error: no identifier for declarator `i`\n/tmp/tmpm5lnksac.d(27): Error: found `-` when expecting `;`\n/tmp/tmpm5lnksac.d(27): Error: expression expected, not `>`\n/tmp/tmpm5lnksac.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpm5lnksac.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpm5lnksac.d(27): Error: found `if` when expecting `)`\n/tmp/tmpm5lnksac.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmpm5lnksac.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm5lnksac.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n            if(col == x) \n            {\n                if(res == null) \n                {\n                    res = Tuple!(long, long)[](row,col);\n                }\n                else \n                {\n                    res = Tuple!(long, long)[](row,col);\n                    foreach(row2,lst) \n                    {\n                        foreach(col2,row2) \n                        {\n                            if(col2 == col) \n                            {\n                                res = Tuple!(long, long)[](row,col);\n                                break;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3pl4j3_o.d(26): Error: no identifier for declarator `lst`\n/tmp/tmp3pl4j3_o.d(26): Error: found `)` when expecting `;`\n/tmp/tmp3pl4j3_o.d(28): Error: no identifier for declarator `row`\n/tmp/tmp3pl4j3_o.d(28): Error: found `)` when expecting `;`\n/tmp/tmp3pl4j3_o.d(39): Error: no identifier for declarator `lst`\n/tmp/tmp3pl4j3_o.d(39): Error: found `)` when expecting `;`\n/tmp/tmp3pl4j3_o.d(41): Error: no identifier for declarator `row2`\n/tmp/tmp3pl4j3_o.d(41): Error: found `)` when expecting `;`\n/tmp/tmp3pl4j3_o.d(49): Error: found `}` when expecting `)`\n/tmp/tmp3pl4j3_o.d(50): Error: found `}` instead of statement\n/tmp/tmp3pl4j3_o.d(51): Error: found `break` when expecting `)`\n/tmp/tmp3pl4j3_o.d(51): Error: use `{ }` for an empty statement, not `;`\n/tmp/tmp3pl4j3_o.d(55): Error: found `return` when expecting `)`\n/tmp/tmp3pl4j3_o.d(57): Error: unterminated /* */ comment\n/tmp/tmp3pl4j3_o.d(69): Error: found `End of File` when expecting `)`\n/tmp/tmp3pl4j3_o.d(69): Error: found `End of File` instead of state",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row: lst, i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)(i + 1, j + 1));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxg768cuo.d(27): Error: no identifier for declarator `row`\n/tmp/tmpxg768cuo.d(27): Error: found `:` when expecting `;`\n/tmp/tmpxg768cuo.d(27): Error: found `:` when expecting `)`\n/tmp/tmpxg768cuo.d(27): Error: found `)` when expecting `;` following statement\n/tmp/tmpxg768cuo.d(29): Error: no identifier for declarator `col`\n/tmp/tmpxg768cuo.d(29): Error: found `:` when expecting `;`\n/tmp/tmpxg768cuo.d(29): Error: found `:` when expecting `)`\n/tmp/tmpxg768cuo.d(29): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxg768cuo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            for(int j = 0; j < lst[i].length; j++){\n                if(lst[i][j] == x){\n                    res.push(new Tuple!(i, j));\n                }\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpswyqvy4s.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpswyqvy4s.d(30): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpswyqvy4s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                result.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) {\n        if(a.0 < b.0)\n        {\n            return -1;\n        }\n        if(a.0 > b.0)\n        {\n            return 1;\n        }\n        return 0;\n    });\n    \n    foreach(i : 0..result.length-1)\n    {\n        result.sort(function(a, b) {\n            if(a.1 < b.1)\n            {\n                return -1;\n            }\n            if(a.1 > b.1)\n            {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmposcz52j3.d(27): Error: no identifier for declarator `i`\n/tmp/tmposcz52j3.d(27): Error: found `:` when expecting `;`\n/tmp/tmposcz52j3.d(29): Error: no identifier for declarator `j`\n/tmp/tmposcz52j3.d(29): Error: found `:` when expecting `;`\n/tmp/tmposcz52j3.d(39): Error: found `0.00000` when expecting `)`\n/tmp/tmposcz52j3.d(39): Error: found `<` instead of statement\n/tmp/tmposcz52j3.d(43): Error: found `if` when expecting `,`\n/tmp/tmposcz52j3.d(43): Error: found `0.00000` when expecting `)`\n/tmp/tmposcz52j3.d(43): Error: missing `{ ... }` for function literal\n/tmp/tmposcz52j3.d(43): Error: found `0.00000` when expecting `,`\n/tmp/tmposcz52j3.d(44): Error: found `{` when expecting `;` following statement\n/tmp/tmposcz52j3.d(47): Error: declaration expected, not `return`\n/tmp/tmposcz52j3.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmposcz52j3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i, j};\n            foreach(k -> {\n                if(lst[i][k] > lst[k][j]) {\n                    tuple = tuple + new Tuple!(long, long)[] {k, j};\n                }\n            });\n            res = res + tuple;\n        }\n    }), range(0, lst.length));\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps88r_ypw.d(27): Error: no identifier for declarator `i`\n/tmp/tmps88r_ypw.d(27): Error: found `-` when expecting `;`\n/tmp/tmps88r_ypw.d(27): Error: expression expected, not `>`\n/tmp/tmps88r_ypw.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmps88r_ypw.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmps88r_ypw.d(27): Error: found `if` when expecting `)`\n/tmp/tmps88r_ypw.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmps88r_ypw.d(29): Error: semicolon expected, not `{`\n/tmp/tmps88r_ypw.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmps88r_ypw.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmps88r_ypw.d(30): Error: no identifier for declarator `k`\n/tmp/tmps88r_ypw.d(30): Error: found `-` when expecting `;`\n/tmp/tmps88r_ypw.d(30): Error: expression expected, not `>`\n/tmp/tmps88r_ypw.d(30): Error: found `{` when expecting `)`\n/tmp/tmps88r_ypw.d(32): Error: found `{` when expecting `;` following statement\n/tmp/tmps88r_ypw.d(32): ",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res.push(Tuple!(long, long)((row,col)));\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpms9eiu24.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpms9eiu24.d(26): Error: found `)` when expecting `;`\n/tmp/tmpms9eiu24.d(28): Error: no identifier for declarator `row`\n/tmp/tmpms9eiu24.d(28): Error: found `)` when expecting `;`\n/tmp/tmpms9eiu24.d(35): Error: found `}` when expecting `)`\n/tmp/tmpms9eiu24.d(39): Error: found `unittest` when expecting `)`\n/tmp/tmpms9eiu24.d(50): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpms9eiu24.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n    sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n        if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp07_h1nfy.d(27): Error: no identifier for declarator `i`\n/tmp/tmp07_h1nfy.d(27): Error: found `-` when expecting `;`\n/tmp/tmp07_h1nfy.d(27): Error: expression expected, not `>`\n/tmp/tmp07_h1nfy.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp07_h1nfy.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp07_h1nfy.d(27): Error: found `if` when expecting `)`\n/tmp/tmp07_h1nfy.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp07_h1nfy.d(30): Error: declaration expected, not `)`\n/tmp/tmp07_h1nfy.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp07_h1nfy.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmp07_h1nfy.d(33): Error: unexpected `(` in declarator\n/tmp/tmp07_h1nfy.d(33): Error: basic type expected, not `(`\n/tmp/tmp07_h1nfy.d(33): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp07_h1nfy.d(33): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst) \n    {\n        foreach(column: row) \n        {\n            if(column == x) \n            {\n                result ~= Tuple!(row, column);\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) => a.1 < b.1);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp38iqy76q.d(27): Error: no identifier for declarator `row`\n/tmp/tmp38iqy76q.d(27): Error: found `:` when expecting `;`\n/tmp/tmp38iqy76q.d(29): Error: no identifier for declarator `column`\n/tmp/tmp38iqy76q.d(29): Error: found `:` when expecting `;`\n/tmp/tmp38iqy76q.d(39): Error: found `0.1` when expecting `,`\n/tmp/tmp38iqy76q.d(39): Error: expression expected, not `<`\n/tmp/tmp38iqy76q.d(39): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp38iqy76q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a[1] > b[1]);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi3ebont9.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpi3ebont9.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmpi3ebont9.d(37): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpi3ebont9.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi3ebont9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                ret.add(new Tuple!(i, j));\n            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4but4s78.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp4but4s78.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcqn30c08.d(27): Error: no identifier for declarator `lst`\n/tmp/tmpcqn30c08.d(27): Error: found `)` when expecting `;`\n/tmp/tmpcqn30c08.d(29): Error: no identifier for declarator `row`\n/tmp/tmpcqn30c08.d(29): Error: found `)` when expecting `;`\n/tmp/tmpcqn30c08.d(37): Error: found `}` when expecting `)`\n/tmp/tmpcqn30c08.d(41): Error: found `unittest` when expecting `)`\n/tmp/tmpcqn30c08.d(52): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcqn30c08.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi1irn8dp.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpi1irn8dp.d(33): Error: template instance `tmpi1irn8dp.get_row.Tuple!(i, j)` error instant",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row,lst) \n    {\n        foreach(column,row)\n        {\n            if(column == x)\n            {\n                result ~= Tuple!(row,column);\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, descending);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp774_vldo.d(27): Error: no identifier for declarator `lst`\n/tmp/tmp774_vldo.d(27): Error: found `)` when expecting `;`\n/tmp/tmp774_vldo.d(29): Error: no identifier for declarator `row`\n/tmp/tmp774_vldo.d(29): Error: found `)` when expecting `;`\n/tmp/tmp774_vldo.d(36): Error: found `}` when expecting `)`\n/tmp/tmp774_vldo.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmp774_vldo.d(54): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp774_vldo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, (x, y) => Comparer<long>.Default.Compare(x, y));\n    Array.Sort(row, col, (x, y) => Comparer<long>.Default.Compare(y, x));\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n        {\n            res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx62q4o9i.d(32): Error: found `>` when expecting `.` following long\n/tmp/tmpx62q4o9i.d(32): Error: found `.` when expecting identifier following `long`.\n/tmp/tmpx62q4o9i.d(32): Error: found `Default` when expecting `,`\n/tmp/tmpx62q4o9i.d(33): Error: found `>` when expecting `.` following long\n/tmp/tmpx62q4o9i.d(33): Error: found `.` when expecting identifier following `long`.\n/tmp/tmpx62q4o9i.d(33): Error: found `Default` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx62q4o9i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst) {\n        foreach(col: row) {\n            if(col == x) {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5z5lruu5.d(26): Error: no identifier for declarator `row`\n/tmp/tmp5z5lruu5.d(26): Error: found `:` when expecting `;`\n/tmp/tmp5z5lruu5.d(27): Error: no identifier for declarator `col`\n/tmp/tmp5z5lruu5.d(27): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5z5lruu5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                result ~= Tuple!(row, column);\n            }\n        }\n    }\n    \n    result.sort(by=byRow);\n    result.sort(by=byColumn);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqx63mvrd.d(27): Error: no identifier for declarator `row`\n/tmp/tmpqx63mvrd.d(27): Error: found `:` when expecting `;`\n/tmp/tmpqx63mvrd.d(29): Error: no identifier for declarator `column`\n/tmp/tmpqx63mvrd.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqx63mvrd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpini1k066.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpini1k066.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpini1k066.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n            foreach(m -> {\n                Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.x = i;\n                coord.y = j;\n                col.x = k;\n                col.y = m;\n                row.push(coord);\n            });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n            foreach(m -> {\n                Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.x = i;\n                coord.y = j;\n                col.x = k;\n                col.y = m;\n                row.push(coord);\n            });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n            foreach(m -> {\n                Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.x = i;\n                coord.y = j;\n                col.x = k;\n                col.y = m;\n                row.push(coord);\n            });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] col = new Tuple!(long, long)[];\n            foreach(m -> {\n                Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.x = i;\n                coord.y = j;\n                col.x = k;\n                col.y = m;\n                row.push(coord);\n            });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1ipbrh2y.d(27): Error: no identifier for declarator `i`\n/tmp/tmp1ipbrh2y.d(27): Error: found `-` when expecting `;`\n/tmp/tmp1ipbrh2y.d(27): Error: expression expected, not `>`\n/tmp/tmp1ipbrh2y.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp1ipbrh2y.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp1ipbrh2y.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmp1ipbrh2y.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmp1ipbrh2y.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmp1ipbrh2y.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp1ipbrh2y.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmp1ipbrh2y.d(28): Error: found `=` instead of statement\n/tmp/tmp1ipbrh2y.d(29): Error: no identifier for declarator `k`\n/tmp/tmp1ipbrh2y.d(29): Error: found `-` when expecting `;`\n/tmp/tmp1ipbrh2y.d(29): Error: expression expected, not `>`\n/tmp/tmp1ipbrh2y.d(29): Error: found `{` when expecting `)`\n/tmp/tmp1ipb",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp42k8taxe.d(27): Error: no identifier for declarator `i`\n/tmp/tmp42k8taxe.d(27): Error: found `-` when expecting `;`\n/tmp/tmp42k8taxe.d(27): Error: expression expected, not `>`\n/tmp/tmp42k8taxe.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp42k8taxe.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp42k8taxe.d(27): Error: found `if` when expecting `)`\n/tmp/tmp42k8taxe.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmp42k8taxe.d(30): Error: no identifier for declarator `k`\n/tmp/tmp42k8taxe.d(30): Error: found `-` when expecting `;`\n/tmp/tmp42k8taxe.d(30): Error: expression expected, not `>`\n/tmp/tmp42k8taxe.d(30): Error: found `{` when expecting `)`\n/tmp/tmp42k8taxe.d(34): Error: declaration expected, not `)`\n/tmp/tmp42k8taxe.d(35): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp42k8taxe.d(35): Error: no identifier for declarator `res.add(row)`\n/tmp/tmp42k8taxe.d(36): Error: unrecognized declaration\nFailed: ",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    sort(res);\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3l9mjs_v.d(26): Error: no identifier for declarator `i`\n/tmp/tmp3l9mjs_v.d(26): Error: found `-` when expecting `;`\n/tmp/tmp3l9mjs_v.d(26): Error: expression expected, not `>`\n/tmp/tmp3l9mjs_v.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmp3l9mjs_v.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmp3l9mjs_v.d(26): Error: found `if` when expecting `)`\n/tmp/tmp3l9mjs_v.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmp3l9mjs_v.d(29): Error: declaration expected, not `)`\n/tmp/tmp3l9mjs_v.d(30): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp3l9mjs_v.d(30): Error: no identifier for declarator `sort(res)`\n/tmp/tmp3l9mjs_v.d(31): Error: declaration expected, not `return`\n/tmp/tmp3l9mjs_v.d(32): Error: unrecognized declaration\n/tmp/tmp3l9mjs_v.d(33): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3l9mjs_v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6yws74zm.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp6yws74zm.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == (x)`: `long[]` and `long`\n/tmp/tmp6yws74zm.d(33): Error: no property `add` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6yws74zm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, col), Tuple!(1, row)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgseplvfr.d(26): Error: no identifier for declarator `row`\n/tmp/tmpgseplvfr.d(26): Error: found `:` when expecting `;`\n/tmp/tmpgseplvfr.d(26): Error: expression expected, not `:`\n/tmp/tmpgseplvfr.d(26): Error: found `lst` when expecting `)`\n/tmp/tmpgseplvfr.d(26): Error: found `)` instead of statement\n/tmp/tmpgseplvfr.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgseplvfr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n    sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n        if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp07_h1nfy.d(27): Error: no identifier for declarator `i`\n/tmp/tmp07_h1nfy.d(27): Error: found `-` when expecting `;`\n/tmp/tmp07_h1nfy.d(27): Error: expression expected, not `>`\n/tmp/tmp07_h1nfy.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp07_h1nfy.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp07_h1nfy.d(27): Error: found `if` when expecting `)`\n/tmp/tmp07_h1nfy.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp07_h1nfy.d(30): Error: declaration expected, not `)`\n/tmp/tmp07_h1nfy.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp07_h1nfy.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmp07_h1nfy.d(33): Error: unexpected `(` in declarator\n/tmp/tmp07_h1nfy.d(33): Error: basic type expected, not `(`\n/tmp/tmp07_h1nfy.d(33): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp07_h1nfy.d(33): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][k+1]) {\n                    Tuple!(long, long)[] coord2 = new Tuple!(long, long)[] {i, k};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[k+1][l]) {\n                            Tuple!(long, long)[] coord3 = new Tuple!(long, long)[] {k, l};\n                            foreach(m -> {\n                                if(lst[m][j] > lst[m+1][j]) {\n                                    coord = coord.concat(coord2);\n                                    coord2 = coord3;\n                                }\n                                else {\n                                    coord = coord.concat(coord3);\n                                    coord3 = coord2;\n                                }\n                            });\n                        }\n                        else {\n                            coord = coord.concat(coord2);\n                            coord2 = coord;\n                        }\n                    });\n                }\n                else {\n                    coord = coord.concat(coord2);\n                    coord2 = coord;\n                }\n            });\n            res = res.concat(coord);\n        }\n    }));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][k+1]) {\n                    Tuple!(long, long)[] coord2 = new Tuple!(long, long)[] {i, k};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[k+1][l]) {\n                            Tuple!(long, long)[] coord3 = new Tuple!(long, long)[] {k, l};\n                            foreach(m -> {\n                                if(lst[m][j] > lst[m+1][j]) {\n                                    coord = coord.concat(coord2);\n                                    coord2 = coord3;\n                                }\n                                else {\n                                    coord = coord.concat(coord3);\n                                    coord3 = coord2;\n                                }\n                            });\n                        }\n                        else {\n                            coord = coord.concat(coord2);\n                            coord2 = coord;\n                        }\n                    });\n                }\n                else {\n                    coord = coord.concat(coord2);\n                    coord2 = coord;\n                }\n            });\n            res = res.concat(coord);\n        }\n    }));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjyz73cad.d(27): Error: no identifier for declarator `i`\n/tmp/tmpjyz73cad.d(27): Error: found `-` when expecting `;`\n/tmp/tmpjyz73cad.d(27): Error: expression expected, not `>`\n/tmp/tmpjyz73cad.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpjyz73cad.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpjyz73cad.d(27): Error: found `if` when expecting `)`\n/tmp/tmpjyz73cad.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpjyz73cad.d(29): Error: semicolon expected, not `{`\n/tmp/tmpjyz73cad.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpjyz73cad.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpjyz73cad.d(30): Error: no identifier for declarator `k`\n/tmp/tmpjyz73cad.d(30): Error: found `-` when expecting `;`\n/tmp/tmpjyz73cad.d(30): Error: expression expected, not `>`\n/tmp/tmpjyz73cad.d(30): Error: found `{` when expecting `)`\n/tmp/tmpjyz73cad.d(32): Error: semicolon expected, not `{`\n/tmp/tmpjyz73cad.d(32): Error: found `}` when",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1, col)];\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptj88ivnq.d(27): Error: no identifier for declarator `row`\n/tmp/tmptj88ivnq.d(27): Error: found `:` when expecting `;`\n/tmp/tmptj88ivnq.d(27): Error: expression expected, not `:`\n/tmp/tmptj88ivnq.d(27): Error: found `lst` when expecting `)`\n/tmp/tmptj88ivnq.d(27): Error: found `)` instead of statement\n/tmp/tmptj88ivnq.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptj88ivnq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3z3zl2ht.d(27): Error: no identifier for declarator `i`\n/tmp/tmp3z3zl2ht.d(27): Error: found `-` when expecting `;`\n/tmp/tmp3z3zl2ht.d(27): Error: expression expected, not `>`\n/tmp/tmp3z3zl2ht.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp3z3zl2ht.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp3z3zl2ht.d(27): Error: found `if` when expecting `)`\n/tmp/tmp3z3zl2ht.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmp3z3zl2ht.d(30): Error: no identifier for declarator `k`\n/tmp/tmp3z3zl2ht.d(30): Error: found `-` when expecting `;`\n/tmp/tmp3z3zl2ht.d(30): Error: expression expected, not `>`\n/tmp/tmp3z3zl2ht.d(30): Error: found `{` when expecting `)`\n/tmp/tmp3z3zl2ht.d(34): Error: declaration expected, not `)`\n/tmp/tmp3z3zl2ht.d(35): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp3z3zl2ht.d(35): Error: no identifier for declarator `res.add(row)`\n/tmp/tmp3z3zl2ht.d(36): Error: unrecognized declaration\nFailed: ",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                if(lst[i][j] == x)\n                {\n                    ret.push_back(new Tuple!(i, j));\n                }\n            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw4jzql_7.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpw4jzql_7.d(34): Error: no property `push_back` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw4jzql_7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[];\n            t[0] = i;\n            t[1] = j;\n            res.add(t);\n        }\n    }), std.range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[];\n            t[0] = i;\n            t[1] = j;\n            res.add(t);\n        }\n    }), std.range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqb9zs04k.d(26): Error: no identifier for declarator `i`\n/tmp/tmpqb9zs04k.d(26): Error: found `-` when expecting `;`\n/tmp/tmpqb9zs04k.d(26): Error: expression expected, not `>`\n/tmp/tmpqb9zs04k.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmpqb9zs04k.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpqb9zs04k.d(26): Error: found `if` when expecting `)`\n/tmp/tmpqb9zs04k.d(27): Error: found `{` when expecting `;` following statement\n/tmp/tmpqb9zs04k.d(33): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqb9zs04k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst){\n        foreach(col,row){\n            if(col == x){\n                res = Tuple!(long, long)[Tuple!(long, long)[row, col]];\n            }\n        }\n    }\n    sort(res);\n    sort(res,1,-1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_rfnxkto.d(26): Error: no identifier for declarator `lst`\n/tmp/tmp_rfnxkto.d(26): Error: found `)` when expecting `;`\n/tmp/tmp_rfnxkto.d(27): Error: no identifier for declarator `row`\n/tmp/tmp_rfnxkto.d(27): Error: found `)` when expecting `;`\n/tmp/tmp_rfnxkto.d(32): Error: found `}` when expecting `)`\n/tmp/tmp_rfnxkto.d(37): Error: found `unittest` when expecting `)`\n/tmp/tmp_rfnxkto.d(48): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_rfnxkto.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n    sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n        if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n    sort(res, (a, b) -> {\n        if(a.c > b.c)\n            return 1;\n        if(a.c < b.c)\n            return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphsa4ris5.d(27): Error: no identifier for declarator `i`\n/tmp/tmphsa4ris5.d(27): Error: found `-` when expecting `;`\n/tmp/tmphsa4ris5.d(27): Error: expression expected, not `>`\n/tmp/tmphsa4ris5.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmphsa4ris5.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmphsa4ris5.d(27): Error: found `if` when expecting `)`\n/tmp/tmphsa4ris5.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmphsa4ris5.d(30): Error: declaration expected, not `)`\n/tmp/tmphsa4ris5.d(32): Error: unexpected `(` in declarator\n/tmp/tmphsa4ris5.d(32): Error: basic type expected, not `(`\n/tmp/tmphsa4ris5.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmphsa4ris5.d(32): Error: found `-` when expecting `)`\n/tmp/tmphsa4ris5.d(32): Error: no identifier for declarator `sort(res, _error_(a, b))`\n/tmp/tmphsa4ris5.d(32): Error: semicolon expected following function declaration\n/tmp/tmphsa4ris5.d(32): Error: de",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n            long c = i;\n            long d = k;\n            \n            if(r == x)\n                row.push((r, c));\n            \n            if(c == x)\n                row.push((r, d));\n            \n            if(r == x && c == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o == x && p == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o == x && p == x && q == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o == x && p == x && q == x && r == x)\n                row.push((r, d));\n            \n            if(r == x && c == x && d == x && k == x && l == x && m == x && n == x && o == x && p == x && q == x && r == x && s == x)\n                row.push((r, d));\n            \n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmwy04i1x.d(27): Error: no identifier for declarator `i`\n/tmp/tmpmwy04i1x.d(27): Error: found `-` when expecting `;`\n/tmp/tmpmwy04i1x.d(27): Error: expression expected, not `>`\n/tmp/tmpmwy04i1x.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpmwy04i1x.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpmwy04i1x.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpmwy04i1x.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpmwy04i1x.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpmwy04i1x.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpmwy04i1x.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpmwy04i1x.d(28): Error: found `=` instead of statement\n/tmp/tmpmwy04i1x.d(29): Error: no identifier for declarator `k`\n/tmp/tmpmwy04i1x.d(29): Error: found `-` when expecting `;`\n/tmp/tmpmwy04i1x.d(29): Error: expression expected, not `>`\n/tmp/tmpmwy04i1x.d(29): Error: found `{` when expecting `)`\n/tmp/tmpmwy0",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[]((i, j), Tuple!(long, long)((i, j)));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphkmof8ct.d(26): Error: no identifier for declarator `i`\n/tmp/tmphkmof8ct.d(26): Error: found `:` when expecting `;`\n/tmp/tmphkmof8ct.d(28): Error: no identifier for declarator `j`\n/tmp/tmphkmof8ct.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkmof8ct.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst) {\n        foreach(col,row) {\n            if(col == x) {\n                res = Tuple!(long, long)[](row,col);\n            }\n        }\n    }\n    \n    foreach(row,lst) {\n        foreach(col,row) {\n            if(col != x) {\n                res = Tuple!(long, long)[](row,col);\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeqft02_2.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpeqft02_2.d(26): Error: found `)` when expecting `;`\n/tmp/tmpeqft02_2.d(27): Error: no identifier for declarator `row`\n/tmp/tmpeqft02_2.d(27): Error: found `)` when expecting `;`\n/tmp/tmpeqft02_2.d(32): Error: found `}` when expecting `)`\n/tmp/tmpeqft02_2.d(34): Error: no identifier for declarator `lst`\n/tmp/tmpeqft02_2.d(34): Error: found `)` when expecting `;`\n/tmp/tmpeqft02_2.d(35): Error: no identifier for declarator `row`\n/tmp/tmpeqft02_2.d(35): Error: found `)` when expecting `;`\n/tmp/tmpeqft02_2.d(40): Error: found `}` when expecting `)`\n/tmp/tmpeqft02_2.d(44): Error: found `unittest` when expecting `)`\n/tmp/tmpeqft02_2.d(55): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpeqft02_2.d(55): Error: found `End of File` when expecting `)`\n/tmp/tmpeqft02_2.d(55): Error: found `End of File` instead of statement\n/tmp/tmpeqft02_2.d(55): Error: found `End of File` when expecting `}` following compound sta",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if (col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprq8r_68w.d(26): Error: no identifier for declarator `row`\n/tmp/tmprq8r_68w.d(26): Error: found `:` when expecting `;`\n/tmp/tmprq8r_68w.d(28): Error: no identifier for declarator `col`\n/tmp/tmprq8r_68w.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprq8r_68w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt.push((i, j));\n            res.push(tt);\n        }\n    }), std.range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt.push((i, j));\n            res.push(tt);\n        }\n    }), std.range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkuzbg_9f.d(27): Error: no identifier for declarator `i`\n/tmp/tmpkuzbg_9f.d(27): Error: found `-` when expecting `;`\n/tmp/tmpkuzbg_9f.d(27): Error: expression expected, not `>`\n/tmp/tmpkuzbg_9f.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpkuzbg_9f.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmpkuzbg_9f.d(27): Error: found `if` when expecting `)`\n/tmp/tmpkuzbg_9f.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmpkuzbg_9f.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkuzbg_9f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst) {\n        foreach(col,row) {\n            if(col == x) {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphs7_so15.d(26): Error: no identifier for declarator `lst`\n/tmp/tmphs7_so15.d(26): Error: found `)` when expecting `;`\n/tmp/tmphs7_so15.d(27): Error: no identifier for declarator `row`\n/tmp/tmphs7_so15.d(27): Error: found `)` when expecting `;`\n/tmp/tmphs7_so15.d(32): Error: found `}` when expecting `)`\n/tmp/tmphs7_so15.d(35): Error: found `unittest` when expecting `)`\n/tmp/tmphs7_so15.d(46): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphs7_so15.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(0, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(1, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(2, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(3, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(4, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(5, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(6, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(7, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(8, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(9, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(10, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(11, lst.len));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result = [(i, j)];\n        }\n    }), range(12, lst.len));\n    \n    foreach(i -> foreach(j \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6ypf5fdt.d(27): Error: no identifier for declarator `i`\n/tmp/tmp6ypf5fdt.d(27): Error: found `-` when expecting `;`\n/tmp/tmp6ypf5fdt.d(27): Error: expression expected, not `>`\n/tmp/tmp6ypf5fdt.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp6ypf5fdt.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp6ypf5fdt.d(27): Error: found `if` when expecting `)`\n/tmp/tmp6ypf5fdt.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmp6ypf5fdt.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ypf5fdt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res;\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpss9y6g91.d(33): Error: template instance `tmpss9y6g91.get_row.Tuple!(i, j)` error instantiating\n/tmp/tmpss9y6g91.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpss9y6g91.d(39): E",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int)\n    {\n        foreach(col: row, j: int)\n        {\n            if(col == x)\n            {\n                result.add(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort!(result, (a, b) => (a.1 < b.1) || (a.1 == b.1 && b.1 < a.1));\n    sort!(result, (a, b) => (a.2 < b.2) || (a.2 == b.2 && b.2 < a.2));\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpocfld019.d(27): Error: no identifier for declarator `row`\n/tmp/tmpocfld019.d(27): Error: found `:` when expecting `;`\n/tmp/tmpocfld019.d(27): Error: found `:` when expecting `)`\n/tmp/tmpocfld019.d(27): Error: no identifier for declarator `int`\n/tmp/tmpocfld019.d(27): Error: found `)` instead of statement\n/tmp/tmpocfld019.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpocfld019.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst) {\n        foreach(col: row) {\n            if(col == x) {\n                result = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(result != null) break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp4ifpiu6.d(26): Error: no identifier for declarator `row`\n/tmp/tmpp4ifpiu6.d(26): Error: found `:` when expecting `;`\n/tmp/tmpp4ifpiu6.d(27): Error: no identifier for declarator `col`\n/tmp/tmpp4ifpiu6.d(27): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp4ifpiu6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    sort(res);\n    sort(res, (a, b) -> {\n        if(a.first < b.first)\n            return -1;\n        if(a.first > b.first)\n            return 1;\n        if(a.second < b.second)\n            return -1;\n        if(a.second > b.second)\n            return 1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvtizmhjo.d(27): Error: no identifier for declarator `i`\n/tmp/tmpvtizmhjo.d(27): Error: found `-` when expecting `;`\n/tmp/tmpvtizmhjo.d(27): Error: expression expected, not `>`\n/tmp/tmpvtizmhjo.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpvtizmhjo.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpvtizmhjo.d(27): Error: found `if` when expecting `)`\n/tmp/tmpvtizmhjo.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmpvtizmhjo.d(30): Error: declaration expected, not `)`\n/tmp/tmpvtizmhjo.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpvtizmhjo.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmpvtizmhjo.d(33): Error: unexpected `(` in declarator\n/tmp/tmpvtizmhjo.d(33): Error: basic type expected, not `(`\n/tmp/tmpvtizmhjo.d(33): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpvtizmhjo.d(33): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(res != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpaqi6syq4.d(26): Error: no identifier for declarator `row`\n/tmp/tmpaqi6syq4.d(26): Error: found `:` when expecting `;`\n/tmp/tmpaqi6syq4.d(26): Error: expression expected, not `:`\n/tmp/tmpaqi6syq4.d(26): Error: found `lst` when expecting `)`\n/tmp/tmpaqi6syq4.d(26): Error: found `)` instead of statement\n/tmp/tmpaqi6syq4.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaqi6syq4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt.push((i, j));\n            res.push(tt);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt.push((i, j));\n            res.push(tt);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppxn1a9zg.d(27): Error: no identifier for declarator `i`\n/tmp/tmppxn1a9zg.d(27): Error: found `-` when expecting `;`\n/tmp/tmppxn1a9zg.d(27): Error: expression expected, not `>`\n/tmp/tmppxn1a9zg.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmppxn1a9zg.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmppxn1a9zg.d(27): Error: found `if` when expecting `)`\n/tmp/tmppxn1a9zg.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmppxn1a9zg.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppxn1a9zg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(1, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(2, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(3, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(4, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(5, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(6, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(7, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(8, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(9, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(10, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x) {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(11, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwdxpc5x8.d(27): Error: no identifier for declarator `i`\n/tmp/tmpwdxpc5x8.d(27): Error: found `-` when expecting `;`\n/tmp/tmpwdxpc5x8.d(27): Error: expression expected, not `>`\n/tmp/tmpwdxpc5x8.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpwdxpc5x8.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpwdxpc5x8.d(27): Error: found `if` when expecting `)`\n/tmp/tmpwdxpc5x8.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpwdxpc5x8.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwdxpc5x8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res[lst[i].length * i + j] = Tuple!(long, long)((int)i, (int)j);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphbpwd108.d(32): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmphbpwd108.d(32): Error: C style cast illegal, use `cast(int)j`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbpwd108.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i, j};\n            foreach(k -> foreach(l -> \n            {\n                if(lst[i][k] == x && lst[k][j] == x)\n                {\n                    tuple.push(Tuple!(long, long)[] {k, l});\n                }\n            }));\n            res.push(tuple);\n        }\n    }));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i, j};\n            foreach(k -> foreach(l -> \n            {\n                if(lst[i][k] == x && lst[k][j] == x)\n                {\n                    tuple.push(Tuple!(long, long)[] {l, k});\n                }\n            }));\n            res.push(tuple);\n        }\n    }));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[] {i, j};\n            foreach(k -> foreach(l -> \n            {\n                if(lst[i][k] == x && lst[k][j] == x)\n                {\n                    tuple.push(Tuple!(long, long)[] {j, l});\n                }\n            }));\n            res.push(tuple);\n        }\n    }));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5d6lombc.d(27): Error: no identifier for declarator `i`\n/tmp/tmp5d6lombc.d(27): Error: found `-` when expecting `;`\n/tmp/tmp5d6lombc.d(27): Error: expression expected, not `>`\n/tmp/tmp5d6lombc.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp5d6lombc.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp5d6lombc.d(27): Error: found `if` when expecting `)`\n/tmp/tmp5d6lombc.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp5d6lombc.d(30): Error: declaration expected, not `)`\n/tmp/tmp5d6lombc.d(32): Error: declaration expected, not `return`\n/tmp/tmp5d6lombc.d(33): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5d6lombc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, Comparer<int>.Create((x, y) => { return lst[x].CompareTo(lst[y]); }));\n    Array.Sort(col, row, Comparer<int>.Create((x, y) => { return lst[y].CompareTo(lst[x]); }));\n    List<Tuple<long, long>> res = new List<Tuple<long, long>>();\n    for(int i = 0; i < row.Length; i++)\n    {\n        res.Add(new Tuple<long, long>(row[i], col[i]));\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptgkwnelr.d(32): Error: found `>` when expecting `.` following int\n/tmp/tmptgkwnelr.d(32): Error: found `.` when expecting identifier following `int`.\n/tmp/tmptgkwnelr.d(32): Error: found `Create` when expecting `,`\n/tmp/tmptgkwnelr.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmptgkwnelr.d(33): Error: found `.` when expecting identifier following `int`.\n/tmp/tmptgkwnelr.d(33): Error: found `Create` when expecting `,`\n/tmp/tmptgkwnelr.d(34): Error: found `<` when expecting `;` following statement\n/tmp/tmptgkwnelr.d(34): Error: no identifier for declarator `long`\n/tmp/tmptgkwnelr.d(34): Error: found `,` instead of statement\n/tmp/tmptgkwnelr.d(37): Error: found `,` when expecting `.` following long\n/tmp/tmptgkwnelr.d(37): Error: found `long` when expecting identifier following `long`.\n/tmp/tmptgkwnelr.d(37): Error: found `>` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptgkwnelr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(res != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprz8mk5ce.d(26): Error: no identifier for declarator `row`\n/tmp/tmprz8mk5ce.d(26): Error: found `:` when expecting `;`\n/tmp/tmprz8mk5ce.d(28): Error: no identifier for declarator `col`\n/tmp/tmprz8mk5ce.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprz8mk5ce.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i, row) \n    {\n        foreach(j, col) \n        {\n            if(row[j] == x)\n            {\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    foreach(tuple, tuple2) \n    {\n        foreach(tuple3, tuple4) \n        {\n            if(tuple2.first == tuple4.first && tuple2.second == tuple4.second)\n            {\n                res[res.length] = tuple;\n            }\n        }\n    }\n    \n    foreach(tuple, tuple2) \n    {\n        foreach(tuple3, tuple4) \n        {\n            if(tuple2.first == tuple4.first && tuple2.second > tuple4.second)\n            {\n                res[res.length] = tuple;\n            }\n        }\n    }\n    \n    foreach(tuple, tuple2) \n    {\n        foreach(tuple3, tuple4) \n        {\n            if(tuple2.first == tuple4.first && tuple2.second < tuple4.second)\n            {\n                res[res.length] = tuple;\n            }\n        }\n    }\n    \n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptofbb5ud.d(26): Error: no identifier for declarator `row`\n/tmp/tmptofbb5ud.d(26): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(28): Error: no identifier for declarator `col`\n/tmp/tmptofbb5ud.d(28): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(35): Error: found `}` when expecting `)`\n/tmp/tmptofbb5ud.d(37): Error: no identifier for declarator `tuple2`\n/tmp/tmptofbb5ud.d(37): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(39): Error: no identifier for declarator `tuple4`\n/tmp/tmptofbb5ud.d(39): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(46): Error: found `}` when expecting `)`\n/tmp/tmptofbb5ud.d(48): Error: no identifier for declarator `tuple2`\n/tmp/tmptofbb5ud.d(48): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(50): Error: no identifier for declarator `tuple4`\n/tmp/tmptofbb5ud.d(50): Error: found `)` when expecting `;`\n/tmp/tmptofbb5ud.d(57): Error: found `}` when expecting `)`\n/tmp/tmptofbb5ud.d(59): Error: no identifier for declarator `tuple2`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)((row,col)));\n            }\n        }\n    }\n    sort(res);\n    sort(res,true);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_9ftbwt2.d(26): Error: no identifier for declarator `lst`\n/tmp/tmp_9ftbwt2.d(26): Error: found `)` when expecting `;`\n/tmp/tmp_9ftbwt2.d(28): Error: no identifier for declarator `row`\n/tmp/tmp_9ftbwt2.d(28): Error: found `)` when expecting `;`\n/tmp/tmp_9ftbwt2.d(35): Error: found `}` when expecting `)`\n/tmp/tmp_9ftbwt2.d(40): Error: found `unittest` when expecting `)`\n/tmp/tmp_9ftbwt2.d(51): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9ftbwt2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res, (a, b) => (a.first > b.first) ? 1 : -1);\n    sort(res, (a, b) => (a.second > b.second) ? 1 : -1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb3qls2g7.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpb3qls2g7.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmpb3qls2g7.d(37): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpb3qls2g7.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb3qls2g7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                result.push(Tuple!(long, long)((row), column));\n            }\n        }\n    }\n    sort(result);\n    sort(result, (a, b) => a.first > b.first);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoq2d5azk.d(26): Error: no identifier for declarator `row`\n/tmp/tmpoq2d5azk.d(26): Error: found `:` when expecting `;`\n/tmp/tmpoq2d5azk.d(28): Error: no identifier for declarator `column`\n/tmp/tmpoq2d5azk.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoq2d5azk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                if(result == null)\n                {\n                    result = Tuple!(long, long)[](row, column);\n                }\n                else\n                {\n                    result = Tuple!(long, long)[](row, column);\n                }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4z9vjisq.d(27): Error: no identifier for declarator `row`\n/tmp/tmp4z9vjisq.d(27): Error: found `:` when expecting `;`\n/tmp/tmp4z9vjisq.d(29): Error: no identifier for declarator `column`\n/tmp/tmp4z9vjisq.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4z9vjisq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            ret.add(new Tuple!(i, j));\n        }\n    }), 0);\n    \n    sort(ret, (x, y) -> {\n        if(x._1 == y._1)\n        {\n            return x._2 < y._2;\n        }\n        else\n        {\n            return x._1 < y._1;\n        }\n    });\n    \n    sort(ret, (x, y) -> {\n        if(x._1 == y._1)\n        {\n            return x._2 < y._2;\n        }\n        else\n        {\n            return x._1 < y._1;\n        }\n    });\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpit4erbz0.d(27): Error: no identifier for declarator `i`\n/tmp/tmpit4erbz0.d(27): Error: found `-` when expecting `;`\n/tmp/tmpit4erbz0.d(27): Error: expression expected, not `>`\n/tmp/tmpit4erbz0.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpit4erbz0.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpit4erbz0.d(27): Error: found `if` when expecting `)`\n/tmp/tmpit4erbz0.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmpit4erbz0.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpit4erbz0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.length];\n    int[] col = new int[lst[0].length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        row[i] = i;\n        for(int j = 0; j < lst[i].length; j++)\n            col[j] = j;\n    }\n    \n    Arrays.sort(row);\n    Arrays.sort(col);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(col[j] == x)\n                res[i] = Tuple!(row[i], j);\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_pk__0i1.d(35): Error: undefined identifier `Arrays`\n/tmp/tmp_pk__0i1.d(36): Error: undefined identifier `Arrays`\n/tmp/tmp_pk__0i1.d(45): Error: variable `row` cannot be read at compile time\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_pk__0i1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res = [(i, j)];\n    }), range(0, lst.length));\n    \n    sort(res, (i, j) => (lst[i][j].compareTo(x)));\n    sort(res, (i, j) => (lst[j][i].compareTo(x)));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdgfm3vhe.d(27): Error: no identifier for declarator `i`\n/tmp/tmpdgfm3vhe.d(27): Error: found `-` when expecting `;`\n/tmp/tmpdgfm3vhe.d(27): Error: expression expected, not `>`\n/tmp/tmpdgfm3vhe.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpdgfm3vhe.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpdgfm3vhe.d(27): Error: found `if` when expecting `)`\n/tmp/tmpdgfm3vhe.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmpdgfm3vhe.d(29): Error: found `=` instead of statement\n/tmp/tmpdgfm3vhe.d(30): Error: declaration expected, not `)`\n/tmp/tmpdgfm3vhe.d(32): Error: unexpected `(` in declarator\n/tmp/tmpdgfm3vhe.d(32): Error: basic type expected, not `(`\n/tmp/tmpdgfm3vhe.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpdgfm3vhe.d(32): Error: found `=>` when expecting `)`\n/tmp/tmpdgfm3vhe.d(32): Error: no identifier for declarator `sort(res, _error_(i, j))`\n/tmp/tmpdgfm3vhe.d(32): Error: semicolon expected f",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.add(new Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmph9qsr2xc.d(39): Error: expression expected, not `>`\n/tmp/tmph9qsr2xc.d(39): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph9qsr2xc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> \n            {\n                if(lst[i][k] == x)\n                {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> \n            {\n                if(lst[i][k] == x)\n                {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4nlyj29l.d(27): Error: no identifier for declarator `i`\n/tmp/tmp4nlyj29l.d(27): Error: found `-` when expecting `;`\n/tmp/tmp4nlyj29l.d(27): Error: expression expected, not `>`\n/tmp/tmp4nlyj29l.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp4nlyj29l.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmp4nlyj29l.d(27): Error: found `if` when expecting `)`\n/tmp/tmp4nlyj29l.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmp4nlyj29l.d(32): Error: no identifier for declarator `k`\n/tmp/tmp4nlyj29l.d(32): Error: found `-` when expecting `;`\n/tmp/tmp4nlyj29l.d(32): Error: expression expected, not `>`\n/tmp/tmp4nlyj29l.d(33): Error: found `{` when expecting `)`\n/tmp/tmp4nlyj29l.d(38): Error: declaration expected, not `)`\n/tmp/tmp4nlyj29l.d(39): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp4nlyj29l.d(39): Error: no identifier for declarator `res.add(row)`\n/tmp/tmp4nlyj29l.d(40): Error: unrecognized declaration\nFailed: ",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n        {\n            if(lst[i][j] > x)\n            {\n                res[i] = new Tuple!(i, j);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmp8d_bs_if.d(37): Error: template instance `tmp8d_bs_if.get_row.Tuple!(i, j)` error instantiating\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8d_bs_if.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    foreach(i -> foreach(j -> res = append(res, Tuple!(i, j), Tuple!(0, 0))), lst);\n    sort(res);\n    sort(res, (a, b) -> b._1 - a._1);\n    sort(res, (a, b) -> b._2 - a._2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeb47x7rx.d(26): Error: no identifier for declarator `i`\n/tmp/tmpeb47x7rx.d(26): Error: found `-` when expecting `;`\n/tmp/tmpeb47x7rx.d(26): Error: expression expected, not `>`\n/tmp/tmpeb47x7rx.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmpeb47x7rx.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpeb47x7rx.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpeb47x7rx.d(26): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpeb47x7rx.d(28): Error: expression expected, not `>`\n/tmp/tmpeb47x7rx.d(28): Error: found `b` when expecting `,`\n/tmp/tmpeb47x7rx.d(29): Error: expression expected, not `>`\n/tmp/tmpeb47x7rx.d(29): Error: found `b` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeb47x7rx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(res != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprz8mk5ce.d(26): Error: no identifier for declarator `row`\n/tmp/tmprz8mk5ce.d(26): Error: found `:` when expecting `;`\n/tmp/tmprz8mk5ce.d(28): Error: no identifier for declarator `col`\n/tmp/tmprz8mk5ce.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprz8mk5ce.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res = Tuple!(long, long)!(x, i);\n    }), 0..lst.length-1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9lgsm1np.d(26): Error: no identifier for declarator `i`\n/tmp/tmp9lgsm1np.d(26): Error: found `-` when expecting `;`\n/tmp/tmp9lgsm1np.d(26): Error: expression expected, not `>`\n/tmp/tmp9lgsm1np.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmp9lgsm1np.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmp9lgsm1np.d(26): Error: found `if` when expecting `)`\n/tmp/tmp9lgsm1np.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmp9lgsm1np.d(28): Error: found `=` instead of statement\n/tmp/tmp9lgsm1np.d(29): Error: declaration expected, not `)`\n/tmp/tmp9lgsm1np.d(30): Error: declaration expected, not `return`\n/tmp/tmp9lgsm1np.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9lgsm1np.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, true);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpycywc_el.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpycywc_el.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmpycywc_el.d(37): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpycywc_el.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpycywc_el.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = i;\n            long c = j;\n            long k = k;\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r > x && c > x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r < x && c < x)\n            {\n                row.push((k, k));\n            }\n            \n            if(r == x && c == x)\n            {\n                row.push((k, k));\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvc6ptduw.d(27): Error: no identifier for declarator `i`\n/tmp/tmpvc6ptduw.d(27): Error: found `-` when expecting `;`\n/tmp/tmpvc6ptduw.d(27): Error: expression expected, not `>`\n/tmp/tmpvc6ptduw.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpvc6ptduw.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpvc6ptduw.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpvc6ptduw.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpvc6ptduw.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpvc6ptduw.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpvc6ptduw.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpvc6ptduw.d(28): Error: found `=` instead of statement\n/tmp/tmpvc6ptduw.d(29): Error: no identifier for declarator `k`\n/tmp/tmpvc6ptduw.d(29): Error: found `-` when expecting `;`\n/tmp/tmpvc6ptduw.d(29): Error: expression expected, not `>`\n/tmp/tmpvc6ptduw.d(29): Error: found `{` when expecting `)`\n/tmp/tmpvc6p",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) {\n        foreach(col::row) {\n            if(col == x) {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp16825on3.d(26): Error: no identifier for declarator `row`\n/tmp/tmp16825on3.d(26): Error: found `:` when expecting `;`\n/tmp/tmp16825on3.d(26): Error: expression expected, not `:`\n/tmp/tmp16825on3.d(26): Error: found `lst` when expecting `)`\n/tmp/tmp16825on3.d(26): Error: found `)` instead of statement\n/tmp/tmp16825on3.d(31): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp16825on3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (lst[i][j] == x) {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n    }\n    \n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2a5gkoj0.d(33): Error: no `[]` operator overload for type `Tuple!(long, long)`\n/tmp/tmp2a5gkoj0.d(39): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp2a5gkoj0.d(40): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2a5gkoj0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8maeszhw.d(27): Error: no identifier for declarator `row`\n/tmp/tmp8maeszhw.d(27): Error: found `:` when expecting `;`\n/tmp/tmp8maeszhw.d(29): Error: no identifier for declarator `col`\n/tmp/tmp8maeszhw.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8maeszhw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n    sort(res);\n    sort(res, (a, b) -> Tuple!(b._1, a._2));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8hmlhrz6.d(27): Error: no identifier for declarator `i`\n/tmp/tmp8hmlhrz6.d(27): Error: found `-` when expecting `;`\n/tmp/tmp8hmlhrz6.d(27): Error: expression expected, not `>`\n/tmp/tmp8hmlhrz6.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp8hmlhrz6.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp8hmlhrz6.d(27): Error: found `if` when expecting `)`\n/tmp/tmp8hmlhrz6.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp8hmlhrz6.d(30): Error: declaration expected, not `)`\n/tmp/tmp8hmlhrz6.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp8hmlhrz6.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmp8hmlhrz6.d(33): Error: unexpected `(` in declarator\n/tmp/tmp8hmlhrz6.d(33): Error: basic type expected, not `(`\n/tmp/tmp8hmlhrz6.d(33): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp8hmlhrz6.d(33): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                result.push(Tuple!(long, long)((row,col)));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, 1, result.length - 1);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm27pzr3m.d(27): Error: no identifier for declarator `lst`\n/tmp/tmpm27pzr3m.d(27): Error: found `)` when expecting `;`\n/tmp/tmpm27pzr3m.d(29): Error: no identifier for declarator `row`\n/tmp/tmpm27pzr3m.d(29): Error: found `)` when expecting `;`\n/tmp/tmpm27pzr3m.d(36): Error: found `}` when expecting `)`\n/tmp/tmpm27pzr3m.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpm27pzr3m.d(54): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm27pzr3m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_t7ajbal.d(26): Error: no identifier for declarator `row`\n/tmp/tmp_t7ajbal.d(26): Error: found `:` when expecting `;`\n/tmp/tmp_t7ajbal.d(26): Error: expression expected, not `:`\n/tmp/tmp_t7ajbal.d(26): Error: found `lst` when expecting `)`\n/tmp/tmp_t7ajbal.d(26): Error: found `)` instead of statement\n/tmp/tmp_t7ajbal.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_t7ajbal.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                result.push(Tuple!(long, long)((row), column));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsw4dmsxk.d(27): Error: no identifier for declarator `row`\n/tmp/tmpsw4dmsxk.d(27): Error: found `:` when expecting `;`\n/tmp/tmpsw4dmsxk.d(29): Error: no identifier for declarator `column`\n/tmp/tmpsw4dmsxk.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsw4dmsxk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                ret.add(new Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(ret, (a, b) -> a.first > b.first ? 1 : -1);\n    sort(ret, (a, b) -> a.second > b.second ? 1 : -1);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3tipvqwb.d(38): Error: expression expected, not `>`\n/tmp/tmp3tipvqwb.d(38): Error: found `a` when expecting `,`\n/tmp/tmp3tipvqwb.d(39): Error: expression expected, not `>`\n/tmp/tmp3tipvqwb.d(39): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3tipvqwb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] temp = new Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[] temp2 = new Tuple!(long, long)[];\n            foreach(l -> {\n                Tuple!(long, long)[] temp3 = new Tuple!(long, long)[];\n                foreach(m -> {\n                    Tuple!(long, long)[] temp4 = new Tuple!(long, long)[];\n                    foreach(n -> {\n                        Tuple!(long, long)[] temp5 = new Tuple!(long, long)[];\n                        foreach(o -> {\n                            Tuple!(long, long)[] temp6 = new Tuple!(long, long)[];\n                            foreach(p -> {\n                                Tuple!(long, long)[] temp7 = new Tuple!(long, long)[];\n                                foreach(q -> {\n                                    Tuple!(long, long)[] temp8 = new Tuple!(long, long)[];\n                                    foreach(r -> {\n                                        Tuple!(long, long)[] temp9 = new Tuple!(long, long)[];\n                                        foreach(s -> {\n                                            Tuple!(long, long)[] temp10 = new Tuple!(long, long)[];\n                                            foreach(t -> {\n                                                Tuple!(long, long)[] temp11 = new Tuple!(long, long)[];\n                                                foreach(u -> {\n                                                    Tuple!(long, long)[] temp12 = new Tuple!(long, long)[];\n                                                    foreach(v -> {\n                                                        Tuple!(long, long)[] temp13 = new Tuple!(long, long)[];\n                                                        foreach(w -> {\n                                                            Tuple!(long, long)[] temp14 = new Tuple!(long, long)[];\n                                                            foreach(x -> {\n                                                                Tuple!(long, long)[] temp15 = new Tuple!(long, long)[];\n                                                                foreach(y -> {\n                                                                    Tuple!(long, long)[] temp16 = new Tuple!(long, long)[];\n                                                                    foreach(z -> {\n                                                                        Tuple!(long, long)[] temp17 = new Tuple!(long, long)[];\n                                                                        foreach(a -> {\n                                                                            Tuple!(long, long)[] temp18 = new Tuple!(long, long)[];\n                                                                            foreach(b -> {\n                                                                                Tuple!(long, long)[] temp19 = new Tuple!(long, long)[];\n                                                                                foreach(c -> {\n                                                                                    Tuple!(long, long)[] temp20 = new Tuple!(long, long)[];\n                                                                                    foreach(d -> {\n                                                                                        Tuple!(long, long)[] temp21 = new Tuple!(long, long)[];\n                                                                                        foreach(e -> {\n                                                                                            Tuple!(long, long)[] temp22 = new Tuple!(long, \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn4ezy5x_.d(27): Error: no identifier for declarator `i`\n/tmp/tmpn4ezy5x_.d(27): Error: found `-` when expecting `;`\n/tmp/tmpn4ezy5x_.d(27): Error: expression expected, not `>`\n/tmp/tmpn4ezy5x_.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpn4ezy5x_.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpn4ezy5x_.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpn4ezy5x_.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpn4ezy5x_.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpn4ezy5x_.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpn4ezy5x_.d(28): Error: found `temp` when expecting `;` following statement\n/tmp/tmpn4ezy5x_.d(28): Error: found `=` instead of statement\n/tmp/tmpn4ezy5x_.d(29): Error: no identifier for declarator `k`\n/tmp/tmpn4ezy5x_.d(29): Error: found `-` when expecting `;`\n/tmp/tmpn4ezy5x_.d(29): Error: expression expected, not `>`\n/tmp/tmpn4ezy5x_.d(29): Error: found `{` when expecting `)`\n/tmp/tmpn4e",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                res.push(Tuple!(long, long)((row), col));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbd8oo4un.d(26): Error: no identifier for declarator `row`\n/tmp/tmpbd8oo4un.d(26): Error: found `:` when expecting `;`\n/tmp/tmpbd8oo4un.d(28): Error: no identifier for declarator `col`\n/tmp/tmpbd8oo4un.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbd8oo4un.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt[0] = i;\n            tt[1] = j;\n            res.add(tt);\n        }\n    }), range(0, lst.Length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt[0] = i;\n            tt[1] = j;\n            res.add(tt);\n        }\n    }), range(1, lst.Length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] < x)\n        {\n            Tuple!(long, long)[] tt = new Tuple!(long, long)[];\n            tt[0] = i;\n            tt[1] = j;\n            res.add(tt);\n        }\n    }), range(0, lst.Length - 1));\n    \n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp960j2a9n.d(27): Error: no identifier for declarator `i`\n/tmp/tmp960j2a9n.d(27): Error: found `-` when expecting `;`\n/tmp/tmp960j2a9n.d(27): Error: expression expected, not `>`\n/tmp/tmp960j2a9n.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp960j2a9n.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmp960j2a9n.d(27): Error: found `if` when expecting `)`\n/tmp/tmp960j2a9n.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmp960j2a9n.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp960j2a9n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) -> a.first > b.first ? 1 : -1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa1ciz7f4.d(37): Error: expression expected, not `>`\n/tmp/tmpa1ciz7f4.d(37): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa1ciz7f4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                result.add(Tuple!(long, long)((row, column)));\n            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n    \n    foreach(row: result)\n    {\n        foreach(column: row)\n        {\n            foreach(coord: column)\n            {\n                coord.swap();\n            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6ydp5fmn.d(27): Error: no identifier for declarator `row`\n/tmp/tmp6ydp5fmn.d(27): Error: found `:` when expecting `;`\n/tmp/tmp6ydp5fmn.d(29): Error: no identifier for declarator `column`\n/tmp/tmp6ydp5fmn.d(29): Error: found `:` when expecting `;`\n/tmp/tmp6ydp5fmn.d(40): Error: no identifier for declarator `row`\n/tmp/tmp6ydp5fmn.d(40): Error: found `:` when expecting `;`\n/tmp/tmp6ydp5fmn.d(42): Error: no identifier for declarator `column`\n/tmp/tmp6ydp5fmn.d(42): Error: found `:` when expecting `;`\n/tmp/tmp6ydp5fmn.d(44): Error: no identifier for declarator `coord`\n/tmp/tmp6ydp5fmn.d(44): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ydp5fmn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj9cx2d03.d(26): Error: no identifier for declarator `row`\n/tmp/tmpj9cx2d03.d(26): Error: found `:` when expecting `;`\n/tmp/tmpj9cx2d03.d(26): Error: expression expected, not `:`\n/tmp/tmpj9cx2d03.d(26): Error: found `lst` when expecting `)`\n/tmp/tmpj9cx2d03.d(26): Error: found `)` instead of statement\n/tmp/tmpj9cx2d03.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9cx2d03.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplxegsr33.d(27): Error: no identifier for declarator `i`\n/tmp/tmplxegsr33.d(27): Error: found `-` when expecting `;`\n/tmp/tmplxegsr33.d(27): Error: expression expected, not `>`\n/tmp/tmplxegsr33.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmplxegsr33.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmplxegsr33.d(27): Error: found `if` when expecting `)`\n/tmp/tmplxegsr33.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmplxegsr33.d(30): Error: declaration expected, not `)`\n/tmp/tmplxegsr33.d(32): Error: declaration expected, not `return`\n/tmp/tmplxegsr33.d(33): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplxegsr33.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                result.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    result.sort(compareByDescending);\n    result.sort(compareByDescending);\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3g0a1qxy.d(26): Error: no identifier for declarator `row`\n/tmp/tmp3g0a1qxy.d(26): Error: found `:` when expecting `;`\n/tmp/tmp3g0a1qxy.d(28): Error: no identifier for declarator `col`\n/tmp/tmp3g0a1qxy.d(28): Error: found `:` when expecting `;`\n/tmp/tmp3g0a1qxy.d(40): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3g0a1qxy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps7w4ovn3.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmps7w4ovn3.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmps7w4ovn3.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmps7w4ovn3.d(39): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmps7w4ovn3.d(40): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps7w4ovn3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                foreach(coord: Tuple!(long, long)[])\n                {\n                    if(coord.0 == row)\n                    {\n                        result.push(coord);\n                    }\n                }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.0 > result.length)\n        {\n            result.push(coord);\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.1 < result.length)\n        {\n            int row = coord.0;\n            int column = coord.1;\n            \n            foreach(row: lst)\n            {\n                foreach(column: row)\n                {\n                    if(column == row)\n                    {\n                        result.push(coord);\n                    }\n                }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.1 < result.length)\n        {\n            int row = coord.0;\n            int column = coord.1;\n            \n            foreach(row: lst)\n            {\n                foreach(column: row)\n                {\n                    if(column == row)\n                    {\n                        result.push(coord);\n                    }\n                }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.1 < result.length)\n        {\n            int row = coord.0;\n            int column = coord.1;\n            \n            foreach(row: lst)\n            {\n                foreach(column: row)\n                {\n                    if(column == row)\n                    {\n                        result.push(coord);\n                    }\n                }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.1 < result.length)\n        {\n            int row = coord.0;\n            int column = coord.1;\n            \n            foreach(row: lst)\n            {\n                foreach(column: row)\n                {\n                    if(column == row)\n                    {\n                        result.push(coord);\n                    }\n                }\n            }\n        }\n    }\n    \n    foreach(coord: Tuple!(long, long)[])\n    {\n        if(coord.1 < result.length)\n        {\n            int row = coord.0;\n            int column = coord.1;\n            \n            foreach(row: lst)\n            {\n                foreach(column: row)\n                {\n                    if(column == row)\n                    {\n                        result.push(\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3mngr2sk.d(27): Error: no identifier for declarator `row`\n/tmp/tmp3mngr2sk.d(27): Error: found `:` when expecting `;`\n/tmp/tmp3mngr2sk.d(29): Error: no identifier for declarator `column`\n/tmp/tmp3mngr2sk.d(29): Error: found `:` when expecting `;`\n/tmp/tmp3mngr2sk.d(33): Error: no identifier for declarator `coord`\n/tmp/tmp3mngr2sk.d(33): Error: found `:` when expecting `;`\n/tmp/tmp3mngr2sk.d(35): Error: found `0.00000` when expecting `)`\n/tmp/tmp3mngr2sk.d(35): Error: found `==` instead of statement\n/tmp/tmp3mngr2sk.d(44): Error: declaration expected, not `foreach`\n/tmp/tmp3mngr2sk.d(49): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3mngr2sk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), lst);\n        result.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), result);\n        result.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), result);\n        result.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), result);\n        result.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), result);\n        result.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row;\n        foreach(k -> {\n            if(i == k) {\n                row = new Tuple!(long, long)[];\n                foreach(l -> {\n                    if(j == l) {\n                        row.push((i, j));\n                    }\n                });\n            }\n        }), result);\n        result.push(row);\n    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptzfwqwow.d(27): Error: no identifier for declarator `i`\n/tmp/tmptzfwqwow.d(27): Error: found `-` when expecting `;`\n/tmp/tmptzfwqwow.d(27): Error: expression expected, not `>`\n/tmp/tmptzfwqwow.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmptzfwqwow.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmptzfwqwow.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmptzfwqwow.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmptzfwqwow.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmptzfwqwow.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmptzfwqwow.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmptzfwqwow.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmptzfwqwow.d(29): Error: no identifier for declarator `k`\n/tmp/tmptzfwqwow.d(29): Error: found `-` when expecting `;`\n/tmp/tmptzfwqwow.d(29): Error: expression expected, not `>`\n/tmp/tmptzfwqwow.d(29): Error: found `{` when expecting",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz454cqvg.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpz454cqvg.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz454cqvg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j -> res = append(res, Tuple!(long, long)((i, j), lst[i][j]))), 0 .. lst.length - 1)\n    \n    sort(res, (i, j) -> j > i);\n    sort(res, (i, j) -> j > i);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjf36iugn.d(27): Error: no identifier for declarator `i`\n/tmp/tmpjf36iugn.d(27): Error: found `-` when expecting `;`\n/tmp/tmpjf36iugn.d(27): Error: expression expected, not `>`\n/tmp/tmpjf36iugn.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpjf36iugn.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpjf36iugn.d(27): Error: found `..` when expecting `;` following statement\n/tmp/tmpjf36iugn.d(27): Error: found `)` when expecting `;` following statement\n/tmp/tmpjf36iugn.d(29): Error: expression expected, not `>`\n/tmp/tmpjf36iugn.d(29): Error: found `j` when expecting `,`\n/tmp/tmpjf36iugn.d(29): Error: expression expected, not `>`\n/tmp/tmpjf36iugn.d(29): Error: found `i` when expecting `,`\n/tmp/tmpjf36iugn.d(30): Error: expression expected, not `>`\n/tmp/tmpjf36iugn.d(30): Error: found `j` when expecting `,`\n/tmp/tmpjf36iugn.d(30): Error: expression expected, not `>`\n/tmp/tmpjf36iugn.d(30): Error: found `i` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjf36iugn.d\", \"-",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5iyn0khw.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp5iyn0khw.d(29): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmp5iyn0khw.d(33): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5iyn0khw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long, long)[] row = get_row(lst[i], x);\n                Tuple!(long, long)[] col = get_row(lst[j], x);\n                \n                res = Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmfkkvq5f.d(37): Error: expression expected, not `unittest`\n/tmp/tmpmfkkvq5f.d(38): Error: found `{` when expecting `)` following template argument list\n/tmp/tmpmfkkvq5f.d(39): Error: found `alias` when expecting `,`\n/tmp/tmpmfkkvq5f.d(39): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(41): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(42): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(43): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(44): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(45): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(46): Error: found `;` when expecting `,`\n/tmp/tmpmfkkvq5f.d(47): Error: expression expected, not `}`\n/tmp/tmpmfkkvq5f.d(48): Error: found `void` when expecting `,`\n/tmp/tmpmfkkvq5f.d(48): Error: found `{` when expecting `,`\n/tmp/tmpmfkkvq5f.d(48): Error: expression expected, not `}`\n/tmp/tmpmfkkvq5f.d(48): Error: found `End of File` when expecting `,`\n/tmp/tmpmfkkvq5f.d(48): Error: found `End of File` when expecting `",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n    sort(res, (i, j) -> {\n        if(i < j)\n            return 1;\n        else if(i > j)\n            return -1;\n        else\n            return 0;\n    });\n    \n    sort(res, (i, j) -> {\n        if(i < j)\n            return -1;\n        else if(i > j)\n            return 1;\n        else\n            return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu9cjvyyr.d(27): Error: no identifier for declarator `i`\n/tmp/tmpu9cjvyyr.d(27): Error: found `-` when expecting `;`\n/tmp/tmpu9cjvyyr.d(27): Error: expression expected, not `>`\n/tmp/tmpu9cjvyyr.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpu9cjvyyr.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpu9cjvyyr.d(27): Error: found `if` when expecting `)`\n/tmp/tmpu9cjvyyr.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmpu9cjvyyr.d(30): Error: declaration expected, not `)`\n/tmp/tmpu9cjvyyr.d(32): Error: unexpected `(` in declarator\n/tmp/tmpu9cjvyyr.d(32): Error: basic type expected, not `(`\n/tmp/tmpu9cjvyyr.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpu9cjvyyr.d(32): Error: found `-` when expecting `)`\n/tmp/tmpu9cjvyyr.d(32): Error: no identifier for declarator `sort(res, _error_(i, j))`\n/tmp/tmpu9cjvyyr.d(32): Error: semicolon expected following function declaration\n/tmp/tmpu9cjvyyr.d(32): Error: de",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                res.push(Tuple!(long, long)(x-1, row));\n            }\n        }\n    }\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col != x)\n            {\n                res.push(Tuple!(long, long)(x, col-1));\n            }\n        }\n    }\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc04tmlx9.d(27): Error: no identifier for declarator `row`\n/tmp/tmpc04tmlx9.d(27): Error: found `:` when expecting `;`\n/tmp/tmpc04tmlx9.d(29): Error: no identifier for declarator `col`\n/tmp/tmpc04tmlx9.d(29): Error: found `:` when expecting `;`\n/tmp/tmpc04tmlx9.d(38): Error: no identifier for declarator `row`\n/tmp/tmpc04tmlx9.d(38): Error: found `:` when expecting `;`\n/tmp/tmpc04tmlx9.d(40): Error: no identifier for declarator `col`\n/tmp/tmpc04tmlx9.d(40): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc04tmlx9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                result = Tuple!(long, long)[Tuple!(long, long)[row, col]];\n                break;\n            }\n        }\n        if(result != null) break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3f1pclov.d(26): Error: no identifier for declarator `row`\n/tmp/tmp3f1pclov.d(26): Error: found `:` when expecting `;`\n/tmp/tmp3f1pclov.d(28): Error: no identifier for declarator `col`\n/tmp/tmp3f1pclov.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3f1pclov.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(column == x) \n            {\n                result ~= Tuple!(row, column);\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, descending);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdagodsb1.d(27): Error: no identifier for declarator `row`\n/tmp/tmpdagodsb1.d(27): Error: found `)` when expecting `;`\n/tmp/tmpdagodsb1.d(29): Error: no identifier for declarator `column`\n/tmp/tmpdagodsb1.d(29): Error: found `)` when expecting `;`\n/tmp/tmpdagodsb1.d(36): Error: found `}` when expecting `)`\n/tmp/tmpdagodsb1.d(43): Error: found `unittest` when expecting `)`\n/tmp/tmpdagodsb1.d(54): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdagodsb1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[]; \n            t[0] = i; \n            t[1] = j; \n            res.add(t);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[]; \n            t[0] = i; \n            t[1] = j; \n            res.add(t);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpidy3s5ku.d(27): Error: no identifier for declarator `i`\n/tmp/tmpidy3s5ku.d(27): Error: found `-` when expecting `;`\n/tmp/tmpidy3s5ku.d(27): Error: expression expected, not `>`\n/tmp/tmpidy3s5ku.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpidy3s5ku.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmpidy3s5ku.d(27): Error: found `if` when expecting `)`\n/tmp/tmpidy3s5ku.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmpidy3s5ku.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpidy3s5ku.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] < x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            result.add((i, j));\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n        {\n            result.add((i, j));\n        }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcprzhx3l.d(27): Error: no identifier for declarator `i`\n/tmp/tmpcprzhx3l.d(27): Error: found `-` when expecting `;`\n/tmp/tmpcprzhx3l.d(27): Error: expression expected, not `>`\n/tmp/tmpcprzhx3l.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpcprzhx3l.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpcprzhx3l.d(27): Error: found `if` when expecting `)`\n/tmp/tmpcprzhx3l.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmpcprzhx3l.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcprzhx3l.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst) \n    {\n        foreach(column: row) \n        {\n            if(column == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n                break;\n            }\n        }\n        if(result != null) break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpicvd42su.d(26): Error: no identifier for declarator `row`\n/tmp/tmpicvd42su.d(26): Error: found `:` when expecting `;`\n/tmp/tmpicvd42su.d(28): Error: no identifier for declarator `column`\n/tmp/tmpicvd42su.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpicvd42su.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n                break;\n            }\n        }\n        if(j == m)\n        {\n            res[i] = Tuple!(long, long)[i, j];\n        }\n    }\n    sort(res);\n    sort(res, (a, b) => -cmp(b.1, a.1));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1itca0hw.d(45): Error: found `0.1` when expecting `,`\n/tmp/tmp1itca0hw.d(45): Error: expression expected, not `,`\n/tmp/tmp1itca0hw.d(45): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1itca0hw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = null;\n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                if(result == null)\n                {\n                    result = Tuple!(long, long)[](row, col);\n                }\n                else\n                {\n                    result = Tuple!(long, long)[](row, col);\n                    result.push(result);\n                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoprttctq.d(26): Error: no identifier for declarator `row`\n/tmp/tmpoprttctq.d(26): Error: found `:` when expecting `;`\n/tmp/tmpoprttctq.d(28): Error: no identifier for declarator `col`\n/tmp/tmpoprttctq.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoprttctq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[Tuple!(long, long)[row, col]];\n                break;\n            }\n        }\n        if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkke1w7mg.d(26): Error: no identifier for declarator `row`\n/tmp/tmpkke1w7mg.d(26): Error: found `:` when expecting `;`\n/tmp/tmpkke1w7mg.d(28): Error: no identifier for declarator `col`\n/tmp/tmpkke1w7mg.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkke1w7mg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                if(res == null)\n                    res = Tuple!(long, long)[]();\n                res[res.length-1] = Tuple!(i, j);\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) -> a.first > b.first);\n    return res;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprqynioze.d(26): Error: no identifier for declarator `i`\n/tmp/tmprqynioze.d(26): Error: found `:` when expecting `;`\n/tmp/tmprqynioze.d(28): Error: no identifier for declarator `j`\n/tmp/tmprqynioze.d(28): Error: found `:` when expecting `;`\n/tmp/tmprqynioze.d(39): Error: expression expected, not `>`\n/tmp/tmprqynioze.d(39): Error: found `a` when expecting `,`\n/tmp/tmprqynioze.d(42): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqynioze.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res[lst[i].length - 1 - j] = (i, j);\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first ? 1 : -1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp05bj64le.d(38): Error: expression expected, not `>`\n/tmp/tmp05bj64le.d(38): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp05bj64le.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    for(long i = 0; i < lst.length; i++)\n    {\n        for(long j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                ret.add(new Tuple!(i, j));\n            }\n        }\n    }\n    \n    ret.sort(function(a, b) -> a.first > b.first);\n    ret.sort(function(a, b) -> a.second > b.second);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqrlf7mq2.d(38): Error: missing `{ ... }` for function literal\n/tmp/tmpqrlf7mq2.d(38): Error: expression expected, not `>`\n/tmp/tmpqrlf7mq2.d(38): Error: found `a` when expecting `,`\n/tmp/tmpqrlf7mq2.d(39): Error: missing `{ ... }` for function literal\n/tmp/tmpqrlf7mq2.d(39): Error: expression expected, not `>`\n/tmp/tmpqrlf7mq2.d(39): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqrlf7mq2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] > x)\n            res[res.length] = Tuple!(i, j);\n    }), 0..lst.length-1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphw67wdmp.d(26): Error: no identifier for declarator `i`\n/tmp/tmphw67wdmp.d(26): Error: found `-` when expecting `;`\n/tmp/tmphw67wdmp.d(26): Error: expression expected, not `>`\n/tmp/tmphw67wdmp.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmphw67wdmp.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmphw67wdmp.d(26): Error: found `if` when expecting `)`\n/tmp/tmphw67wdmp.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmphw67wdmp.d(29): Error: declaration expected, not `)`\n/tmp/tmphw67wdmp.d(30): Error: declaration expected, not `foreach`\n/tmp/tmphw67wdmp.d(33): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphw67wdmp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = get_row(lst[i], x);\n        foreach(k -> {\n            Tuple!(long, long)[] col = get_row(lst[j], k);\n            foreach(l -> {\n                res.push(Tuple!(long, long)((i, j), (k, l)));\n            });\n        });\n    }));\n    \n    sort(res, (i, j) -> {\n        Tuple!(long, long)[] row = get_row(lst[i], x);\n        Tuple!(long, long)[] col = get_row(lst[j], x);\n        return row[0] > col[0];\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpg6ci1xh0.d(27): Error: no identifier for declarator `i`\n/tmp/tmpg6ci1xh0.d(27): Error: found `-` when expecting `;`\n/tmp/tmpg6ci1xh0.d(27): Error: expression expected, not `>`\n/tmp/tmpg6ci1xh0.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpg6ci1xh0.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpg6ci1xh0.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpg6ci1xh0.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpg6ci1xh0.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpg6ci1xh0.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpg6ci1xh0.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpg6ci1xh0.d(28): Error: found `=` instead of statement\n/tmp/tmpg6ci1xh0.d(29): Error: no identifier for declarator `k`\n/tmp/tmpg6ci1xh0.d(29): Error: found `-` when expecting `;`\n/tmp/tmpg6ci1xh0.d(29): Error: expression expected, not `>`\n/tmp/tmpg6ci1xh0.d(29): Error: found `{` when expecting `)`\n/tmp/tmpg6ci",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                row.add((i, j));\n            });\n            res.add((i, row));\n        }\n    }), range(0, lst.length));\n    sort(res, (i, j) -> {\n        if (i == 0) return 1;\n        if (j == 0) return -1;\n        return lst[i][j] - lst[i - 1][j];\n    });\n    sort(res, (i, j) -> {\n        if (i == 0) return -1;\n        if (j == 0) return 1;\n        return lst[i][j] - lst[i - 1][j];\n    });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzqludqya.d(26): Error: no identifier for declarator `i`\n/tmp/tmpzqludqya.d(26): Error: found `-` when expecting `;`\n/tmp/tmpzqludqya.d(26): Error: expression expected, not `>`\n/tmp/tmpzqludqya.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmpzqludqya.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpzqludqya.d(26): Error: found `if` when expecting `)`\n/tmp/tmpzqludqya.d(27): Error: found `{` when expecting `;` following statement\n/tmp/tmpzqludqya.d(29): Error: no identifier for declarator `k`\n/tmp/tmpzqludqya.d(29): Error: found `-` when expecting `;`\n/tmp/tmpzqludqya.d(29): Error: expression expected, not `>`\n/tmp/tmpzqludqya.d(29): Error: found `{` when expecting `)`\n/tmp/tmpzqludqya.d(31): Error: declaration expected, not `)`\n/tmp/tmpzqludqya.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpzqludqya.d(32): Error: no identifier for declarator `res.add(i, row)`\n/tmp/tmpzqludqya.d(33): Error: unrecognized declaration\nFaile",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                if(res == null)\n                    res = make_tuple(i, j);\n                else\n                    res = make_tuple(i, j) + res;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi9qfi7pr.d(27): Error: no identifier for declarator `i`\n/tmp/tmpi9qfi7pr.d(27): Error: found `:` when expecting `;`\n/tmp/tmpi9qfi7pr.d(29): Error: no identifier for declarator `j`\n/tmp/tmpi9qfi7pr.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi9qfi7pr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                res.push((i, j));\n            }\n        }\n    }\n    \n    sort(res, (a, b) => a.first < b.first ? -1 : a.first > b.first ? 1 : 0);\n    sort(res, (a, b) => a.second > b.second ? -1 : a.second < b.second ? 1 : 0);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcvvo_821.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpcvvo_821.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == (x)`: `long[]` and `long`\n/tmp/tmpcvvo_821.d(32): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmpcvvo_821.d(37): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpcvvo_821.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcvvo_821.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n            if(column == x)\n            {\n                result.push(Tuple!(long, long)((row), column));\n            }\n        }\n    }\n    \n    result.sort(compareByDescending);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_ycd9igp.d(27): Error: no identifier for declarator `row`\n/tmp/tmp_ycd9igp.d(27): Error: found `:` when expecting `;`\n/tmp/tmp_ycd9igp.d(29): Error: no identifier for declarator `column`\n/tmp/tmp_ycd9igp.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ycd9igp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n                ret.add(new Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(ret, (a, b) -> a.first > b.first ? 1 : -1);\n    sort(ret, (a, b) -> a.second > b.second ? 1 : -1);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgdjhf7fz.d(35): Error: expression expected, not `>`\n/tmp/tmpgdjhf7fz.d(35): Error: found `a` when expecting `,`\n/tmp/tmpgdjhf7fz.d(36): Error: expression expected, not `>`\n/tmp/tmpgdjhf7fz.d(36): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgdjhf7fz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)((row), col));\n            }\n        }\n    }\n    \n    sort(res, (row1, row2) => row1._1 > row2._1);\n    sort(res, (row1, row2) => row1._2 > row2._2);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1tfg06hu.d(27): Error: no identifier for declarator `row`\n/tmp/tmp1tfg06hu.d(27): Error: found `:` when expecting `;`\n/tmp/tmp1tfg06hu.d(29): Error: no identifier for declarator `col`\n/tmp/tmp1tfg06hu.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1tfg06hu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n            foreach(k -> {\n                if(lst[i][k] > lst[i][k + 1]) {\n                    Tuple!(long, long)[] coord2 = new Tuple!(long, long)[] {i, k};\n                    foreach(l -> {\n                        if(lst[k][l] > lst[k + 1][l]) {\n                            Tuple!(long, long)[] coord3 = new Tuple!(long, long)[] {k, l};\n                            foreach(m -> {\n                                if(lst[l][m] > lst[k][m]) {\n                                    coord = coord.concat(coord2);\n                                    coord2 = coord3;\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            res = res.concat(coord);\n        }\n    }));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpavbosiow.d(26): Error: no identifier for declarator `i`\n/tmp/tmpavbosiow.d(26): Error: found `-` when expecting `;`\n/tmp/tmpavbosiow.d(26): Error: expression expected, not `>`\n/tmp/tmpavbosiow.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmpavbosiow.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpavbosiow.d(26): Error: found `if` when expecting `)`\n/tmp/tmpavbosiow.d(27): Error: found `{` when expecting `;` following statement\n/tmp/tmpavbosiow.d(28): Error: semicolon expected, not `{`\n/tmp/tmpavbosiow.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmpavbosiow.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpavbosiow.d(29): Error: no identifier for declarator `k`\n/tmp/tmpavbosiow.d(29): Error: found `-` when expecting `;`\n/tmp/tmpavbosiow.d(29): Error: expression expected, not `>`\n/tmp/tmpavbosiow.d(29): Error: found `{` when expecting `)`\n/tmp/tmpavbosiow.d(31): Error: semicolon expected, not `{`\n/tmp/tmpavbosiow.d(31): Error: found `}` when",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    \n    foreach(i : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[](Tuple!(i + 1, j), Tuple!(i + 1, j + 1));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1vn90y3g.d(27): Error: no identifier for declarator `i`\n/tmp/tmp1vn90y3g.d(27): Error: found `:` when expecting `;`\n/tmp/tmp1vn90y3g.d(29): Error: no identifier for declarator `j`\n/tmp/tmp1vn90y3g.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1vn90y3g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n            sort(coord);\n            sort(coord, (x, y) -> -y);\n            foreach(k -> {\n                res[k.0].add(k.1);\n            });\n        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmponp9u1jt.d(27): Error: no identifier for declarator `i`\n/tmp/tmponp9u1jt.d(27): Error: found `-` when expecting `;`\n/tmp/tmponp9u1jt.d(27): Error: expression expected, not `>`\n/tmp/tmponp9u1jt.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmponp9u1jt.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmponp9u1jt.d(27): Error: found `if` when expecting `)`\n/tmp/tmponp9u1jt.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmponp9u1jt.d(29): Error: semicolon expected, not `{`\n/tmp/tmponp9u1jt.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmponp9u1jt.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmponp9u1jt.d(31): Error: expression expected, not `>`\n/tmp/tmponp9u1jt.d(32): Error: no identifier for declarator `k`\n/tmp/tmponp9u1jt.d(32): Error: found `-` when expecting `;`\n/tmp/tmponp9u1jt.d(32): Error: expression expected, not `>`\n/tmp/tmponp9u1jt.d(32): Error: found `{` when expecting `)`\n/tmp/tmponp9u1jt.d(33): Error: found `0.0000",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvn0tarw0.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpvn0tarw0.d(29): Error: template instance `tmpvn0tarw0.get_row.Tuple!(i, j)` error instant",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw4kgkg_h.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpw4kgkg_h.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw4kgkg_h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst, i: int)\n    {\n        foreach(column: row, j: int)\n        {\n            if(column == x)\n            {\n                result.add((i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) -> a.0 < b.0 ? -1 : a.0 > b.0 ? 1 : 0);\n    result.sort(function(a, b) -> a.1 < b.0 ? -1 : a.1 > b.0 ? 1 : 0);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn_r4iiv5.d(27): Error: no identifier for declarator `row`\n/tmp/tmpn_r4iiv5.d(27): Error: found `:` when expecting `;`\n/tmp/tmpn_r4iiv5.d(27): Error: found `:` when expecting `)`\n/tmp/tmpn_r4iiv5.d(27): Error: no identifier for declarator `int`\n/tmp/tmpn_r4iiv5.d(27): Error: found `)` instead of statement\n/tmp/tmpn_r4iiv5.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_r4iiv5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][col[i]] == x)\n        {\n            Tuple!(long, long)[] res = new Tuple!(long, long)[row.Length];\n            for(int j = 0; j < row.Length; j++)\n            {\n                res[j] = (row[j], col[j]);\n            }\n            return res;\n        }\n    }\n    return new Tuple!(long, long)[0];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3se4d0ki.d(25): Error: no property `Length` for type `long[][]`\n/tmp/tmp3se4d0ki.d(26): Error: no property `Length` for type `long[][]`\n/tmp/tmp3se4d0ki.d(28): Error: no property `Length` for type `long[][]`\n/tmp/tmp3se4d0ki.d(34): Error: no property `Length` for type `long[][]`\n/tmp/tmp3se4d0ki.d(38): Error: no property `Length` for type `int[]`\n/tmp/tmp3se4d0ki.d(39): Error: no property `Length` for type `int[]`\n/tmp/tmp3se4d0ki.d(41): Error: Using the result of a comma expression is not allowed\n/tmp/tmp3se4d0ki.d(41): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign` cannot deduce function from argument types `!()(int)`, candidates are:\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long, long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, \"=\"))`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3se4d0ki.d\", \"-I/",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                res = Tuple!(long, long)[](row,col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpas8r4mga.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpas8r4mga.d(26): Error: found `)` when expecting `;`\n/tmp/tmpas8r4mga.d(28): Error: no identifier for declarator `row`\n/tmp/tmpas8r4mga.d(28): Error: found `)` when expecting `;`\n/tmp/tmpas8r4mga.d(35): Error: found `}` when expecting `)`\n/tmp/tmpas8r4mga.d(38): Error: found `unittest` when expecting `)`\n/tmp/tmpas8r4mga.d(49): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas8r4mga.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        long row = 0;\n        long col = 0;\n        \n        if(lst[i][j] == x) {\n            row = i;\n            col = j;\n        }\n        \n        Tuple!(long, long)[] tuple = new Tuple!(row, col);\n        \n        result.push(tuple);\n    }), range(0, lst.length));\n    \n    sort(result, (a, b) => a.first - b.first);\n    sort(result, (a, b) => b.second - a.second);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2k5h6sv9.d(27): Error: no identifier for declarator `i`\n/tmp/tmp2k5h6sv9.d(27): Error: found `-` when expecting `;`\n/tmp/tmp2k5h6sv9.d(27): Error: expression expected, not `>`\n/tmp/tmp2k5h6sv9.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp2k5h6sv9.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp2k5h6sv9.d(27): Error: found `long` when expecting `)`\n/tmp/tmp2k5h6sv9.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmp2k5h6sv9.d(28): Error: found `=` instead of statement\n/tmp/tmp2k5h6sv9.d(39): Error: declaration expected, not `)`\n/tmp/tmp2k5h6sv9.d(41): Error: unexpected `(` in declarator\n/tmp/tmp2k5h6sv9.d(41): Error: basic type expected, not `(`\n/tmp/tmp2k5h6sv9.d(41): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp2k5h6sv9.d(41): Error: found `=>` when expecting `)`\n/tmp/tmp2k5h6sv9.d(41): Error: no identifier for declarator `sort(result, _error_(a, b))`\n/tmp/tmp2k5h6sv9.d(41): Error: semicolon expec",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                res[j].x = j;\n                res[j].y = 0;\n            }\n            else if(j == 0)\n            {\n                res[j].x = i;\n                res[j].y = i;\n            }\n            else\n            {\n                if(lst[i][j] == x)\n                {\n                    res[j].x = i;\n                    res[j].y = j;\n                }\n            }\n        }), 0);\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                res[j].x = j;\n                res[j].y = i;\n            }\n            else if(j == 0)\n            {\n                res[j].x = i;\n                res[j].y = j;\n            }\n            else\n            {\n                if(lst[i][j] > lst[i][j + 1])\n                {\n                    res[j].x = i;\n                    res[j].y = j;\n                }\n            }\n        }), 0);\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                res[j].x = j;\n                res[j].y = i;\n            }\n            else if(j == 0)\n            {\n                res[j].x = i;\n                res[j].y = j;\n            }\n            else\n            {\n                if(lst[i][j] < lst[i][j + 1])\n                {\n                    res[j].x = i;\n                    res[j].y = j;\n                }\n            }\n        }), 0);\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                res[j].x = j;\n                res[j].y = i;\n            }\n            else if(j == 0)\n            {\n                res[j].x = i;\n                res[j].y = j;\n            }\n            else\n            {\n                if(lst[i][j] > lst[i][j + 1])\n                {\n                    res[j].x = i;\n                    res[j].y = j;\n                }\n            }\n        }), 0);\n    \n    foreach(i -> foreach(j -> \n        {\n            if(i == 0)\n            {\n                res[j].x = j;\n                res[j].y = i;\n            }\n            else if(j == 0)\n            {\n                res[j].x = i;\n                res[j].y = j;\n            }\n            else\n            {\n                if(lst[i][j] < lst[i][j + 1])\n                {\n                    res[j].x = i;\n                    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpawhetttd.d(27): Error: no identifier for declarator `i`\n/tmp/tmpawhetttd.d(27): Error: found `-` when expecting `;`\n/tmp/tmpawhetttd.d(27): Error: expression expected, not `>`\n/tmp/tmpawhetttd.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpawhetttd.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmpawhetttd.d(27): Error: found `if` when expecting `)`\n/tmp/tmpawhetttd.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmpawhetttd.d(34): Error: declaration expected, not `else`\n/tmp/tmpawhetttd.d(37): Error: no identifier for declarator `res[j].y`\n/tmp/tmpawhetttd.d(37): Error: declaration expected, not `=`\n/tmp/tmpawhetttd.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpawhetttd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n    sort(res);\n    sort(res, (a, b) -> -cmp(a.i, b.i));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmxnfvlon.d(27): Error: no identifier for declarator `i`\n/tmp/tmpmxnfvlon.d(27): Error: found `-` when expecting `;`\n/tmp/tmpmxnfvlon.d(27): Error: expression expected, not `>`\n/tmp/tmpmxnfvlon.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpmxnfvlon.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpmxnfvlon.d(27): Error: found `if` when expecting `)`\n/tmp/tmpmxnfvlon.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmpmxnfvlon.d(30): Error: declaration expected, not `)`\n/tmp/tmpmxnfvlon.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpmxnfvlon.d(32): Error: no identifier for declarator `sort(res)`\n/tmp/tmpmxnfvlon.d(33): Error: unexpected `(` in declarator\n/tmp/tmpmxnfvlon.d(33): Error: basic type expected, not `(`\n/tmp/tmpmxnfvlon.d(33): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmpmxnfvlon.d(33): Error: found `-` when expecting `)`\n/tmp/tm",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length > 0)\n        {\n            row[i] = i;\n            col[i] = lst[i].Length - 1;\n        }\n        else\n        {\n            row[i] = 0;\n            col[i] = 0;\n        }\n    }\n    Array.Sort(row);\n    Array.Sort(col);\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == 0)\n        {\n            res[i] = Tuple!(long, long)(0, 0);\n        }\n        else\n        {\n            res[i] = Tuple!(long, long)(row[i], col[i]);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvf7aipiv.d(25): Error: no property `Length` for type `long[][]`\n/tmp/tmpvf7aipiv.d(26): Error: no property `Length` for type `long[][]`\n/tmp/tmpvf7aipiv.d(27): Error: no property `Length` for type `long[][]`\n/tmp/tmpvf7aipiv.d(29): Error: no property `Length` for type `long[]`\n/tmp/tmpvf7aipiv.d(32): Error: no property `Length` for type `long[]`\n/tmp/tmpvf7aipiv.d(40): Error: undefined identifier `Array`\n/tmp/tmpvf7aipiv.d(41): Error: undefined identifier `Array`\n/tmp/tmpvf7aipiv.d(42): Error: no property `Length` for type `long[][]`\n/tmp/tmpvf7aipiv.d(43): Error: no property `Length` for type `long[][]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvf7aipiv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(i == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(j == k) row.add((i, j));\n        });\n        res.add(row);\n    }), range(0, lst[0].length));\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp__ii4ro_.d(27): Error: no identifier for declarator `i`\n/tmp/tmp__ii4ro_.d(27): Error: found `-` when expecting `;`\n/tmp/tmp__ii4ro_.d(27): Error: expression expected, not `>`\n/tmp/tmp__ii4ro_.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp__ii4ro_.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp__ii4ro_.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmp__ii4ro_.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmp__ii4ro_.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmp__ii4ro_.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp__ii4ro_.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmp__ii4ro_.d(28): Error: found `=` instead of statement\n/tmp/tmp__ii4ro_.d(29): Error: no identifier for declarator `k`\n/tmp/tmp__ii4ro_.d(29): Error: found `-` when expecting `;`\n/tmp/tmp__ii4ro_.d(29): Error: expression expected, not `>`\n/tmp/tmp__ii4ro_.d(29): Error: found `{` when expecting `)`\n/tmp/tmp__ii",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = i;\n        col[i] = i;\n    }\n    Array.Sort(row, col, (x, y) => Comparer<int>.Default.Compare(x, y));\n    Array.Sort(col, row, (x, y) => Comparer<int>.Default.Compare(y, x));\n    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(row[i] == x)\n        {\n            res[i] = Tuple!(long, long)[i, col[i]];\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=algorithm,c#,sorting,list |>\n<| c |>\nThis doesn't seem to work. `get_row([[], [1L], [1L, 2L, 3L]], 3L)` returns `[tuple(2L, 2L)]` instead of `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]`\n<|/ c |>\n<| c |>\nI tested it and it works fine. `get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]`\n<|/ c |>\n<| c |>\nI tested it again and it works fine. `get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]`\n<|/ c |>\n<| c |>\nI tested it again and it works fine. `get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)` returns `[tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjrd3ib5r.d(32): Error: found `>` when expecting `.` following int\n/tmp/tmpjrd3ib5r.d(32): Error: found `.` when expecting identifier following `int`.\n/tmp/tmpjrd3ib5r.d(32): Error: found `Default` when expecting `,`\n/tmp/tmpjrd3ib5r.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpjrd3ib5r.d(33): Error: found `.` when expecting identifier following `int`.\n/tmp/tmpjrd3ib5r.d(33): Error: found `Default` when expecting `,`\n/tmp/tmpjrd3ib5r.d(44): Error: declaration expected, not `<`\n/tmp/tmpjrd3ib5r.d(47): Error: unterminated character constant\n/tmp/tmpjrd3ib5r.d(56): Error: unterminated string constant starting at /tmp/tmpjrd3ib5r.d(56)\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            res[res.length] = Tuple!(i, j);\n        }\n    }), range(0, lst.length));\n    \n    sort(res, (i, j) -> Tuple!(i, j).f0);\n    sort(res, (i, j) -> Tuple!(i, j).f1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp67t2h5mp.d(27): Error: no identifier for declarator `i`\n/tmp/tmp67t2h5mp.d(27): Error: found `-` when expecting `;`\n/tmp/tmp67t2h5mp.d(27): Error: expression expected, not `>`\n/tmp/tmp67t2h5mp.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp67t2h5mp.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmp67t2h5mp.d(27): Error: found `if` when expecting `)`\n/tmp/tmp67t2h5mp.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmp67t2h5mp.d(33): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67t2h5mp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[];\n            tuple[0] = i;\n            tuple[1] = j;\n            res.add(tuple);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] > x)\n        {\n            Tuple!(long, long)[] tuple = new Tuple!(long, long)[];\n            tuple[0] = i;\n            tuple[1] = j;\n            res.add(tuple);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppgkvym87.d(27): Error: no identifier for declarator `i`\n/tmp/tmppgkvym87.d(27): Error: found `-` when expecting `;`\n/tmp/tmppgkvym87.d(27): Error: expression expected, not `>`\n/tmp/tmppgkvym87.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmppgkvym87.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmppgkvym87.d(27): Error: found `if` when expecting `)`\n/tmp/tmppgkvym87.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmppgkvym87.d(36): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppgkvym87.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i, j};\n            sort(coord, (a, b) => a.first > b.first);\n            sort(coord, (a, b) => a.second > b.second);\n            foreach(coord -> res.push(coord));\n        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp405haf_k.d(27): Error: no identifier for declarator `i`\n/tmp/tmp405haf_k.d(27): Error: found `-` when expecting `;`\n/tmp/tmp405haf_k.d(27): Error: expression expected, not `>`\n/tmp/tmp405haf_k.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp405haf_k.d(28): Error: use `.` for member lookup, not `->`\n/tmp/tmp405haf_k.d(27): Error: found `if` when expecting `)`\n/tmp/tmp405haf_k.d(30): Error: found `{` when expecting `;` following statement\n/tmp/tmp405haf_k.d(31): Error: semicolon expected, not `{`\n/tmp/tmp405haf_k.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmp405haf_k.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp405haf_k.d(34): Error: no identifier for declarator `coord`\n/tmp/tmp405haf_k.d(34): Error: found `-` when expecting `;`\n/tmp/tmp405haf_k.d(34): Error: expression expected, not `>`\n/tmp/tmp405haf_k.d(34): Error: found `res` when expecting `)`\n/tmp/tmp405haf_k.d(34): Error: found `)` when expecting `;` following statement\n/tmp/tmp405haf_k.d",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row: lst, i: 0, row.length)\n    {\n        foreach(col: row, j: 0, row.length)\n        {\n            if(col == x)\n            {\n                res[res.length] = Tuple!(i, j);\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5xlw6fx_.d(26): Error: no identifier for declarator `row`\n/tmp/tmp5xlw6fx_.d(26): Error: found `:` when expecting `;`\n/tmp/tmp5xlw6fx_.d(26): Error: found `:` when expecting `)`\n/tmp/tmp5xlw6fx_.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmp5xlw6fx_.d(28): Error: no identifier for declarator `col`\n/tmp/tmp5xlw6fx_.d(28): Error: found `:` when expecting `;`\n/tmp/tmp5xlw6fx_.d(28): Error: found `:` when expecting `)`\n/tmp/tmp5xlw6fx_.d(28): Error: found `)` when expecting `;` following statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5xlw6fx_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                res = Tuple!(long, long)[Tuple!(i,j)];\n                break;\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkz4ta0sy.d(27): Error: no identifier for declarator `i`\n/tmp/tmpkz4ta0sy.d(27): Error: found `:` when expecting `;`\n/tmp/tmpkz4ta0sy.d(29): Error: no identifier for declarator `j`\n/tmp/tmpkz4ta0sy.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkz4ta0sy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                res = append(res, Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, fun(Tuple!(long, long)) -> Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return Tuple!(long, long)->bool {return \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppysg1gg5.d(27): Error: no identifier for declarator `i`\n/tmp/tmppysg1gg5.d(27): Error: found `:` when expecting `;`\n/tmp/tmppysg1gg5.d(29): Error: no identifier for declarator `j`\n/tmp/tmppysg1gg5.d(29): Error: found `:` when expecting `;`\n/tmp/tmppysg1gg5.d(39): Error: expression expected, not `>`\n/tmp/tmppysg1gg5.d(39): Error: found `Tuple` when expecting `,`\n/tmp/tmppysg1gg5.d(39): Error: found `,` when expecting `.` following long\n/tmp/tmppysg1gg5.d(39): Error: found `long` when expecting identifier following `long`.\n/tmp/tmppysg1gg5.d(39): Error: expression expected, not `>`\n/tmp/tmppysg1gg5.d(39): Error: found `bool` when expecting `,`\n/tmp/tmppysg1gg5.d(39): Error: expression expected, not `>`\n/tmp/tmppysg1gg5.d(39): Error: found `bool` when expecting `;` following `return` statement\n/tmp/tmppysg1gg5.d(39): Error: expression expected, not `>`\n/tmp/tmppysg1gg5.d(39): Error: found `bool` when expecting `;` following `return` statement\n/tmp/tmppysg1gg5.d(39): Error: expression expected, not `>`\n/t",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] temp;\n        foreach(k -> {\n            if(i == k) {\n                temp += Tuple!(long, long)[](Tuple!(x, j), Tuple!(x, k));\n            }\n        });\n        res += temp;\n    }), range(0, lst.length));\n    \n    sort(res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp52av6szv.d(27): Error: no identifier for declarator `i`\n/tmp/tmp52av6szv.d(27): Error: found `-` when expecting `;`\n/tmp/tmp52av6szv.d(27): Error: expression expected, not `>`\n/tmp/tmp52av6szv.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp52av6szv.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp52av6szv.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmp52av6szv.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmp52av6szv.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmp52av6szv.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmp52av6szv.d(28): Error: found `temp` when expecting `;` following statement\n/tmp/tmp52av6szv.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp52av6szv.d(29): Error: no identifier for declarator `k`\n/tmp/tmp52av6szv.d(29): Error: found `-` when expecting `;`\n/tmp/tmp52av6szv.d(29): Error: expression expected, not `>`\n/tmp/tmp52av6szv.d(29): Error: found `{` when expectin",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row,lst) \n    {\n        foreach(col,row)\n        {\n            if(col == x)\n            {\n                result ~= Tuple!(row,col);\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, descending);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptx8ifpmc.d(27): Error: no identifier for declarator `lst`\n/tmp/tmptx8ifpmc.d(27): Error: found `)` when expecting `;`\n/tmp/tmptx8ifpmc.d(29): Error: no identifier for declarator `row`\n/tmp/tmptx8ifpmc.d(29): Error: found `)` when expecting `;`\n/tmp/tmptx8ifpmc.d(36): Error: found `}` when expecting `)`\n/tmp/tmptx8ifpmc.d(42): Error: found `unittest` when expecting `)`\n/tmp/tmptx8ifpmc.d(53): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptx8ifpmc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i].length == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                if(lst[i][j] == x)\n                {\n                    res.push(Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => b._1 - a._1);\n    sort(res, (a, b) => b._2 - a._2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmuxlbzs7.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpmuxlbzs7.d(34): Error: no property `push` for type `Tuple!(long, long)[]`\n/tmp/tmpmuxlbzs7.d(40): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpmuxlbzs7.d(41): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmpmuxlbzs7.d(42): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmuxlbzs7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                result.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplkde7px2.d(27): Error: no identifier for declarator `row`\n/tmp/tmplkde7px2.d(27): Error: found `:` when expecting `;`\n/tmp/tmplkde7px2.d(29): Error: no identifier for declarator `col`\n/tmp/tmplkde7px2.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkde7px2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                result.push(Tuple!(long, long)((row), col));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvkku4kkk.d(27): Error: no identifier for declarator `row`\n/tmp/tmpvkku4kkk.d(27): Error: found `:` when expecting `;`\n/tmp/tmpvkku4kkk.d(29): Error: no identifier for declarator `col`\n/tmp/tmpvkku4kkk.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvkku4kkk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n        if(res != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprz8mk5ce.d(26): Error: no identifier for declarator `row`\n/tmp/tmprz8mk5ce.d(26): Error: found `:` when expecting `;`\n/tmp/tmprz8mk5ce.d(28): Error: no identifier for declarator `col`\n/tmp/tmprz8mk5ce.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprz8mk5ce.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) -> -cmp(a.first, b.first));\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9b9vmf6r.d(34): Error: expression expected, not `>`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9b9vmf6r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                result.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    \n    result.sort(byDescending);\n    foreach(tuple: result)\n    {\n        tuple.sort(byDescending);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu590od1j.d(27): Error: no identifier for declarator `row`\n/tmp/tmpu590od1j.d(27): Error: found `:` when expecting `;`\n/tmp/tmpu590od1j.d(29): Error: no identifier for declarator `col`\n/tmp/tmpu590od1j.d(29): Error: found `:` when expecting `;`\n/tmp/tmpu590od1j.d(39): Error: no identifier for declarator `tuple`\n/tmp/tmpu590od1j.d(39): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu590od1j.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi02_cdxw.d(27): Error: no identifier for declarator `i`\n/tmp/tmpi02_cdxw.d(27): Error: found `:` when expecting `;`\n/tmp/tmpi02_cdxw.d(29): Error: no identifier for declarator `j`\n/tmp/tmpi02_cdxw.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi02_cdxw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(row: lst)\n    {\n        foreach(col: row)\n        {\n            if(col == x)\n            {\n                res.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprhdro0w9.d(27): Error: no identifier for declarator `row`\n/tmp/tmprhdro0w9.d(27): Error: found `:` when expecting `;`\n/tmp/tmprhdro0w9.d(29): Error: no identifier for declarator `col`\n/tmp/tmprhdro0w9.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprhdro0w9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] t = (i, j);\n            foreach(k -> {\n                if(lst[i][k] > lst[k][j]) {\n                    t = swap(t, (j, k));\n                }\n            });\n            foreach(k -> {\n                if(lst[i][k] < lst[k][j]) {\n                    t = swap(t, (j, k));\n                }\n            });\n            res.add(t);\n        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvsv8jimm.d(27): Error: no identifier for declarator `i`\n/tmp/tmpvsv8jimm.d(27): Error: found `-` when expecting `;`\n/tmp/tmpvsv8jimm.d(27): Error: expression expected, not `>`\n/tmp/tmpvsv8jimm.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpvsv8jimm.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpvsv8jimm.d(27): Error: found `if` when expecting `)`\n/tmp/tmpvsv8jimm.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpvsv8jimm.d(30): Error: no identifier for declarator `k`\n/tmp/tmpvsv8jimm.d(30): Error: found `-` when expecting `;`\n/tmp/tmpvsv8jimm.d(30): Error: expression expected, not `>`\n/tmp/tmpvsv8jimm.d(30): Error: found `{` when expecting `)`\n/tmp/tmpvsv8jimm.d(34): Error: declaration expected, not `)`\n/tmp/tmpvsv8jimm.d(35): Error: declaration expected, not `foreach`\n/tmp/tmpvsv8jimm.d(38): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvsv8jimm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, r, c;\n    Tuple!(long, long)[] res;\n    \n    res = new();\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < m; j++) {\n            if (lst[i][j] == x) {\n                for (k = i; k < n; k++) {\n                    r = lst[k][i];\n                    c = lst[k][i];\n                    for (; k < n; k++) {\n                        c = lst[k][j];\n                        if (c < r) {\n                            r = c;\n                        }\n                    }\n                    res[res.length] = Tuple!(r, j);\n                }\n            }\n        }\n    }\n    \n    sort(res, fun(x) -> x.1);\n    sort(res, fun(x) -> -x.1);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpisd75wyl.d(30): Error: basic type expected, not `;`\n/tmp/tmpisd75wyl.d(50): Error: expression expected, not `>`\n/tmp/tmpisd75wyl.d(50): Error: found `x` when expecting `,`\n/tmp/tmpisd75wyl.d(51): Error: expression expected, not `>`\n/tmp/tmpisd75wyl.d(51): Error: found `0.1` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpisd75wyl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i].length == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                if(lst[i][j] == x)\n                {\n                    ret.push_back(new Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n    sort(ret.begin(), ret.end(), [](Tuple!(long, long)& a, Tuple!(long, long)& b) -> bool \n    {\n        return a.first < b.first;\n    });\n    \n    sort(ret.begin(), ret.end(), [](Tuple!(long, long)& a, Tuple!(long, long)& b) -> bool \n    {\n        return a.second > b.second;\n    });\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyjxwpfh1.d(40): Error: expression expected, not `>`\n/tmp/tmpyjxwpfh1.d(40): Error: found `bool` when expecting `,`\n/tmp/tmpyjxwpfh1.d(45): Error: expression expected, not `>`\n/tmp/tmpyjxwpfh1.d(45): Error: found `bool` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyjxwpfh1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            res.add(new Tuple!(i, j));\n        }\n    }), range(0, lst.length));\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfscenj1p.d(26): Error: no identifier for declarator `i`\n/tmp/tmpfscenj1p.d(26): Error: found `-` when expecting `;`\n/tmp/tmpfscenj1p.d(26): Error: expression expected, not `>`\n/tmp/tmpfscenj1p.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmpfscenj1p.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmpfscenj1p.d(26): Error: found `if` when expecting `)`\n/tmp/tmpfscenj1p.d(27): Error: found `{` when expecting `;` following statement\n/tmp/tmpfscenj1p.d(30): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfscenj1p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                if(lst[i][j] == x)\n                {\n                    res.push(Tuple!(i, j));\n                }\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9y2qxx6x.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp9y2qxx6x.d(34): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9y2qxx6x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new int[lst.Length];\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        row[i] = i;\n        col[i] = 0;\n    }\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][col[i]] == x)\n        {\n            return Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[](Tuple!(long, long)[]\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5necu049.d(39): Error: found `unittest` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `void` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `{` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: expression expected, not `}`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `)`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `)`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `)`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `)`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `)`\n/tmp/tmp5necu049.d(50): Error: found `End of File` when expecting `,`\n/tmp",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n            long c = i;\n            if(r == x)\n            {\n                row.push((r, c));\n            }\n        });\n        res.push(row);\n    }), lst);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n            long c = i;\n            if(r != x)\n            {\n                row.push((r, c));\n            }\n        });\n        res.push(row);\n    }), res);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long r = j;\n            long c = i;\n            if(c != x)\n            {\n                row.push((r, c));\n            }\n        });\n        res.push(row);\n    }), res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpprdcufs3.d(27): Error: no identifier for declarator `i`\n/tmp/tmpprdcufs3.d(27): Error: found `-` when expecting `;`\n/tmp/tmpprdcufs3.d(27): Error: expression expected, not `>`\n/tmp/tmpprdcufs3.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpprdcufs3.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpprdcufs3.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpprdcufs3.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpprdcufs3.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpprdcufs3.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpprdcufs3.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpprdcufs3.d(28): Error: found `=` instead of statement\n/tmp/tmpprdcufs3.d(29): Error: no identifier for declarator `k`\n/tmp/tmpprdcufs3.d(29): Error: found `-` when expecting `;`\n/tmp/tmpprdcufs3.d(29): Error: expression expected, not `>`\n/tmp/tmpprdcufs3.d(29): Error: found `{` when expecting `)`\n/tmp/tmpprdc",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] == x){\n                res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) -> a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx7hougkw.d(35): Error: expression expected, not `>`\n/tmp/tmpx7hougkw.d(35): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7hougkw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n            res = [(i, j)];\n        }\n    }), range(0, lst.length));\n    \n    sort(res);\n    sort(res, (a, b) -> {\n        if(res[a][0] == res[b][0])\n        {\n            return res[a][1] > res[b][1] ? 1 : -1;\n        }\n        else\n        {\n            return res[a][0] > res[b][0] ? 1 : -1;\n        }\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxqe381h7.d(27): Error: no identifier for declarator `i`\n/tmp/tmpxqe381h7.d(27): Error: found `-` when expecting `;`\n/tmp/tmpxqe381h7.d(27): Error: expression expected, not `>`\n/tmp/tmpxqe381h7.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpxqe381h7.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpxqe381h7.d(27): Error: found `if` when expecting `)`\n/tmp/tmpxqe381h7.d(29): Error: found `{` when expecting `;` following statement\n/tmp/tmpxqe381h7.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxqe381h7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) \n            res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n    sort(res, (i, j) -> {\n        if (i == 0) \n            return 1;\n        if (j == 0) \n            return -1;\n        return lst[i][j] - lst[i-1][j];\n    });\n    \n    sort(res, (i, j) -> {\n        if (i == 0) \n            return -1;\n        if (j == 0) \n            return 1;\n        return lst[i][j] - lst[i-1][j];\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppj00828t.d(27): Error: no identifier for declarator `i`\n/tmp/tmppj00828t.d(27): Error: found `-` when expecting `;`\n/tmp/tmppj00828t.d(27): Error: expression expected, not `>`\n/tmp/tmppj00828t.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmppj00828t.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmppj00828t.d(27): Error: found `if` when expecting `)`\n/tmp/tmppj00828t.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmppj00828t.d(30): Error: declaration expected, not `)`\n/tmp/tmppj00828t.d(32): Error: unexpected `(` in declarator\n/tmp/tmppj00828t.d(32): Error: basic type expected, not `(`\n/tmp/tmppj00828t.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmppj00828t.d(32): Error: found `-` when expecting `)`\n/tmp/tmppj00828t.d(32): Error: no identifier for declarator `sort(res, _error_(i, j))`\n/tmp/tmppj00828t.d(32): Error: semicolon expected following function declaration\n/tmp/tmppj00828t.d(32): Error: de",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(row[0] == x && column[0] == x) \n            {\n                result.push(Tuple!(long, long)((row[0], column[0])));\n            }\n        }\n    }\n    \n    foreach(row) \n    {\n        foreach\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphf9k8q_t.d(27): Error: no identifier for declarator `row`\n/tmp/tmphf9k8q_t.d(27): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(29): Error: no identifier for declarator `column`\n/tmp/tmphf9k8q_t.d(29): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(36): Error: found `}` when expecting `)`\n/tmp/tmphf9k8q_t.d(38): Error: no identifier for declarator `row`\n/tmp/tmphf9k8q_t.d(38): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(40): Error: no identifier for declarator `column`\n/tmp/tmphf9k8q_t.d(40): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(47): Error: found `}` when expecting `)`\n/tmp/tmphf9k8q_t.d(49): Error: no identifier for declarator `row`\n/tmp/tmphf9k8q_t.d(49): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(51): Error: no identifier for declarator `column`\n/tmp/tmphf9k8q_t.d(51): Error: found `)` when expecting `;`\n/tmp/tmphf9k8q_t.d(58): Error: found `}` when expecting `)`\n/tmp/tmphf9k8q_t.d(60): Error: no identifier for declarator `row`\n/tmp/tmphf9k8",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                result.add(new Tuple!(i, j));\n            }\n        }\n    }\n    result.sort(0, true);\n    result.sort(1, false);\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpobqzv3hs.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpobqzv3hs.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmpobqzv3hs.d(36): Error: no property `sort` for type `Tuple!(long, long)[]`\n/tmp/tmpobqzv3hs.d(37): Error: no property `sort` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpobqzv3hs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    long n = lst.length;\n    long m = lst[0].length;\n    long[][] result = new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                result[i][j] = i;\n                result[i][m - 1] = j;\n                result[n - 1][j] = i;\n                result[n - 1][m - 1] = j;\n            }\n        }\n    }\n    Arrays.sort(result, (a, b) -> {\n        if(a[0] == b[0])\n            return a[1] > b[1];\n        return a[0] > b[0];\n    });\n    Arrays.sort(result, (a, b) -> {\n        if(a[0] == b[0])\n            return a[2] > b[2];\n        return a[0] > b[0];\n    });\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1f6uhc4q.d(41): Error: expression expected, not `>`\n/tmp/tmp1f6uhc4q.d(41): Error: found `{` when expecting `,`\n/tmp/tmp1f6uhc4q.d(42): Error: expression expected, not `if`\n/tmp/tmp1f6uhc4q.d(43): Error: found `return` when expecting `,`\n/tmp/tmp1f6uhc4q.d(43): Error: found `;` when expecting `,`\n/tmp/tmp1f6uhc4q.d(44): Error: expression expected, not `return`\n/tmp/tmp1f6uhc4q.d(44): Error: found `a` when expecting `,`\n/tmp/tmp1f6uhc4q.d(44): Error: found `;` when expecting `,`\n/tmp/tmp1f6uhc4q.d(45): Error: expression expected, not `}`\n/tmp/tmp1f6uhc4q.d(46): Error: expression expected, not `>`\n/tmp/tmp1f6uhc4q.d(46): Error: found `{` when expecting `,`\n/tmp/tmp1f6uhc4q.d(47): Error: expression expected, not `if`\n/tmp/tmp1f6uhc4q.d(48): Error: found `return` when expecting `,`\n/tmp/tmp1f6uhc4q.d(48): Error: found `;` when expecting `,`\n/tmp/tmp1f6uhc4q.d(49): Error: expression expected, not `return`\n/tmp/tmp1f6uhc4q.d(49): Error: found `a` when expecting `,`\n/tmp/tmp1f6uhc4q.d(49): Error: found `;` w",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpod98qe96.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpod98qe96.d(32): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpod98qe96.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i] == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n    sort(res, (a, b) => -cmp(a, b));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0765dvuy.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp0765dvuy.d(29): Error: incompatible types for `(lst[cast(ulong)i]) == (x)`: `long[]` and `long`\n/tmp/tmp0765dvuy.d(33): Error: no property `add` for type `Tuple!(long, long)[]`\n/tmp/tmp0765dvuy.d(38): Error: undefined identifier `sort`, did you mean function `sqrt`?\n/tmp/tmp0765dvuy.d(39): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0765dvuy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n    \n    foreach(i : 0..lst.length-1)\n    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j] == x)\n            {\n                ret.add(Tuple!(i, j));\n            }\n        }\n    }\n    \n    sort(ret);\n    sort(ret, true);\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpo008d3x0.d(27): Error: no identifier for declarator `i`\n/tmp/tmpo008d3x0.d(27): Error: found `:` when expecting `;`\n/tmp/tmpo008d3x0.d(29): Error: no identifier for declarator `j`\n/tmp/tmpo008d3x0.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo008d3x0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(i == k) {\n                row.push((i, j));\n            }\n        });\n        if(row.contains((x, j))) {\n            res.push(row);\n        }\n    }), lst);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(i == k) {\n                row.push((i, j));\n            }\n        });\n        if(row.contains((x, j))) {\n            res.push(row);\n        }\n    }), res);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwn_g1p38.d(27): Error: no identifier for declarator `i`\n/tmp/tmpwn_g1p38.d(27): Error: found `-` when expecting `;`\n/tmp/tmpwn_g1p38.d(27): Error: expression expected, not `>`\n/tmp/tmpwn_g1p38.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpwn_g1p38.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpwn_g1p38.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpwn_g1p38.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpwn_g1p38.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpwn_g1p38.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpwn_g1p38.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpwn_g1p38.d(28): Error: found `=` instead of statement\n/tmp/tmpwn_g1p38.d(29): Error: no identifier for declarator `k`\n/tmp/tmpwn_g1p38.d(29): Error: found `-` when expecting `;`\n/tmp/tmpwn_g1p38.d(29): Error: expression expected, not `>`\n/tmp/tmpwn_g1p38.d(29): Error: found `{` when expecting `)`\n/tmp/tmpwn_g",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n            long rowI = i;\n            long rowJ = j;\n            long rowK = k;\n            \n            long colI = rowI;\n            long colJ = rowJ;\n            long colK = rowK;\n            \n            if(colJ == x) {\n                row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colK == x) {\n                row.add(Tuple!(rowI, rowJ));\n            }\n            \n            if(colI == x) {\n                row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colJ == x && colK == x) {\n                row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colI == x && colJ == x) {\n                row.add(Tuple!(rowI, rowJ));\n            }\n            \n            if(colK == x && colI == x) {\n                row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colJ == x && colK == x && colI == x) {\n                row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colI == x && colJ == x && colK == x) {\n                row.add(Tuple!(rowI, rowJ));\n            }\n            \n            if(colK == x && colI == x && colJ == x) {\n                row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colI == x && colJ == x && colK == x && colI == x) {\n                row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colK == x && colI == x && colJ == x && colK == x) {\n                row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colI == x && colJ == x && colK == x && colI == x && colJ == x) {\n                row.add(Tuple!(rowI, rowK));\n            }\n            \n            if(colK == x && colI == x && colJ == x && colK == x && colI == x && colJ == x) {\n                row.add(Tuple!(rowK, rowJ));\n            }\n            \n            if(colI == x && colJ == x && colK == x && \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyhe85xls.d(27): Error: no identifier for declarator `i`\n/tmp/tmpyhe85xls.d(27): Error: found `-` when expecting `;`\n/tmp/tmpyhe85xls.d(27): Error: expression expected, not `>`\n/tmp/tmpyhe85xls.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpyhe85xls.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpyhe85xls.d(27): Error: found `Tuple` when expecting `)`\n/tmp/tmpyhe85xls.d(28): Error: found `!` when expecting `;` following statement\n/tmp/tmpyhe85xls.d(28): Error: found `,` when expecting `.` following long\n/tmp/tmpyhe85xls.d(28): Error: found `long` when expecting identifier following `long`.\n/tmp/tmpyhe85xls.d(28): Error: found `row` when expecting `;` following statement\n/tmp/tmpyhe85xls.d(28): Error: found `=` instead of statement\n/tmp/tmpyhe85xls.d(29): Error: no identifier for declarator `k`\n/tmp/tmpyhe85xls.d(29): Error: found `-` when expecting `;`\n/tmp/tmpyhe85xls.d(29): Error: expression expected, not `>`\n/tmp/tmpyhe85xls.d(29): Error: found `{` when expecting `)`\n/tmp/tmpyhe8",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    for(int i = 0; i < lst.length; i++){\n        if(lst[i] == x)\n            return Tuple!(long, long)[](Tuple!(0, i));\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe71qqd38.d(28): Error: incompatible types for `(lst[cast(ulong)i]) == (x)`: `long[]` and `long`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501): Error: template instance `parseSpecs!(0, i)` cannot use local `i` as parameter to non-global template `parseSpecs(Specs...)`\n/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614): Error: CTFE failed because of previous errors in `injectNamedFields`\n/tmp/tmpe71qqd38.d(29): Error: template instance `tmpe71qqd38.get_row.Tuple!(0, i)` error instantiating\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe71qqd38.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n                break;\n            }\n        }\n    }\n    \n    if(res == null) \n    {\n        foreach(row::lst) \n        {\n            foreach(col::row) \n            {\n                if(col != x) \n                {\n                    res = Tuple!(long, long)[](row, col);\n                    break;\n                }\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp65gz7ex2.d(26): Error: no identifier for declarator `row`\n/tmp/tmp65gz7ex2.d(26): Error: found `:` when expecting `;`\n/tmp/tmp65gz7ex2.d(26): Error: expression expected, not `:`\n/tmp/tmp65gz7ex2.d(26): Error: found `lst` when expecting `)`\n/tmp/tmp65gz7ex2.d(26): Error: found `)` instead of statement\n/tmp/tmp65gz7ex2.d(35): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp65gz7ex2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n            if(col == x) \n            {\n                res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_t7ajbal.d(26): Error: no identifier for declarator `row`\n/tmp/tmp_t7ajbal.d(26): Error: found `:` when expecting `;`\n/tmp/tmp_t7ajbal.d(26): Error: expression expected, not `:`\n/tmp/tmp_t7ajbal.d(26): Error: found `lst` when expecting `)`\n/tmp/tmp_t7ajbal.d(26): Error: found `)` instead of statement\n/tmp/tmp_t7ajbal.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_t7ajbal.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) \n    {\n        foreach(column) \n        {\n            if(column == x) \n            {\n                result.push(Tuple!(long, long)((row), column));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, 1, descending);\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_0_bgfyr.d(27): Error: no identifier for declarator `row`\n/tmp/tmp_0_bgfyr.d(27): Error: found `)` when expecting `;`\n/tmp/tmp_0_bgfyr.d(29): Error: no identifier for declarator `column`\n/tmp/tmp_0_bgfyr.d(29): Error: found `)` when expecting `;`\n/tmp/tmp_0_bgfyr.d(36): Error: found `}` when expecting `)`\n/tmp/tmp_0_bgfyr.d(42): Error: unterminated /* */ comment\n/tmp/tmp_0_bgfyr.d(54): Error: found `End of File` when expecting `)`\n/tmp/tmp_0_bgfyr.d(54): Error: found `End of File` instead of statement\n/tmp/tmp_0_bgfyr.d(54): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_0_bgfyr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push((i, j));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptsx3j6w2.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmptsx3j6w2.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptsx3j6w2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i : 0..lst.length - 1, j : 0..lst[i].length - 1)\n    {\n        if(lst[i][j] == x)\n        {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(j : 0..lst[i].length - 1)\n            {\n                row.push(Tuple!(long, long)[i, j]);\n            }\n            res.push(row);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvt8wxe_b.d(26): Error: no identifier for declarator `i`\n/tmp/tmpvt8wxe_b.d(26): Error: found `:` when expecting `;`\n/tmp/tmpvt8wxe_b.d(26): Error: found `:` when expecting `)`\n/tmp/tmpvt8wxe_b.d(26): Error: found `..` when expecting `;` following statement\n/tmp/tmpvt8wxe_b.d(26): Error: found `)` when expecting `;` following statement\n/tmp/tmpvt8wxe_b.d(31): Error: no identifier for declarator `j`\n/tmp/tmpvt8wxe_b.d(31): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvt8wxe_b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] t = new Tuple!(long, long)[]; \n            t[0] = i; \n            t[1] = j; \n            res.add(t);\n        }\n    }), range(0, lst.length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsy1wtmfn.d(27): Error: no identifier for declarator `i`\n/tmp/tmpsy1wtmfn.d(27): Error: found `-` when expecting `;`\n/tmp/tmpsy1wtmfn.d(27): Error: expression expected, not `>`\n/tmp/tmpsy1wtmfn.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmpsy1wtmfn.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmpsy1wtmfn.d(27): Error: found `if` when expecting `)`\n/tmp/tmpsy1wtmfn.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmpsy1wtmfn.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsy1wtmfn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    sort(res);\n    sort(res, (a, b) => a.first > b.first);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1l9nz0cg.d(26): Error: no identifier for declarator `row`\n/tmp/tmp1l9nz0cg.d(26): Error: found `:` when expecting `;`\n/tmp/tmp1l9nz0cg.d(28): Error: no identifier for declarator `col`\n/tmp/tmp1l9nz0cg.d(28): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1l9nz0cg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst.length));\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) {\n            Tuple!(long, long)[] row = new Tuple!(long, long)[];\n            foreach(k -> {\n                if(lst[i][k] == x) {\n                    row.add(k);\n                }\n            });\n            res.add(row);\n        }\n    }), range(0, lst[0].length));\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3z3zl2ht.d(27): Error: no identifier for declarator `i`\n/tmp/tmp3z3zl2ht.d(27): Error: found `-` when expecting `;`\n/tmp/tmp3z3zl2ht.d(27): Error: expression expected, not `>`\n/tmp/tmp3z3zl2ht.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp3z3zl2ht.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp3z3zl2ht.d(27): Error: found `if` when expecting `)`\n/tmp/tmp3z3zl2ht.d(28): Error: found `{` when expecting `;` following statement\n/tmp/tmp3z3zl2ht.d(30): Error: no identifier for declarator `k`\n/tmp/tmp3z3zl2ht.d(30): Error: found `-` when expecting `;`\n/tmp/tmp3z3zl2ht.d(30): Error: expression expected, not `>`\n/tmp/tmp3z3zl2ht.d(30): Error: found `{` when expecting `)`\n/tmp/tmp3z3zl2ht.d(34): Error: declaration expected, not `)`\n/tmp/tmp3z3zl2ht.d(35): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp3z3zl2ht.d(35): Error: no identifier for declarator `res.add(row)`\n/tmp/tmp3z3zl2ht.d(36): Error: unrecognized declaration\nFailed: ",
      "stdout": "",
      "timestamp": 1660164575
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x) \n            res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    sort(res, (a, b) => a.first < b.first ? 1 : a.first == b.first ? 0 : -1);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp788d0elh.d(26): Error: no identifier for declarator `i`\n/tmp/tmp788d0elh.d(26): Error: found `-` when expecting `;`\n/tmp/tmp788d0elh.d(26): Error: expression expected, not `>`\n/tmp/tmp788d0elh.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmp788d0elh.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmp788d0elh.d(26): Error: found `if` when expecting `)`\n/tmp/tmp788d0elh.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmp788d0elh.d(29): Error: declaration expected, not `)`\n/tmp/tmp788d0elh.d(30): Error: unexpected `(` in declarator\n/tmp/tmp788d0elh.d(30): Error: basic type expected, not `(`\n/tmp/tmp788d0elh.d(30): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp788d0elh.d(30): Error: found `=>` when expecting `)`\n/tmp/tmp788d0elh.d(30): Error: no identifier for declarator `sort(res, _error_(a, b))`\n/tmp/tmp788d0elh.d(30): Error: semicolon expected following function declaration\n/tmp/tmp788d0elh.d(30): Error: n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n    sort(res, (a, b) -> {\n        if(a.first < b.first)\n            return -1;\n        if(a.first > b.first)\n            return 1;\n        return 0;\n    });\n    \n    sort(res, (a, b) -> {\n        if(a.second < b.second)\n            return -1;\n        if(a.second > b.second)\n            return 1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4kp6oz6o.d(27): Error: no identifier for declarator `i`\n/tmp/tmp4kp6oz6o.d(27): Error: found `-` when expecting `;`\n/tmp/tmp4kp6oz6o.d(27): Error: expression expected, not `>`\n/tmp/tmp4kp6oz6o.d(27): Error: found `foreach` when expecting `)`\n/tmp/tmp4kp6oz6o.d(27): Error: use `.` for member lookup, not `->`\n/tmp/tmp4kp6oz6o.d(27): Error: found `if` when expecting `)`\n/tmp/tmp4kp6oz6o.d(29): Error: found `res` when expecting `;` following statement\n/tmp/tmp4kp6oz6o.d(30): Error: declaration expected, not `)`\n/tmp/tmp4kp6oz6o.d(32): Error: unexpected `(` in declarator\n/tmp/tmp4kp6oz6o.d(32): Error: basic type expected, not `(`\n/tmp/tmp4kp6oz6o.d(32): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp4kp6oz6o.d(32): Error: found `-` when expecting `)`\n/tmp/tmp4kp6oz6o.d(32): Error: no identifier for declarator `sort(res, _error_(a, b))`\n/tmp/tmp4kp6oz6o.d(32): Error: semicolon expected following function declaration\n/tmp/tmp4kp6oz6o.d(32): Error: de",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; ++j)\n            {\n                result.add((i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxdtnayl6.d(38): Error: missing `{ ... }` for function literal\n/tmp/tmpxdtnayl6.d(38): Error: expression expected, not `>`\n/tmp/tmpxdtnayl6.d(38): Error: found `a` when expecting `,`\n/tmp/tmpxdtnayl6.d(39): Error: missing `{ ... }` for function literal\n/tmp/tmpxdtnayl6.d(39): Error: expression expected, not `>`\n/tmp/tmpxdtnayl6.d(39): Error: found `a` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdtnayl6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] == x)\n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw4kgkg_h.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmpw4kgkg_h.d(33): Error: no property `push` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw4kgkg_h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            for(int j = 0; j < lst[i].length; j++)\n            {\n                res.add((i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9eekj07b.d(25): Error: new can only create structs, dynamic arrays or class objects, not `Tuple!(long, long)[]`'s\n/tmp/tmp9eekj07b.d(32): Error: no property `add` for type `Tuple!(long, long)[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9eekj07b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(row: lst, i: int) \n    {\n        foreach(col: row, j: int) \n        {\n            if(col == x) \n            {\n                res.push(Tuple!(i, j));\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7wprxi8a.d(26): Error: no identifier for declarator `row`\n/tmp/tmp7wprxi8a.d(26): Error: found `:` when expecting `;`\n/tmp/tmp7wprxi8a.d(26): Error: found `:` when expecting `)`\n/tmp/tmp7wprxi8a.d(26): Error: no identifier for declarator `int`\n/tmp/tmp7wprxi8a.d(26): Error: found `)` instead of statement\n/tmp/tmp7wprxi8a.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7wprxi8a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row,lst){\n        if(row.length == x){\n            res = row;\n            break;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoa_4isn3.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpoa_4isn3.d(26): Error: found `)` when expecting `;`\n/tmp/tmpoa_4isn3.d(32): Error: found `return` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoa_4isn3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(row: lst) \n    {\n        foreach(col: row) \n        {\n            if(col == x) \n            {\n                result.push(Tuple!(long, long)((row, col)));\n            }\n        }\n    }\n    \n    sort(result);\n    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplkde7px2.d(27): Error: no identifier for declarator `row`\n/tmp/tmplkde7px2.d(27): Error: found `:` when expecting `;`\n/tmp/tmplkde7px2.d(29): Error: no identifier for declarator `col`\n/tmp/tmplkde7px2.d(29): Error: found `:` when expecting `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplkde7px2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L], [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_3mdsikv.d(26): Error: no identifier for declarator `i`\n/tmp/tmp_3mdsikv.d(26): Error: found `-` when expecting `;`\n/tmp/tmp_3mdsikv.d(26): Error: expression expected, not `>`\n/tmp/tmp_3mdsikv.d(26): Error: found `foreach` when expecting `)`\n/tmp/tmp_3mdsikv.d(26): Error: use `.` for member lookup, not `->`\n/tmp/tmp_3mdsikv.d(26): Error: found `if` when expecting `)`\n/tmp/tmp_3mdsikv.d(28): Error: found `res` when expecting `;` following statement\n/tmp/tmp_3mdsikv.d(29): Error: declaration expected, not `)`\n/tmp/tmp_3mdsikv.d(30): Error: function declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp_3mdsikv.d(30): Error: no identifier for declarator `sort(res)`\n/tmp/tmp_3mdsikv.d(31): Error: declaration expected, not `return`\n/tmp/tmp_3mdsikv.d(32): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_3mdsikv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164576
    }
  ]
}