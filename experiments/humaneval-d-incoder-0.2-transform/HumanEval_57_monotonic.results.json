{
  "language": "d",
  "name": "HumanEval_57_monotonic",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    while(i < l.length && j < l.length)\n    {\n        if(l[i] < l[j])\n        {\n            isIncreasing = false;\n        }\n        else if(l[i] > l[j])\n        {\n            isDecreasing = false;\n        }\n        i++;\n        j++;\n    }\n    if(isIncreasing && isDecreasing)\n    {\n        return true;\n    }\n    else if(isIncreasing && !isDecreasing)\n    {\n        return false;\n    }\n    else if(!isIncreasing && isDecreasing)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code>\n<|/ a tags=c++,sorting,arrays |>\n<| c |>\nI like your solution, but I think it can be improved by using std::sort and comparing only two elements at a time. Also, why do you use \"isIncreasing\" and \"isDecreasing\" instead of just \"isIncreasing\" and \"isDecreasing\"?\n<|/ c |>\n<| c |>\nI used isIncreasing and isDecreasing because I wanted to be sure that if one element was increasing and the other was decreasing, then they were both increasing. That way I wouldn't have to worry about what happened to the other element. Also, std::sort is O(n log n), so it's more efficient than my solution.\n<|/ c |>\n<| c |>\nOh, I see. Thanks for explaining that. :)\n<|/ c |>\n<| c |>\nI like your solution, but I think it can be improved by using std::sort and comparing only two elements at a time. Also, why do you use \"isIncreasing\" and \"isDecreasing\" instead of just \"isIncreasing\" and \"isDecreasing\"?\n<|/ c |>\n<| c |>\nI used isIncreasing and isDecreasing because I wanted to be sure that if one element was increasing and the other was decreasing, then they were both increasing. That way I wouldn't have to worry about what happened to the other element. Also, std::sort is O(n log n), so it's more efficient than my solution.\n<|/ c |>\n<| a tags=c++,sorting,arrays |>\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpz0bgri_a.d(50): Error: declaration expected, not `<`\n/tmp/tmpz0bgri_a.d(56): Error: unterminated character constant\n/tmp/tmpz0bgri_a.d(56): Error: unterminated character constant\n/tmp/tmpz0bgri_a.d(65): Error: unterminated character constant\n/tmp/tmpz0bgri_a.d(65): Error: unterminated character constant\n/tmp/tmpz0bgri_a.d(73): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(74): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(75): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(76): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(77): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(78): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(79): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(80): Error: declaration expected, not `assert`\n/tmp/tmpz0bgri_a.d(81): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz0bgri_a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164391
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n        {\n            isMonotonic = false;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpscdttm08.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpscdttm08.__unittest_L35_C1() [0x427ff1]\n??:? void tmpscdttm08.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphc2hbqla.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmphc2hbqla.__unittest_L26_C1() [0x427f47]\n??:? void tmphc2hbqla.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkecvbfm5.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpkecvbfm5.__unittest_L27_C1() [0x427eac]\n??:? void tmpkecvbfm5.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long first = l[0];\n    long last = l[0];\n    long curr = l[0];\n    long i;\n    bool result = true;\n    for (i = 1; i < l.length; ++i) {\n        curr = l[i];\n        if (curr < first) {\n            result = false;\n            break;\n        }\n        if (curr > last) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyggyzhoe.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpyggyzhoe.__unittest_L33_C1() [0x427e58]\n??:? void tmpyggyzhoe.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd239771a.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpd239771a.__unittest_L27_C1() [0x427f47]\n??:? void tmpd239771a.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0nantr7l.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp0nantr7l.__unittest_L30_C1() [0x427f4b]\n??:? void tmp0nantr7l.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i < l.length && j > 0) {\n        if(l[i] < l[j]) {\n            result = false;\n            break;\n        }\n        else if(l[i] > l[j]) {\n            result = true;\n            break;\n        }\n        else {\n            i++;\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp3cqv1zu3.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp3cqv1zu3.__unittest_L34_C1() [0x427e58]\n??:? void tmp3cqv1zu3.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpo2ldacun.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpo2ldacun.__unittest_L23_C1() [0x427f47]\n??:? void tmpo2ldacun.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tlong next = l[i];\n\t\tif (curr < next) {\n\t\t\tresult = false;\n\t\t}\n\t\telse if (curr > next) {\n\t\t\tresult = true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpg9zr6j0m.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmpg9zr6j0m.__unittest_L31_C1() [0x427e18]\n??:? void tmpg9zr6j0m.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; i++) \n    {\n        long next = l[i];\n        if(curr > next) \n        {\n            result = false;\n            break;\n        }\n        else if(curr < prev) \n        {\n            result = false;\n            break;\n        }\n        prev = curr;\n        curr = next;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpyaadv4vx.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpyaadv4vx.__unittest_L36_C1() [0x427f0d]\n??:? void tmpyaadv4vx.__modtest() [0x428090]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkecvbfm5.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpkecvbfm5.__unittest_L27_C1() [0x427eac]\n??:? void tmpkecvbfm5.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpelrbgmgc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpelrbgmgc.__unittest_L30_C1() [0x427f4b]\n??:? void tmpelrbgmgc.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplwnuq5vu.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmplwnuq5vu.__unittest_L30_C1() [0x427f47]\n??:? void tmplwnuq5vu.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            min = l[i];\n        }\n        if (l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    if (isMonotonic == false)\n    {\n        return false;\n    }\n    long mid = min + ((max - min) / 2);\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < mid)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,c# |>\n<code>\npublic bool IsMonotonic(List<int> list)\n{\n    if (list.Count < 2)\n    {\n        return true;\n    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8zjlue7k.d(43): Error: declaration expected, not `<`\n/tmp/tmp8zjlue7k.d(52): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8zjlue7k.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164391
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n            isMonotonic = false;\n            break;\n        }\n        if (l[i] > max) {\n            isMonotonic = false;\n            break;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp355s8j0w.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp355s8j0w.__unittest_L30_C1() [0x427e58]\n??:? void tmp355s8j0w.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0h5tc5u2.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp0h5tc5u2.__unittest_L30_C1() [0x427e9c]\n??:? void tmp0h5tc5u2.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptehbfshr.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmptehbfshr.__unittest_L27_C1() [0x427eac]\n??:? void tmptehbfshr.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpaa4fzmnz.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpaa4fzmnz.__unittest_L24_C1() [0x427f37]\n??:? void tmpaa4fzmnz.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max <= min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0nauyydv.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp0nauyydv.__unittest_L30_C1() [0x427e9c]\n??:? void tmp0nauyydv.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i-1] > l[i])\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsadg06wq.d(15): Error: variable `l` is shadowing variable `tmpsadg06wq.monotonic.l`\n/tmp/tmpsadg06wq.d(17): Error: no property `length` for type `long`\n/tmp/tmpsadg06wq.d(19): Error: only one index allowed to index `long`\n/tmp/tmpsadg06wq.d(19): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsadg06wq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164391
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\t\tlong next = l[i];\n\t\tif (curr < next) \n\t\t{\n\t\t\tif (curr < prev) \n\t\t\t\treturn false;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif (curr > prev) \n\t\t\t\treturn false;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpn1bgznjp.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmpn1bgznjp.__unittest_L37_C1() [0x427f2d]\n??:? void tmpn1bgznjp.__modtest() [0x4280b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b242]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430884]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430361]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]\n??:? runModuleUnitTests [0x42c185]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmple78_c26.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmple78_c26.__unittest_L26_C1() [0x427f47]\n??:? void tmple78_c26.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpr2767abc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpr2767abc.__unittest_L30_C1() [0x427f4b]\n??:? void tmpr2767abc.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            min = l[i];\n        }\n        if (l[i] > max)\n        {\n            max = l[i];\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp63da0m46.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp63da0m46.__unittest_L32_C1() [0x427eac]\n??:? void tmp63da0m46.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i;\n    long max = l[0];\n    bool result = true;\n    for(i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp7stbvyx.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42831d]\n??:? void tmpp7stbvyx.__unittest_L26_C1() [0x427e30]\n??:? void tmpp7stbvyx.__modtest() [0x42809c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b232]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430874]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430351]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]\n??:? runModuleUnitTests [0x42c175]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbh9oz_z5.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpbh9oz_z5.__unittest_L24_C1() [0x427f37]\n??:? void tmpbh9oz_z5.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong last = l[0];\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tcurr = l[i];\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4tz6lz48.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42835d]\n??:? void tmp4tz6lz48.__unittest_L36_C1() [0x427f0f]\n??:? void tmp4tz6lz48.__modtest() [0x4280e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b272]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430405]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430391]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]\n??:? runModuleUnitTests [0x42c1b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428820]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] > max) \n        {\n            max = l[i];\n        }\n        if(l[i] < min) \n        {\n            min = l[i];\n        }\n    }\n    return max >= min;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm |>\n<| c |>\nThis is not the best solution. Try it with a list with two elements: [1, 1] and [1, 2]. Your algorithm will return true while it should return false.\n<|/ c |>\n<| c |>\n: I agree, my algorithm is just an example to show that it is possible to implement a sorting algorithm with O(n) complexity (where n is the number of elements in the list). Of course, there are other algorithms that can achieve O(n) complexity (such as quicksort, heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n<| c |>\n: I agree, my algorithm is just an example to show that it is possible to implement a sorting algorithm with O(n) complexity (where n is the number of elements in the list). Of course, there are other algorithms that can achieve O(n) complexity (such as quicksort, heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n<| c |>\n: I agree, my algorithm is just an example to show that it is possible to implement a sorting algorithm with O(n) complexity (where n is the number of elements in the list). Of course, there are other algorithms that can achieve O(n) complexity (such as quicksort, heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n<| c |>\n: I agree, my algorithm is just an example to show that it is possible to implement a sorting algorithm with O(n) complexity (where n is the number of elements in the list). Of course, there are other algorithms that can achieve O(n) complexity (such as quicksort, heapsort, etc.), but this one is easy to implement and understand.\n<|/ c |>\n<| a tags=c#,sorting,algorithm |>\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8e4o3au9.d(30): Error: declaration expected, not `<`\n/tmp/tmp8e4o3au9.d(53): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(54): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(55): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(56): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(57): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(58): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(59): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(60): Error: declaration expected, not `assert`\n/tmp/tmp8e4o3au9.d(61): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8e4o3au9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptehbfshr.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmptehbfshr.__unittest_L27_C1() [0x427eac]\n??:? void tmptehbfshr.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    if(min > max)\n    {\n        result = false;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9x793v3u.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmp9x793v3u.__unittest_L35_C1() [0x427f53]\n??:? void tmp9x793v3u.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long first = l[0];\n    long last = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < first) {\n            result = false;\n            break;\n        }\n        else if(l[i] > last) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp50e1b2va.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp50e1b2va.__unittest_L30_C1() [0x427e58]\n??:? void tmp50e1b2va.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            result = false;\n            break;\n        }\n        if (l[i] > max)\n        {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp63tc_826.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp63tc_826.__unittest_L33_C1() [0x427e58]\n??:? void tmp63tc_826.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp28eqrq2u.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp28eqrq2u.__unittest_L26_C1() [0x427f47]\n??:? void tmp28eqrq2u.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < l)\n        {\n            l = l[i];\n        }\n    }\n    return l == l[0];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3x0dgqwb.d(15): Error: variable `l` is shadowing variable `tmp3x0dgqwb.monotonic.l`\n/tmp/tmp3x0dgqwb.d(16): Error: no property `length` for type `long`\n/tmp/tmp3x0dgqwb.d(18): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(20): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(23): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3x0dgqwb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpx0b9drig.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpx0b9drig.__unittest_L26_C1() [0x427f47]\n??:? void tmpx0b9drig.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n = l.length;\n    if (n < 2) return true;\n    if (l[0] > l[1]) return true;\n    if (l[n-1] < l[n-2]) return true;\n    for (int i = 1; i < n-1; ++i) {\n        if (l[i] > l[i-1]) return true;\n        if (l[i] < l[i+1]) return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp938gjx18.d(15): Error: cannot implicitly convert expression `l.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp938gjx18.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < l)\n        {\n            l = l[i];\n        }\n    }\n    return l == l[0];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3x0dgqwb.d(15): Error: variable `l` is shadowing variable `tmp3x0dgqwb.monotonic.l`\n/tmp/tmp3x0dgqwb.d(16): Error: no property `length` for type `long`\n/tmp/tmp3x0dgqwb.d(18): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(20): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(23): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3x0dgqwb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpplg6caot.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpplg6caot.__unittest_L26_C1() [0x427f47]\n??:? void tmpplg6caot.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2mi1rsss.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp2mi1rsss.__unittest_L30_C1() [0x427f4b]\n??:? void tmp2mi1rsss.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| a dscore=2 |>\n<code>\npublic static bool IsMonotonic(this IEnumerable<int> list)\n{\n    if (list == null)\n    {\n        throw new ArgumentNullException(\"list\");\n    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp30krvkx2.d(30): Error: declaration expected, not `<`\n/tmp/tmp30krvkx2.d(39): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp30krvkx2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmppzyr8q1o.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmppzyr8q1o.__unittest_L35_C1() [0x427ff1]\n??:? void tmppzyr8q1o.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfv5ernsx.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpfv5ernsx.__unittest_L30_C1() [0x427f4b]\n??:? void tmpfv5ernsx.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    long max = l[0];\n    bool result = true;\n    while(i < l.length && j < l.length) {\n        if(l[i] < l[j]) {\n            max = l[i];\n            i++;\n        } else {\n            max = l[j];\n            j++;\n        }\n        if(max < l[i]) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp72_ckxc.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpp72_ckxc.__unittest_L34_C1() [0x427eb4]\n??:? void tmpp72_ckxc.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfv5ernsx.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpfv5ernsx.__unittest_L30_C1() [0x427f4b]\n??:? void tmpfv5ernsx.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpaa4fzmnz.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpaa4fzmnz.__unittest_L24_C1() [0x427f37]\n??:? void tmpaa4fzmnz.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5pah2kga.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp5pah2kga.__unittest_L27_C1() [0x427f47]\n??:? void tmp5pah2kga.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj8jmcscc.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpj8jmcscc.__unittest_L31_C1() [0x427f53]\n??:? void tmpj8jmcscc.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n = l.length;\n    if (n < 2) return true;\n    long m = l[0], last = l[0];\n    for (int i = 1; i < n; ++i)\n    {\n        long next = l[i];\n        if (next < last)\n        {\n            return false;\n        }\n        last = next;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp07zk12bf.d(15): Error: cannot implicitly convert expression `l.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp07zk12bf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpu2xwve1o.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpu2xwve1o.__unittest_L26_C1() [0x427eac]\n??:? void tmpu2xwve1o.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpq26immvy.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpq26immvy.__unittest_L30_C1() [0x427f4b]\n??:? void tmpq26immvy.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] > max) \n        {\n            max = l[i];\n        }\n        if(l[i] < min) \n        {\n            min = l[i];\n        }\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfkjiz_b7.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpfkjiz_b7.__unittest_L30_C1() [0x427f37]\n??:? void tmpfkjiz_b7.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplwnuq5vu.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmplwnuq5vu.__unittest_L30_C1() [0x427f47]\n??:? void tmplwnuq5vu.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp80mhc2g_.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp80mhc2g_.__unittest_L26_C1() [0x427f47]\n??:? void tmp80mhc2g_.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i < l.length && j < l.length) {\n        if(l[i] < l[j]) {\n            result = false;\n            break;\n        }\n        else if(l[i] > l[j]) {\n            result = true;\n            break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpixt7jq5f.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpixt7jq5f.__unittest_L32_C1() [0x427e5c]\n??:? void tmpixt7jq5f.__modtest() [0x4280c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            isMonotonic = false;\n            break;\n        }\n        if (l[i] > max)\n        {\n            isMonotonic = false;\n            break;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp6c3ldsi8.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp6c3ldsi8.__unittest_L33_C1() [0x427e58]\n??:? void tmp6c3ldsi8.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd239771a.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpd239771a.__unittest_L27_C1() [0x427f47]\n??:? void tmpd239771a.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    long r = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i] < r)\n        {\n            return false;\n        }\n        r = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp970bgok2.d(15): Error: variable `l` is shadowing variable `tmp970bgok2.monotonic.l`\n/tmp/tmp970bgok2.d(16): Error: only one index allowed to index `long`\n/tmp/tmp970bgok2.d(17): Error: no property `length` for type `long`\n/tmp/tmp970bgok2.d(19): Error: only one index allowed to index `long`\n/tmp/tmp970bgok2.d(23): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp970bgok2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp00nqth4_.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp00nqth4_.__unittest_L36_C1() [0x427ff5]\n??:? void tmp00nqth4_.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i;\n    long max = l[0];\n    bool isMonotonic = true;\n    for (i = 1; i < l.length; ++i) {\n        if (l[i] > max) {\n            max = l[i];\n            isMonotonic = false;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp0y9sgtr.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42831d]\n??:? void tmpp0y9sgtr.__unittest_L26_C1() [0x427e30]\n??:? void tmpp0y9sgtr.__modtest() [0x42809c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b232]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430874]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430351]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]\n??:? runModuleUnitTests [0x42c175]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1m3p5oz2.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp1m3p5oz2.__unittest_L23_C1() [0x427f47]\n??:? void tmp1m3p5oz2.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfbacr71j.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpfbacr71j.__unittest_L30_C1() [0x427e58]\n??:? void tmpfbacr71j.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpip4kx7lm.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpip4kx7lm.__unittest_L30_C1() [0x427eac]\n??:? void tmpip4kx7lm.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = 0;\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkmtm4lkb.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42832d]\n??:? void tmpkmtm4lkb.__unittest_L33_C1() [0x427e40]\n??:? void tmpkmtm4lkb.__modtest() [0x4280ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b242]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430884]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430361]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]\n??:? runModuleUnitTests [0x42c185]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            min = l[i];\n        }\n        if (l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    if (isMonotonic)\n    {\n        if (min < max)\n        {\n            return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphfi0s_3e.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x4283ad]\n??:? void tmphfi0s_3e.__unittest_L38_C1() [0x427f5b]\n??:? void tmphfi0s_3e.__modtest() [0x42812c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c42f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430455]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430904]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]\n??:? runModuleUnitTests [0x42c205]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428870]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpctsvach2.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpctsvach2.__unittest_L35_C1() [0x427ea8]\n??:? void tmpctsvach2.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    int k = l.length - 1;\n    long curr = l[i];\n    long next = l[j];\n    long prev;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n    \n    while (i < k && j < k) {\n        if (curr < next) {\n            prev = curr;\n            curr = next;\n            next = l[j];\n            isIncreasing = false;\n        } else if (curr > next) {\n            prev = curr;\n            curr = next;\n            next = l[j];\n            isDecreasing = false;\n        } else {\n            prev = curr;\n            curr = next;\n            next = l[j];\n        }\n        j++;\n    }\n    \n    if (isIncreasing) {\n        if (prev > curr) {\n            isDecreasing = false;\n        }\n    } else {\n        if (prev < curr) {\n            isIncreasing = false;\n        }\n    }\n    \n    return isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kzk3hkl.d(17): Error: cannot implicitly convert expression `l.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kzk3hkl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpc8v9xagz.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpc8v9xagz.__unittest_L35_C1() [0x427ff1]\n??:? void tmpc8v9xagz.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            result = false;\n            break;\n        }\n        else if(l[i] > curr)\n        {\n            prev = curr;\n            curr = l[i];\n        }\n    }\n    if(!result)\n    {\n        prev = curr;\n        curr = l[0];\n    }\n    return result && (prev < curr);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpe_gsqvvx.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4283ad]\n??:? void tmpe_gsqvvx.__unittest_L38_C1() [0x427fa9]\n??:? void tmpe_gsqvvx.__modtest() [0x42812c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c42f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430455]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430904]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]\n??:? runModuleUnitTests [0x42c205]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428870]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (l[i] > curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t}\n\t\telse if (l[i] == prev)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisIncreasing = true;\n\t\t\tisDecreasing = true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = l[i];\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0z6ssn32.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4283c5]\n??:? void tmp0z6ssn32.__unittest_L44_C1() [0x42812e]\n??:? void tmp0z6ssn32.__modtest() [0x428148]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c447]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43046d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43091c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2b1]\n??:? runModuleUnitTests [0x42c21d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428888]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1kyijznr.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp1kyijznr.__unittest_L30_C1() [0x427eb0]\n??:? void tmp1kyijznr.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5c7n4oio.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp5c7n4oio.__unittest_L31_C1() [0x427f43]\n??:? void tmp5c7n4oio.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbh9oz_z5.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpbh9oz_z5.__unittest_L24_C1() [0x427f37]\n??:? void tmpbh9oz_z5.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i) {\n        long next = l[i];\n        if (curr > next) {\n            result = false;\n            break;\n        }\n        prev = curr;\n        curr = next;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfi0iuw9t.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpfi0iuw9t.__unittest_L29_C1() [0x427ef5]\n??:? void tmpfi0iuw9t.__modtest() [0x428078]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c377]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b20a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43039d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43084c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430329]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]\n??:? runModuleUnitTests [0x42c14d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n    }\n    return min <= max;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| c |>\nThis doesn't work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` returns `true`, but `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `false`.\n<|/ c |>\n<| c |>\n: It does work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| c |>\n: It does work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| c |>\n: It does work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| c |>\n: It does work for negative numbers. `monotonic([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])` returns `true`.\n<|/ c |>\n<| a tags=c#,algorithm,sorting |>\nI wrote a C# version that works correctly for negative numbers and also for duplicate numbers. \n<code>\npublic static bool IsMonotonic(IEnumerable<int> numbers)\n{\n    var numberSet = new HashSet<int>(numbers);\n    if (numberSet.Count == 0)\n        return true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn4a1gilt.d(26): Error: declaration expected, not `<`\n/tmp/tmpn4a1gilt.d(29): Error: unterminated character constant\n/tmp/tmpn4a1gilt.d(49): Error: declaration expected, not `if`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn4a1gilt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpov5lzla3.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpov5lzla3.__unittest_L30_C1() [0x427eac]\n??:? void tmpov5lzla3.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tbool isIncreasing = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < curr)\n\t\t{\n\t\t\tisIncreasing = false;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = l[i];\n\t\t}\n\t}\n\treturn isIncreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp7hymae7f.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42831d]\n??:? void tmp7hymae7f.__unittest_L33_C1() [0x427f1d]\n??:? void tmp7hymae7f.__modtest() [0x4280a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b232]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430874]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430351]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]\n??:? runModuleUnitTests [0x42c175]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong last = l[0];\n\tlong cur = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < cur)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tlast = cur;\n\t\tcur = l[i];\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpligjl_03.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmpligjl_03.__unittest_L28_C1() [0x427f35]\n??:? void tmpligjl_03.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b24a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43088c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430369]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b221]\n??:? runModuleUnitTests [0x42c18d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpu89hbrce.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpu89hbrce.__unittest_L30_C1() [0x427f47]\n??:? void tmpu89hbrce.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n            max = l[i];\n        if(l[i] < min)\n            min = l[i];\n    }\n    return max >= min;\n}\n</code>\n<|/ a tags=c#,algorithm,sorting |>\n<| c |>\nThis doesn't work. Try it with `monotonic([1L, 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L, 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L, 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L, 2L, 4L, 20L])`\n<|/ c |>\n<| c |>\n: It does work. Try it with `monotonic([1L, 2L, 4L, 20L])`\n<|/ c |>\n<| a tags=c#,algorithm,sorting |>\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp10qm6y26.d(26): Error: declaration expected, not `<`\n/tmp/tmp10qm6y26.d(29): Error: unterminated character constant\n/tmp/tmp10qm6y26.d(49): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(50): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(51): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(52): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(53): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(54): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(55): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(56): Error: declaration expected, not `assert`\n/tmp/tmp10qm6y26.d(57): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp10qm6y26.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkecvbfm5.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpkecvbfm5.__unittest_L27_C1() [0x427eac]\n??:? void tmpkecvbfm5.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpaa4fzmnz.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpaa4fzmnz.__unittest_L24_C1() [0x427f37]\n??:? void tmpaa4fzmnz.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp127ypp37.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp127ypp37.__unittest_L26_C1() [0x427f47]\n??:? void tmp127ypp37.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0ddoaium.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp0ddoaium.__unittest_L30_C1() [0x427f47]\n??:? void tmp0ddoaium.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n        {\n            result = false;\n        }\n    }\n    return result;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwh9y7fnh.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpwh9y7fnh.__unittest_L45_C1() [0x427ff1]\n??:? void tmpwh9y7fnh.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = 0;\n\tlong max = l[0];\n\tlong mid = 0;\n\tbool isIncreasing = true;\n\tbool isDecreasing = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tmid = l[i];\n\t\tif (mid > max)\n\t\t{\n\t\t\tmax = mid;\n\t\t\tisDecreasing = false;\n\t\t}\n\t\telse if (mid < min)\n\t\t{\n\t\t\tmin = mid;\n\t\t\tisIncreasing = false;\n\t\t}\n\t}\n\treturn isIncreasing || isDecreasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpafg3jlhy.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpafg3jlhy.__unittest_L36_C1() [0x427ed3]\n??:? void tmpafg3jlhy.__modtest() [0x4280a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b23a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43087c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430359]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b211]\n??:? runModuleUnitTests [0x42c17d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) {\n            min = l[i];\n        } else if(l[i] > max) {\n            max = l[i];\n        } else {\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2krdxavg.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp2krdxavg.__unittest_L29_C1() [0x427ff1]\n??:? void tmp2krdxavg.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkg3plenj.d(15): Error: variable `l` is shadowing variable `tmpkg3plenj.monotonic.l`\n/tmp/tmpkg3plenj.d(16): Error: no property `length` for type `long`\n/tmp/tmpkg3plenj.d(18): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkg3plenj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i < l.length && j > 0) {\n        if(l[i] < l[j]) {\n            result = false;\n            break;\n        }\n        else if(l[i] > l[j]) {\n            result = true;\n            break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpvekysjya.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpvekysjya.__unittest_L32_C1() [0x427e58]\n??:? void tmpvekysjya.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 1;\n    bool result = true;\n    while(i < l.length && j < l.length)\n    {\n        if(l[i] < l[j])\n        {\n            result = false;\n            break;\n        }\n        else if(l[i] > l[j])\n        {\n            result = true;\n            break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpxfak6qge.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpxfak6qge.__unittest_L35_C1() [0x427e5c]\n??:? void tmpxfak6qge.__modtest() [0x4280c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n            min = l[i];\n        } else if (l[i] > max) {\n            max = l[i];\n        } else {\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpp1mqwhk_.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpp1mqwhk_.__unittest_L29_C1() [0x427ff1]\n??:? void tmpp1mqwhk_.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpb1zoi5l6.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpb1zoi5l6.__unittest_L30_C1() [0x427e9c]\n??:? void tmpb1zoi5l6.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool first = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t}\n\t\telse {\n\t\t\tif (l[i] < min) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (l[i] > max) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpv6mn4d01.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428415]\n??:? void tmpv6mn4d01.__unittest_L39_C1() [0x427fc7]\n??:? void tmpv6mn4d01.__modtest() [0x428198]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c497]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b32a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43096c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430449]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b301]\n??:? runModuleUnitTests [0x42c26d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288d8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0nantr7l.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp0nantr7l.__unittest_L30_C1() [0x427f4b]\n??:? void tmp0nantr7l.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long l = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < l)\n        {\n            l = l[i];\n        }\n    }\n    return l == l[0];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3x0dgqwb.d(15): Error: variable `l` is shadowing variable `tmp3x0dgqwb.monotonic.l`\n/tmp/tmp3x0dgqwb.d(16): Error: no property `length` for type `long`\n/tmp/tmp3x0dgqwb.d(18): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(20): Error: only one index allowed to index `long`\n/tmp/tmp3x0dgqwb.d(23): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3x0dgqwb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n    }\n    return max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpu4xb_wf_.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpu4xb_wf_.__unittest_L30_C1() [0x427eac]\n??:? void tmpu4xb_wf_.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmprqo17e4v.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmprqo17e4v.__unittest_L23_C1() [0x427f47]\n??:? void tmprqo17e4v.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp241kbduf.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp241kbduf.__unittest_L32_C1() [0x427eac]\n??:? void tmp241kbduf.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            result = false;\n            break;\n        }\n        else if(l[i] > curr)\n        {\n            prev = curr;\n            curr = l[i];\n        }\n    }\n    prev = curr;\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_dd8wvin.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x428355]\n??:? void tmp_dd8wvin.__unittest_L34_C1() [0x427f51]\n??:? void tmp_dd8wvin.__modtest() [0x4280d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b26a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ac]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430389]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]\n??:? runModuleUnitTests [0x42c1ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428818]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    long next = 1;\n    bool result = true;\n    \n    for(int i = 1; i < l.length; ++i)\n    {\n        prev = curr;\n        curr = next;\n        next = l[i];\n        \n        if(curr < prev)\n        {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpxo7tb1y6.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpxo7tb1y6.__unittest_L35_C1() [0x427ef9]\n??:? void tmpxo7tb1y6.__modtest() [0x42807c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) {\n            min = l[i];\n        }\n        if(l[i] > max) {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp39yso247.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp39yso247.__unittest_L27_C1() [0x427f47]\n??:? void tmp39yso247.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0nantr7l.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp0nantr7l.__unittest_L30_C1() [0x427f4b]\n??:? void tmp0nantr7l.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpn_11rcw7.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpn_11rcw7.__unittest_L30_C1() [0x427f47]\n??:? void tmpn_11rcw7.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1m3p5oz2.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp1m3p5oz2.__unittest_L23_C1() [0x427f47]\n??:? void tmp1m3p5oz2.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n = l.length;\n    if (n < 2) return true;\n    long m = l[0];\n    for (int i = 1; i < n; ++i) {\n        if (l[i] < m) return false;\n        m = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwcgw690d.d(15): Error: cannot implicitly convert expression `l.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwcgw690d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool first = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse if (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (first)\n\t\t\t{\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2sw3fr5t.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmp2sw3fr5t.__unittest_L42_C1() [0x42805e]\n??:? void tmp2sw3fr5t.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpr2767abc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpr2767abc.__unittest_L30_C1() [0x427f4b]\n??:? void tmpr2767abc.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; i++) \n\t{\n\t\tif(l[i] < min) min = l[i];\n\t\tif(l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpargnvnji.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpargnvnji.__unittest_L24_C1() [0x427f37]\n??:? void tmpargnvnji.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    if(min > max)\n    {\n        result = false;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9x793v3u.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmp9x793v3u.__unittest_L35_C1() [0x427f53]\n??:? void tmp9x793v3u.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpx5vfs5lf.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283ed]\n??:? void tmpx5vfs5lf.__unittest_L31_C1() [0x427f9f]\n??:? void tmpx5vfs5lf.__modtest() [0x428170]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c46f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b302]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430495]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430944]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430421]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d9]\n??:? runModuleUnitTests [0x42c245]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplwnuq5vu.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmplwnuq5vu.__unittest_L30_C1() [0x427f47]\n??:? void tmplwnuq5vu.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            return false;\n        }\n        else if(l[i] > prev)\n        {\n            return true;\n        }\n        prev = curr;\n        curr = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp59xb8hzp.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428365]\n??:? void tmp59xb8hzp.__unittest_L32_C1() [0x427f13]\n??:? void tmp59xb8hzp.__modtest() [0x4280e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b27a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43040d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308bc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430399]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b251]\n??:? runModuleUnitTests [0x42c1bd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428828]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tmax = max(max, l[i]);\n\t\tmin = min(min, l[i]);\n\t}\n\treturn (max < min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpune3l_oc.d(18): Error: function expected before `()`, not `max` of type `long`\n/tmp/tmpune3l_oc.d(19): Error: function expected before `()`, not `min` of type `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpune3l_oc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) {\n            min = l[i];\n        }\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    if (min > max) {\n        result = false;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwojd2qjv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpwojd2qjv.__unittest_L31_C1() [0x427f53]\n??:? void tmpwojd2qjv.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tfor(int i = 1; i < l.length; i++)\n\t{\n\t\tif(l[i] < l)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgy6etppa.d(15): Error: variable `l` is shadowing variable `tmpgy6etppa.monotonic.l`\n/tmp/tmpgy6etppa.d(16): Error: no property `length` for type `long`\n/tmp/tmpgy6etppa.d(18): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgy6etppa.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpo4kt4s_g.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpo4kt4s_g.__unittest_L30_C1() [0x427f47]\n??:? void tmpo4kt4s_g.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev = 0;\n\tlong curr = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tlong next = l[i];\n\t\tif (curr > next)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (curr < prev)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmphgabik3x.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmphgabik3x.__unittest_L33_C1() [0x427e20]\n??:? void tmphgabik3x.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcwlm7ls3.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpcwlm7ls3.__unittest_L34_C1() [0x427faf]\n??:? void tmpcwlm7ls3.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkh0wt8hd.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpkh0wt8hd.__unittest_L27_C1() [0x427f47]\n??:? void tmpkh0wt8hd.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmptehbfshr.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmptehbfshr.__unittest_L27_C1() [0x427eac]\n??:? void tmptehbfshr.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max <= min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0nauyydv.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmp0nauyydv.__unittest_L30_C1() [0x427e9c]\n??:? void tmp0nauyydv.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpaa4fzmnz.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmpaa4fzmnz.__unittest_L24_C1() [0x427f37]\n??:? void tmpaa4fzmnz.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i = 0;\n    int j = 0;\n    bool result = true;\n    while(i < l.length && j < l.length) \n    {\n        if(l[i] < l[j]) \n        {\n            result = false;\n            break;\n        }\n        else if(l[i] > l[j]) \n        {\n            result = true;\n            break;\n        }\n        i++;\n        j++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++,sorting,arrays |>\n<| c |>\nThis code is not working as expected. `monotonic([1L, 2L, 4L, 20L])` returns `true` while it should be `false`.\n<|/ c |>\n<| c |>\nI tested it on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C) and it returns `false`. What compiler are you using?\n<|/ c |>\n<| c |>\nI'm using Visual Studio 2019. Maybe it's an issue with my compiler.\n<|/ c |>\n<| c |>\nIt works fine on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C). Maybe you have a problem with your compiler. Try reinstalling it.\n<|/ c |>\n<| c |>\nI tested it on [onlinegdb](https://onlinegdb.com/Syw0Y9Y9C) and it returns `false`. Maybe it's an issue with my compiler.\n<|/ c |>\n<| a |>\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpohjtl4f8.d(35): Error: declaration expected, not `<`\n/tmp/tmpohjtl4f8.d(44): Error: unterminated character constant\n/tmp/tmpohjtl4f8.d(44): Error: unterminated character constant\n/tmp/tmpohjtl4f8.d(58): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(59): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(60): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(61): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(62): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(63): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(64): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(65): Error: declaration expected, not `assert`\n/tmp/tmpohjtl4f8.d(66): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpohjtl4f8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max=0;\n\tlong min=l[0];\n\tfor(int i=1;i<l.length;i++)\n\t{\n\t\tif(l[i]>max)\n\t\t\tmax=l[i];\n\t\tif(l[i]<min)\n\t\t\tmin=l[i];\n\t}\n\tif(max<min)\n\t\treturn false;\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpcnex0s4z.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42837d]\n??:? void tmpcnex0s4z.__unittest_L28_C1() [0x427f2b]\n??:? void tmpcnex0s4z.__modtest() [0x4280fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b292]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430425]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308d4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b269]\n??:? runModuleUnitTests [0x42c1d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428840]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min || l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpsvkm_3rc.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4283ed]\n??:? void tmpsvkm_3rc.__unittest_L35_C1() [0x427f9f]\n??:? void tmpsvkm_3rc.__modtest() [0x428170]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c46f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b302]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430495]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430944]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430421]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2d9]\n??:? runModuleUnitTests [0x42c245]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288b0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp9cc_bpld.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmp9cc_bpld.__unittest_L30_C1() [0x427e58]\n??:? void tmp9cc_bpld.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return max >= min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp127ypp37.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp127ypp37.__unittest_L26_C1() [0x427f47]\n??:? void tmp127ypp37.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n        {\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpzrlikfhr.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpzrlikfhr.__unittest_L35_C1() [0x427ff1]\n??:? void tmpzrlikfhr.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] < min)\n\t\t\tmin = l[i];\n\t\tif(l[i] > max)\n\t\t\tmax = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpigq5s7it.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpigq5s7it.__unittest_L26_C1() [0x427f47]\n??:? void tmpigq5s7it.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (max < min) {\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp8oif2gka.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmp8oif2gka.__unittest_L31_C1() [0x427f53]\n??:? void tmp8oif2gka.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\tif (min < max)\n\t{\n\t\tisMonotonic = false;\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpctsvach2.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpctsvach2.__unittest_L35_C1() [0x427ea8]\n??:? void tmpctsvach2.__modtest() [0x428114]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplwnuq5vu.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmplwnuq5vu.__unittest_L30_C1() [0x427f47]\n??:? void tmplwnuq5vu.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long last = l[0];\n    long curr = l[0];\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < last) {\n            return false;\n        }\n        if (l[i] > curr) {\n            return true;\n        }\n        last = curr;\n        curr = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2nipev7h.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428375]\n??:? void tmp2nipev7h.__unittest_L29_C1() [0x427f27]\n??:? void tmp2nipev7h.__modtest() [0x4280f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b28a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43041d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308cc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b261]\n??:? runModuleUnitTests [0x42c1cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428838]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (min > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpj8jmcscc.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4283a5]\n??:? void tmpj8jmcscc.__unittest_L31_C1() [0x427f53]\n??:? void tmpj8jmcscc.__modtest() [0x428124]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c427]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43044d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308fc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b291]\n??:? runModuleUnitTests [0x42c1fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428868]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpr2767abc.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpr2767abc.__unittest_L30_C1() [0x427f4b]\n??:? void tmpr2767abc.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool result = true;\n    for (int i = 1; i < l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n            min = l[i];\n        }\n        else if (l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n        {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbiqrq1cu.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpbiqrq1cu.__unittest_L36_C1() [0x427ff5]\n??:? void tmpbiqrq1cu.__modtest() [0x428120]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i] < min) min = l[i];\n\t\tif (l[i] > max) max = l[i];\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpty67zk76.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpty67zk76.__unittest_L23_C1() [0x427f47]\n??:? void tmpty67zk76.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < l)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnfprqhm6.d(15): Error: variable `l` is shadowing variable `tmpnfprqhm6.monotonic.l`\n/tmp/tmpnfprqhm6.d(16): Error: no property `length` for type `long`\n/tmp/tmpnfprqhm6.d(18): Error: only one index allowed to index `long`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnfprqhm6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        else if(l[i] > max)\n        {\n            max = l[i];\n        }\n        else\n        {\n            result = false;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpndlvpt_e.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42839d]\n??:? void tmpndlvpt_e.__unittest_L35_C1() [0x427ff1]\n??:? void tmpndlvpt_e.__modtest() [0x42811c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c41f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430445]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308f4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]\n??:? runModuleUnitTests [0x42c1f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428860]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    bool isMonotonic = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            isMonotonic = false;\n            break;\n        }\n        if(l[i] > max)\n        {\n            isMonotonic = false;\n            break;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpkb3lctwj.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428345]\n??:? void tmpkb3lctwj.__unittest_L33_C1() [0x427e58]\n??:? void tmpkb3lctwj.__modtest() [0x4280c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b25a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43089c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430379]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b231]\n??:? runModuleUnitTests [0x42c19d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428808]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1m3p5oz2.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp1m3p5oz2.__unittest_L23_C1() [0x427f47]\n??:? void tmp1m3p5oz2.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n = l.length;\n    if (n < 2) return true;\n    long first = l[0];\n    long last = l[n-1];\n    long mid = first + (n-1)/2;\n    long mid2 = mid + (n-1)/2;\n    long mid3 = mid2 + (n-1)/2;\n    long mid4 = mid3 + (n-1)/2;\n    long mid5 = mid4 + (n-1)/2;\n    long mid6 = mid5 + (n-1)/2;\n    long mid7 = mid6 + (n-1)/2;\n    long mid8 = mid7 + (n-1)/2;\n    long mid9 = mid8 + (n-1)/2;\n    long mid10 = mid9 + (n-1)/2;\n    long mid11 = mid10 + (n-1)/2;\n    long mid12 = mid11 + (n-1)/2;\n    long mid13 = mid12 + (n-1)/2;\n    long mid14 = mid13 + (n-1)/2;\n    long mid15 = mid14 + (n-1)/2;\n    long mid16 = mid15 + (n-1)/2;\n    long mid17 = mid16 + (n-1)/2;\n    long mid18 = mid17 + (n-1)/2;\n    long mid19 = mid18 + (n-1)/2;\n    long mid20 = mid19 + (n-1)/2;\n    long mid21 = mid20 + (n-1)/2;\n    long mid22 = mid21 + (n-1)/2;\n    long mid23 = mid22 + (n-1)/2;\n    long mid24 = mid23 + (n-1)/2;\n    long mid25 = mid24 + (n-1)/2;\n    long mid26 = mid25 + (n-1)/2;\n    long mid27 = mid26 + (n-1)/2;\n    long mid28 = mid27 + (n-1)/2;\n    long mid29 = mid28 + (n-1)/2;\n    long mid30 = mid29 + (n-1)/2;\n    long mid31 = mid30 + (n-1)/2;\n    long mid32 = mid31 + (n-1)/2;\n    long mid33 = mid32 + (n-1)/2;\n    long mid34 = mid33 + (n-1)/2;\n    long mid35 = mid34 + (n-1)/2;\n    long mid36 = mid35 + (n-1)/2;\n    long mid37 = mid36 + (n-1)/2;\n    long mid38 = mid37 + (n-1)/2;\n    long mid39 = \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2xmdahoa.d(58): Error: expression expected, not `unittest`\n/tmp/tmp2xmdahoa.d(59): Error: semicolon expected, not `{`\n/tmp/tmp2xmdahoa.d(71): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2xmdahoa.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return max >= min;\n}\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5o5gftol.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp5o5gftol.__unittest_L37_C1() [0x427f47]\n??:? void tmp5o5gftol.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < min) min = l[i];\n        if (l[i] > max) max = l[i];\n    }\n    if (isMonotonic) {\n        if (min < max) {\n            isMonotonic = false;\n        }\n    }\n    return isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdwbebfj3.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4283ad]\n??:? void tmpdwbebfj3.__unittest_L29_C1() [0x427ec0]\n??:? void tmpdwbebfj3.__modtest() [0x42812c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c42f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430455]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430904]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]\n??:? runModuleUnitTests [0x42c205]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428870]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] > max) {\n            max = l[i];\n        }\n        if(l[i] < min) {\n            min = l[i];\n        }\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpd239771a.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpd239771a.__unittest_L27_C1() [0x427f47]\n??:? void tmpd239771a.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(curr < l[i])\n        {\n            return false;\n        }\n        else if(curr > l[i])\n        {\n            prev = curr;\n            curr = l[i];\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp73sagh95.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x42834d]\n??:? void tmp73sagh95.__unittest_L31_C1() [0x427e64]\n??:? void tmp73sagh95.__modtest() [0x4280d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b262]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430381]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]\n??:? runModuleUnitTests [0x42c1a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428810]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev = 0;\n    long curr = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < curr)\n        {\n            return false;\n        }\n        else if(l[i] > curr)\n        {\n            return true;\n        }\n        else if(l[i] == prev)\n        {\n            continue;\n        }\n        else if(l[i] < prev)\n        {\n            return false;\n        }\n        prev = curr;\n        curr = l[i];\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpncwo3r5i.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4283bd]\n??:? void tmpncwo3r5i.__unittest_L40_C1() [0x427f6f]\n??:? void tmpncwo3r5i.__modtest() [0x428140]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c43f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430465]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430914]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2a9]\n??:? runModuleUnitTests [0x42c215]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428880]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1m3p5oz2.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp1m3p5oz2.__unittest_L23_C1() [0x427f47]\n??:? void tmp1m3p5oz2.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmplre2h2lq.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428385]\n??:? void tmplre2h2lq.__unittest_L30_C1() [0x427f37]\n??:? void tmplre2h2lq.__modtest() [0x428108]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c407]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b29a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43042d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]\n??:? runModuleUnitTests [0x42c1dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428848]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpo4kt4s_g.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpo4kt4s_g.__unittest_L30_C1() [0x427f47]\n??:? void tmpo4kt4s_g.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp898onf80.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp898onf80.__unittest_L30_C1() [0x427f47]\n??:? void tmp898onf80.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n    }\n    return min <= max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpnsywyzh8.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpnsywyzh8.__unittest_L26_C1() [0x427f47]\n??:? void tmpnsywyzh8.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164392
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t}\n\treturn (max <= min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpqk7kskz0.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmpqk7kskz0.__unittest_L26_C1() [0x427eac]\n??:? void tmpqk7kskz0.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2w6yc0pm.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428335]\n??:? void tmp2w6yc0pm.__unittest_L33_C1() [0x427e4c]\n??:? void tmp2w6yc0pm.__modtest() [0x4280b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b24a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303dd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43088c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430369]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b221]\n??:? runModuleUnitTests [0x42c18d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287f8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt2ef05s6.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x4283fd]\n??:? void tmpt2ef05s6.__unittest_L39_C1() [0x427faf]\n??:? void tmpt2ef05s6.__modtest() [0x428180]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c47f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b312]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430954]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]\n??:? runModuleUnitTests [0x42c255]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4288c0]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tif(l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\tif(l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max > min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp5swy7slo.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp5swy7slo.__unittest_L30_C1() [0x427f47]\n??:? void tmp5swy7slo.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164394
    },
    {
      "exit_code": 1,
      "program": "import std.math;\nimport std.typecons;\n/*\nReturn True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min = l[0];\n    long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n        {\n            min = l[i];\n        }\n        if(l[i] > max)\n        {\n            max = l[i];\n        }\n    }\n    return min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp0ddoaium.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x428395]\n??:? void tmp0ddoaium.__unittest_L30_C1() [0x427f47]\n??:? void tmp0ddoaium.__modtest() [0x428118]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c417]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b2aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43043d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308ec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303c9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]\n??:? runModuleUnitTests [0x42c1ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428858]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164393
    }
  ]
}