language: py
name: HumanEval_119_match_parens
results:
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for elem in lst:\n        if elem ==\
    \ '(':\n            stack.append(elem)\n        elif elem == ')':\n          \
    \  if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \    if len(stack) > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5rxw83q9.py\"\
    , line 50, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5rxw83q9.py\"\
    , line 48, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp5rxw83q9.py\"\
    , line 34, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpurpmsz7z.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpurpmsz7z.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpurpmsz7z.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack[-1]\
    \ += s\n    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpusdcsubo.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpusdcsubo.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpusdcsubo.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3m88ekz.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3m88ekz.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt3m88ekz.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmput19oysc.py\"\
    , line 55, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmput19oysc.py\"\
    , line 53, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmput19oysc.py\"\
    , line 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 54, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 52, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    if len(stack) == 0:\n   \
    \     return 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc_j7hkox.py\"\
    , line 61, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc_j7hkox.py\"\
    , line 59, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpc_j7hkox.py\"\
    , line 45, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) != 0:\n        return\
    \ 'No'\n    else:\n        return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 53, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 51, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpr49bz7yf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpr49bz7yf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpr49bz7yf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 49, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 47, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 55, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 53, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            stack.pop()\n\
    \        elif s == ')':\n            if len(stack) == 0:\n                return\
    \ 'No'\n            else:\n                stack.pop()\n        else:\n      \
    \      return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) == 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 53, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 51, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpeu5ujvjc.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpeu5ujvjc.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpeu5ujvjc.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxakotusx.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpxakotusx.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpxakotusx.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != '(':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph9i26vyz.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmph9i26vyz.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmph9i26vyz.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            stack.pop()\n        else:\n       \
    \     return 'No'\n    return stack == []\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmporyckdqg.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmporyckdqg.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmporyckdqg.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for elem in lst:\n        if elem ==\
    \ '(':\n            stack.append(elem)\n        elif elem == ')':\n          \
    \  if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptlvknjjr.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmptlvknjjr.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmptlvknjjr.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_braces = 0\n    close_braces =\
    \ 0\n    for s in lst:\n        if s == '(':\n            open_braces += 1\n \
    \           stack.append(s)\n        elif s == ')':\n            close_braces\
    \ += 1\n            if open_braces == close_braces:\n                stack.pop()\n\
    \            else:\n                return False\n        else:\n            return\
    \ False\n    return not stack\n\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxkf8g33v.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpxkf8g33v.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpxkf8g33v.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] != '(':\n                return 'No'\n            else:\n\
    \                stack.pop()\n                stack.append(s)\n    return 'Yes'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmpkrv1ifov.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprr851mu2.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmprr851mu2.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmprr851mu2.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            return 'No'\n    if len(stack) == 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppjv09eo4.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmppjv09eo4.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmppjv09eo4.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \      else:\n            return 'No'\n    if len(stack) != 0:\n        return\
    \ 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptnxv_4kf.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmptnxv_4kf.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmptnxv_4kf.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            stack.pop()\n    return stack == []\n\
    \n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9ar95mdg.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp9ar95mdg.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp9ar95mdg.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != ')':\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpwej0m1_4.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return ''.join(stack)\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1f9yd579.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp1f9yd579.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp1f9yd579.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 55, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 53, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(x)\n\
    \            else:\n                return 'No'\n    if len(stack) > 0:\n    \
    \    return 'No'\n    else:\n        return 'Yes'\n\ndef check(candidate):\n \
    \   assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf5anood5.py\", line\
    \ 61, in <module>\n    test_check()\n  File \"/tmp/tmpf5anood5.py\", line 59,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpf5anood5.py\", line\
    \ 45, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return stack == []\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp0jj1ke4n.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    stack.append(lst[0])\n    stack.append(lst[1])\n\
    \    \n    open_brackets = 0\n    close_brackets = 0\n    \n    for char in lst[0]:\n\
    \        if char == '(':\n            open_brackets += 1\n        elif char ==\
    \ ')':\n            close_brackets += 1\n        elif char == ')' and open_brackets\
    \ > 0:\n            open_brackets -= 1\n        elif char == '(' and close_brackets\
    \ > 0:\n            close_brackets -= 1\n        \n        if open_brackets ==\
    \ 0 and close_brackets == 0:\n            return 'Yes'\n        \n        if open_brackets\
    \ > 0 and close_brackets == 0:\n            return 'No'\n        \n        if\
    \ open_brackets == 0 and close_brackets > 0:\n            return 'No'\n      \
    \  \n        if open_brackets > 0 and close_brackets > 0:\n            return\
    \ 'No'\n        \n    return ''\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8o_1pjqu.py\", line\
    \ 68, in <module>\n    test_check()\n  File \"/tmp/tmp8o_1pjqu.py\", line 66,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp8o_1pjqu.py\", line\
    \ 52, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] != '(':\n                return 'No'\n            elif\
    \ stack[-1] != ')':\n                return 'No'\n            else:\n        \
    \        stack.pop()\n                stack.append(s)\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp08cc1hxa.py\", line\
    \ 60, in <module>\n    test_check()\n  File \"/tmp/tmp08cc1hxa.py\", line 58,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp08cc1hxa.py\", line\
    \ 44, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif len(stack) == 1:\n                stack.append(s)\n        \
    \    else:\n                stack.pop()\n                stack.append(s)\n   \
    \ return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) ==\
    \ 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpi5ix9xmx.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpi5ix9xmx.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpi5ix9xmx.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    stack.append(lst[0])\n    stack.append(lst[1])\n\
    \    \n    stack.pop()\n    stack.pop()\n    \n    stack.pop()\n    \n    if stack\
    \ == []:\n        return 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvmef5her.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpvmef5her.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpvmef5her.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\n  File \"/tmp/tmpvmef5her.py\"\
    , line 27, in match_parens\n    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpx76jvokt.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 49, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 47, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if stack:\n                stack[-1] += s\n      \
    \      else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5rlei_si.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp5rlei_si.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp5rlei_si.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes' if len(stack) == 0 else 'No'\n\n\
    def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeatq02yv.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpeatq02yv.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpeatq02yv.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    stack.append(lst[0])\n    lst.pop(0)\n\
    \    \n    for s in lst:\n        if s == '(':\n            stack.append(s)\n\
    \        elif s == ')':\n            if len(stack) == 0:\n                return\
    \ 'No'\n            else:\n                stack.pop()\n        else:\n      \
    \      return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyd6ip14l.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpyd6ip14l.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpyd6ip14l.py\", line\
    \ 38, in check\n    assert candidate([')', ')']) == 'No'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2py9g_yq.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmp2py9g_yq.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp2py9g_yq.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            stack.pop()\n\
    \        elif s == ')':\n            if len(stack) == 0:\n                return\
    \ 'No'\n            else:\n                stack.pop()\n        else:\n      \
    \      return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] != '(':\n                return 'No'\n            else:\n\
    \                stack.pop()\n                stack.append(s)\n    return 'Yes'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmpkrv1ifov.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != s:\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9_h4vrvb.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp9_h4vrvb.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp9_h4vrvb.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif len(stack) == 1:\n                return 'Yes'\n           \
    \ else:\n                stack.pop()\n                stack.append(s)\n    return\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpljp7rjbb.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpljp7rjbb.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpljp7rjbb.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxakotusx.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpxakotusx.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpxakotusx.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] != '(':\n                return 'No'\n            else:\n\
    \                stack.pop()\n                stack.append(s)\n    return 'Yes'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmpkrv1ifov.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpkrv1ifov.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return stack == []\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp0jj1ke4n.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6k837z46.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp6k837z46.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp6k837z46.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            stack.pop()\n\
    \        elif s == ')':\n            if len(stack) == 0:\n                return\
    \ 'No'\n            else:\n                stack.pop()\n        else:\n      \
    \      return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpx1a8nwfb.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != ')':\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpwej0m1_4.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.append(s)\n       \
    \     elif stack[-1] == ')':\n                stack.pop()\n            else:\n\
    \                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmpgk41_cwz.py\", line 55,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 41, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpmie2zsd_.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) != 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjnwcanan.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpjnwcanan.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpjnwcanan.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            if len(stack) == 0:\n                return\
    \ 'No'\n            elif open_brackets > close_brackets:\n                return\
    \ 'Yes'\n            else:\n                stack.pop()\n        else:\n     \
    \       stack.append(char)\n    return 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqk9zmtm1.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpqk9zmtm1.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpqk9zmtm1.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(x)\n\
    \    if len(stack) != 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo6lod4el.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpo6lod4el.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpo6lod4el.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        return 'No'\n    if len(stack) == 0:\n        return 'Yes'\n    return\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjqdv7ia8.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpjqdv7ia8.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpjqdv7ia8.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmpebp8t8hh.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            stack.pop()\n\
    \        else:\n            return False\n    return len(stack) == 0\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp56hwu0mz.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmp56hwu0mz.py\", line 45,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp56hwu0mz.py\", line\
    \ 31, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            if len(stack) == 0:\n                return\
    \ 'No'\n            elif stack[-1] == '(':\n                stack.pop()\n    \
    \        else:\n                stack.pop()\n                open_brackets -=\
    \ 1\n        else:\n            stack.append(char)\n    if len(stack) == 0:\n\
    \        return 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy6mxiipl.py\", line\
    \ 60, in <module>\n    test_check()\n  File \"/tmp/tmpy6mxiipl.py\", line 58,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpy6mxiipl.py\", line\
    \ 47, in check\n    assert candidate([')())', '(()()(']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) == 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 53, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 51, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpskej1akx.py\"\
    , line 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 54, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 52, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    if len(stack) != 0:\n   \
    \     return 'No'\n    else:\n        return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgswm0yu3.py\", line\
    \ 61, in <module>\n    test_check()\n  File \"/tmp/tmpgswm0yu3.py\", line 59,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpgswm0yu3.py\", line\
    \ 45, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return stack == []\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmp0jj1ke4n.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp0jj1ke4n.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] != '(':\n   \
    \             return 'No'\n            else:\n                stack.pop()\n  \
    \  return stack == []\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw8_tjcvw.py\", line\
    \ 50, in <module>\n    test_check()\n  File \"/tmp/tmpw8_tjcvw.py\", line 48,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpw8_tjcvw.py\", line\
    \ 34, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            else:\n                stack.pop()\n                stack.append(s)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaznw4o8j.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpaznw4o8j.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpaznw4o8j.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpor4gb17m.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpor4gb17m.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpor4gb17m.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    stack.append(lst[0])\n    stack.append(lst[1])\n\
    \    \n    \n    while len(stack) > 0:\n        top = stack.pop()\n        if\
    \ top == '(':\n            stack.append(top)\n        elif top == ')':\n     \
    \       if len(stack) == 0:\n                return 'No'\n            else:\n\
    \                stack.pop()\n        else:\n            return 'No'\n    return\
    \ 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7e1292u9.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmp7e1292u9.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp7e1292u9.py\", line\
    \ 40, in check\n    assert candidate([')', ')']) == 'No'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps167x4yr.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmps167x4yr.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmps167x4yr.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            if stack:\n                if stack[-1] == '(':\n  \
    \                  stack.pop()\n                else:\n                    return\
    \ 'No'\n            else:\n                return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfld59gc9.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmpfld59gc9.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpfld59gc9.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            if open_brackets == close_brackets:\n    \
    \            stack.pop()\n            else:\n                return False\n  \
    \      else:\n            return False\n    return not stack\n\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0uzhr59_.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmp0uzhr59_.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp0uzhr59_.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) == 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcct09lg9.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpcct09lg9.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpcct09lg9.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpmie2zsd_.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            if open_brackets == close_brackets:\n    \
    \            stack.pop()\n            else:\n                return False\n  \
    \  return True if open_brackets == close_brackets else False\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp19rcnj1o.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmp19rcnj1o.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp19rcnj1o.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != ')':\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpwej0m1_4.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpwej0m1_4.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for c in lst:\n        if c == '(':\n            open_brackets += 1\n\
    \            stack.append(c)\n        elif c == ')':\n            close_brackets\
    \ += 1\n            stack.pop()\n            if open_brackets == close_brackets:\n\
    \                return 'Yes'\n    return 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwu0_giet.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpwu0_giet.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpwu0_giet.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\n  File \"/tmp/tmpwu0_giet.py\"\
    , line 29, in match_parens\n    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpx76jvokt.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprr851mu2.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmprr851mu2.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmprr851mu2.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] == '(':\n                stack.pop()\n            elif\
    \ stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    if len(stack) == 0:\n   \
    \     return 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpi266d7ip.py\", line\
    \ 63, in <module>\n    test_check()\n  File \"/tmp/tmpi266d7ip.py\", line 61,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpi266d7ip.py\", line\
    \ 47, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != ')':\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) > 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpua7y35e1.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpua7y35e1.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpua7y35e1.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            if open_brackets > close_brackets:\n     \
    \           return 'Yes'\n            open_brackets -= 1\n            stack.pop()\n\
    \        else:\n            stack.append(char)\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpktj8nisx.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpktj8nisx.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpktj8nisx.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \            elif stack[-1] == ')':\n                stack.pop()\n           \
    \     stack.append(s)\n            else:\n                return 'No'\n    return\
    \ 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkubhetsp.py\", line\
    \ 61, in <module>\n    test_check()\n  File \"/tmp/tmpkubhetsp.py\", line 59,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpkubhetsp.py\", line\
    \ 45, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] == '(':\n                stack.pop()\n            elif\
    \ stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzmxktwwp.py\", line\
    \ 60, in <module>\n    test_check()\n  File \"/tmp/tmpzmxktwwp.py\", line 58,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpzmxktwwp.py\", line\
    \ 44, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_braces = 0\n    for char in lst:\n\
    \        if char == '(':\n            open_braces += 1\n            stack.append(char)\n\
    \        elif char == ')':\n            open_braces -= 1\n            if not open_braces:\n\
    \                if stack:\n                    stack.pop()\n                else:\n\
    \                    return 'No'\n            elif stack:\n                stack.pop()\n\
    \            else:\n                return 'No'\n    if stack:\n        return\
    \ 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4qm0_14c.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmp4qm0_14c.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp4qm0_14c.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(x)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpiklbkvh4.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpiklbkvh4.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpiklbkvh4.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            stack.pop()\n\
    \        elif s == ')':\n            if len(stack) == 0:\n                return\
    \ 'No'\n            else:\n                stack.pop()\n        else:\n      \
    \      if len(stack) == 0:\n                return 'No'\n            else:\n \
    \               stack.pop()\n                stack.append(s)\n    return 'Yes'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp39resbj_.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmp39resbj_.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp39resbj_.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmpebp8t8hh.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] == '(':\n                stack.pop()\n            elif\
    \ stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    if len(stack) != 0:\n   \
    \     return 'No'\n    else:\n        return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5m74sd13.py\", line\
    \ 63, in <module>\n    test_check()\n  File \"/tmp/tmp5m74sd13.py\", line 61,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp5m74sd13.py\", line\
    \ 47, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpx76jvokt.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) != 0:\n        return\
    \ 'No'\n    else:\n        return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 53, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 51, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp0jgfufz9.py\"\
    , line 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 49, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 47, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack[-1]\
    \ += s\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpqq5mpk34.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for s in lst:\n        if s == '(':\n            open_brackets += 1\n\
    \            stack.append(s)\n        elif s == ')':\n            close_brackets\
    \ += 1\n            if open_brackets > close_brackets:\n                return\
    \ 'Yes'\n            stack.pop()\n        else:\n            if open_brackets\
    \ > close_brackets:\n                return 'No'\n            stack.append(s)\n\
    \    return 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpic4dcr5k.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpic4dcr5k.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpic4dcr5k.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        return 'No'\n    if len(stack) != 0:\n        return 'No'\n    return\
    \ 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy6ju2my5.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpy6ju2my5.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpy6ju2my5.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            stack.pop()\n        else:\n       \
    \     return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsjhfxxef.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpsjhfxxef.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpsjhfxxef.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(x)\n\
    \    if len(stack) == 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6djuurwv.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp6djuurwv.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp6djuurwv.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != s:\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) > 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr6q11dv0.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpr6q11dv0.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpr6q11dv0.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpmie2zsd_.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack.pop() != '(':\n \
    \               return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmpebp8t8hh.py\", line 46,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpebp8t8hh.py\", line\
    \ 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ == 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzqt1opa3.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpzqt1opa3.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpzqt1opa3.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes' if len(stack) == 0 else 'No'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp_e62yxbq.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    stack.append(lst[0])\n    lst.pop(0)\n\
    \    for s in lst:\n        if s == '(':\n            stack.append(s)\n      \
    \  elif s == ')':\n            if len(stack) == 0:\n                return 'No'\n\
    \            top = stack.pop()\n            if top != s:\n                return\
    \ 'No'\n        else:\n            return 'No'\n    if len(stack) != 0:\n    \
    \    return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgthzgoxm.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpgthzgoxm.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpgthzgoxm.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.append(s)\n       \
    \     elif stack[-1] == ')':\n                stack.pop()\n            else:\n\
    \                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmpgk41_cwz.py\", line 55,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 41, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppb6lv0nv.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmppb6lv0nv.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmppb6lv0nv.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) == 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqwrfv_us.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpqwrfv_us.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpqwrfv_us.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            return 'No'\n    if len(stack) != 0:\n        return 'Yes'\n    return\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps0suxozk.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmps0suxozk.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmps0suxozk.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_braces = 0\n    close_braces =\
    \ 0\n    for c in lst:\n        if c == '(':\n            open_braces += 1\n \
    \           stack.append(c)\n        elif c == ')':\n            close_braces\
    \ += 1\n            if len(stack) == 0:\n                return 'No'\n       \
    \     elif open_braces == close_braces:\n                stack.pop()\n       \
    \         open_braces -= 1\n            else:\n                return 'No'\n \
    \   if len(stack) > 0:\n        return 'No'\n    else:\n        return 'Yes'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8yy64yv6.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmp8yy64yv6.py\", line 56,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp8yy64yv6.py\", line\
    \ 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \     stack.append(s)\n                stack.append(s)\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n                stack.append(s)\n    \
    \            stack.append(s)\n                stack.append(s)\n            elif\
    \ stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \     stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \  elif stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \  elif stack[-1] == '(':\n                stack.pop()\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n            elif stack[-1] == '(':\n       \
    \         stack.pop()\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n                stack.append(s)\n          \
    \      stack.append(s)\n                stack.append(s)\n                stack.append(s)\n\
    \                stack.append(s)\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxqe3o7xs.py\", line\
    \ 143, in <module>\n    test_check()\n  File \"/tmp/tmpxqe3o7xs.py\", line 141,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpxqe3o7xs.py\", line\
    \ 127, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for x in lst:\n        if x == '(':\n\
    \            stack.append(x)\n        elif x == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        stack.append(x)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpa72o184h.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpa72o184h.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpa72o184h.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for elem in lst:\n        if elem ==\
    \ '(':\n            stack.append(elem)\n        elif elem == ')':\n          \
    \  if len(stack) == 0:\n                return 'No'\n            top = stack.pop()\n\
    \            if top != elem:\n                return 'No'\n    if len(stack) !=\
    \ 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsr7zsgtp.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpsr7zsgtp.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpsr7zsgtp.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpor4gb17m.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpor4gb17m.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpor4gb17m.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            return 'No'\n    if len(stack) > 0:\n        return\
    \ 'Yes'\n    else:\n        return 'No'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzv5uokiu.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpzv5uokiu.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpzv5uokiu.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n    if len(stack)\
    \ != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 49, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 47, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpz0mdt8t0.py\"\
    , line 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n\
    def check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe0pw5y6i.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpe0pw5y6i.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpe0pw5y6i.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) == 0:\n        return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcct09lg9.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmpcct09lg9.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpcct09lg9.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        elif s\
    \ == ')':\n            if len(stack) == 0:\n                return 'No'\n    \
    \        stack.pop()\n        else:\n            if len(stack) == 0:\n       \
    \         return 'No'\n            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprbiqvz_y.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmprbiqvz_y.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmprbiqvz_y.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.append(s)\n       \
    \     elif stack[-1] == ')':\n                stack.pop()\n            else:\n\
    \                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 57, in <module>\n    test_check()\n  File \"/tmp/tmpgk41_cwz.py\", line 55,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpgk41_cwz.py\", line\
    \ 41, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for elem in lst:\n        if elem ==\
    \ '(':\n            stack.append(elem)\n        elif elem == ')':\n          \
    \  if not stack:\n                return 'No'\n            stack.pop()\n     \
    \   else:\n            return 'No'\n    return 'Yes' if stack == [] else 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpg9ozahc_.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpg9ozahc_.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpg9ozahc_.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    close_brackets\
    \ = 0\n    for char in lst:\n        if char == '(':\n            open_brackets\
    \ += 1\n            stack.append(char)\n        elif char == ')':\n          \
    \  close_brackets += 1\n            stack.pop()\n            if open_brackets\
    \ == close_brackets:\n                return 'Yes'\n    return 'No'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvqun2fwj.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpvqun2fwj.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpvqun2fwj.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\n  File \"/tmp/tmpvqun2fwj.py\"\
    , line 29, in match_parens\n    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack[-1]\
    \ += s\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpqq5mpk34.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            top = stack.pop()\n        \
    \    if top != s:\n                return 'No'\n        else:\n            return\
    \ 'No'\n    if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9_h4vrvb.py\", line\
    \ 53, in <module>\n    test_check()\n  File \"/tmp/tmp9_h4vrvb.py\", line 51,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp9_h4vrvb.py\", line\
    \ 37, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack[-1]\
    \ += s\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpqq5mpk34.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpqq5mpk34.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \  if len(stack) != 0:\n        return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 52, in <module>\n    test_check()\n  File \"/tmp/tmpmie2zsd_.py\", line 50,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpmie2zsd_.py\", line\
    \ 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    if len(stack) > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 54, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 52, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpt32qme9s.py\"\
    , line 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.append(s)\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmpx76jvokt.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpx76jvokt.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != ')':\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpa8a3bj1j.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 48, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 46, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpvmihcxuu.py\"\
    , line 32, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_braces = 0\n    close_braces =\
    \ 0\n    for s in lst:\n        if s == '(':\n            open_braces += 1\n \
    \           stack.append(s)\n        elif s == ')':\n            close_braces\
    \ += 1\n            if open_braces > close_braces:\n                return 'Yes'\n\
    \            else:\n                stack.pop()\n        else:\n            stack.pop()\n\
    \    return stack == []\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprl9ua23x.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmprl9ua23x.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmprl9ua23x.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\n  File \"/tmp/tmprl9ua23x.py\"\
    , line 34, in match_parens\n    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            stack.pop()\n        else:\n       \
    \     return 'No'\n    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(',\
    \ ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsjhfxxef.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpsjhfxxef.py\", line 47,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpsjhfxxef.py\", line\
    \ 33, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    open_brackets = 0\n    for char in\
    \ lst:\n        if char == '(':\n            stack.append(char)\n            open_brackets\
    \ += 1\n        elif char == ')':\n            open_brackets -= 1\n          \
    \  if open_brackets == 0:\n                stack.pop()\n            else:\n  \
    \              stack.append(char)\n        else:\n            if open_brackets\
    \ == 0:\n                return 'No'\n    return 'Yes' if len(stack) == 0 else\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2mrdmxej.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmp2mrdmxej.py\", line 52,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp2mrdmxej.py\", line\
    \ 38, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == ')':\n                stack.pop()\n                stack.append(s)\n\
    \            else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 58, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 56, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpw89ncxro.py\"\
    , line 42, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ else:\n                return 'No'\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 55, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 53, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpizsh2v_4.py\"\
    , line 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            elif stack[-1] == '(':\n   \
    \             stack.pop()\n            else:\n                return 'No'\n  \
    \      else:\n            if len(stack) == 0:\n                return 'No'\n \
    \           elif stack[-1] == '(':\n                stack.pop()\n            elif\
    \ stack[-1] == '(':\n                stack.pop()\n            elif stack[-1] ==\
    \ '(':\n                stack.pop()\n            elif stack[-1] == '(':\n    \
    \            stack.pop()\n            elif stack[-1] == '(':\n               \
    \ stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\n \
    \               stack.pop()\n            elif stack[-1] == '(':\n            \
    \    stack.pop()\n            elif stack[-1] == '(':\n                stack.pop()\n\
    \            elif stack[-1] == '(':\n                stack.pop()\n           \
    \ elif stack[-1] == '(':\n                stack.pop()\n            elif stack[-1]\
    \ == '(':\n                stack.pop()\n            elif stack[-1] == '(':\ndef\
    \ check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')',\
    \ ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert\
    \ candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())(('])\
    \ == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(',\
    \ '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert\
    \ candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n\
    \    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) ==\
    \ 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "  File \"/tmp/tmpd8qk8o44.py\", line 125\n    def check(candidate):\nIndentationError:\
    \ expected an indented block after 'elif' statement on line 124\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \        else:\n            if len(stack) == 0:\n                return 'No'\n\
    \            elif len(stack) == 1:\n                return 'Yes'\n           \
    \ else:\n                stack.pop()\n                stack.append(s)\n    return\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpljp7rjbb.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpljp7rjbb.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpljp7rjbb.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n\
    \            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n    assert\
    \ candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n\
    \    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 52, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 50, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmp95ps5nzz.py\"\
    , line 36, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == '(':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        elif s\
    \ == ')':\n            if len(stack) == 0:\n                return 'No'\n    \
    \        stack.pop()\n        else:\n            if len(stack) == 0:\n       \
    \         return 'No'\n            stack.append(s)\n    return 'Yes'\n\ndef check(candidate):\n\
    \    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')'])\
    \ == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())',\
    \ '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n\
    \    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()'])\
    \ == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()',\
    \ '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    assert candidate(['(',\
    \ ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n\
    \    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprbiqvz_y.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmprbiqvz_y.py\", line 53,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmprbiqvz_y.py\", line\
    \ 39, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            else:\n                stack.pop()\n\
    \    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\
    \ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n    assert\
    \ candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) ==\
    \ 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2py9g_yq.py\", line\
    \ 51, in <module>\n    test_check()\n  File \"/tmp/tmp2py9g_yq.py\", line 49,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmp2py9g_yq.py\", line\
    \ 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if not stack:\n\
    \                return 'No'\n            top = stack.pop()\n            if top\
    \ != s:\n                return 'No'\n        else:\n            return 'No'\n\
    \    return 'Yes'\n\ndef check(candidate):\n    assert candidate(['()(', ')'])\
    \ == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())',\
    \ '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert\
    \ candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())'])\
    \ == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((',\
    \ '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert\
    \ candidate([')(', ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n\
    \    assert candidate([')', '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 51, in <module>\n    test_check()\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 49, in test_check\n    check(match_parens)\n  File \"/var/folders/2x/0c5d4d9j4dzd7354ndbb_gwr0000gq/T/tmpk4txyflf.py\"\
    , line 35, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
- exit_code: -1
  program: "from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n\
    \    \"\"\"\n    You are given a list of two strings, both strings consist of\
    \ open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to\
    \ check if it is possible to concatenate the two strings in\n    some order, that\
    \ the resulting string will be good.\n    A string S is considered to be good\
    \ if and only if all parentheses in S\n    are balanced. For example: the string\
    \ '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's\
    \ a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n \
    \   >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    stack = []\n    for s in lst:\n        if s == '(':\n\
    \            stack.append(s)\n        elif s == ')':\n            if len(stack)\
    \ == 0:\n                return 'No'\n            stack.pop()\n        else:\n\
    \            if len(stack) == 0:\n                return 'No'\n            if\
    \ stack[-1] == '(':\n                stack.pop()\n            else:\n        \
    \        return 'No'\n    if len(stack) == 0:\n        return 'Yes'\n    return\
    \ 'No'\n\ndef check(candidate):\n    assert candidate(['()(', ')']) == 'Yes'\n\
    \    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())'])\
    \ == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))',\
    \ '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert\
    \ candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())'])\
    \ == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(',\
    \ ')(']) == 'No'\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')',\
    \ '(']) == 'Yes'\n\ndef test_check():\n    check(match_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjqdv7ia8.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmpjqdv7ia8.py\", line 54,\
    \ in test_check\n    check(match_parens)\n  File \"/tmp/tmpjqdv7ia8.py\", line\
    \ 40, in check\n    assert candidate(['()(', ')']) == 'Yes'\nAssertionError\n"
  stdout: ''
  timestamp: 1659747760
